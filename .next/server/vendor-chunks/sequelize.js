/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sequelize";
exports.ids = ["vendor-chunks/sequelize"];
exports.modules = {

/***/ "(rsc)/./node_modules/sequelize/lib/associations/base.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { AssociationError } = __webpack_require__(/*! ./../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nclass Association {\n  constructor(source, target, options = {}) {\n    this.source = source;\n    this.target = target;\n    this.options = options;\n    this.scope = options.scope;\n    this.isSelfAssociation = this.source === this.target;\n    this.as = options.as;\n    this.associationType = \"\";\n    if (source.hasAlias(options.as)) {\n      throw new AssociationError(`You have used the alias ${options.as} in two separate associations. Aliased associations must have unique aliases.`);\n    }\n  }\n  toInstanceArray(input) {\n    if (!Array.isArray(input)) {\n      input = [input];\n    }\n    return input.map((element) => {\n      if (element instanceof this.target)\n        return element;\n      const tmpInstance = {};\n      tmpInstance[this.target.primaryKeyAttribute] = element;\n      return this.target.build(tmpInstance, { isNewRecord: false });\n    });\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.as;\n  }\n}\nmodule.exports = Association;\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyx1RUFBYTtBQUNsRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmFzZS5qcz9kMmRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgeyBBc3NvY2lhdGlvbkVycm9yIH0gPSByZXF1aXJlKFwiLi8uLi9lcnJvcnNcIik7XG5jbGFzcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2NvcGUgPSBvcHRpb25zLnNjb3BlO1xuICAgIHRoaXMuaXNTZWxmQXNzb2NpYXRpb24gPSB0aGlzLnNvdXJjZSA9PT0gdGhpcy50YXJnZXQ7XG4gICAgdGhpcy5hcyA9IG9wdGlvbnMuYXM7XG4gICAgdGhpcy5hc3NvY2lhdGlvblR5cGUgPSBcIlwiO1xuICAgIGlmIChzb3VyY2UuaGFzQWxpYXMob3B0aW9ucy5hcykpIHtcbiAgICAgIHRocm93IG5ldyBBc3NvY2lhdGlvbkVycm9yKGBZb3UgaGF2ZSB1c2VkIHRoZSBhbGlhcyAke29wdGlvbnMuYXN9IGluIHR3byBzZXBhcmF0ZSBhc3NvY2lhdGlvbnMuIEFsaWFzZWQgYXNzb2NpYXRpb25zIG11c3QgaGF2ZSB1bmlxdWUgYWxpYXNlcy5gKTtcbiAgICB9XG4gIH1cbiAgdG9JbnN0YW5jZUFycmF5KGlucHV0KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQubWFwKChlbGVtZW50KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIGNvbnN0IHRtcEluc3RhbmNlID0ge307XG4gICAgICB0bXBJbnN0YW5jZVt0aGlzLnRhcmdldC5wcmltYXJ5S2V5QXR0cmlidXRlXSA9IGVsZW1lbnQ7XG4gICAgICByZXR1cm4gdGhpcy50YXJnZXQuYnVpbGQodG1wSW5zdGFuY2UsIHsgaXNOZXdSZWNvcmQ6IGZhbHNlIH0pO1xuICAgIH0pO1xuICB9XG4gIFtTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIildKCkge1xuICAgIHJldHVybiB0aGlzLmFzO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEFzc29jaWF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to-many.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst HasMany = __webpack_require__(/*! ./has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst HasOne = __webpack_require__(/*! ./has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nconst AssociationError = (__webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\").AssociationError);\nconst EmptyResultError = (__webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\").EmptyResultError);\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    if (this.options.through === void 0 || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n    this.associationType = \"BelongsToMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = __spreadValues({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError(\"'as' must be defined for many-to-many self-associations\");\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    _.each(this.target.associations, (association) => {\n      if (association.associationType !== \"BelongsToMany\")\n        return;\n      if (association.target !== this.source)\n        return;\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n    this._createForeignAndOtherKeys();\n    if (typeof this.through.model === \"string\") {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          paranoid: this.through.paranoid ? this.through.paranoid : false,\n          validate: {}\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      \"timestamps\",\n      \"createdAt\",\n      \"updatedAt\",\n      \"deletedAt\",\n      \"paranoid\"\n    ]));\n    if (this.paired) {\n      let needInjectPaired = false;\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as;\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _createForeignAndOtherKeys() {\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize([\n        this.source.options.name.singular,\n        this.sourceKey\n      ].join(\"_\"));\n    }\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize([\n        this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n        this.targetKey\n      ].join(\"_\"));\n    }\n  }\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = __spreadValues({ type: sourceKeyType }, this.foreignKeyAttribute);\n    const targetAttribute = __spreadValues({ type: targetKeyType }, this.otherKeyAttribute);\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === \"string\" && this.options.uniqueKey !== \"\") {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, \"unique\"].join(\"_\");\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete)\n        sourceAttribute.onDelete = \"CASCADE\";\n      if (!sourceAttribute.onUpdate)\n        sourceAttribute.onUpdate = \"CASCADE\";\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete)\n        targetAttribute.onDelete = \"CASCADE\";\n      if (!targetAttribute.onUpdate)\n        targetAttribute.onUpdate = \"CASCADE\";\n    }\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.through.model.refreshAttributes();\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n    if (this.options.sequelize.options.dialect === \"db2\" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n    if (this.scope) {\n      scopeWhere = __spreadValues({}, this.scope);\n    }\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, \"paranoid\", true),\n        where: throughWhere\n      });\n    }\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n    return model.findAll(options);\n  }\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn(\"COUNT\", sequelize.col([this.target.name, this.targetKeyField].join(\".\"))), \"count\"]\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n    options = __spreadProps(__spreadValues({\n      raw: true\n    }, options), {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const instancePrimaryKeys = instances.map((instance) => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey)\n    }, this.through.scope);\n    const updateAssociations = (currentRows) => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n      const unassociatedObjects = newAssociatedObjects.filter((obj) => !currentRows.some((currentRow) => currentRow[foreignIdentifier] === obj.get(targetKey)));\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find((obj) => currentRow[foreignIdentifier] === obj.get(targetKey));\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).length) {\n            promises.push(this.through.model.update(attributes, Object.assign(options, {\n              where: {\n                [identifier]: sourceInstance.get(sourceKey),\n                [foreignIdentifier]: newObj.get(targetKey)\n              }\n            })));\n          }\n        }\n      }\n      if (obsoleteAssociations.length > 0) {\n        promises.push(this.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n          where: __spreadValues({\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: obsoleteAssociations.map((obsoleteAssociation) => obsoleteAssociation[foreignIdentifier])\n          }, this.through.scope)\n        })));\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map((unassociatedObject) => {\n          return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[this.through.model.name]), {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey)\n          }), this.through.scope);\n        });\n        promises.push(this.through.model.bulkCreate(bulk, __spreadValues({ validate: true }, options)));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await this.through.model.findAll(__spreadProps(__spreadValues({}, options), { where, raw: true }));\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError)\n        return updateAssociations([]);\n      throw error;\n    }\n  }\n  async add(sourceInstance, newInstances, options) {\n    if (!newInstances)\n      return Promise.resolve();\n    options = __spreadValues({}, options);\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n    newInstances = association.toInstanceArray(newInstances);\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map((newInstance) => newInstance.get(targetKey))\n    }, association.through.scope);\n    const updateAssociations = (currentRows) => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find((current) => current[foreignIdentifier] === obj.get(targetKey));\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).some((attribute) => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map((unassociatedObject) => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, __spreadValues({ validate: true }, options)));\n      }\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await association.through.model.findAll(__spreadProps(__spreadValues({}, options), { where, raw: true }));\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError)\n        return updateAssociations();\n      throw error;\n    }\n  }\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map((newInstance) => newInstance.get(association.targetKey))\n    };\n    return association.through.model.destroy(__spreadProps(__spreadValues({}, options), { where }));\n  }\n  async create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n    const newAssociatedObject = await association.target.create(values, options);\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, [\"fields\"]));\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports[\"default\"] = BelongsToMany;\n//# sourceMappingURL=belongs-to-many.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywrREFBWTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RUFBVztBQUNuQyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsb0JBQW9CLG1CQUFPLENBQUMsdUVBQVE7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMsbUZBQWM7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQVk7QUFDcEMsZUFBZSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2xDLHlCQUF5Qiw2R0FBcUM7QUFDOUQseUJBQXlCLDZHQUFxQztBQUM5RCxXQUFXLG1CQUFPLENBQUMscUVBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxpQkFBaUIsWUFBWTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4Qix5QkFBeUIsT0FBTztBQUNoQyxpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0IsT0FBTztBQUN0Qyx1QkFBdUIsU0FBUztBQUNoQyxvQkFBb0IsT0FBTztBQUMzQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFCQUFxQjtBQUNsRSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsOEJBQThCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCwyRUFBMkUsZ0JBQWdCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGNBQWMsa0JBQWtCO0FBQzFIO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtGQUFrRixnQkFBZ0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGNBQWMsa0JBQWtCO0FBQ2pJO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsY0FBYyxPQUFPO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueS5qcz82NzFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLy4uL3V0aWxzXCIpO1xuY29uc3QgSGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG9cIik7XG5jb25zdCBIYXNNYW55ID0gcmVxdWlyZShcIi4vaGFzLW1hbnlcIik7XG5jb25zdCBIYXNPbmUgPSByZXF1aXJlKFwiLi9oYXMtb25lXCIpO1xuY29uc3QgQXNzb2NpYXRpb25FcnJvciA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIikuQXNzb2NpYXRpb25FcnJvcjtcbmNvbnN0IEVtcHR5UmVzdWx0RXJyb3IgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpLkVtcHR5UmVzdWx0RXJyb3I7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvcnNcIik7XG5jbGFzcyBCZWxvbmdzVG9NYW55IGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRocm91Z2ggPT09IHZvaWQgMCB8fCB0aGlzLm9wdGlvbnMudGhyb3VnaCA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMudGhyb3VnaCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFzc29jaWF0aW9uRXJyb3IoYCR7c291cmNlLm5hbWV9LmJlbG9uZ3NUb01hbnkoJHt0YXJnZXQubmFtZX0pIHJlcXVpcmVzIHRocm91Z2ggb3B0aW9uLCBwYXNzIGVpdGhlciBhIHN0cmluZyBvciBhIG1vZGVsYCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5vcHRpb25zLnRocm91Z2gubW9kZWwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50aHJvdWdoID0ge1xuICAgICAgICBtb2RlbDogb3B0aW9ucy50aHJvdWdoXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9IFwiQmVsb25nc1RvTWFueVwiO1xuICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSBudWxsO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc291cmNlLnNlcXVlbGl6ZTtcbiAgICB0aGlzLnRocm91Z2ggPSBfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zLnRocm91Z2gpO1xuICAgIHRoaXMuaXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICB0aGlzLmRvdWJsZUxpbmtlZCA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5hcyAmJiB0aGlzLmlzU2VsZkFzc29jaWF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzb2NpYXRpb25FcnJvcihcIidhcycgbXVzdCBiZSBkZWZpbmVkIGZvciBtYW55LXRvLW1hbnkgc2VsZi1hc3NvY2lhdGlvbnNcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHRoaXMuYXMpKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy5hcztcbiAgICAgICAgdGhpcy5hcyA9IHRoaXMuYXMucGx1cmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hbWUgPSB7XG4gICAgICAgICAgcGx1cmFsOiB0aGlzLmFzLFxuICAgICAgICAgIHNpbmd1bGFyOiBVdGlscy5zaW5ndWxhcml6ZSh0aGlzLmFzKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFzID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnBsdXJhbDtcbiAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0gdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lO1xuICAgIH1cbiAgICB0aGlzLmNvbWJpbmVkVGFibGVOYW1lID0gVXRpbHMuY29tYmluZVRhYmxlTmFtZXModGhpcy5zb3VyY2UudGFibGVOYW1lLCB0aGlzLmlzU2VsZkFzc29jaWF0aW9uID8gdGhpcy5hcyB8fCB0aGlzLnRhcmdldC50YWJsZU5hbWUgOiB0aGlzLnRhcmdldC50YWJsZU5hbWUpO1xuICAgIGlmICh0aGlzLmlzU2VsZkFzc29jaWF0aW9uKSB7XG4gICAgICB0aGlzLnRhcmdldEFzc29jaWF0aW9uID0gdGhpcztcbiAgICB9XG4gICAgXy5lYWNoKHRoaXMudGFyZ2V0LmFzc29jaWF0aW9ucywgKGFzc29jaWF0aW9uKSA9PiB7XG4gICAgICBpZiAoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlICE9PSBcIkJlbG9uZ3NUb01hbnlcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKGFzc29jaWF0aW9uLnRhcmdldCAhPT0gdGhpcy5zb3VyY2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGhyb3VnaC5tb2RlbCA9PT0gYXNzb2NpYXRpb24ub3B0aW9ucy50aHJvdWdoLm1vZGVsKSB7XG4gICAgICAgIHRoaXMucGFpcmVkID0gYXNzb2NpYXRpb247XG4gICAgICAgIGFzc29jaWF0aW9uLnBhaXJlZCA9IHRoaXM7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zb3VyY2VLZXkgPSB0aGlzLm9wdGlvbnMuc291cmNlS2V5IHx8IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0S2V5KSB7XG4gICAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMub3B0aW9ucy50YXJnZXRLZXk7XG4gICAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0uZmllbGQgfHwgdGhpcy50YXJnZXRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFyZ2V0S2V5RGVmYXVsdCA9IHRydWU7XG4gICAgICB0aGlzLnRhcmdldEtleSA9IHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgICB0aGlzLnRhcmdldEtleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLnRhcmdldEtleV0uZmllbGQgfHwgdGhpcy50YXJnZXRLZXk7XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZUZvcmVpZ25BbmRPdGhlcktleXMoKTtcbiAgICBpZiAodHlwZW9mIHRoaXMudGhyb3VnaC5tb2RlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5pc0RlZmluZWQodGhpcy50aHJvdWdoLm1vZGVsKSkge1xuICAgICAgICB0aGlzLnRocm91Z2gubW9kZWwgPSB0aGlzLnNlcXVlbGl6ZS5kZWZpbmUodGhpcy50aHJvdWdoLm1vZGVsLCB7fSwgT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgICB0YWJsZU5hbWU6IHRoaXMudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgICBpbmRleGVzOiBbXSxcbiAgICAgICAgICBwYXJhbm9pZDogdGhpcy50aHJvdWdoLnBhcmFub2lkID8gdGhpcy50aHJvdWdoLnBhcmFub2lkIDogZmFsc2UsXG4gICAgICAgICAgdmFsaWRhdGU6IHt9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGhyb3VnaC5tb2RlbCA9IHRoaXMuc2VxdWVsaXplLm1vZGVsKHRoaXMudGhyb3VnaC5tb2RlbCk7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBfLnBpY2sodGhpcy50aHJvdWdoLm1vZGVsLm9wdGlvbnMsIFtcbiAgICAgIFwidGltZXN0YW1wc1wiLFxuICAgICAgXCJjcmVhdGVkQXRcIixcbiAgICAgIFwidXBkYXRlZEF0XCIsXG4gICAgICBcImRlbGV0ZWRBdFwiLFxuICAgICAgXCJwYXJhbm9pZFwiXG4gICAgXSkpO1xuICAgIGlmICh0aGlzLnBhaXJlZCkge1xuICAgICAgbGV0IG5lZWRJbmplY3RQYWlyZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnRhcmdldEtleURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLnBhaXJlZC5zb3VyY2VLZXk7XG4gICAgICAgIHRoaXMudGFyZ2V0S2V5RmllbGQgPSB0aGlzLnBhaXJlZC5zb3VyY2VLZXlGaWVsZDtcbiAgICAgICAgdGhpcy5fY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGFpcmVkLnRhcmdldEtleURlZmF1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMucGFpcmVkLnRhcmdldEtleSAhPT0gdGhpcy5zb3VyY2VLZXkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5wYWlyZWQub3RoZXJLZXldO1xuICAgICAgICAgIHRoaXMucGFpcmVkLnRhcmdldEtleSA9IHRoaXMuc291cmNlS2V5O1xuICAgICAgICAgIHRoaXMucGFpcmVkLnRhcmdldEtleUZpZWxkID0gdGhpcy5zb3VyY2VLZXlGaWVsZDtcbiAgICAgICAgICB0aGlzLnBhaXJlZC5fY3JlYXRlRm9yZWlnbkFuZE90aGVyS2V5cygpO1xuICAgICAgICAgIG5lZWRJbmplY3RQYWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdGhlcktleURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5vdGhlcktleSA9IHRoaXMucGFpcmVkLmZvcmVpZ25LZXk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wYWlyZWQub3RoZXJLZXlEZWZhdWx0KSB7XG4gICAgICAgIGlmICh0aGlzLnBhaXJlZC5vdGhlcktleSAhPT0gdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMucGFpcmVkLm90aGVyS2V5XTtcbiAgICAgICAgICB0aGlzLnBhaXJlZC5vdGhlcktleSA9IHRoaXMuZm9yZWlnbktleTtcbiAgICAgICAgICBuZWVkSW5qZWN0UGFpcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRJbmplY3RQYWlyZWQpIHtcbiAgICAgICAgdGhpcy5wYWlyZWQuX2luamVjdEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMudGhyb3VnaCkge1xuICAgICAgdGhpcy50aHJvdWdoTW9kZWwgPSB0aGlzLnRocm91Z2gubW9kZWw7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucy50YWJsZU5hbWUgPSB0aGlzLmNvbWJpbmVkTmFtZSA9IHRoaXMudGhyb3VnaC5tb2RlbCA9PT0gT2JqZWN0KHRoaXMudGhyb3VnaC5tb2RlbCkgPyB0aGlzLnRocm91Z2gubW9kZWwudGFibGVOYW1lIDogdGhpcy50aHJvdWdoLm1vZGVsO1xuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgY29uc3QgcGx1cmFsID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnBsdXJhbCk7XG4gICAgY29uc3Qgc2luZ3VsYXIgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUuc2luZ3VsYXIpO1xuICAgIHRoaXMuYWNjZXNzb3JzID0ge1xuICAgICAgZ2V0OiBgZ2V0JHtwbHVyYWx9YCxcbiAgICAgIHNldDogYHNldCR7cGx1cmFsfWAsXG4gICAgICBhZGRNdWx0aXBsZTogYGFkZCR7cGx1cmFsfWAsXG4gICAgICBhZGQ6IGBhZGQke3Npbmd1bGFyfWAsXG4gICAgICBjcmVhdGU6IGBjcmVhdGUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmU6IGByZW1vdmUke3Npbmd1bGFyfWAsXG4gICAgICByZW1vdmVNdWx0aXBsZTogYHJlbW92ZSR7cGx1cmFsfWAsXG4gICAgICBoYXNTaW5nbGU6IGBoYXMke3Npbmd1bGFyfWAsXG4gICAgICBoYXNBbGw6IGBoYXMke3BsdXJhbH1gLFxuICAgICAgY291bnQ6IGBjb3VudCR7cGx1cmFsfWBcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVGb3JlaWduQW5kT3RoZXJLZXlzKCkge1xuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5mb3JlaWduS2V5KSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUubmFtZSB8fCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB7fTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMub3B0aW9ucy5mb3JlaWduS2V5IHx8IFV0aWxzLmNhbWVsaXplKFtcbiAgICAgICAgdGhpcy5zb3VyY2Uub3B0aW9ucy5uYW1lLnNpbmd1bGFyLFxuICAgICAgICB0aGlzLnNvdXJjZUtleVxuICAgICAgXS5qb2luKFwiX1wiKSk7XG4gICAgfVxuICAgIGlmIChfLmlzT2JqZWN0KHRoaXMub3B0aW9ucy5vdGhlcktleSkpIHtcbiAgICAgIHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMub3RoZXJLZXk7XG4gICAgICB0aGlzLm90aGVyS2V5ID0gdGhpcy5vdGhlcktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMub3RoZXJLZXlBdHRyaWJ1dGUuZmllbGROYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5vdGhlcktleSkge1xuICAgICAgICB0aGlzLm90aGVyS2V5RGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLm90aGVyS2V5QXR0cmlidXRlID0ge307XG4gICAgICB0aGlzLm90aGVyS2V5ID0gdGhpcy5vcHRpb25zLm90aGVyS2V5IHx8IFV0aWxzLmNhbWVsaXplKFtcbiAgICAgICAgdGhpcy5pc1NlbGZBc3NvY2lhdGlvbiA/IFV0aWxzLnNpbmd1bGFyaXplKHRoaXMuYXMpIDogdGhpcy50YXJnZXQub3B0aW9ucy5uYW1lLnNpbmd1bGFyLFxuICAgICAgICB0aGlzLnRhcmdldEtleVxuICAgICAgXS5qb2luKFwiX1wiKSk7XG4gICAgfVxuICB9XG4gIF9pbmplY3RBdHRyaWJ1dGVzKCkge1xuICAgIHRoaXMuaWRlbnRpZmllciA9IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLmZvcmVpZ25JZGVudGlmaWVyID0gdGhpcy5vdGhlcktleTtcbiAgICBfLmVhY2godGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGF0dHJpYnV0ZU5hbWUpID0+IHtcbiAgICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSA9PT0gdHJ1ZSAmJiBhdHRyaWJ1dGUuX2F1dG9HZW5lcmF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKFt0aGlzLmZvcmVpZ25LZXksIHRoaXMub3RoZXJLZXldLmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgYXR0cmlidXRlLnByaW1hcnlLZXkgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmltYXJ5S2V5RGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc291cmNlS2V5ID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV07XG4gICAgY29uc3Qgc291cmNlS2V5VHlwZSA9IHNvdXJjZUtleS50eXBlO1xuICAgIGNvbnN0IHNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2VLZXlGaWVsZDtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMudGFyZ2V0S2V5XTtcbiAgICBjb25zdCB0YXJnZXRLZXlUeXBlID0gdGFyZ2V0S2V5LnR5cGU7XG4gICAgY29uc3QgdGFyZ2V0S2V5RmllbGQgPSB0aGlzLnRhcmdldEtleUZpZWxkO1xuICAgIGNvbnN0IHNvdXJjZUF0dHJpYnV0ZSA9IF9fc3ByZWFkVmFsdWVzKHsgdHlwZTogc291cmNlS2V5VHlwZSB9LCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUpO1xuICAgIGNvbnN0IHRhcmdldEF0dHJpYnV0ZSA9IF9fc3ByZWFkVmFsdWVzKHsgdHlwZTogdGFyZ2V0S2V5VHlwZSB9LCB0aGlzLm90aGVyS2V5QXR0cmlidXRlKTtcbiAgICBpZiAodGhpcy5wcmltYXJ5S2V5RGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgdGFyZ2V0QXR0cmlidXRlLnByaW1hcnlLZXkgPSBzb3VyY2VBdHRyaWJ1dGUucHJpbWFyeUtleSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRocm91Z2gudW5pcXVlICE9PSBmYWxzZSkge1xuICAgICAgbGV0IHVuaXF1ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnVuaXF1ZUtleSA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLm9wdGlvbnMudW5pcXVlS2V5ICE9PSBcIlwiKSB7XG4gICAgICAgIHVuaXF1ZUtleSA9IHRoaXMub3B0aW9ucy51bmlxdWVLZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmlxdWVLZXkgPSBbdGhpcy50aHJvdWdoLm1vZGVsLnRhYmxlTmFtZSwgdGhpcy5mb3JlaWduS2V5LCB0aGlzLm90aGVyS2V5LCBcInVuaXF1ZVwiXS5qb2luKFwiX1wiKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldEF0dHJpYnV0ZS51bmlxdWUgPSBzb3VyY2VBdHRyaWJ1dGUudW5pcXVlID0gdW5pcXVlS2V5O1xuICAgIH1cbiAgICBpZiAoIXRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0pIHtcbiAgICAgIHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gPSB7XG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldKSB7XG4gICAgICB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XSA9IHtcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBzb3VyY2VBdHRyaWJ1dGUucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgbW9kZWw6IHRoaXMuc291cmNlLmdldFRhYmxlTmFtZSgpLFxuICAgICAgICBrZXk6IHNvdXJjZUtleUZpZWxkXG4gICAgICB9O1xuICAgICAgc291cmNlQXR0cmlidXRlLm9uRGVsZXRlID0gdGhpcy5vcHRpb25zLm9uRGVsZXRlIHx8IHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0ub25EZWxldGU7XG4gICAgICBzb3VyY2VBdHRyaWJ1dGUub25VcGRhdGUgPSB0aGlzLm9wdGlvbnMub25VcGRhdGUgfHwgdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5vblVwZGF0ZTtcbiAgICAgIGlmICghc291cmNlQXR0cmlidXRlLm9uRGVsZXRlKVxuICAgICAgICBzb3VyY2VBdHRyaWJ1dGUub25EZWxldGUgPSBcIkNBU0NBREVcIjtcbiAgICAgIGlmICghc291cmNlQXR0cmlidXRlLm9uVXBkYXRlKVxuICAgICAgICBzb3VyY2VBdHRyaWJ1dGUub25VcGRhdGUgPSBcIkNBU0NBREVcIjtcbiAgICAgIHRhcmdldEF0dHJpYnV0ZS5yZWZlcmVuY2VzID0ge1xuICAgICAgICBtb2RlbDogdGhpcy50YXJnZXQuZ2V0VGFibGVOYW1lKCksXG4gICAgICAgIGtleTogdGFyZ2V0S2V5RmllbGRcbiAgICAgIH07XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUub25EZWxldGUgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XS5vbkRlbGV0ZSB8fCB0aGlzLm9wdGlvbnMub25EZWxldGU7XG4gICAgICB0YXJnZXRBdHRyaWJ1dGUub25VcGRhdGUgPSB0aGlzLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm90aGVyS2V5XS5vblVwZGF0ZSB8fCB0aGlzLm9wdGlvbnMub25VcGRhdGU7XG4gICAgICBpZiAoIXRhcmdldEF0dHJpYnV0ZS5vbkRlbGV0ZSlcbiAgICAgICAgdGFyZ2V0QXR0cmlidXRlLm9uRGVsZXRlID0gXCJDQVNDQURFXCI7XG4gICAgICBpZiAoIXRhcmdldEF0dHJpYnV0ZS5vblVwZGF0ZSlcbiAgICAgICAgdGFyZ2V0QXR0cmlidXRlLm9uVXBkYXRlID0gXCJDQVNDQURFXCI7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgc291cmNlQXR0cmlidXRlKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMudGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMub3RoZXJLZXldLCB0YXJnZXRBdHRyaWJ1dGUpO1xuICAgIHRoaXMudGhyb3VnaC5tb2RlbC5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgdGhpcy5mb3JlaWduSWRlbnRpZmllckZpZWxkID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5vdGhlcktleV0uZmllbGQgfHwgdGhpcy5vdGhlcktleTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QgPT09IFwiZGIyXCIgJiYgdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0ucHJpbWFyeUtleSAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0udW5pcXVlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFpcmVkICYmICF0aGlzLnBhaXJlZC5mb3JlaWduSWRlbnRpZmllckZpZWxkKSB7XG4gICAgICB0aGlzLnBhaXJlZC5mb3JlaWduSWRlbnRpZmllckZpZWxkID0gdGhpcy50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5wYWlyZWQub3RoZXJLZXldLmZpZWxkIHx8IHRoaXMucGFpcmVkLm90aGVyS2V5O1xuICAgIH1cbiAgICB0aGlzLnRvU291cmNlID0gbmV3IEJlbG9uZ3NUbyh0aGlzLnRocm91Z2gubW9kZWwsIHRoaXMuc291cmNlLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLmZvcmVpZ25LZXlcbiAgICB9KTtcbiAgICB0aGlzLm1hbnlGcm9tU291cmNlID0gbmV3IEhhc01hbnkodGhpcy5zb3VyY2UsIHRoaXMudGhyb3VnaC5tb2RlbCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5mb3JlaWduS2V5XG4gICAgfSk7XG4gICAgdGhpcy5vbmVGcm9tU291cmNlID0gbmV3IEhhc09uZSh0aGlzLnNvdXJjZSwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLmZvcmVpZ25LZXksXG4gICAgICBzb3VyY2VLZXk6IHRoaXMuc291cmNlS2V5LFxuICAgICAgYXM6IHRoaXMudGhyb3VnaC5tb2RlbC5uYW1lXG4gICAgfSk7XG4gICAgdGhpcy50b1RhcmdldCA9IG5ldyBCZWxvbmdzVG8odGhpcy50aHJvdWdoLm1vZGVsLCB0aGlzLnRhcmdldCwge1xuICAgICAgZm9yZWlnbktleTogdGhpcy5vdGhlcktleVxuICAgIH0pO1xuICAgIHRoaXMubWFueUZyb21UYXJnZXQgPSBuZXcgSGFzTWFueSh0aGlzLnRhcmdldCwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLm90aGVyS2V5XG4gICAgfSk7XG4gICAgdGhpcy5vbmVGcm9tVGFyZ2V0ID0gbmV3IEhhc09uZSh0aGlzLnRhcmdldCwgdGhpcy50aHJvdWdoLm1vZGVsLCB7XG4gICAgICBmb3JlaWduS2V5OiB0aGlzLm90aGVyS2V5LFxuICAgICAgc291cmNlS2V5OiB0aGlzLnRhcmdldEtleSxcbiAgICAgIGFzOiB0aGlzLnRocm91Z2gubW9kZWwubmFtZVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnBhaXJlZCAmJiB0aGlzLnBhaXJlZC5vdGhlcktleURlZmF1bHQpIHtcbiAgICAgIHRoaXMucGFpcmVkLnRvVGFyZ2V0ID0gbmV3IEJlbG9uZ3NUbyh0aGlzLnBhaXJlZC50aHJvdWdoLm1vZGVsLCB0aGlzLnBhaXJlZC50YXJnZXQsIHtcbiAgICAgICAgZm9yZWlnbktleTogdGhpcy5wYWlyZWQub3RoZXJLZXlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYWlyZWQub25lRnJvbVRhcmdldCA9IG5ldyBIYXNPbmUodGhpcy5wYWlyZWQudGFyZ2V0LCB0aGlzLnBhaXJlZC50aHJvdWdoLm1vZGVsLCB7XG4gICAgICAgIGZvcmVpZ25LZXk6IHRoaXMucGFpcmVkLm90aGVyS2V5LFxuICAgICAgICBzb3VyY2VLZXk6IHRoaXMucGFpcmVkLnRhcmdldEtleSxcbiAgICAgICAgYXM6IHRoaXMucGFpcmVkLnRocm91Z2gubW9kZWwubmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIEhlbHBlcnMuY2hlY2tOYW1pbmdDb2xsaXNpb24odGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbWl4aW4ob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFtcImdldFwiLCBcImNvdW50XCIsIFwiaGFzU2luZ2xlXCIsIFwiaGFzQWxsXCIsIFwic2V0XCIsIFwiYWRkXCIsIFwiYWRkTXVsdGlwbGVcIiwgXCJyZW1vdmVcIiwgXCJyZW1vdmVNdWx0aXBsZVwiLCBcImNyZWF0ZVwiXTtcbiAgICBjb25zdCBhbGlhc2VzID0ge1xuICAgICAgaGFzU2luZ2xlOiBcImhhc1wiLFxuICAgICAgaGFzQWxsOiBcImhhc1wiLFxuICAgICAgYWRkTXVsdGlwbGU6IFwiYWRkXCIsXG4gICAgICByZW1vdmVNdWx0aXBsZTogXCJyZW1vdmVcIlxuICAgIH07XG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzLCBhbGlhc2VzKTtcbiAgfVxuICBhc3luYyBnZXQoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpIHx8IHt9O1xuICAgIGNvbnN0IHRocm91Z2ggPSB0aGlzLnRocm91Z2g7XG4gICAgbGV0IHNjb3BlV2hlcmU7XG4gICAgbGV0IHRocm91Z2hXaGVyZTtcbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgc2NvcGVXaGVyZSA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLnNjb3BlKTtcbiAgICB9XG4gICAgb3B0aW9ucy53aGVyZSA9IHtcbiAgICAgIFtPcC5hbmRdOiBbXG4gICAgICAgIHNjb3BlV2hlcmUsXG4gICAgICAgIG9wdGlvbnMud2hlcmVcbiAgICAgIF1cbiAgICB9O1xuICAgIGlmIChPYmplY3QodGhyb3VnaC5tb2RlbCkgPT09IHRocm91Z2gubW9kZWwpIHtcbiAgICAgIHRocm91Z2hXaGVyZSA9IHt9O1xuICAgICAgdGhyb3VnaFdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuICAgICAgaWYgKHRocm91Z2guc2NvcGUpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aHJvdWdoV2hlcmUsIHRocm91Z2guc2NvcGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudGhyb3VnaCAmJiBvcHRpb25zLnRocm91Z2gud2hlcmUpIHtcbiAgICAgICAgdGhyb3VnaFdoZXJlID0ge1xuICAgICAgICAgIFtPcC5hbmRdOiBbdGhyb3VnaFdoZXJlLCBvcHRpb25zLnRocm91Z2gud2hlcmVdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUgfHwgW107XG4gICAgICBvcHRpb25zLmluY2x1ZGUucHVzaCh7XG4gICAgICAgIGFzc29jaWF0aW9uOiB0aGlzLm9uZUZyb21UYXJnZXQsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuam9pblRhYmxlQXR0cmlidXRlcyxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIHBhcmFub2lkOiBfLmdldChvcHRpb25zLnRocm91Z2gsIFwicGFyYW5vaWRcIiwgdHJ1ZSksXG4gICAgICAgIHdoZXJlOiB0aHJvdWdoV2hlcmVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbW9kZWwgPSB0aGlzLnRhcmdldDtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NvcGVcIikpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zY29wZSkge1xuICAgICAgICBtb2RlbCA9IG1vZGVsLnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbCA9IG1vZGVsLnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NoZW1hXCIpKSB7XG4gICAgICBtb2RlbCA9IG1vZGVsLnNjaGVtYShvcHRpb25zLnNjaGVtYSwgb3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwuZmluZEFsbChvcHRpb25zKTtcbiAgfVxuICBhc3luYyBjb3VudChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNlcXVlbGl6ZSA9IHRoaXMudGFyZ2V0LnNlcXVlbGl6ZTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IFtcbiAgICAgIFtzZXF1ZWxpemUuZm4oXCJDT1VOVFwiLCBzZXF1ZWxpemUuY29sKFt0aGlzLnRhcmdldC5uYW1lLCB0aGlzLnRhcmdldEtleUZpZWxkXS5qb2luKFwiLlwiKSkpLCBcImNvdW50XCJdXG4gICAgXTtcbiAgICBvcHRpb25zLmpvaW5UYWJsZUF0dHJpYnV0ZXMgPSBbXTtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgb3B0aW9ucy5wbGFpbiA9IHRydWU7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQoaW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBwYXJzZUludChyZXN1bHQuY291bnQsIDEwKTtcbiAgfVxuICBhc3luYyBoYXMoc291cmNlSW5zdGFuY2UsIGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcmF3OiB0cnVlXG4gICAgfSwgb3B0aW9ucyksIHtcbiAgICAgIHNjb3BlOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZXM6IFt0aGlzLnRhcmdldEtleV0sXG4gICAgICBqb2luVGFibGVBdHRyaWJ1dGVzOiBbXVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RhbmNlUHJpbWFyeUtleXMgPSBpbnN0YW5jZXMubWFwKChpbnN0YW5jZSkgPT4ge1xuICAgICAgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLndoZXJlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbdGhpcy50YXJnZXRLZXldOiBpbnN0YW5jZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgeyBbT3Aub3JdOiBpbnN0YW5jZVByaW1hcnlLZXlzIH0sXG4gICAgICAgIG9wdGlvbnMud2hlcmVcbiAgICAgIF1cbiAgICB9O1xuICAgIGNvbnN0IGFzc29jaWF0ZWRPYmplY3RzID0gYXdhaXQgdGhpcy5nZXQoc291cmNlSW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2VXaXRoKGluc3RhbmNlUHJpbWFyeUtleXMsIGFzc29jaWF0ZWRPYmplY3RzLCAoYSwgYikgPT4gXy5pc0VxdWFsKGFbdGhpcy50YXJnZXRLZXldLCBiW3RoaXMudGFyZ2V0S2V5XSkpLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBhc3luYyBzZXQoc291cmNlSW5zdGFuY2UsIG5ld0Fzc29jaWF0ZWRPYmplY3RzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc291cmNlS2V5ID0gdGhpcy5zb3VyY2VLZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy50YXJnZXRLZXk7XG4gICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcjtcbiAgICBjb25zdCBmb3JlaWduSWRlbnRpZmllciA9IHRoaXMuZm9yZWlnbklkZW50aWZpZXI7XG4gICAgaWYgKG5ld0Fzc29jaWF0ZWRPYmplY3RzID09PSBudWxsKSB7XG4gICAgICBuZXdBc3NvY2lhdGVkT2JqZWN0cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdBc3NvY2lhdGVkT2JqZWN0cyA9IHRoaXMudG9JbnN0YW5jZUFycmF5KG5ld0Fzc29jaWF0ZWRPYmplY3RzKTtcbiAgICB9XG4gICAgY29uc3Qgd2hlcmUgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpXG4gICAgfSwgdGhpcy50aHJvdWdoLnNjb3BlKTtcbiAgICBjb25zdCB1cGRhdGVBc3NvY2lhdGlvbnMgPSAoY3VycmVudFJvd3MpID0+IHtcbiAgICAgIGNvbnN0IG9ic29sZXRlQXNzb2NpYXRpb25zID0gW107XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZXMgPSBvcHRpb25zLnRocm91Z2ggfHwge307XG4gICAgICBjb25zdCB1bmFzc29jaWF0ZWRPYmplY3RzID0gbmV3QXNzb2NpYXRlZE9iamVjdHMuZmlsdGVyKChvYmopID0+ICFjdXJyZW50Um93cy5zb21lKChjdXJyZW50Um93KSA9PiBjdXJyZW50Um93W2ZvcmVpZ25JZGVudGlmaWVyXSA9PT0gb2JqLmdldCh0YXJnZXRLZXkpKSk7XG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnRSb3cgb2YgY3VycmVudFJvd3MpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqID0gbmV3QXNzb2NpYXRlZE9iamVjdHMuZmluZCgob2JqKSA9PiBjdXJyZW50Um93W2ZvcmVpZ25JZGVudGlmaWVyXSA9PT0gb2JqLmdldCh0YXJnZXRLZXkpKTtcbiAgICAgICAgaWYgKCFuZXdPYmopIHtcbiAgICAgICAgICBvYnNvbGV0ZUFzc29jaWF0aW9ucy5wdXNoKGN1cnJlbnRSb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCB0aHJvdWdoQXR0cmlidXRlcyA9IG5ld09ialt0aGlzLnRocm91Z2gubW9kZWwubmFtZV07XG4gICAgICAgICAgaWYgKHRocm91Z2hBdHRyaWJ1dGVzIGluc3RhbmNlb2YgdGhpcy50aHJvdWdoLm1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdWdoQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRBdHRyaWJ1dGVzKSwgdGhyb3VnaEF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy50aHJvdWdoLm1vZGVsLnVwZGF0ZShhdHRyaWJ1dGVzLCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgd2hlcmU6IHtcbiAgICAgICAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IG5ld09iai5nZXQodGFyZ2V0S2V5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9ic29sZXRlQXNzb2NpYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRocm91Z2gubW9kZWwuZGVzdHJveShfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgIHdoZXJlOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgICAgW2ZvcmVpZ25JZGVudGlmaWVyXTogb2Jzb2xldGVBc3NvY2lhdGlvbnMubWFwKChvYnNvbGV0ZUFzc29jaWF0aW9uKSA9PiBvYnNvbGV0ZUFzc29jaWF0aW9uW2ZvcmVpZ25JZGVudGlmaWVyXSlcbiAgICAgICAgICB9LCB0aGlzLnRocm91Z2guc2NvcGUpXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICBpZiAodW5hc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGJ1bGsgPSB1bmFzc29jaWF0ZWRPYmplY3RzLm1hcCgodW5hc3NvY2lhdGVkT2JqZWN0KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGRlZmF1bHRBdHRyaWJ1dGVzKSwgdW5hc3NvY2lhdGVkT2JqZWN0W3RoaXMudGhyb3VnaC5tb2RlbC5uYW1lXSksIHtcbiAgICAgICAgICAgIFtpZGVudGlmaWVyXTogc291cmNlSW5zdGFuY2UuZ2V0KHNvdXJjZUtleSksXG4gICAgICAgICAgICBbZm9yZWlnbklkZW50aWZpZXJdOiB1bmFzc29jaWF0ZWRPYmplY3QuZ2V0KHRhcmdldEtleSlcbiAgICAgICAgICB9KSwgdGhpcy50aHJvdWdoLnNjb3BlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy50aHJvdWdoLm1vZGVsLmJ1bGtDcmVhdGUoYnVsaywgX19zcHJlYWRWYWx1ZXMoeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRpb25zKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93cyA9IGF3YWl0IHRoaXMudGhyb3VnaC5tb2RlbC5maW5kQWxsKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHdoZXJlLCByYXc6IHRydWUgfSkpO1xuICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUFzc29jaWF0aW9ucyhjdXJyZW50Um93cyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVtcHR5UmVzdWx0RXJyb3IpXG4gICAgICAgIHJldHVybiB1cGRhdGVBc3NvY2lhdGlvbnMoW10pO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZChzb3VyY2VJbnN0YW5jZSwgbmV3SW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuZXdJbnN0YW5jZXMpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IHRoaXM7XG4gICAgY29uc3Qgc291cmNlS2V5ID0gYXNzb2NpYXRpb24uc291cmNlS2V5O1xuICAgIGNvbnN0IHRhcmdldEtleSA9IGFzc29jaWF0aW9uLnRhcmdldEtleTtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gYXNzb2NpYXRpb24uaWRlbnRpZmllcjtcbiAgICBjb25zdCBmb3JlaWduSWRlbnRpZmllciA9IGFzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyO1xuICAgIGNvbnN0IGRlZmF1bHRBdHRyaWJ1dGVzID0gb3B0aW9ucy50aHJvdWdoIHx8IHt9O1xuICAgIG5ld0luc3RhbmNlcyA9IGFzc29jaWF0aW9uLnRvSW5zdGFuY2VBcnJheShuZXdJbnN0YW5jZXMpO1xuICAgIGNvbnN0IHdoZXJlID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgW2lkZW50aWZpZXJdOiBzb3VyY2VJbnN0YW5jZS5nZXQoc291cmNlS2V5KSxcbiAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IG5ld0luc3RhbmNlcy5tYXAoKG5ld0luc3RhbmNlKSA9PiBuZXdJbnN0YW5jZS5nZXQodGFyZ2V0S2V5KSlcbiAgICB9LCBhc3NvY2lhdGlvbi50aHJvdWdoLnNjb3BlKTtcbiAgICBjb25zdCB1cGRhdGVBc3NvY2lhdGlvbnMgPSAoY3VycmVudFJvd3MpID0+IHtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBjb25zdCB1bmFzc29jaWF0ZWRPYmplY3RzID0gW107XG4gICAgICBjb25zdCBjaGFuZ2VkQXNzb2NpYXRpb25zID0gW107XG4gICAgICBmb3IgKGNvbnN0IG9iaiBvZiBuZXdJbnN0YW5jZXMpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdBc3NvY2lhdGlvbiA9IGN1cnJlbnRSb3dzICYmIGN1cnJlbnRSb3dzLmZpbmQoKGN1cnJlbnQpID0+IGN1cnJlbnRbZm9yZWlnbklkZW50aWZpZXJdID09PSBvYmouZ2V0KHRhcmdldEtleSkpO1xuICAgICAgICBpZiAoIWV4aXN0aW5nQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICB1bmFzc29jaWF0ZWRPYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IG9ialthc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEF0dHJpYnV0ZXMpLCB0aHJvdWdoQXR0cmlidXRlcyk7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLnNvbWUoKGF0dHJpYnV0ZSkgPT4gYXR0cmlidXRlc1thdHRyaWJ1dGVdICE9PSBleGlzdGluZ0Fzc29jaWF0aW9uW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgICAgICBjaGFuZ2VkQXNzb2NpYXRpb25zLnB1c2gob2JqKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1bmFzc29jaWF0ZWRPYmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYnVsayA9IHVuYXNzb2NpYXRlZE9iamVjdHMubWFwKCh1bmFzc29jaWF0ZWRPYmplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IHVuYXNzb2NpYXRlZE9iamVjdFthc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdO1xuICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgZGVmYXVsdEF0dHJpYnV0ZXMpLCB0aHJvdWdoQXR0cmlidXRlcyk7XG4gICAgICAgICAgYXR0cmlidXRlc1tpZGVudGlmaWVyXSA9IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpO1xuICAgICAgICAgIGF0dHJpYnV0ZXNbZm9yZWlnbklkZW50aWZpZXJdID0gdW5hc3NvY2lhdGVkT2JqZWN0LmdldCh0YXJnZXRLZXkpO1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oYXR0cmlidXRlcywgYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZSk7XG4gICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwuYnVsa0NyZWF0ZShidWxrLCBfX3NwcmVhZFZhbHVlcyh7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdGlvbnMpKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGFzc29jIG9mIGNoYW5nZWRBc3NvY2lhdGlvbnMpIHtcbiAgICAgICAgbGV0IHRocm91Z2hBdHRyaWJ1dGVzID0gYXNzb2NbYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBkZWZhdWx0QXR0cmlidXRlcyksIHRocm91Z2hBdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKHRocm91Z2hBdHRyaWJ1dGVzIGluc3RhbmNlb2YgYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbCkge1xuICAgICAgICAgIHRocm91Z2hBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZXMucHVzaChhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnVwZGF0ZShhdHRyaWJ1dGVzLCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHsgd2hlcmU6IHtcbiAgICAgICAgICBbaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChzb3VyY2VLZXkpLFxuICAgICAgICAgIFtmb3JlaWduSWRlbnRpZmllcl06IGFzc29jLmdldCh0YXJnZXRLZXkpXG4gICAgICAgIH0gfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3VycmVudFJvd3MgPSBhd2FpdCBhc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLmZpbmRBbGwoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgd2hlcmUsIHJhdzogdHJ1ZSB9KSk7XG4gICAgICBjb25zdCBbYXNzb2NpYXRpb25zXSA9IGF3YWl0IHVwZGF0ZUFzc29jaWF0aW9ucyhjdXJyZW50Um93cyk7XG4gICAgICByZXR1cm4gYXNzb2NpYXRpb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFbXB0eVJlc3VsdEVycm9yKVxuICAgICAgICByZXR1cm4gdXBkYXRlQXNzb2NpYXRpb25zKCk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlKHNvdXJjZUluc3RhbmNlLCBvbGRBc3NvY2lhdGVkT2JqZWN0cywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvbGRBc3NvY2lhdGVkT2JqZWN0cyA9IGFzc29jaWF0aW9uLnRvSW5zdGFuY2VBcnJheShvbGRBc3NvY2lhdGVkT2JqZWN0cyk7XG4gICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICBbYXNzb2NpYXRpb24uaWRlbnRpZmllcl06IHNvdXJjZUluc3RhbmNlLmdldChhc3NvY2lhdGlvbi5zb3VyY2VLZXkpLFxuICAgICAgW2Fzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyXTogb2xkQXNzb2NpYXRlZE9iamVjdHMubWFwKChuZXdJbnN0YW5jZSkgPT4gbmV3SW5zdGFuY2UuZ2V0KGFzc29jaWF0aW9uLnRhcmdldEtleSkpXG4gICAgfTtcbiAgICByZXR1cm4gYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5kZXN0cm95KF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHdoZXJlIH0pKTtcbiAgfVxuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gdGhpcztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGZpZWxkczogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGFzc29jaWF0aW9uLnNjb3BlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHZhbHVlcywgYXNzb2NpYXRpb24uc2NvcGUpO1xuICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gb3B0aW9ucy5maWVsZHMuY29uY2F0KE9iamVjdC5rZXlzKGFzc29jaWF0aW9uLnNjb3BlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5ld0Fzc29jaWF0ZWRPYmplY3QgPSBhd2FpdCBhc3NvY2lhdGlvbi50YXJnZXQuY3JlYXRlKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgYXdhaXQgc291cmNlSW5zdGFuY2VbYXNzb2NpYXRpb24uYWNjZXNzb3JzLmFkZF0obmV3QXNzb2NpYXRlZE9iamVjdCwgXy5vbWl0KG9wdGlvbnMsIFtcImZpZWxkc1wiXSkpO1xuICAgIHJldHVybiBuZXdBc3NvY2lhdGVkT2JqZWN0O1xuICB9XG4gIHZlcmlmeUFzc29jaWF0aW9uQWxpYXMoYWxpYXMpIHtcbiAgICBpZiAodHlwZW9mIGFsaWFzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXM7XG4gICAgfVxuICAgIGlmIChhbGlhcyAmJiBhbGlhcy5wbHVyYWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5wbHVyYWw7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQmVsb25nc1RvTWFueTtcbm1vZHVsZS5leHBvcnRzLkJlbG9uZ3NUb01hbnkgPSBCZWxvbmdzVG9NYW55O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEJlbG9uZ3NUb01hbnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZWxvbmdzLXRvLW1hbnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/belongs-to.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"BelongsTo\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        this.as,\n        this.target.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n    if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? \"SET NULL\" : \"NO ACTION\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n    this.source.refreshAttributes();\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map((_instance) => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, { raw: true })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, { raw: true })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n    sourceInstance.set(this.foreignKey, value);\n    if (options.save === false)\n      return;\n    options = __spreadValues({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n    return await sourceInstance.save(options);\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports[\"default\"] = BelongsTo;\n//# sourceMappingURL=belongs-to.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsK0RBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFRO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxxRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx1QkFBdUIseURBQXlELGlCQUFpQjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQixpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by5qcz9mN2VlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi8uLi91dGlsc1wiKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvcnNcIik7XG5jbGFzcyBCZWxvbmdzVG8gZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gXCJCZWxvbmdzVG9cIjtcbiAgICB0aGlzLmlzU2luZ2xlQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgc2luZ3VsYXI6IHRoaXMuYXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUuc2luZ3VsYXI7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgfVxuICAgIGlmICghdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSBVdGlscy5jYW1lbGl6ZShbXG4gICAgICAgIHRoaXMuYXMsXG4gICAgICAgIHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVcbiAgICAgIF0uam9pbihcIl9cIikpO1xuICAgIH1cbiAgICB0aGlzLmlkZW50aWZpZXIgPSB0aGlzLmZvcmVpZ25LZXk7XG4gICAgaWYgKHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5pZGVudGlmaWVyXSkge1xuICAgICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuaWRlbnRpZmllcl0uZmllbGQgfHwgdGhpcy5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnRhcmdldEtleSAmJiAhdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLm9wdGlvbnMudGFyZ2V0S2V5XSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGF0dHJpYnV0ZSBcIiR7dGhpcy5vcHRpb25zLnRhcmdldEtleX1cIiBwYXNzZWQgYXMgdGFyZ2V0S2V5LCBkZWZpbmUgdGhpcyBhdHRyaWJ1dGUgb24gbW9kZWwgXCIke3RoaXMudGFyZ2V0Lm5hbWV9XCIgZmlyc3RgKTtcbiAgICB9XG4gICAgdGhpcy50YXJnZXRLZXkgPSB0aGlzLm9wdGlvbnMudGFyZ2V0S2V5IHx8IHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy50YXJnZXRLZXlGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLmZpZWxkIHx8IHRoaXMudGFyZ2V0S2V5O1xuICAgIHRoaXMudGFyZ2V0S2V5SXNQcmltYXJ5ID0gdGhpcy50YXJnZXRLZXkgPT09IHRoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgdGhpcy50YXJnZXRJZGVudGlmaWVyID0gdGhpcy50YXJnZXRLZXk7XG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICB0aGlzLm9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLnVzZUhvb2tzO1xuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7c2luZ3VsYXJ9YCxcbiAgICAgIHNldDogYHNldCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YFxuICAgIH07XG4gIH1cbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5rZXlUeXBlIHx8IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy50YXJnZXRLZXldLnR5cGUsXG4gICAgICAgIGFsbG93TnVsbDogdHJ1ZVxuICAgICAgfSwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSB8fCBuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV07XG4gICAgICB0aGlzLm9wdGlvbnMub25EZWxldGUgPSB0aGlzLm9wdGlvbnMub25EZWxldGUgfHwgKHNvdXJjZS5hbGxvd051bGwgPyBcIlNFVCBOVUxMXCIgOiBcIk5PIEFDVElPTlwiKTtcbiAgICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZSA9IHRoaXMub3B0aW9ucy5vblVwZGF0ZSB8fCBcIkNBU0NBREVcIjtcbiAgICB9XG4gICAgSGVscGVycy5hZGRGb3JlaWduS2V5Q29uc3RyYWludHMobmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLCB0aGlzLnRhcmdldCwgdGhpcy5zb3VyY2UsIHRoaXMub3B0aW9ucywgdGhpcy50YXJnZXRLZXlGaWVsZCk7XG4gICAgVXRpbHMubWVyZ2VEZWZhdWx0cyh0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcbiAgICB0aGlzLnNvdXJjZS5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICBIZWxwZXJzLmNoZWNrTmFtaW5nQ29sbGlzaW9uKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG1peGluKG9iaikge1xuICAgIGNvbnN0IG1ldGhvZHMgPSBbXCJnZXRcIiwgXCJzZXRcIiwgXCJjcmVhdGVcIl07XG4gICAgSGVscGVycy5taXhpbk1ldGhvZHModGhpcywgb2JqLCBtZXRob2RzKTtcbiAgfVxuICBhc3luYyBnZXQoaW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgICBsZXQgVGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInNjb3BlXCIpKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnVuc2NvcGVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBUYXJnZXQgPSBUYXJnZXQuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY2hlbWFcIikpIHtcbiAgICAgIFRhcmdldCA9IFRhcmdldC5zY2hlbWEob3B0aW9ucy5zY2hlbWEsIG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICB3aGVyZVt0aGlzLnRhcmdldEtleV0gPSB7XG4gICAgICAgIFtPcC5pbl06IGluc3RhbmNlcy5tYXAoKF9pbnN0YW5jZSkgPT4gX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXkpKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0S2V5SXNQcmltYXJ5ICYmICFvcHRpb25zLndoZXJlKSB7XG4gICAgICAgIHJldHVybiBUYXJnZXQuZmluZEJ5UGsoaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgd2hlcmVbdGhpcy50YXJnZXRLZXldID0gaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSk7XG4gICAgICBvcHRpb25zLmxpbWl0ID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucy53aGVyZSA9IG9wdGlvbnMud2hlcmUgPyB7IFtPcC5hbmRdOiBbd2hlcmUsIG9wdGlvbnMud2hlcmVdIH0gOiB3aGVyZTtcbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgVGFyZ2V0LmZpbmRBbGwob3B0aW9ucyk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXksIHsgcmF3OiB0cnVlIH0pXSA9IG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMudGFyZ2V0S2V5LCB7IHJhdzogdHJ1ZSB9KV0gPSBfaW5zdGFuY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gVGFyZ2V0LmZpbmRPbmUob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCBhc3NvY2lhdGVkSW5zdGFuY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCB2YWx1ZSA9IGFzc29jaWF0ZWRJbnN0YW5jZTtcbiAgICBpZiAoYXNzb2NpYXRlZEluc3RhbmNlIGluc3RhbmNlb2YgdGhpcy50YXJnZXQpIHtcbiAgICAgIHZhbHVlID0gYXNzb2NpYXRlZEluc3RhbmNlW3RoaXMudGFyZ2V0S2V5XTtcbiAgICB9XG4gICAgc291cmNlSW5zdGFuY2Uuc2V0KHRoaXMuZm9yZWlnbktleSwgdmFsdWUpO1xuICAgIGlmIChvcHRpb25zLnNhdmUgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBmaWVsZHM6IFt0aGlzLmZvcmVpZ25LZXldLFxuICAgICAgYWxsb3dOdWxsOiBbdGhpcy5mb3JlaWduS2V5XSxcbiAgICAgIGFzc29jaWF0aW9uOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHNvdXJjZUluc3RhbmNlLnNhdmUob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlKHNvdXJjZUluc3RhbmNlLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbmV3QXNzb2NpYXRlZE9iamVjdCA9IGF3YWl0IHRoaXMudGFyZ2V0LmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgIGF3YWl0IHNvdXJjZUluc3RhbmNlW3RoaXMuYWNjZXNzb3JzLnNldF0obmV3QXNzb2NpYXRlZE9iamVjdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ld0Fzc29jaWF0ZWRPYmplY3Q7XG4gIH1cbiAgdmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykge1xuICAgIGlmICh0eXBlb2YgYWxpYXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcztcbiAgICB9XG4gICAgaWYgKGFsaWFzICYmIGFsaWFzLnNpbmd1bGFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMuc2luZ3VsYXI7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0FsaWFzZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQmVsb25nc1RvO1xubW9kdWxlLmV4cG9ydHMuQmVsb25nc1RvID0gQmVsb25nc1RvO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEJlbG9uZ3NUbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJlbG9uZ3MtdG8uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/has-many.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-many.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.options.through) {\n      throw new Error(\"N:M associations are not supported with hasMany. Use belongsToMany instead\");\n    }\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        this.source.options.name.singular,\n        this.source.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    const constraintOptions = __spreadValues({}, this.options);\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      constraintOptions.onUpdate = constraintOptions.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instances, options = {}) {\n    const where = {};\n    let Model = this.target;\n    let instance;\n    let values;\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    options = __spreadValues({}, options);\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    if (instances) {\n      values = instances.map((_instance) => _instance.get(this.sourceKey, { raw: true }));\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this,\n          values\n        };\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n    const results = await Model.findAll(options);\n    if (instance)\n      return results;\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, { raw: true })] = [];\n    }\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);\n    }\n    return result;\n  }\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [\n        this.sequelize.fn(\"COUNT\", this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)),\n        \"count\"\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    });\n    where[Op.or] = targetInstances.map((instance) => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return associatedObjects.length === targetInstances.length;\n  }\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n    const oldAssociations = await this.get(sourceInstance, __spreadProps(__spreadValues({}, options), { scope: false, raw: true }));\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter((old) => !targetInstances.find((obj) => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    const unassociatedObjects = targetInstances.filter((obj) => !oldAssociations.find((old) => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    let updateWhere;\n    let update;\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map((associatedObject) => associatedObject[this.target.primaryKeyAttribute])\n      };\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map((unassociatedObject) => unassociatedObject[this.target.primaryKeyAttribute]);\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n    await Promise.all(promises);\n    return sourceInstance;\n  }\n  async add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances)\n      return Promise.resolve();\n    targetInstances = this.toInstanceArray(targetInstances);\n    const update = __spreadValues({\n      [this.foreignKey]: sourceInstance.get(this.sourceKey)\n    }, this.scope);\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map((unassociatedObject) => unassociatedObject.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), { where }));\n    return sourceInstance;\n  }\n  async remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n    targetInstances = this.toInstanceArray(targetInstances);\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map((targetInstance) => targetInstance.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), { where }));\n    return this;\n  }\n  async create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (values === void 0) {\n      values = {};\n    }\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields)\n          options.fields.push(attribute);\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields)\n      options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports[\"default\"] = HasMany;\n//# sourceMappingURL=has-many.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW1hbnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLCtEQUFZO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFXO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBUTtBQUNwQyxXQUFXLG1CQUFPLENBQUMscUVBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4Qix5QkFBeUIsT0FBTztBQUNoQyxpQkFBaUIsU0FBUztBQUMxQix1QkFBdUIsU0FBUztBQUNoQyx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0IsT0FBTztBQUN0Qyx1QkFBdUIsU0FBUztBQUNoQyxvQkFBb0IsT0FBTztBQUMzQixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFdBQVc7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4REFBOEQsV0FBVztBQUN6RTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUJBQWlCLEdBQUcsNEJBQTRCO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBGQUEwRixjQUFjLHlCQUF5QjtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWMsT0FBTztBQUNwRztBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYyxPQUFPO0FBQ3BHO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW1hbnkuanM/MTFjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi8uLi91dGlsc1wiKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvcnNcIik7XG5jbGFzcyBIYXNNYW55IGV4dGVuZHMgQXNzb2NpYXRpb24ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICB0aGlzLmFzc29jaWF0aW9uVHlwZSA9IFwiSGFzTWFueVwiO1xuICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSBudWxsO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc291cmNlLnNlcXVlbGl6ZTtcbiAgICB0aGlzLmlzTXVsdGlBc3NvY2lhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlID0ge307XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aHJvdWdoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOOk0gYXNzb2NpYXRpb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggaGFzTWFueS4gVXNlIGJlbG9uZ3NUb01hbnkgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxmQXNzb2NpYXRpb24pIHtcbiAgICAgIHRoaXMudGFyZ2V0QXNzb2NpYXRpb24gPSB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcykge1xuICAgICAgdGhpcy5pc0FsaWFzZWQgPSB0cnVlO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdCh0aGlzLmFzKSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMuYXM7XG4gICAgICAgIHRoaXMuYXMgPSB0aGlzLmFzLnBsdXJhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5uYW1lID0ge1xuICAgICAgICAgIHBsdXJhbDogdGhpcy5hcyxcbiAgICAgICAgICBzaW5ndWxhcjogVXRpbHMuc2luZ3VsYXJpemUodGhpcy5hcylcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcyA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZS5wbHVyYWw7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgfVxuICAgIGlmICghdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSBVdGlscy5jYW1lbGl6ZShbXG4gICAgICAgIHRoaXMuc291cmNlLm9wdGlvbnMubmFtZS5zaW5ndWxhcixcbiAgICAgICAgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgXS5qb2luKFwiX1wiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0pIHtcbiAgICAgIHRoaXMuaWRlbnRpZmllckZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2VLZXkgPSB0aGlzLm9wdGlvbnMuc291cmNlS2V5IHx8IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgaWYgKHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldKSB7XG4gICAgICB0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSA9IHRoaXMuc291cmNlS2V5O1xuICAgICAgdGhpcy5zb3VyY2VLZXlGaWVsZCA9IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLmZpZWxkIHx8IHRoaXMuc291cmNlS2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSA9IHRoaXMuc291cmNlLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucHJpbWFyeUtleUZpZWxkO1xuICAgIH1cbiAgICBjb25zdCBwbHVyYWwgPSBfLnVwcGVyRmlyc3QodGhpcy5vcHRpb25zLm5hbWUucGx1cmFsKTtcbiAgICBjb25zdCBzaW5ndWxhciA9IF8udXBwZXJGaXJzdCh0aGlzLm9wdGlvbnMubmFtZS5zaW5ndWxhcik7XG4gICAgdGhpcy5hc3NvY2lhdGlvbkFjY2Vzc29yID0gdGhpcy5hcztcbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7cGx1cmFsfWAsXG4gICAgICBzZXQ6IGBzZXQke3BsdXJhbH1gLFxuICAgICAgYWRkTXVsdGlwbGU6IGBhZGQke3BsdXJhbH1gLFxuICAgICAgYWRkOiBgYWRkJHtzaW5ndWxhcn1gLFxuICAgICAgY3JlYXRlOiBgY3JlYXRlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlOiBgcmVtb3ZlJHtzaW5ndWxhcn1gLFxuICAgICAgcmVtb3ZlTXVsdGlwbGU6IGByZW1vdmUke3BsdXJhbH1gLFxuICAgICAgaGFzU2luZ2xlOiBgaGFzJHtzaW5ndWxhcn1gLFxuICAgICAgaGFzQWxsOiBgaGFzJHtwbHVyYWx9YCxcbiAgICAgIGNvdW50OiBgY291bnQke3BsdXJhbH1gXG4gICAgfTtcbiAgfVxuICBfaW5qZWN0QXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLmtleVR5cGUgfHwgdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZV0udHlwZSxcbiAgICAgICAgYWxsb3dOdWxsOiB0cnVlXG4gICAgICB9LCB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUpXG4gICAgfTtcbiAgICBjb25zdCBjb25zdHJhaW50T3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29uc3RyYWludHMgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0gfHwgbmV3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldO1xuICAgICAgY29uc3RyYWludE9wdGlvbnMub25EZWxldGUgPSBjb25zdHJhaW50T3B0aW9ucy5vbkRlbGV0ZSB8fCAodGFyZ2V0LmFsbG93TnVsbCA/IFwiU0VUIE5VTExcIiA6IFwiQ0FTQ0FERVwiKTtcbiAgICAgIGNvbnN0cmFpbnRPcHRpb25zLm9uVXBkYXRlID0gY29uc3RyYWludE9wdGlvbnMub25VcGRhdGUgfHwgXCJDQVNDQURFXCI7XG4gICAgfVxuICAgIEhlbHBlcnMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgdGhpcy5zb3VyY2UsIHRoaXMudGFyZ2V0LCBjb25zdHJhaW50T3B0aW9ucywgdGhpcy5zb3VyY2VLZXlGaWVsZCk7XG4gICAgVXRpbHMubWVyZ2VEZWZhdWx0cyh0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzKTtcbiAgICB0aGlzLnRhcmdldC5yZWZyZXNoQXR0cmlidXRlcygpO1xuICAgIHRoaXMuc291cmNlLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gICAgdGhpcy5pZGVudGlmaWVyRmllbGQgPSB0aGlzLnRhcmdldC5yYXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV0uZmllbGQgfHwgdGhpcy5mb3JlaWduS2V5O1xuICAgIHRoaXMuZm9yZWlnbktleUZpZWxkID0gdGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldLmZpZWxkIHx8IHRoaXMuZm9yZWlnbktleTtcbiAgICB0aGlzLnNvdXJjZUtleUZpZWxkID0gdGhpcy5zb3VyY2UucmF3QXR0cmlidXRlc1t0aGlzLnNvdXJjZUtleV0uZmllbGQgfHwgdGhpcy5zb3VyY2VLZXk7XG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gW1wiZ2V0XCIsIFwiY291bnRcIiwgXCJoYXNTaW5nbGVcIiwgXCJoYXNBbGxcIiwgXCJzZXRcIiwgXCJhZGRcIiwgXCJhZGRNdWx0aXBsZVwiLCBcInJlbW92ZVwiLCBcInJlbW92ZU11bHRpcGxlXCIsIFwiY3JlYXRlXCJdO1xuICAgIGNvbnN0IGFsaWFzZXMgPSB7XG4gICAgICBoYXNTaW5nbGU6IFwiaGFzXCIsXG4gICAgICBoYXNBbGw6IFwiaGFzXCIsXG4gICAgICBhZGRNdWx0aXBsZTogXCJhZGRcIixcbiAgICAgIHJlbW92ZU11bHRpcGxlOiBcInJlbW92ZVwiXG4gICAgfTtcbiAgICBIZWxwZXJzLm1peGluTWV0aG9kcyh0aGlzLCBvYmosIG1ldGhvZHMsIGFsaWFzZXMpO1xuICB9XG4gIGFzeW5jIGdldChpbnN0YW5jZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG4gICAgbGV0IE1vZGVsID0gdGhpcy50YXJnZXQ7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGxldCB2YWx1ZXM7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGluc3RhbmNlcykpIHtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzO1xuICAgICAgaW5zdGFuY2VzID0gdm9pZCAwO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnNjb3BlKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHdoZXJlLCB0aGlzLnNjb3BlKTtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgdmFsdWVzID0gaW5zdGFuY2VzLm1hcCgoX2luc3RhbmNlKSA9PiBfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5LCB7IHJhdzogdHJ1ZSB9KSk7XG4gICAgICBpZiAob3B0aW9ucy5saW1pdCAmJiBpbnN0YW5jZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBvcHRpb25zLmdyb3VwZWRMaW1pdCA9IHtcbiAgICAgICAgICBsaW1pdDogb3B0aW9ucy5saW1pdCxcbiAgICAgICAgICBvbjogdGhpcyxcbiAgICAgICAgICB2YWx1ZXNcbiAgICAgICAgfTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMubGltaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGVyZVt0aGlzLmZvcmVpZ25LZXldID0ge1xuICAgICAgICAgIFtPcC5pbl06IHZhbHVlc1xuICAgICAgICB9O1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5ncm91cGVkTGltaXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pO1xuICAgIH1cbiAgICBvcHRpb25zLndoZXJlID0gb3B0aW9ucy53aGVyZSA/IHsgW09wLmFuZF06IFt3aGVyZSwgb3B0aW9ucy53aGVyZV0gfSA6IHdoZXJlO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY29wZVwiKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIE1vZGVsID0gTW9kZWwudW5zY29wZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1vZGVsID0gTW9kZWwuc2NvcGUob3B0aW9ucy5zY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY2hlbWFcIikpIHtcbiAgICAgIE1vZGVsID0gTW9kZWwuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBNb2RlbC5maW5kQWxsKG9wdGlvbnMpO1xuICAgIGlmIChpbnN0YW5jZSlcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgX2luc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiByZXN1bHRzKSB7XG4gICAgICByZXN1bHRbX2luc3RhbmNlLmdldCh0aGlzLmZvcmVpZ25LZXksIHsgcmF3OiB0cnVlIH0pXS5wdXNoKF9pbnN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY291bnQoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IFtcbiAgICAgIFtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUuZm4oXCJDT1VOVFwiLCB0aGlzLnNlcXVlbGl6ZS5jb2woYCR7dGhpcy50YXJnZXQubmFtZX0uJHt0aGlzLnRhcmdldC5wcmltYXJ5S2V5RmllbGR9YCkpLFxuICAgICAgICBcImNvdW50XCJcbiAgICAgIF1cbiAgICBdO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnBsYWluID0gdHJ1ZTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmdldChpbnN0YW5jZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KHJlc3VsdC5jb3VudCwgMTApO1xuICB9XG4gIGFzeW5jIGhhcyhzb3VyY2VJbnN0YW5jZSwgdGFyZ2V0SW5zdGFuY2VzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2hlcmUgPSB7fTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0SW5zdGFuY2VzKSkge1xuICAgICAgdGFyZ2V0SW5zdGFuY2VzID0gW3RhcmdldEluc3RhbmNlc107XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgc2NvcGU6IGZhbHNlLFxuICAgICAgYXR0cmlidXRlczogW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdLFxuICAgICAgcmF3OiB0cnVlXG4gICAgfSk7XG4gICAgd2hlcmVbT3Aub3JdID0gdGFyZ2V0SW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS53aGVyZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiBpbnN0YW5jZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgd2hlcmUsXG4gICAgICAgIG9wdGlvbnMud2hlcmVcbiAgICAgIF1cbiAgICB9O1xuICAgIGNvbnN0IGFzc29jaWF0ZWRPYmplY3RzID0gYXdhaXQgdGhpcy5nZXQoc291cmNlSW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhc3NvY2lhdGVkT2JqZWN0cy5sZW5ndGggPT09IHRhcmdldEluc3RhbmNlcy5sZW5ndGg7XG4gIH1cbiAgYXN5bmMgc2V0KHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0SW5zdGFuY2VzID09PSBudWxsKSB7XG4gICAgICB0YXJnZXRJbnN0YW5jZXMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0SW5zdGFuY2VzID0gdGhpcy50b0luc3RhbmNlQXJyYXkodGFyZ2V0SW5zdGFuY2VzKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkQXNzb2NpYXRpb25zID0gYXdhaXQgdGhpcy5nZXQoc291cmNlSW5zdGFuY2UsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHNjb3BlOiBmYWxzZSwgcmF3OiB0cnVlIH0pKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IG9ic29sZXRlQXNzb2NpYXRpb25zID0gb2xkQXNzb2NpYXRpb25zLmZpbHRlcigob2xkKSA9PiAhdGFyZ2V0SW5zdGFuY2VzLmZpbmQoKG9iaikgPT4gb2JqW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBvbGRbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0pKTtcbiAgICBjb25zdCB1bmFzc29jaWF0ZWRPYmplY3RzID0gdGFyZ2V0SW5zdGFuY2VzLmZpbHRlcigob2JqKSA9PiAhb2xkQXNzb2NpYXRpb25zLmZpbmQoKG9sZCkgPT4gb2JqW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdID09PSBvbGRbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0pKTtcbiAgICBsZXQgdXBkYXRlV2hlcmU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBpZiAob2Jzb2xldGVBc3NvY2lhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlID0ge307XG4gICAgICB1cGRhdGVbdGhpcy5mb3JlaWduS2V5XSA9IG51bGw7XG4gICAgICB1cGRhdGVXaGVyZSA9IHtcbiAgICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiBvYnNvbGV0ZUFzc29jaWF0aW9ucy5tYXAoKGFzc29jaWF0ZWRPYmplY3QpID0+IGFzc29jaWF0ZWRPYmplY3RbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0pXG4gICAgICB9O1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZSh1cGRhdGUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIHdoZXJlOiB1cGRhdGVXaGVyZVxuICAgICAgfSkpKTtcbiAgICB9XG4gICAgaWYgKHVuYXNzb2NpYXRlZE9iamVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgdXBkYXRlV2hlcmUgPSB7fTtcbiAgICAgIHVwZGF0ZSA9IHt9O1xuICAgICAgdXBkYXRlW3RoaXMuZm9yZWlnbktleV0gPSBzb3VyY2VJbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuICAgICAgT2JqZWN0LmFzc2lnbih1cGRhdGUsIHRoaXMuc2NvcGUpO1xuICAgICAgdXBkYXRlV2hlcmVbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSB1bmFzc29jaWF0ZWRPYmplY3RzLm1hcCgodW5hc3NvY2lhdGVkT2JqZWN0KSA9PiB1bmFzc29jaWF0ZWRPYmplY3RbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0pO1xuICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZSh1cGRhdGUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIHdoZXJlOiB1cGRhdGVXaGVyZVxuICAgICAgfSkpKTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIHJldHVybiBzb3VyY2VJbnN0YW5jZTtcbiAgfVxuICBhc3luYyBhZGQoc291cmNlSW5zdGFuY2UsIHRhcmdldEluc3RhbmNlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0YXJnZXRJbnN0YW5jZXMpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGFyZ2V0SW5zdGFuY2VzID0gdGhpcy50b0luc3RhbmNlQXJyYXkodGFyZ2V0SW5zdGFuY2VzKTtcbiAgICBjb25zdCB1cGRhdGUgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBbdGhpcy5mb3JlaWduS2V5XTogc291cmNlSW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KVxuICAgIH0sIHRoaXMuc2NvcGUpO1xuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW3RoaXMudGFyZ2V0LnByaW1hcnlLZXlBdHRyaWJ1dGVdOiB0YXJnZXRJbnN0YW5jZXMubWFwKCh1bmFzc29jaWF0ZWRPYmplY3QpID0+IHVuYXNzb2NpYXRlZE9iamVjdC5nZXQodGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZSkpXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZSh1cGRhdGUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHdoZXJlIH0pKTtcbiAgICByZXR1cm4gc291cmNlSW5zdGFuY2U7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlKHNvdXJjZUluc3RhbmNlLCB0YXJnZXRJbnN0YW5jZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBudWxsXG4gICAgfTtcbiAgICB0YXJnZXRJbnN0YW5jZXMgPSB0aGlzLnRvSW5zdGFuY2VBcnJheSh0YXJnZXRJbnN0YW5jZXMpO1xuICAgIGNvbnN0IHdoZXJlID0ge1xuICAgICAgW3RoaXMuZm9yZWlnbktleV06IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSksXG4gICAgICBbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV06IHRhcmdldEluc3RhbmNlcy5tYXAoKHRhcmdldEluc3RhbmNlKSA9PiB0YXJnZXRJbnN0YW5jZS5nZXQodGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZSkpXG4gICAgfTtcbiAgICBhd2FpdCB0aGlzLnRhcmdldC51bnNjb3BlZCgpLnVwZGF0ZSh1cGRhdGUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHdoZXJlIH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIGZpZWxkczogb3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZXMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKHRoaXMuc2NvcGUpKSB7XG4gICAgICAgIHZhbHVlc1thdHRyaWJ1dGVdID0gdGhpcy5zY29wZVthdHRyaWJ1dGVdO1xuICAgICAgICBpZiAob3B0aW9ucy5maWVsZHMpXG4gICAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXNbdGhpcy5mb3JlaWduS2V5XSA9IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleSk7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKVxuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh0aGlzLmZvcmVpZ25LZXkpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMucGx1cmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcyA9PT0gYWxpYXMucGx1cmFsO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNBbGlhc2VkO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhhc01hbnk7XG5tb2R1bGUuZXhwb3J0cy5IYXNNYW55ID0gSGFzTWFueTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBIYXNNYW55O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLW1hbnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/has-many.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/has-one.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/has-one.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ./../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Helpers = __webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/sequelize/lib/associations/helpers.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst Op = __webpack_require__(/*! ../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nclass HasOne extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasOne\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([\n        Utils.singularize(this.options.as || this.source.name),\n        this.source.primaryKeyAttribute\n      ].join(\"_\"));\n    }\n    if (this.options.sourceKey && !this.source.rawAttributes[this.options.sourceKey]) {\n      throw new Error(`Unknown attribute \"${this.options.sourceKey}\" passed as sourceKey, define this attribute on model \"${this.source.name}\" first`);\n    }\n    this.sourceKey = this.sourceKeyAttribute = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    this.sourceKeyIsPrimary = this.sourceKey === this.source.primaryKeyAttribute;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, this.options, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.foreignKey] = {\n        [Op.in]: instances.map((_instance) => _instance.get(this.sourceKey))\n      };\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey);\n    }\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n    options.where = options.where ? { [Op.and]: [where, options.where] } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.sourceKey, { raw: true })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.foreignKey, { raw: true })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance, options) {\n    options = __spreadProps(__spreadValues({}, options), { scope: false });\n    const oldInstance = await sourceInstance[this.accessors.get](options);\n    const alreadyAssociated = oldInstance && associatedInstance && this.target.primaryKeyAttributes.every((attribute) => oldInstance.get(attribute, { raw: true }) === (associatedInstance.get ? associatedInstance.get(attribute, { raw: true }) : associatedInstance));\n    if (oldInstance && !alreadyAssociated) {\n      oldInstance[this.foreignKey] = null;\n      await oldInstance.save(__spreadProps(__spreadValues({}, options), {\n        fields: [this.foreignKey],\n        allowNull: [this.foreignKey],\n        association: true\n      }));\n    }\n    if (associatedInstance && !alreadyAssociated) {\n      if (!(associatedInstance instanceof this.target)) {\n        const tmpInstance = {};\n        tmpInstance[this.target.primaryKeyAttribute] = associatedInstance;\n        associatedInstance = this.target.build(tmpInstance, {\n          isNewRecord: false\n        });\n      }\n      Object.assign(associatedInstance, this.scope);\n      associatedInstance.set(this.foreignKey, sourceInstance.get(this.sourceKeyAttribute));\n      return associatedInstance.save(options);\n    }\n    return null;\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) {\n          options.fields.push(attribute);\n        }\n      }\n    }\n    values[this.foreignKey] = sourceInstance.get(this.sourceKeyAttribute);\n    if (options.fields) {\n      options.fields.push(this.foreignKey);\n    }\n    return await this.target.create(values, options);\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = HasOne;\n//# sourceMappingURL=has-one.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGFzLW9uZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsK0RBQVk7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsNkVBQVc7QUFDbkMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFRO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxxRUFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsdUJBQXVCLHlEQUF5RCxpQkFBaUI7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLGlCQUFpQixTQUFTO0FBQzFCLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxtQ0FBbUM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsY0FBYztBQUN6RTtBQUNBLHNKQUFzSixXQUFXLG9FQUFvRSxXQUFXO0FBQ2hQO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvYXNzb2NpYXRpb25zL2hhcy1vbmUuanM/NzZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi8uLi91dGlsc1wiKTtcbmNvbnN0IEhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Jhc2VcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvcnNcIik7XG5jbGFzcyBIYXNPbmUgZXh0ZW5kcyBBc3NvY2lhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSwgdGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgc3VwZXIoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHRoaXMuYXNzb2NpYXRpb25UeXBlID0gXCJIYXNPbmVcIjtcbiAgICB0aGlzLmlzU2luZ2xlQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZSA9IHt9O1xuICAgIGlmICh0aGlzLmFzKSB7XG4gICAgICB0aGlzLmlzQWxpYXNlZCA9IHRydWU7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHtcbiAgICAgICAgc2luZ3VsYXI6IHRoaXMuYXNcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXMgPSB0aGlzLnRhcmdldC5vcHRpb25zLm5hbWUuc2luZ3VsYXI7XG4gICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMudGFyZ2V0Lm9wdGlvbnMubmFtZTtcbiAgICB9XG4gICAgaWYgKF8uaXNPYmplY3QodGhpcy5vcHRpb25zLmZvcmVpZ25LZXkpKSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXlBdHRyaWJ1dGUgPSB0aGlzLm9wdGlvbnMuZm9yZWlnbktleTtcbiAgICAgIHRoaXMuZm9yZWlnbktleSA9IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5uYW1lIHx8IHRoaXMuZm9yZWlnbktleUF0dHJpYnV0ZS5maWVsZE5hbWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgdGhpcy5mb3JlaWduS2V5ID0gdGhpcy5vcHRpb25zLmZvcmVpZ25LZXk7XG4gICAgfVxuICAgIGlmICghdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICB0aGlzLmZvcmVpZ25LZXkgPSBVdGlscy5jYW1lbGl6ZShbXG4gICAgICAgIFV0aWxzLnNpbmd1bGFyaXplKHRoaXMub3B0aW9ucy5hcyB8fCB0aGlzLnNvdXJjZS5uYW1lKSxcbiAgICAgICAgdGhpcy5zb3VyY2UucHJpbWFyeUtleUF0dHJpYnV0ZVxuICAgICAgXS5qb2luKFwiX1wiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuc291cmNlS2V5ICYmICF0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMub3B0aW9ucy5zb3VyY2VLZXldKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYXR0cmlidXRlIFwiJHt0aGlzLm9wdGlvbnMuc291cmNlS2V5fVwiIHBhc3NlZCBhcyBzb3VyY2VLZXksIGRlZmluZSB0aGlzIGF0dHJpYnV0ZSBvbiBtb2RlbCBcIiR7dGhpcy5zb3VyY2UubmFtZX1cIiBmaXJzdGApO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZUtleSA9IHRoaXMuc291cmNlS2V5QXR0cmlidXRlID0gdGhpcy5vcHRpb25zLnNvdXJjZUtleSB8fCB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMuc291cmNlS2V5RmllbGQgPSB0aGlzLnNvdXJjZS5yYXdBdHRyaWJ1dGVzW3RoaXMuc291cmNlS2V5XS5maWVsZCB8fCB0aGlzLnNvdXJjZUtleTtcbiAgICB0aGlzLnNvdXJjZUtleUlzUHJpbWFyeSA9IHRoaXMuc291cmNlS2V5ID09PSB0aGlzLnNvdXJjZS5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIHRoaXMuYXNzb2NpYXRpb25BY2Nlc3NvciA9IHRoaXMuYXM7XG4gICAgdGhpcy5vcHRpb25zLnVzZUhvb2tzID0gb3B0aW9ucy51c2VIb29rcztcbiAgICBpZiAodGhpcy50YXJnZXQucmF3QXR0cmlidXRlc1t0aGlzLmZvcmVpZ25LZXldKSB7XG4gICAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgfVxuICAgIGNvbnN0IHNpbmd1bGFyID0gXy51cHBlckZpcnN0KHRoaXMub3B0aW9ucy5uYW1lLnNpbmd1bGFyKTtcbiAgICB0aGlzLmFjY2Vzc29ycyA9IHtcbiAgICAgIGdldDogYGdldCR7c2luZ3VsYXJ9YCxcbiAgICAgIHNldDogYHNldCR7c2luZ3VsYXJ9YCxcbiAgICAgIGNyZWF0ZTogYGNyZWF0ZSR7c2luZ3VsYXJ9YFxuICAgIH07XG4gIH1cbiAgX2luamVjdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IHtcbiAgICAgIFt0aGlzLmZvcmVpZ25LZXldOiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHR5cGU6IHRoaXMub3B0aW9ucy5rZXlUeXBlIHx8IHRoaXMuc291cmNlLnJhd0F0dHJpYnV0ZXNbdGhpcy5zb3VyY2VLZXldLnR5cGUsXG4gICAgICAgIGFsbG93TnVsbDogdHJ1ZVxuICAgICAgfSwgdGhpcy5mb3JlaWduS2V5QXR0cmlidXRlKVxuICAgIH07XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSB8fCBuZXdBdHRyaWJ1dGVzW3RoaXMuZm9yZWlnbktleV07XG4gICAgICB0aGlzLm9wdGlvbnMub25EZWxldGUgPSB0aGlzLm9wdGlvbnMub25EZWxldGUgfHwgKHRhcmdldC5hbGxvd051bGwgPyBcIlNFVCBOVUxMXCIgOiBcIkNBU0NBREVcIik7XG4gICAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUgPSB0aGlzLm9wdGlvbnMub25VcGRhdGUgfHwgXCJDQVNDQURFXCI7XG4gICAgfVxuICAgIEhlbHBlcnMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XSwgdGhpcy5zb3VyY2UsIHRoaXMudGFyZ2V0LCB0aGlzLm9wdGlvbnMsIHRoaXMuc291cmNlS2V5RmllbGQpO1xuICAgIFV0aWxzLm1lcmdlRGVmYXVsdHModGhpcy50YXJnZXQucmF3QXR0cmlidXRlcywgbmV3QXR0cmlidXRlcyk7XG4gICAgdGhpcy50YXJnZXQucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLmlkZW50aWZpZXJGaWVsZCA9IHRoaXMudGFyZ2V0LnJhd0F0dHJpYnV0ZXNbdGhpcy5mb3JlaWduS2V5XS5maWVsZCB8fCB0aGlzLmZvcmVpZ25LZXk7XG4gICAgSGVscGVycy5jaGVja05hbWluZ0NvbGxpc2lvbih0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBtaXhpbihvYmopIHtcbiAgICBjb25zdCBtZXRob2RzID0gW1wiZ2V0XCIsIFwic2V0XCIsIFwiY3JlYXRlXCJdO1xuICAgIEhlbHBlcnMubWl4aW5NZXRob2RzKHRoaXMsIG9iaiwgbWV0aG9kcyk7XG4gIH1cbiAgYXN5bmMgZ2V0KGluc3RhbmNlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHdoZXJlID0ge307XG4gICAgbGV0IFRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJzY29wZVwiKSkge1xuICAgICAgaWYgKCFvcHRpb25zLnNjb3BlKSB7XG4gICAgICAgIFRhcmdldCA9IFRhcmdldC51bnNjb3BlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVGFyZ2V0ID0gVGFyZ2V0LnNjb3BlKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic2NoZW1hXCIpKSB7XG4gICAgICBUYXJnZXQgPSBUYXJnZXQuc2NoZW1hKG9wdGlvbnMuc2NoZW1hLCBvcHRpb25zLnNjaGVtYURlbGltaXRlcik7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnN0YW5jZXMpKSB7XG4gICAgICBpbnN0YW5jZSA9IGluc3RhbmNlcztcbiAgICAgIGluc3RhbmNlcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgd2hlcmVbdGhpcy5mb3JlaWduS2V5XSA9IHtcbiAgICAgICAgW09wLmluXTogaW5zdGFuY2VzLm1hcCgoX2luc3RhbmNlKSA9PiBfaW5zdGFuY2UuZ2V0KHRoaXMuc291cmNlS2V5KSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoZXJlW3RoaXMuZm9yZWlnbktleV0gPSBpbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih3aGVyZSwgdGhpcy5zY29wZSk7XG4gICAgfVxuICAgIG9wdGlvbnMud2hlcmUgPSBvcHRpb25zLndoZXJlID8geyBbT3AuYW5kXTogW3doZXJlLCBvcHRpb25zLndoZXJlXSB9IDogd2hlcmU7XG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFRhcmdldC5maW5kQWxsKG9wdGlvbnMpO1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmVzdWx0W19pbnN0YW5jZS5nZXQodGhpcy5zb3VyY2VLZXksIHsgcmF3OiB0cnVlIH0pXSA9IG51bGw7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiByZXN1bHRzKSB7XG4gICAgICAgIHJlc3VsdFtfaW5zdGFuY2UuZ2V0KHRoaXMuZm9yZWlnbktleSwgeyByYXc6IHRydWUgfSldID0gX2luc3RhbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIFRhcmdldC5maW5kT25lKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNldChzb3VyY2VJbnN0YW5jZSwgYXNzb2NpYXRlZEluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHNjb3BlOiBmYWxzZSB9KTtcbiAgICBjb25zdCBvbGRJbnN0YW5jZSA9IGF3YWl0IHNvdXJjZUluc3RhbmNlW3RoaXMuYWNjZXNzb3JzLmdldF0ob3B0aW9ucyk7XG4gICAgY29uc3QgYWxyZWFkeUFzc29jaWF0ZWQgPSBvbGRJbnN0YW5jZSAmJiBhc3NvY2lhdGVkSW5zdGFuY2UgJiYgdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZXMuZXZlcnkoKGF0dHJpYnV0ZSkgPT4gb2xkSW5zdGFuY2UuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSkgPT09IChhc3NvY2lhdGVkSW5zdGFuY2UuZ2V0ID8gYXNzb2NpYXRlZEluc3RhbmNlLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pIDogYXNzb2NpYXRlZEluc3RhbmNlKSk7XG4gICAgaWYgKG9sZEluc3RhbmNlICYmICFhbHJlYWR5QXNzb2NpYXRlZCkge1xuICAgICAgb2xkSW5zdGFuY2VbdGhpcy5mb3JlaWduS2V5XSA9IG51bGw7XG4gICAgICBhd2FpdCBvbGRJbnN0YW5jZS5zYXZlKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIGZpZWxkczogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICAgIGFsbG93TnVsbDogW3RoaXMuZm9yZWlnbktleV0sXG4gICAgICAgIGFzc29jaWF0aW9uOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChhc3NvY2lhdGVkSW5zdGFuY2UgJiYgIWFscmVhZHlBc3NvY2lhdGVkKSB7XG4gICAgICBpZiAoIShhc3NvY2lhdGVkSW5zdGFuY2UgaW5zdGFuY2VvZiB0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgY29uc3QgdG1wSW5zdGFuY2UgPSB7fTtcbiAgICAgICAgdG1wSW5zdGFuY2VbdGhpcy50YXJnZXQucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSBhc3NvY2lhdGVkSW5zdGFuY2U7XG4gICAgICAgIGFzc29jaWF0ZWRJbnN0YW5jZSA9IHRoaXMudGFyZ2V0LmJ1aWxkKHRtcEluc3RhbmNlLCB7XG4gICAgICAgICAgaXNOZXdSZWNvcmQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmFzc2lnbihhc3NvY2lhdGVkSW5zdGFuY2UsIHRoaXMuc2NvcGUpO1xuICAgICAgYXNzb2NpYXRlZEluc3RhbmNlLnNldCh0aGlzLmZvcmVpZ25LZXksIHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSkpO1xuICAgICAgcmV0dXJuIGFzc29jaWF0ZWRJbnN0YW5jZS5zYXZlKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBjcmVhdGUoc291cmNlSW5zdGFuY2UsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodGhpcy5zY29wZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXModGhpcy5zY29wZSkpIHtcbiAgICAgICAgdmFsdWVzW2F0dHJpYnV0ZV0gPSB0aGlzLnNjb3BlW2F0dHJpYnV0ZV07XG4gICAgICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgICAgIG9wdGlvbnMuZmllbGRzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZXNbdGhpcy5mb3JlaWduS2V5XSA9IHNvdXJjZUluc3RhbmNlLmdldCh0aGlzLnNvdXJjZUtleUF0dHJpYnV0ZSk7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKHRoaXMuZm9yZWlnbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnRhcmdldC5jcmVhdGUodmFsdWVzLCBvcHRpb25zKTtcbiAgfVxuICB2ZXJpZnlBc3NvY2lhdGlvbkFsaWFzKGFsaWFzKSB7XG4gICAgaWYgKHR5cGVvZiBhbGlhcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuYXMgPT09IGFsaWFzO1xuICAgIH1cbiAgICBpZiAoYWxpYXMgJiYgYWxpYXMuc2luZ3VsYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmFzID09PSBhbGlhcy5zaW5ndWxhcjtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLmlzQWxpYXNlZDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBIYXNPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtb25lLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/has-one.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(`Naming collision between attribute '${association.as}' and association '${association.as}' on model ${association.source.name}. To remedy this, change either foreignKey or as in your association definition`);\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    const primaryKeys = Object.keys(source.primaryKeys).map((primaryKeyAttribute) => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n  for (const method of methods) {\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n//# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQSwyREFBMkQsZUFBZSxxQkFBcUIsZUFBZSxhQUFhLHdCQUF3QjtBQUNuSjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9oZWxwZXJzLmpzP2RlNmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBjaGVja05hbWluZ0NvbGxpc2lvbihhc3NvY2lhdGlvbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFzc29jaWF0aW9uLnNvdXJjZS5yYXdBdHRyaWJ1dGVzLCBhc3NvY2lhdGlvbi5hcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5hbWluZyBjb2xsaXNpb24gYmV0d2VlbiBhdHRyaWJ1dGUgJyR7YXNzb2NpYXRpb24uYXN9JyBhbmQgYXNzb2NpYXRpb24gJyR7YXNzb2NpYXRpb24uYXN9JyBvbiBtb2RlbCAke2Fzc29jaWF0aW9uLnNvdXJjZS5uYW1lfS4gVG8gcmVtZWR5IHRoaXMsIGNoYW5nZSBlaXRoZXIgZm9yZWlnbktleSBvciBhcyBpbiB5b3VyIGFzc29jaWF0aW9uIGRlZmluaXRpb25gKTtcbiAgfVxufVxuZXhwb3J0cy5jaGVja05hbWluZ0NvbGxpc2lvbiA9IGNoZWNrTmFtaW5nQ29sbGlzaW9uO1xuZnVuY3Rpb24gYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzKG5ld0F0dHJpYnV0ZSwgc291cmNlLCB0YXJnZXQsIG9wdGlvbnMsIGtleSkge1xuICBpZiAob3B0aW9ucy5mb3JlaWduS2V5Q29uc3RyYWludCB8fCBvcHRpb25zLm9uRGVsZXRlIHx8IG9wdGlvbnMub25VcGRhdGUpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZS5wcmltYXJ5S2V5cykubWFwKChwcmltYXJ5S2V5QXR0cmlidXRlKSA9PiBzb3VyY2UucmF3QXR0cmlidXRlc1twcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZCB8fCBwcmltYXJ5S2V5QXR0cmlidXRlKTtcbiAgICBpZiAocHJpbWFyeUtleXMubGVuZ3RoID09PSAxIHx8ICFwcmltYXJ5S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBuZXdBdHRyaWJ1dGUucmVmZXJlbmNlcyA9IHtcbiAgICAgICAgbW9kZWw6IHNvdXJjZS5nZXRUYWJsZU5hbWUoKSxcbiAgICAgICAga2V5OiBrZXkgfHwgcHJpbWFyeUtleXNbMF1cbiAgICAgIH07XG4gICAgICBuZXdBdHRyaWJ1dGUub25EZWxldGUgPSBvcHRpb25zLm9uRGVsZXRlO1xuICAgICAgbmV3QXR0cmlidXRlLm9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzID0gYWRkRm9yZWlnbktleUNvbnN0cmFpbnRzO1xuZnVuY3Rpb24gbWl4aW5NZXRob2RzKGFzc29jaWF0aW9uLCBvYmosIG1ldGhvZHMsIGFsaWFzZXMpIHtcbiAgYWxpYXNlcyA9IGFsaWFzZXMgfHwge307XG4gIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGFzc29jaWF0aW9uLmFjY2Vzc29yc1ttZXRob2RdKSkge1xuICAgICAgY29uc3QgcmVhbE1ldGhvZCA9IGFsaWFzZXNbbWV0aG9kXSB8fCBtZXRob2Q7XG4gICAgICBvYmpbYXNzb2NpYXRpb24uYWNjZXNzb3JzW21ldGhvZF1dID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhc3NvY2lhdGlvbltyZWFsTWV0aG9kXSh0aGlzLCAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMubWl4aW5NZXRob2RzID0gbWl4aW5NZXRob2RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Association = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nAssociation.BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nAssociation.HasOne = __webpack_require__(/*! ./has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nAssociation.HasMany = __webpack_require__(/*! ./has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nAssociation.BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nmodule.exports = Association;\nmodule.exports[\"default\"] = Association;\nmodule.exports.Association = Association;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyx1RUFBUTtBQUNwQyx3QkFBd0IsbUJBQU8sQ0FBQyxtRkFBYztBQUM5QyxxQkFBcUIsbUJBQU8sQ0FBQyw2RUFBVztBQUN4QyxzQkFBc0IsbUJBQU8sQ0FBQywrRUFBWTtBQUMxQyw0QkFBNEIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDdkQ7QUFDQSx5QkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvaW5kZXguanM/NWEzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYmFzZVwiKTtcbkFzc29jaWF0aW9uLkJlbG9uZ3NUbyA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG9cIik7XG5Bc3NvY2lhdGlvbi5IYXNPbmUgPSByZXF1aXJlKFwiLi9oYXMtb25lXCIpO1xuQXNzb2NpYXRpb24uSGFzTWFueSA9IHJlcXVpcmUoXCIuL2hhcy1tYW55XCIpO1xuQXNzb2NpYXRpb24uQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG8tbWFueVwiKTtcbm1vZHVsZS5leHBvcnRzID0gQXNzb2NpYXRpb247XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQXNzb2NpYXRpb247XG5tb2R1bGUuZXhwb3J0cy5Bc3NvY2lhdGlvbiA9IEFzc29jaWF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/associations/mixin.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/associations/mixin.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst HasOne = __webpack_require__(/*! ./has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nconst HasMany = __webpack_require__(/*! ./has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst BelongsToMany = __webpack_require__(/*! ./belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst BelongsTo = __webpack_require__(/*! ./belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    Object.assign(options, _.omit(source.options, [\"hooks\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", { source, target, type: HasMany }, options);\n    }\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", { source, target, type: HasMany, association }, options);\n    }\n    return association;\n  },\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, [\"hooks\", \"timestamps\", \"scopes\", \"defaultScope\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", { source, target, type: BelongsToMany }, options);\n    }\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", { source, target, type: BelongsToMany, association }, options);\n    }\n    return association;\n  },\n  getAssociations(target) {\n    return Object.values(this.associations).filter((association) => association.target.name === target.name);\n  },\n  getAssociationForAlias(target, alias) {\n    return this.getAssociations(target).find((association) => association.verifyAssociationAlias(alias)) || null;\n  }\n};\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    if (options.useHooks) {\n      source.runHooks(\"beforeAssociate\", { source, target, type: Type }, options);\n    }\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      source.runHooks(\"afterAssociate\", { source, target, type: Type, association }, options);\n    }\n    return association;\n  };\n}\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports[\"default\"] = Mixin;\n//# sourceMappingURL=mixin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9hc3NvY2lhdGlvbnMvbWl4aW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsZUFBZSxtQkFBTyxDQUFDLDZFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFZO0FBQ3BDLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFtQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywrQkFBK0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRDQUE0QztBQUNwRjtBQUNBO0FBQ0EsR0FBRztBQUNILG9DQUFvQztBQUNwQztBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHFDQUFxQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0RBQWtEO0FBQzFGO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSx5QkFBeUIsWUFBWSxHQUFHLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Fzc29jaWF0aW9ucy9taXhpbi5qcz8zZDBhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBIYXNPbmUgPSByZXF1aXJlKFwiLi9oYXMtb25lXCIpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoXCIuL2hhcy1tYW55XCIpO1xuY29uc3QgQmVsb25nc1RvTWFueSA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG8tbWFueVwiKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoXCIuL2JlbG9uZ3MtdG9cIik7XG5mdW5jdGlvbiBpc01vZGVsKG1vZGVsLCBzZXF1ZWxpemUpIHtcbiAgcmV0dXJuIG1vZGVsICYmIG1vZGVsLnByb3RvdHlwZSAmJiBtb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBzZXF1ZWxpemUuU2VxdWVsaXplLk1vZGVsO1xufVxuY29uc3QgTWl4aW4gPSB7XG4gIGhhc01hbnkodGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTW9kZWwodGFyZ2V0LCB0aGlzLnNlcXVlbGl6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLm5hbWV9Lmhhc01hbnkgY2FsbGVkIHdpdGggc29tZXRoaW5nIHRoYXQncyBub3QgYSBzdWJjbGFzcyBvZiBTZXF1ZWxpemUuTW9kZWxgKTtcbiAgICB9XG4gICAgY29uc3Qgc291cmNlID0gdGhpcztcbiAgICBvcHRpb25zLmhvb2tzID0gb3B0aW9ucy5ob29rcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBCb29sZWFuKG9wdGlvbnMuaG9va3MpO1xuICAgIG9wdGlvbnMudXNlSG9va3MgPSBvcHRpb25zLmhvb2tzO1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgXy5vbWl0KHNvdXJjZS5vcHRpb25zLCBbXCJob29rc1wiXSkpO1xuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQXNzb2NpYXRlXCIsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEhhc01hbnkgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gbmV3IEhhc01hbnkoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHNvdXJjZS5hc3NvY2lhdGlvbnNbYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3Nvcl0gPSBhc3NvY2lhdGlvbjtcbiAgICBhc3NvY2lhdGlvbi5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgIGFzc29jaWF0aW9uLm1peGluKHNvdXJjZS5wcm90b3R5cGUpO1xuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJBc3NvY2lhdGVcIiwgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogSGFzTWFueSwgYXNzb2NpYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfSxcbiAgYmVsb25nc1RvTWFueSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNNb2RlbCh0YXJnZXQsIHRoaXMuc2VxdWVsaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0uYmVsb25nc1RvTWFueSBjYWxsZWQgd2l0aCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN1YmNsYXNzIG9mIFNlcXVlbGl6ZS5Nb2RlbGApO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzO1xuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB2b2lkIDAgPyBmYWxzZSA6IEJvb2xlYW4ob3B0aW9ucy5ob29rcyk7XG4gICAgb3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMuaG9va3M7XG4gICAgb3B0aW9ucy50aW1lc3RhbXBzID0gb3B0aW9ucy50aW1lc3RhbXBzID09PSB2b2lkIDAgPyB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWVzdGFtcHMgOiBvcHRpb25zLnRpbWVzdGFtcHM7XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBfLm9taXQoc291cmNlLm9wdGlvbnMsIFtcImhvb2tzXCIsIFwidGltZXN0YW1wc1wiLCBcInNjb3Blc1wiLCBcImRlZmF1bHRTY29wZVwiXSkpO1xuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQXNzb2NpYXRlXCIsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IEJlbG9uZ3NUb01hbnkgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gbmV3IEJlbG9uZ3NUb01hbnkoc291cmNlLCB0YXJnZXQsIG9wdGlvbnMpO1xuICAgIHNvdXJjZS5hc3NvY2lhdGlvbnNbYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3Nvcl0gPSBhc3NvY2lhdGlvbjtcbiAgICBhc3NvY2lhdGlvbi5faW5qZWN0QXR0cmlidXRlcygpO1xuICAgIGFzc29jaWF0aW9uLm1peGluKHNvdXJjZS5wcm90b3R5cGUpO1xuICAgIGlmIChvcHRpb25zLnVzZUhvb2tzKSB7XG4gICAgICB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJBc3NvY2lhdGVcIiwgeyBzb3VyY2UsIHRhcmdldCwgdHlwZTogQmVsb25nc1RvTWFueSwgYXNzb2NpYXRpb24gfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfSxcbiAgZ2V0QXNzb2NpYXRpb25zKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuYXNzb2NpYXRpb25zKS5maWx0ZXIoKGFzc29jaWF0aW9uKSA9PiBhc3NvY2lhdGlvbi50YXJnZXQubmFtZSA9PT0gdGFyZ2V0Lm5hbWUpO1xuICB9LFxuICBnZXRBc3NvY2lhdGlvbkZvckFsaWFzKHRhcmdldCwgYWxpYXMpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBc3NvY2lhdGlvbnModGFyZ2V0KS5maW5kKChhc3NvY2lhdGlvbikgPT4gYXNzb2NpYXRpb24udmVyaWZ5QXNzb2NpYXRpb25BbGlhcyhhbGlhcykpIHx8IG51bGw7XG4gIH1cbn07XG5mdW5jdGlvbiBzaW5nbGVMaW5rZWQoVHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzO1xuICAgIGlmICghaXNNb2RlbCh0YXJnZXQsIHNvdXJjZS5zZXF1ZWxpemUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7c291cmNlLm5hbWV9LiR7Xy5sb3dlckZpcnN0KFR5cGUubmFtZSl9IGNhbGxlZCB3aXRoIHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgc3ViY2xhc3Mgb2YgU2VxdWVsaXplLk1vZGVsYCk7XG4gICAgfVxuICAgIG9wdGlvbnMuaG9va3MgPSBvcHRpb25zLmhvb2tzID09PSB2b2lkIDAgPyBmYWxzZSA6IEJvb2xlYW4ob3B0aW9ucy5ob29rcyk7XG4gICAgb3B0aW9ucy51c2VIb29rcyA9IG9wdGlvbnMuaG9va3M7XG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHNvdXJjZS5ydW5Ib29rcyhcImJlZm9yZUFzc29jaWF0ZVwiLCB7IHNvdXJjZSwgdGFyZ2V0LCB0eXBlOiBUeXBlIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IG5ldyBUeXBlKHNvdXJjZSwgdGFyZ2V0LCBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHNvdXJjZS5vcHRpb25zKSk7XG4gICAgc291cmNlLmFzc29jaWF0aW9uc1thc3NvY2lhdGlvbi5hc3NvY2lhdGlvbkFjY2Vzc29yXSA9IGFzc29jaWF0aW9uO1xuICAgIGFzc29jaWF0aW9uLl9pbmplY3RBdHRyaWJ1dGVzKCk7XG4gICAgYXNzb2NpYXRpb24ubWl4aW4oc291cmNlLnByb3RvdHlwZSk7XG4gICAgaWYgKG9wdGlvbnMudXNlSG9va3MpIHtcbiAgICAgIHNvdXJjZS5ydW5Ib29rcyhcImFmdGVyQXNzb2NpYXRlXCIsIHsgc291cmNlLCB0YXJnZXQsIHR5cGU6IFR5cGUsIGFzc29jaWF0aW9uIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXNzb2NpYXRpb247XG4gIH07XG59XG5NaXhpbi5oYXNPbmUgPSBzaW5nbGVMaW5rZWQoSGFzT25lKTtcbk1peGluLmJlbG9uZ3NUbyA9IHNpbmdsZUxpbmtlZChCZWxvbmdzVG8pO1xubW9kdWxlLmV4cG9ydHMgPSBNaXhpbjtcbm1vZHVsZS5leHBvcnRzLk1peGluID0gTWl4aW47XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gTWl4aW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXhpbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/associations/mixin.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/data-types.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/data-types.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst Validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst warnings = {};\nconst { classToInvokable } = __webpack_require__(/*! ./utils/class-to-invokable */ \"(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js\");\nconst { joinSQLFragments } = __webpack_require__(/*! ./utils/join-sql-fragments */ \"(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js\");\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\nABSTRACT.prototype.dialectTypes = \"\";\nclass STRING extends ABSTRACT {\n  constructor(length, binary) {\n    super();\n    const options = typeof length === \"object\" && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\n      `VARCHAR(${this._length})`,\n      this._binary && \"BINARY\"\n    ]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== \"[object String]\") {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === \"number\") {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\nclass CHAR extends STRING {\n  constructor(length, binary) {\n    super(typeof length === \"object\" && length || { length, binary });\n  }\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this._length})`,\n      this._binary && \"BINARY\"\n    ]);\n  }\n}\nclass TEXT extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYTEXT\";\n      case \"medium\":\n        return \"MEDIUMTEXT\";\n      case \"long\":\n        return \"LONGTEXT\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return \"CITEXT\";\n  }\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nclass NUMBER extends ABSTRACT {\n  constructor(options = {}) {\n    super();\n    if (typeof options === \"number\") {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === \"number\") {\n        result += `,${this._decimals}`;\n      }\n      result += \")\";\n    }\n    if (this._unsigned) {\n      result += \" UNSIGNED\";\n    }\n    if (this._zerofill) {\n      result += \" ZEROFILL\";\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === \"number\" || typeof number === \"bigint\" || typeof number === \"boolean\" || number === null || number === void 0) {\n      return number;\n    }\n    if (typeof number.toString === \"function\") {\n      return number.toString();\n    }\n    return number;\n  }\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\nclass TINYINT extends INTEGER {\n}\nclass SMALLINT extends INTEGER {\n}\nclass MEDIUMINT extends INTEGER {\n}\nclass BIGINT extends INTEGER {\n}\nclass FLOAT extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid float\", value));\n    }\n    return true;\n  }\n}\nclass REAL extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n}\nclass DOUBLE extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || { length, decimals });\n  }\n}\nclass DECIMAL extends NUMBER {\n  constructor(precision, scale) {\n    super(typeof precision === \"object\" && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(\",\")})`;\n    }\n    return \"DECIMAL\";\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid decimal\", value));\n    }\n    return true;\n  }\n}\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return \"NaN\";\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? \"-\" : \"\";\n      return `${sign}Infinity`;\n    }\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return \"TINYINT(1)\";\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid boolean\", value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== void 0) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === \"string\") {\n        return value === \"true\" ? true : value === \"false\" ? false : value;\n      }\n      if (type === \"number\") {\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\nclass TIME extends ABSTRACT {\n  toSql() {\n    return \"TIME\";\n  }\n}\nclass DATE extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    return \"DATETIME\";\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid date\", value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n    return date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n  }\n}\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return \"DATE\";\n  }\n  _stringify(date) {\n    return moment(date).format(\"YYYY-MM-DD\");\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid hstore\", value));\n    }\n    return true;\n  }\n}\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\nclass JSONB extends JSONTYPE {\n}\nclass NOW extends ABSTRACT {\n}\nclass BLOB extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || { length };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYBLOB\";\n      case \"medium\":\n        return \"MEDIUMBLOB\";\n      case \"long\":\n        return \"LONGBLOB\";\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid blob\", value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString(\"hex\");\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\nBLOB.prototype.escape = false;\nclass RANGE extends ABSTRACT {\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === \"function\") {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid range\", value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError(\"A range must be an array with two elements\");\n    }\n    return true;\n  }\n}\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n    return true;\n  }\n}\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuidv4\", value));\n    }\n    return true;\n  }\n}\nclass VIRTUAL extends ABSTRACT {\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === \"function\")\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\nclass ENUM extends ABSTRACT {\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === \"object\" && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid choice in %j\", value, this.values));\n    }\n    return true;\n  }\n}\nclass ARRAY extends ABSTRACT {\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === \"function\" ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid array\", value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\nclass GEOMETRY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\nGEOMETRY.prototype.escape = false;\nclass GEOGRAPHY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\nGEOGRAPHY.prototype.escape = false;\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid CIDR\", value));\n    }\n    return true;\n  }\n}\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid INET\", value));\n    }\n    return true;\n  }\n}\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid MACADDR\", value));\n    }\n    return true;\n  }\n}\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n    return true;\n  }\n}\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  \"DOUBLE PRECISION\": DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n_.each(DataTypes, (dataType, name) => {\n  if (!Object.prototype.hasOwnProperty.call(dataType, \"key\")) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\nconst dialectMap = {};\ndialectMap.postgres = __webpack_require__(/*! ./dialects/postgres/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/data-types.js\")(DataTypes);\ndialectMap.mysql = __webpack_require__(/*! ./dialects/mysql/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/data-types.js\")(DataTypes);\ndialectMap.mariadb = __webpack_require__(/*! ./dialects/mariadb/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/data-types.js\")(DataTypes);\ndialectMap.sqlite = __webpack_require__(/*! ./dialects/sqlite/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/data-types.js\")(DataTypes);\ndialectMap.mssql = __webpack_require__(/*! ./dialects/mssql/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/data-types.js\")(DataTypes);\ndialectMap.db2 = __webpack_require__(/*! ./dialects/db2/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/data-types.js\")(DataTypes);\ndialectMap.snowflake = __webpack_require__(/*! ./dialects/snowflake/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/data-types.js\")(DataTypes);\ndialectMap.oracle = __webpack_require__(/*! ./dialects/oracle/data-types */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/data-types.js\")(DataTypes);\nconst dialectList = Object.values(dialectMap);\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\nObject.assign(DataTypes, dialectMap);\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixZQUFZLG1CQUFPLENBQUMsZ0RBQUs7QUFDekIsd0JBQXdCLG1CQUFPLENBQUMsb0VBQVU7QUFDMUMsa0JBQWtCLCtIQUE2QztBQUMvRCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEVBQWdCO0FBQzNDO0FBQ0EsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLGtHQUE0QjtBQUNqRSxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsa0dBQTRCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsdUJBQXVCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBNEQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBeUQ7QUFDdkY7QUFDQTtBQUNBLDhCQUE4Qiw0REFBNEQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIseURBQXlEO0FBQ3ZGO0FBQ0E7QUFDQSw4QkFBOEIsNERBQTREO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQscUJBQXFCLG1CQUFPLENBQUMsd0dBQStCO0FBQzVELG9CQUFvQixtQkFBTyxDQUFDLHNHQUE4QjtBQUMxRCxtQkFBbUIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDeEQsaUJBQWlCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLDRHQUFpQztBQUNoRSxvQkFBb0IsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGF0YS10eXBlcy5qcz83ZDAyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB3a3ggPSByZXF1aXJlKFwid2t4XCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdG9yLWV4dHJhc1wiKS52YWxpZGF0b3I7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IHdhcm5pbmdzID0ge307XG5jb25zdCB7IGNsYXNzVG9JbnZva2FibGUgfSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZVwiKTtcbmNvbnN0IHsgam9pblNRTEZyYWdtZW50cyB9ID0gcmVxdWlyZShcIi4vdXRpbHMvam9pbi1zcWwtZnJhZ21lbnRzXCIpO1xuY2xhc3MgQUJTVFJBQ1Qge1xuICB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TcWwob3B0aW9ucyk7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5O1xuICB9XG4gIHN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl9zdHJpbmdpZnkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX2JpbmRQYXJhbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh0aGlzLnN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykpO1xuICB9XG4gIHN0YXRpYyB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG4gIHN0YXRpYyB3YXJuKGxpbmssIHRleHQpIHtcbiAgICBpZiAoIXdhcm5pbmdzW3RleHRdKSB7XG4gICAgICB3YXJuaW5nc1t0ZXh0XSA9IHRydWU7XG4gICAgICBsb2dnZXIud2FybihgJHt0ZXh0fSBcbj4+IENoZWNrOiAke2xpbmt9YCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBleHRlbmQob2xkVHlwZSkge1xuICAgIHJldHVybiBuZXcgdGhpcyhvbGRUeXBlLm9wdGlvbnMpO1xuICB9XG59XG5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gXCJcIjtcbmNsYXNzIFNUUklORyBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBiaW5hcnkpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCwgYmluYXJ5IH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9iaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCAyNTU7XG4gIH1cbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIGpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYFZBUkNIQVIoJHt0aGlzLl9sZW5ndGh9KWAsXG4gICAgICB0aGlzLl9iaW5hcnkgJiYgXCJCSU5BUllcIlxuICAgIF0pO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09IFwiW29iamVjdCBTdHJpbmddXCIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmluYXJ5ICYmIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBzdHJpbmdcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IEJJTkFSWSgpIHtcbiAgICB0aGlzLl9iaW5hcnkgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5iaW5hcnkgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBnZXQgQklOQVJZKCkge1xuICAgIHJldHVybiBuZXcgdGhpcygpLkJJTkFSWTtcbiAgfVxufVxuY2xhc3MgQ0hBUiBleHRlbmRzIFNUUklORyB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgYmluYXJ5KSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGJpbmFyeSB9KTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgQ0hBUigke3RoaXMuX2xlbmd0aH0pYCxcbiAgICAgIHRoaXMuX2JpbmFyeSAmJiBcIkJJTkFSWVwiXG4gICAgXSk7XG4gIH1cbn1cbmNsYXNzIFRFWFQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCBcIlwiO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHN3aXRjaCAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJ0aW55XCI6XG4gICAgICAgIHJldHVybiBcIlRJTllURVhUXCI7XG4gICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgIHJldHVybiBcIk1FRElVTVRFWFRcIjtcbiAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgIHJldHVybiBcIkxPTkdURVhUXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBzdHJpbmdcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIENJVEVYVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiQ0lURVhUXCI7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHN0cmluZ1wiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgTlVNQkVSIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbGVuZ3RoOiBvcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2xlbmd0aCA9IG9wdGlvbnMubGVuZ3RoO1xuICAgIHRoaXMuX3plcm9maWxsID0gb3B0aW9ucy56ZXJvZmlsbDtcbiAgICB0aGlzLl9kZWNpbWFscyA9IG9wdGlvbnMuZGVjaW1hbHM7XG4gICAgdGhpcy5fcHJlY2lzaW9uID0gb3B0aW9ucy5wcmVjaXNpb247XG4gICAgdGhpcy5fc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIHRoaXMuX3Vuc2lnbmVkID0gb3B0aW9ucy51bnNpZ25lZDtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5rZXk7XG4gICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgcmVzdWx0ICs9IGAoJHt0aGlzLl9sZW5ndGh9YDtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGVjaW1hbHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLl9kZWNpbWFsc31gO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgIHJlc3VsdCArPSBcIiBVTlNJR05FRFwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgIHJlc3VsdCArPSBcIiBaRVJPRklMTFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNGbG9hdChTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoYCVqIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5rZXkudG9Mb3dlckNhc2UoKX1gLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfc3RyaW5naWZ5KG51bWJlcikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBudW1iZXIgPT09IFwiYmlnaW50XCIgfHwgdHlwZW9mIG51bWJlciA9PT0gXCJib29sZWFuXCIgfHwgbnVtYmVyID09PSBudWxsIHx8IG51bWJlciA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG51bWJlci50b1N0cmluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gbnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBudW1iZXI7XG4gIH1cbiAgZ2V0IFVOU0lHTkVEKCkge1xuICAgIHRoaXMuX3Vuc2lnbmVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMudW5zaWduZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldCBaRVJPRklMTCgpIHtcbiAgICB0aGlzLl96ZXJvZmlsbCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLnplcm9maWxsID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgZ2V0IFVOU0lHTkVEKCkge1xuICAgIHJldHVybiBuZXcgdGhpcygpLlVOU0lHTkVEO1xuICB9XG4gIHN0YXRpYyBnZXQgWkVST0ZJTEwoKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkuWkVST0ZJTEw7XG4gIH1cbn1cbmNsYXNzIElOVEVHRVIgZXh0ZW5kcyBOVU1CRVIge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzSW50KFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChgJWogaXMgbm90IGEgdmFsaWQgJHt0aGlzLmtleS50b0xvd2VyQ2FzZSgpfWAsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBUSU5ZSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5jbGFzcyBTTUFMTElOVCBleHRlbmRzIElOVEVHRVIge1xufVxuY2xhc3MgTUVESVVNSU5UIGV4dGVuZHMgSU5URUdFUiB7XG59XG5jbGFzcyBCSUdJTlQgZXh0ZW5kcyBJTlRFR0VSIHtcbn1cbmNsYXNzIEZMT0FUIGV4dGVuZHMgTlVNQkVSIHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgIHN1cGVyKHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoLCBkZWNpbWFscyB9KTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzRmxvYXQoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgZmxvYXRcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFJFQUwgZXh0ZW5kcyBOVU1CRVIge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGRlY2ltYWxzIH0pO1xuICB9XG59XG5jbGFzcyBET1VCTEUgZXh0ZW5kcyBOVU1CRVIge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgc3VwZXIodHlwZW9mIGxlbmd0aCA9PT0gXCJvYmplY3RcIiAmJiBsZW5ndGggfHwgeyBsZW5ndGgsIGRlY2ltYWxzIH0pO1xuICB9XG59XG5jbGFzcyBERUNJTUFMIGV4dGVuZHMgTlVNQkVSIHtcbiAgY29uc3RydWN0b3IocHJlY2lzaW9uLCBzY2FsZSkge1xuICAgIHN1cGVyKHR5cGVvZiBwcmVjaXNpb24gPT09IFwib2JqZWN0XCIgJiYgcHJlY2lzaW9uIHx8IHsgcHJlY2lzaW9uLCBzY2FsZSB9KTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICBpZiAodGhpcy5fcHJlY2lzaW9uIHx8IHRoaXMuX3NjYWxlKSB7XG4gICAgICByZXR1cm4gYERFQ0lNQUwoJHtbdGhpcy5fcHJlY2lzaW9uLCB0aGlzLl9zY2FsZV0uZmlsdGVyKF8uaWRlbnRpdHkpLmpvaW4oXCIsXCIpfSlgO1xuICAgIH1cbiAgICByZXR1cm4gXCJERUNJTUFMXCI7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIVZhbGlkYXRvci5pc0RlY2ltYWwoU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgZGVjaW1hbFwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3QgcHJvdG9FeHRlbnNpb25zID0ge1xuICBlc2NhcGU6IGZhbHNlLFxuICBfdmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICB9XG4gICAgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCI7XG4gICAgICByZXR1cm4gYCR7c2lnbn1JbmZpbml0eWA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSxcbiAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBgJyR7dGhpcy5fdmFsdWUodmFsdWUpfSdgO1xuICB9LFxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX3ZhbHVlKHZhbHVlKSk7XG4gIH1cbn07XG5mb3IgKGNvbnN0IGZsb2F0aW5nIG9mIFtGTE9BVCwgRE9VQkxFLCBSRUFMXSkge1xuICBPYmplY3QuYXNzaWduKGZsb2F0aW5nLnByb3RvdHlwZSwgcHJvdG9FeHRlbnNpb25zKTtcbn1cbmNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHRvU3FsKCkge1xuICAgIHJldHVybiBcIlRJTllJTlQoMSlcIjtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghVmFsaWRhdG9yLmlzQm9vbGVhbihTdHJpbmcodmFsdWUpKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBib29sZWFuXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IHZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxID8gdHJ1ZSA6IHZhbHVlID09PSAwID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5CT09MRUFOLnBhcnNlID0gQk9PTEVBTi5wcm90b3R5cGUuX3Nhbml0aXplO1xuY2xhc3MgVElNRSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiVElNRVwiO1xuICB9XG59XG5jbGFzcyBEQVRFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgbGVuZ3RoID09PSBcIm9iamVjdFwiICYmIGxlbmd0aCB8fCB7IGxlbmd0aCB9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGggfHwgXCJcIjtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJEQVRFVElNRVwiO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFWYWxpZGF0b3IuaXNEYXRlKFN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGRhdGVcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3Nhbml0aXplKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEhdmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfaXNDaGFuZ2VkKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSB7XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgJiYgISF2YWx1ZSAmJiAodmFsdWUgPT09IG9yaWdpbmFsVmFsdWUgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIG9yaWdpbmFsVmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmIHZhbHVlLmdldFRpbWUoKSA9PT0gb3JpZ2luYWxWYWx1ZS5nZXRUaW1lKCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghb3JpZ2luYWxWYWx1ZSAmJiAhdmFsdWUgJiYgb3JpZ2luYWxWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnRpbWV6b25lKSB7XG4gICAgICBpZiAobW9tZW50VHoudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICByZXR1cm4gbW9tZW50VHooZGF0ZSkudHoob3B0aW9ucy50aW1lem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZSA9IG1vbWVudChkYXRlKS51dGNPZmZzZXQob3B0aW9ucy50aW1lem9uZSk7XG4gICAgfVxuICAgIHJldHVybiBtb21lbnRUeihkYXRlKTtcbiAgfVxuICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW1vbWVudC5pc01vbWVudChkYXRlKSkge1xuICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3MuU1NTIFpcIik7XG4gIH1cbn1cbmNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gXCJEQVRFXCI7XG4gIH1cbiAgX3N0cmluZ2lmeShkYXRlKSB7XG4gICAgcmV0dXJuIG1vbWVudChkYXRlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICB9XG4gIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmICEhdmFsdWUpIHtcbiAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfaXNDaGFuZ2VkKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSB7XG4gICAgaWYgKG9yaWdpbmFsVmFsdWUgJiYgISF2YWx1ZSAmJiBvcmlnaW5hbFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIW9yaWdpbmFsVmFsdWUgJiYgIXZhbHVlICYmIG9yaWdpbmFsVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBIU1RPUkUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIGhzdG9yZVwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICB9XG59XG5jbGFzcyBKU09OQiBleHRlbmRzIEpTT05UWVBFIHtcbn1cbmNsYXNzIE5PVyBleHRlbmRzIEFCU1RSQUNUIHtcbn1cbmNsYXNzIEJMT0IgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBsZW5ndGggPT09IFwib2JqZWN0XCIgJiYgbGVuZ3RoIHx8IHsgbGVuZ3RoIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9sZW5ndGggPSBvcHRpb25zLmxlbmd0aCB8fCBcIlwiO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHN3aXRjaCAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJ0aW55XCI6XG4gICAgICAgIHJldHVybiBcIlRJTllCTE9CXCI7XG4gICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgIHJldHVybiBcIk1FRElVTUJMT0JcIjtcbiAgICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICAgIHJldHVybiBcIkxPTkdCTE9CXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBibG9iXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IHZhbHVlLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgIHJldHVybiB0aGlzLl9oZXhpZnkoaGV4KTtcbiAgfVxuICBfaGV4aWZ5KGhleCkge1xuICAgIHJldHVybiBgWCcke2hleH0nYDtcbiAgfVxuICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICB9XG59XG5CTE9CLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbmNsYXNzIFJBTkdFIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3RvcihzdWJ0eXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBvcHRpb25zID0gXy5pc1BsYWluT2JqZWN0KHN1YnR5cGUpID8gc3VidHlwZSA6IHsgc3VidHlwZSB9O1xuICAgIGlmICghb3B0aW9ucy5zdWJ0eXBlKVxuICAgICAgb3B0aW9ucy5zdWJ0eXBlID0gbmV3IElOVEVHRVIoKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc3VidHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvcHRpb25zLnN1YnR5cGUgPSBuZXcgb3B0aW9ucy5zdWJ0eXBlKCk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnR5cGUgPSBvcHRpb25zLnN1YnR5cGUua2V5O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHJhbmdlXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKFwiQSByYW5nZSBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIGVsZW1lbnRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgVVVJRCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICFWYWxpZGF0b3IuaXNVVUlEKHZhbHVlKSAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuYWNjZXB0U3RyaW5ncykpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgdXVpZFwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgVVVJRFYxIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIVZhbGlkYXRvci5pc1VVSUQodmFsdWUpICYmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5hY2NlcHRTdHJpbmdzKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCB1dWlkXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBVVUlEVjQgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiB8fCAhVmFsaWRhdG9yLmlzVVVJRCh2YWx1ZSwgNCkgJiYgKCFvcHRpb25zIHx8ICFvcHRpb25zLmFjY2VwdFN0cmluZ3MpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIHV1aWR2NFwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgVklSVFVBTCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IoUmV0dXJuVHlwZSwgZmllbGRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIFJldHVyblR5cGUgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIFJldHVyblR5cGUgPSBuZXcgUmV0dXJuVHlwZSgpO1xuICAgIHRoaXMucmV0dXJuVHlwZSA9IFJldHVyblR5cGU7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gIH1cbn1cbmNsYXNzIEVOVU0gZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHZhbHVlID0gYXJnc1swXTtcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZSB8fCB7XG4gICAgICB2YWx1ZXM6IGFyZ3MucmVkdWNlKChyZXN1bHQsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoQXJyYXkuaXNBcnJheShlbGVtZW50KSA/IGVsZW1lbnQgOiBbZWxlbWVudF0pO1xuICAgICAgfSwgW10pXG4gICAgfTtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMudmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBjaG9pY2UgaW4gJWpcIiwgdmFsdWUsIHRoaXMudmFsdWVzKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBBUlJBWSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IF8uaXNQbGFpbk9iamVjdCh0eXBlKSA/IHR5cGUgOiB7IHR5cGUgfTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudHlwZSA9IHR5cGVvZiBvcHRpb25zLnR5cGUgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBvcHRpb25zLnR5cGUoKSA6IG9wdGlvbnMudHlwZTtcbiAgfVxuICB0b1NxbCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy50eXBlLnRvU3FsKCl9W11gO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBhcnJheVwiLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXMob2JqLCB0eXBlKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFSUkFZICYmIG9iai50eXBlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxufVxuY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3QodHlwZSkgPyB0eXBlIDogeyB0eXBlLCBzcmlkIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5zcmlkID0gb3B0aW9ucy5zcmlkO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYFNUX0dlb21Gcm9tVGV4dCgke29wdGlvbnMuZXNjYXBlKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYFNUX0dlb21Gcm9tVGV4dCgke29wdGlvbnMuYmluZFBhcmFtKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG59XG5HRU9NRVRSWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG5jbGFzcyBHRU9HUkFQSFkgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfLmlzUGxhaW5PYmplY3QodHlwZSkgPyB0eXBlIDogeyB0eXBlLCBzcmlkIH07XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5zcmlkID0gb3B0aW9ucy5zcmlkO1xuICB9XG4gIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYFNUX0dlb21Gcm9tVGV4dCgke29wdGlvbnMuZXNjYXBlKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG4gIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYFNUX0dlb21Gcm9tVGV4dCgke29wdGlvbnMuYmluZFBhcmFtKHdreC5HZW9tZXRyeS5wYXJzZUdlb0pTT04odmFsdWUpLnRvV2t0KCkpfSlgO1xuICB9XG59XG5HRU9HUkFQSFkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuY2xhc3MgQ0lEUiBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8ICFWYWxpZGF0b3IuaXNJUFJhbmdlKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBDSURSXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBJTkVUIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIVZhbGlkYXRvci5pc0lQKHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3IodXRpbC5mb3JtYXQoXCIlaiBpcyBub3QgYSB2YWxpZCBJTkVUXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jbGFzcyBNQUNBRERSIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIVZhbGlkYXRvci5pc01BQ0FkZHJlc3ModmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvcih1dGlsLmZvcm1hdChcIiVqIGlzIG5vdCBhIHZhbGlkIE1BQ0FERFJcIiwgdmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmNsYXNzIFRTVkVDVE9SIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9yKHV0aWwuZm9ybWF0KFwiJWogaXMgbm90IGEgdmFsaWQgc3RyaW5nXCIsIHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5jb25zdCBEYXRhVHlwZXMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUJTVFJBQ1QsXG4gIFNUUklORyxcbiAgQ0hBUixcbiAgVEVYVCxcbiAgTlVNQkVSLFxuICBUSU5ZSU5ULFxuICBTTUFMTElOVCxcbiAgTUVESVVNSU5ULFxuICBJTlRFR0VSLFxuICBCSUdJTlQsXG4gIEZMT0FULFxuICBUSU1FLFxuICBEQVRFLFxuICBEQVRFT05MWSxcbiAgQk9PTEVBTixcbiAgTk9XLFxuICBCTE9CLFxuICBERUNJTUFMLFxuICBOVU1FUklDOiBERUNJTUFMLFxuICBVVUlELFxuICBVVUlEVjEsXG4gIFVVSURWNCxcbiAgSFNUT1JFLFxuICBKU09OOiBKU09OVFlQRSxcbiAgSlNPTkIsXG4gIFZJUlRVQUwsXG4gIEFSUkFZLFxuICBFTlVNLFxuICBSQU5HRSxcbiAgUkVBTCxcbiAgXCJET1VCTEUgUFJFQ0lTSU9OXCI6IERPVUJMRSxcbiAgRE9VQkxFLFxuICBHRU9NRVRSWSxcbiAgR0VPR1JBUEhZLFxuICBDSURSLFxuICBJTkVULFxuICBNQUNBRERSLFxuICBDSVRFWFQsXG4gIFRTVkVDVE9SXG59O1xuXy5lYWNoKERhdGFUeXBlcywgKGRhdGFUeXBlLCBuYW1lKSA9PiB7XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFUeXBlLCBcImtleVwiKSkge1xuICAgIGRhdGFUeXBlLnR5cGVzID0ge307XG4gICAgZGF0YVR5cGUua2V5ID0gZGF0YVR5cGUucHJvdG90eXBlLmtleSA9IG5hbWU7XG4gIH1cbn0pO1xuY29uc3QgZGlhbGVjdE1hcCA9IHt9O1xuZGlhbGVjdE1hcC5wb3N0Z3JlcyA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3Bvc3RncmVzL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAubXlzcWwgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9teXNxbC9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm1hcmlhZGIgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9tYXJpYWRiL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAuc3FsaXRlID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvc3FsaXRlL2RhdGEtdHlwZXNcIikoRGF0YVR5cGVzKTtcbmRpYWxlY3RNYXAubXNzcWwgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9tc3NxbC9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLmRiMiA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL2RiMi9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLnNub3dmbGFrZSA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3Nub3dmbGFrZS9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5kaWFsZWN0TWFwLm9yYWNsZSA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL29yYWNsZS9kYXRhLXR5cGVzXCIpKERhdGFUeXBlcyk7XG5jb25zdCBkaWFsZWN0TGlzdCA9IE9iamVjdC52YWx1ZXMoZGlhbGVjdE1hcCk7XG5mb3IgKGNvbnN0IGRhdGFUeXBlcyBvZiBkaWFsZWN0TGlzdCkge1xuICBfLmVhY2goZGF0YVR5cGVzLCAoRGF0YVR5cGUsIGtleSkgPT4ge1xuICAgIGlmICghRGF0YVR5cGUua2V5KSB7XG4gICAgICBEYXRhVHlwZS5rZXkgPSBEYXRhVHlwZS5wcm90b3R5cGUua2V5ID0ga2V5O1xuICAgIH1cbiAgfSk7XG59XG5mb3IgKGNvbnN0IGRhdGFUeXBlcyBvZiBbRGF0YVR5cGVzLCAuLi5kaWFsZWN0TGlzdF0pIHtcbiAgXy5lYWNoKGRhdGFUeXBlcywgKERhdGFUeXBlLCBrZXkpID0+IHtcbiAgICBkYXRhVHlwZXNba2V5XSA9IGNsYXNzVG9JbnZva2FibGUoRGF0YVR5cGUpO1xuICB9KTtcbn1cbk9iamVjdC5hc3NpZ24oRGF0YVR5cGVzLCBkaWFsZWN0TWFwKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/deferrable.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/deferrable.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { classToInvokable } = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nclass ABSTRACT {\n  static toString(...args) {\n    return new this().toString(...args);\n  }\n  toString(...args) {\n    return this.toSql(...args);\n  }\n  toSql() {\n    throw new Error(\"toSql implementation missing\");\n  }\n}\nclass INITIALLY_DEFERRED extends ABSTRACT {\n  toSql() {\n    return \"DEFERRABLE INITIALLY DEFERRED\";\n  }\n}\nclass INITIALLY_IMMEDIATE extends ABSTRACT {\n  toSql() {\n    return \"DEFERRABLE INITIALLY IMMEDIATE\";\n  }\n}\nclass NOT extends ABSTRACT {\n  toSql() {\n    return \"NOT DEFERRABLE\";\n  }\n}\nclass SET_DEFERRED extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n  toSql(queryGenerator) {\n    return queryGenerator.setDeferredQuery(this.constraints);\n  }\n}\nclass SET_IMMEDIATE extends ABSTRACT {\n  constructor(constraints) {\n    super();\n    this.constraints = constraints;\n  }\n  toSql(queryGenerator) {\n    return queryGenerator.setImmediateQuery(this.constraints);\n  }\n}\nconst Deferrable = {\n  INITIALLY_DEFERRED: classToInvokable(INITIALLY_DEFERRED),\n  INITIALLY_IMMEDIATE: classToInvokable(INITIALLY_IMMEDIATE),\n  NOT: classToInvokable(NOT),\n  SET_DEFERRED: classToInvokable(SET_DEFERRED),\n  SET_IMMEDIATE: classToInvokable(SET_IMMEDIATE)\n};\nmodule.exports = Deferrable;\n//# sourceMappingURL=deferrable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kZWZlcnJhYmxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsUUFBUSxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLDREQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RlZmVycmFibGUuanM/Nzk2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHsgY2xhc3NUb0ludm9rYWJsZSB9ID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBBQlNUUkFDVCB7XG4gIHN0YXRpYyB0b1N0cmluZyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKCkudG9TdHJpbmcoLi4uYXJncyk7XG4gIH1cbiAgdG9TdHJpbmcoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLnRvU3FsKC4uLmFyZ3MpO1xuICB9XG4gIHRvU3FsKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRvU3FsIGltcGxlbWVudGF0aW9uIG1pc3NpbmdcIik7XG4gIH1cbn1cbmNsYXNzIElOSVRJQUxMWV9ERUZFUlJFRCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiREVGRVJSQUJMRSBJTklUSUFMTFkgREVGRVJSRURcIjtcbiAgfVxufVxuY2xhc3MgSU5JVElBTExZX0lNTUVESUFURSBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiREVGRVJSQUJMRSBJTklUSUFMTFkgSU1NRURJQVRFXCI7XG4gIH1cbn1cbmNsYXNzIE5PVCBleHRlbmRzIEFCU1RSQUNUIHtcbiAgdG9TcWwoKSB7XG4gICAgcmV0dXJuIFwiTk9UIERFRkVSUkFCTEVcIjtcbiAgfVxufVxuY2xhc3MgU0VUX0RFRkVSUkVEIGV4dGVuZHMgQUJTVFJBQ1Qge1xuICBjb25zdHJ1Y3Rvcihjb25zdHJhaW50cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICB9XG4gIHRvU3FsKHF1ZXJ5R2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIHF1ZXJ5R2VuZXJhdG9yLnNldERlZmVycmVkUXVlcnkodGhpcy5jb25zdHJhaW50cyk7XG4gIH1cbn1cbmNsYXNzIFNFVF9JTU1FRElBVEUgZXh0ZW5kcyBBQlNUUkFDVCB7XG4gIGNvbnN0cnVjdG9yKGNvbnN0cmFpbnRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gIH1cbiAgdG9TcWwocXVlcnlHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gcXVlcnlHZW5lcmF0b3Iuc2V0SW1tZWRpYXRlUXVlcnkodGhpcy5jb25zdHJhaW50cyk7XG4gIH1cbn1cbmNvbnN0IERlZmVycmFibGUgPSB7XG4gIElOSVRJQUxMWV9ERUZFUlJFRDogY2xhc3NUb0ludm9rYWJsZShJTklUSUFMTFlfREVGRVJSRUQpLFxuICBJTklUSUFMTFlfSU1NRURJQVRFOiBjbGFzc1RvSW52b2thYmxlKElOSVRJQUxMWV9JTU1FRElBVEUpLFxuICBOT1Q6IGNsYXNzVG9JbnZva2FibGUoTk9UKSxcbiAgU0VUX0RFRkVSUkVEOiBjbGFzc1RvSW52b2thYmxlKFNFVF9ERUZFUlJFRCksXG4gIFNFVF9JTU1FRElBVEU6IGNsYXNzVG9JbnZva2FibGUoU0VUX0lNTUVESUFURSlcbn07XG5tb2R1bGUuZXhwb3J0cyA9IERlZmVycmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlcnJhYmxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/deferrable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Pool, TimeoutError } = __webpack_require__(/*! sequelize-pool */ \"(rsc)/./node_modules/sequelize-pool/lib/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst debug = logger.debugContext(\"pool\");\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n    if (config.pool === false) {\n      throw new Error(\"Support for pool:false was removed in v4.0\");\n    }\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 1e4,\n      acquire: 6e4,\n      evict: 1e3,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, (dataType) => {\n      if (Object.prototype.hasOwnProperty.call(dataType, \"parse\")) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return __webpack_require__(\"(rsc)/./node_modules/sequelize/lib/dialects/abstract sync recursive\")(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      return __webpack_require__(\"(rsc)/./node_modules/sequelize/lib/dialects/abstract sync recursive\")(moduleName);\n    } catch (err) {\n      if (err.code === \"MODULE_NOT_FOUND\") {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n      throw err;\n    }\n  }\n  async _onProcessExit() {\n    if (!this.pool) {\n      return;\n    }\n    await this.pool.drain();\n    debug(\"connection drain due to process exit\");\n    return await this.pool.destroyAllNow();\n  }\n  async close() {\n    this.getConnection = async function getConnection() {\n      throw new Error(\"ConnectionManager.getConnection was called after the connection manager was closed!\");\n    };\n    return await this._onProcessExit();\n  }\n  initPools() {\n    const config = this.config;\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: \"sequelize\",\n        create: () => this._connect(config),\n        destroy: async (connection) => {\n          const result = await this._disconnect(connection);\n          debug(\"connection destroy\");\n          return result;\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, \"replication\"));\n    config.replication.read = config.replication.read.map((readConfig) => _.defaults(readConfig, _.omit(this.config, \"replication\")));\n    let reads = 0;\n    this.pool = {\n      release: (client) => {\n        if (client.queryType === \"read\") {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === void 0 ? false : useMaster;\n        if (queryType === \"SELECT\" && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: (connection) => {\n        this.pool[connection.queryType].destroy(connection);\n        debug(\"connection destroy\");\n      },\n      destroyAllNow: async () => {\n        await Promise.all([\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ]);\n        debug(\"all connections destroyed\");\n      },\n      drain: async () => Promise.all([\n        this.pool.write.drain(),\n        this.pool.read.drain()\n      ]),\n      read: new Pool({\n        name: \"sequelize:read\",\n        create: async () => {\n          const nextRead = reads++ % config.replication.read.length;\n          const connection = await this._connect(config.replication.read[nextRead]);\n          connection.queryType = \"read\";\n          return connection;\n        },\n        destroy: (connection) => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      }),\n      write: new Pool({\n        name: \"sequelize:write\",\n        create: async () => {\n          const connection = await this._connect(config.replication.write);\n          connection.queryType = \"write\";\n          return connection;\n        },\n        destroy: (connection) => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict,\n        maxUses: config.pool.maxUses\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  async getConnection(options) {\n    options = options || {};\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (!this.versionPromise) {\n        this.versionPromise = (async () => {\n          try {\n            const connection = await this._connect(this.config.replication.write || this.config);\n            const _options = {};\n            _options.transaction = { connection };\n            _options.logging = () => {\n            };\n            _options.logging.__testLoggingFn = true;\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = await this.sequelize.databaseVersion(_options);\n              const parsedVersion = _.get(semver.coerce(version), \"version\") || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.dialect.defaultVersion;\n            }\n            if (semver.lt(this.sequelize.options.databaseVersion, this.dialect.defaultVersion)) {\n              deprecations.unsupportedEngine();\n              debug(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`);\n            }\n            this.versionPromise = null;\n            return await this._disconnect(connection);\n          } catch (err) {\n            this.versionPromise = null;\n            throw err;\n          }\n        })();\n      }\n      await this.versionPromise;\n    }\n    let result;\n    try {\n      await this.sequelize.runHooks(\"beforePoolAcquire\", options);\n      result = await this.pool.acquire(options.type, options.useMaster);\n      await this.sequelize.runHooks(\"afterPoolAcquire\", result, options);\n    } catch (error) {\n      if (error instanceof TimeoutError)\n        throw new errors.ConnectionAcquireTimeoutError(error);\n      throw error;\n    }\n    debug(\"connection acquired\");\n    return result;\n  }\n  releaseConnection(connection) {\n    this.pool.release(connection);\n    debug(\"connection released\");\n  }\n  async destroyConnection(connection) {\n    await this.pool.destroy(connection);\n    debug(`connection ${connection.uuid} destroyed`);\n  }\n  async _connect(config) {\n    await this.sequelize.runHooks(\"beforeConnect\", config);\n    const connection = await this.dialect.connectionManager.connect(config);\n    await this.sequelize.runHooks(\"afterConnect\", connection, config);\n    return connection;\n  }\n  async _disconnect(connection) {\n    await this.sequelize.runHooks(\"beforeDisconnect\", connection);\n    await this.dialect.connectionManager.disconnect(connection);\n    return this.sequelize.runHooks(\"afterDisconnect\", connection);\n  }\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsd0VBQWdCO0FBQ3ZELFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHdFQUFjO0FBQ3JDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1FQUFtRSxjQUFjLGFBQWEsaUJBQWlCO0FBQy9HO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJGQUFRLHVDQUF1QyxDQUFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyRkFBUSxVQUFVLENBQUM7QUFDaEMsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1REFBdUQsd0NBQXdDO0FBQy9GO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMENBQTBDLGdCQUFnQixHQUFHLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3Q0FBd0MsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1Q0FBdUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyLmpzP2U3YjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB7IFBvb2wsIFRpbWVvdXRFcnJvciB9ID0gcmVxdWlyZShcInNlcXVlbGl6ZS1wb29sXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgZXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVwcmVjYXRpb25zID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2RlcHJlY2F0aW9uc1wiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInBvb2xcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IF8uY2xvbmVEZWVwKHNlcXVlbGl6ZS5jb25maWcpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuZGlhbGVjdCA9IGRpYWxlY3Q7XG4gICAgdGhpcy52ZXJzaW9uUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5kaWFsZWN0TmFtZSA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdDtcbiAgICBpZiAoY29uZmlnLnBvb2wgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwb3J0IGZvciBwb29sOmZhbHNlIHdhcyByZW1vdmVkIGluIHY0LjBcIik7XG4gICAgfVxuICAgIGNvbmZpZy5wb29sID0gXy5kZWZhdWx0cyhjb25maWcucG9vbCB8fCB7fSwge1xuICAgICAgbWF4OiA1LFxuICAgICAgbWluOiAwLFxuICAgICAgaWRsZTogMWU0LFxuICAgICAgYWNxdWlyZTogNmU0LFxuICAgICAgZXZpY3Q6IDFlMyxcbiAgICAgIHZhbGlkYXRlOiB0aGlzLl92YWxpZGF0ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5pbml0UG9vbHMoKTtcbiAgfVxuICByZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZXMpIHtcbiAgICBfLmVhY2goZGF0YVR5cGVzLCAoZGF0YVR5cGUpID0+IHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YVR5cGUsIFwicGFyc2VcIikpIHtcbiAgICAgICAgaWYgKGRhdGFUeXBlLnR5cGVzW3RoaXMuZGlhbGVjdE5hbWVdKSB7XG4gICAgICAgICAgdGhpcy5fcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyc2UgZnVuY3Rpb24gbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAke2RhdGFUeXBlLmtleX0gaW4gZGlhbGVjdCAke3RoaXMuZGlhbGVjdE5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfbG9hZERpYWxlY3RNb2R1bGUobW9kdWxlTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGVQYXRoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RNb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kaWFsZWN0TW9kdWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcXVpcmUobW9kdWxlTmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgPT09IFwiTU9EVUxFX05PVF9GT1VORFwiKSB7XG4gICAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGRpYWxlY3QgYXQgJHt0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE1vZHVsZVBhdGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQbGVhc2UgaW5zdGFsbCAke21vZHVsZU5hbWV9IHBhY2thZ2UgbWFudWFsbHlgKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX29uUHJvY2Vzc0V4aXQoKSB7XG4gICAgaWYgKCF0aGlzLnBvb2wpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5wb29sLmRyYWluKCk7XG4gICAgZGVidWcoXCJjb25uZWN0aW9uIGRyYWluIGR1ZSB0byBwcm9jZXNzIGV4aXRcIik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucG9vbC5kZXN0cm95QWxsTm93KCk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgdGhpcy5nZXRDb25uZWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbm5lY3Rpb25NYW5hZ2VyLmdldENvbm5lY3Rpb24gd2FzIGNhbGxlZCBhZnRlciB0aGUgY29ubmVjdGlvbiBtYW5hZ2VyIHdhcyBjbG9zZWQhXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX29uUHJvY2Vzc0V4aXQoKTtcbiAgfVxuICBpbml0UG9vbHMoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFjb25maWcucmVwbGljYXRpb24pIHtcbiAgICAgIHRoaXMucG9vbCA9IG5ldyBQb29sKHtcbiAgICAgICAgbmFtZTogXCJzZXF1ZWxpemVcIixcbiAgICAgICAgY3JlYXRlOiAoKSA9PiB0aGlzLl9jb25uZWN0KGNvbmZpZyksXG4gICAgICAgIGRlc3Ryb3k6IGFzeW5jIChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGlzY29ubmVjdChjb25uZWN0aW9uKTtcbiAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gZGVzdHJveVwiKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnBvb2wudmFsaWRhdGUsXG4gICAgICAgIG1heDogY29uZmlnLnBvb2wubWF4LFxuICAgICAgICBtaW46IGNvbmZpZy5wb29sLm1pbixcbiAgICAgICAgYWNxdWlyZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmFjcXVpcmUsXG4gICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5pZGxlLFxuICAgICAgICByZWFwSW50ZXJ2YWxNaWxsaXM6IGNvbmZpZy5wb29sLmV2aWN0LFxuICAgICAgICBtYXhVc2VzOiBjb25maWcucG9vbC5tYXhVc2VzXG4gICAgICB9KTtcbiAgICAgIGRlYnVnKGBwb29sIGNyZWF0ZWQgd2l0aCBtYXgvbWluOiAke2NvbmZpZy5wb29sLm1heH0vJHtjb25maWcucG9vbC5taW59LCBubyByZXBsaWNhdGlvbmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLnJlcGxpY2F0aW9uLnJlYWQpKSB7XG4gICAgICBjb25maWcucmVwbGljYXRpb24ucmVhZCA9IFtjb25maWcucmVwbGljYXRpb24ucmVhZF07XG4gICAgfVxuICAgIGNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSA9IF8uZGVmYXVsdHMoY29uZmlnLnJlcGxpY2F0aW9uLndyaXRlLCBfLm9taXQoY29uZmlnLCBcInJlcGxpY2F0aW9uXCIpKTtcbiAgICBjb25maWcucmVwbGljYXRpb24ucmVhZCA9IGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkLm1hcCgocmVhZENvbmZpZykgPT4gXy5kZWZhdWx0cyhyZWFkQ29uZmlnLCBfLm9taXQodGhpcy5jb25maWcsIFwicmVwbGljYXRpb25cIikpKTtcbiAgICBsZXQgcmVhZHMgPSAwO1xuICAgIHRoaXMucG9vbCA9IHtcbiAgICAgIHJlbGVhc2U6IChjbGllbnQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudC5xdWVyeVR5cGUgPT09IFwicmVhZFwiKSB7XG4gICAgICAgICAgdGhpcy5wb29sLnJlYWQucmVsZWFzZShjbGllbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucG9vbC53cml0ZS5yZWxlYXNlKGNsaWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhY3F1aXJlOiAocXVlcnlUeXBlLCB1c2VNYXN0ZXIpID0+IHtcbiAgICAgICAgdXNlTWFzdGVyID0gdXNlTWFzdGVyID09PSB2b2lkIDAgPyBmYWxzZSA6IHVzZU1hc3RlcjtcbiAgICAgICAgaWYgKHF1ZXJ5VHlwZSA9PT0gXCJTRUxFQ1RcIiAmJiAhdXNlTWFzdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG9vbC5yZWFkLmFjcXVpcmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wb29sLndyaXRlLmFjcXVpcmUoKTtcbiAgICAgIH0sXG4gICAgICBkZXN0cm95OiAoY29ubmVjdGlvbikgPT4ge1xuICAgICAgICB0aGlzLnBvb2xbY29ubmVjdGlvbi5xdWVyeVR5cGVdLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBkZXN0cm95XCIpO1xuICAgICAgfSxcbiAgICAgIGRlc3Ryb3lBbGxOb3c6IGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIHRoaXMucG9vbC5yZWFkLmRlc3Ryb3lBbGxOb3coKSxcbiAgICAgICAgICB0aGlzLnBvb2wud3JpdGUuZGVzdHJveUFsbE5vdygpXG4gICAgICAgIF0pO1xuICAgICAgICBkZWJ1ZyhcImFsbCBjb25uZWN0aW9ucyBkZXN0cm95ZWRcIik7XG4gICAgICB9LFxuICAgICAgZHJhaW46IGFzeW5jICgpID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5wb29sLndyaXRlLmRyYWluKCksXG4gICAgICAgIHRoaXMucG9vbC5yZWFkLmRyYWluKClcbiAgICAgIF0pLFxuICAgICAgcmVhZDogbmV3IFBvb2woe1xuICAgICAgICBuYW1lOiBcInNlcXVlbGl6ZTpyZWFkXCIsXG4gICAgICAgIGNyZWF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5leHRSZWFkID0gcmVhZHMrKyAlIGNvbmZpZy5yZXBsaWNhdGlvbi5yZWFkLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5fY29ubmVjdChjb25maWcucmVwbGljYXRpb24ucmVhZFtuZXh0UmVhZF0pO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucXVlcnlUeXBlID0gXCJyZWFkXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IChjb25uZWN0aW9uKSA9PiB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pLFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnBvb2wudmFsaWRhdGUsXG4gICAgICAgIG1heDogY29uZmlnLnBvb2wubWF4LFxuICAgICAgICBtaW46IGNvbmZpZy5wb29sLm1pbixcbiAgICAgICAgYWNxdWlyZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmFjcXVpcmUsXG4gICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5pZGxlLFxuICAgICAgICByZWFwSW50ZXJ2YWxNaWxsaXM6IGNvbmZpZy5wb29sLmV2aWN0LFxuICAgICAgICBtYXhVc2VzOiBjb25maWcucG9vbC5tYXhVc2VzXG4gICAgICB9KSxcbiAgICAgIHdyaXRlOiBuZXcgUG9vbCh7XG4gICAgICAgIG5hbWU6IFwic2VxdWVsaXplOndyaXRlXCIsXG4gICAgICAgIGNyZWF0ZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLl9jb25uZWN0KGNvbmZpZy5yZXBsaWNhdGlvbi53cml0ZSk7XG4gICAgICAgICAgY29ubmVjdGlvbi5xdWVyeVR5cGUgPSBcIndyaXRlXCI7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IChjb25uZWN0aW9uKSA9PiB0aGlzLl9kaXNjb25uZWN0KGNvbm5lY3Rpb24pLFxuICAgICAgICB2YWxpZGF0ZTogY29uZmlnLnBvb2wudmFsaWRhdGUsXG4gICAgICAgIG1heDogY29uZmlnLnBvb2wubWF4LFxuICAgICAgICBtaW46IGNvbmZpZy5wb29sLm1pbixcbiAgICAgICAgYWNxdWlyZVRpbWVvdXRNaWxsaXM6IGNvbmZpZy5wb29sLmFjcXVpcmUsXG4gICAgICAgIGlkbGVUaW1lb3V0TWlsbGlzOiBjb25maWcucG9vbC5pZGxlLFxuICAgICAgICByZWFwSW50ZXJ2YWxNaWxsaXM6IGNvbmZpZy5wb29sLmV2aWN0LFxuICAgICAgICBtYXhVc2VzOiBjb25maWcucG9vbC5tYXhVc2VzXG4gICAgICB9KVxuICAgIH07XG4gICAgZGVidWcoYHBvb2wgY3JlYXRlZCB3aXRoIG1heC9taW46ICR7Y29uZmlnLnBvb2wubWF4fS8ke2NvbmZpZy5wb29sLm1pbn0sIHdpdGggcmVwbGljYXRpb25gKTtcbiAgfVxuICBhc3luYyBnZXRDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPT09IDApIHtcbiAgICAgIGlmICghdGhpcy52ZXJzaW9uUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuX2Nvbm5lY3QodGhpcy5jb25maWcucmVwbGljYXRpb24ud3JpdGUgfHwgdGhpcy5jb25maWcpO1xuICAgICAgICAgICAgY29uc3QgX29wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIF9vcHRpb25zLnRyYW5zYWN0aW9uID0geyBjb25uZWN0aW9uIH07XG4gICAgICAgICAgICBfb3B0aW9ucy5sb2dnaW5nID0gKCkgPT4ge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9vcHRpb25zLmxvZ2dpbmcuX190ZXN0TG9nZ2luZ0ZuID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUuZGF0YWJhc2VWZXJzaW9uKF9vcHRpb25zKTtcbiAgICAgICAgICAgICAgY29uc3QgcGFyc2VkVmVyc2lvbiA9IF8uZ2V0KHNlbXZlci5jb2VyY2UodmVyc2lvbiksIFwidmVyc2lvblwiKSB8fCB2ZXJzaW9uO1xuICAgICAgICAgICAgICB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbiA9IHNlbXZlci52YWxpZChwYXJzZWRWZXJzaW9uKSA/IHBhcnNlZFZlcnNpb24gOiB0aGlzLmRpYWxlY3QuZGVmYXVsdFZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VtdmVyLmx0KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uLCB0aGlzLmRpYWxlY3QuZGVmYXVsdFZlcnNpb24pKSB7XG4gICAgICAgICAgICAgIGRlcHJlY2F0aW9ucy51bnN1cHBvcnRlZEVuZ2luZSgpO1xuICAgICAgICAgICAgICBkZWJ1ZyhgVW5zdXBwb3J0ZWQgZGF0YWJhc2UgZW5naW5lIHZlcnNpb24gJHt0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmVyc2lvblByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2Rpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb25Qcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLnZlcnNpb25Qcm9taXNlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImJlZm9yZVBvb2xBY3F1aXJlXCIsIG9wdGlvbnMpO1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5wb29sLmFjcXVpcmUob3B0aW9ucy50eXBlLCBvcHRpb25zLnVzZU1hc3Rlcik7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImFmdGVyUG9vbEFjcXVpcmVcIiwgcmVzdWx0LCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVGltZW91dEVycm9yKVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzLkNvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yKGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgdGhpcy5wb29sLnJlbGVhc2UoY29ubmVjdGlvbik7XG4gICAgZGVidWcoXCJjb25uZWN0aW9uIHJlbGVhc2VkXCIpO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3lDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICBhd2FpdCB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICBkZWJ1ZyhgY29ubmVjdGlvbiAke2Nvbm5lY3Rpb24udXVpZH0gZGVzdHJveWVkYCk7XG4gIH1cbiAgYXN5bmMgX2Nvbm5lY3QoY29uZmlnKSB7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJiZWZvcmVDb25uZWN0XCIsIGNvbmZpZyk7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0KGNvbmZpZyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJhZnRlckNvbm5lY3RcIiwgY29ubmVjdGlvbiwgY29uZmlnKTtcbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuICBhc3luYyBfZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucnVuSG9va3MoXCJiZWZvcmVEaXNjb25uZWN0XCIsIGNvbm5lY3Rpb24pO1xuICAgIGF3YWl0IHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0KGNvbm5lY3Rpb24pO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImFmdGVyRGlzY29ubmVjdFwiLCBjb25uZWN0aW9uKTtcbiAgfVxuICBfdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIGlmICghdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLnZhbGlkYXRlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGlhbGVjdC5jb25uZWN0aW9uTWFuYWdlci52YWxpZGF0ZShjb25uZWN0aW9uKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/index.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\nclass AbstractDialect {\n  canBackslashEscape() {\n    return false;\n  }\n}\nAbstractDialect.prototype.supports = {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ON DUPLICATE KEY\": true,\n  \"ORDER NULLS\": false,\n  \"UNION\": true,\n  \"UNION ALL\": true,\n  \"RIGHT JOIN\": true,\n  returnValues: false,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: true,\n    update: true\n  },\n  bulkDefault: false,\n  schemas: false,\n  transactions: true,\n  settingIsolationLevelDuringTransaction: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  inserts: {\n    ignoreDuplicates: \"\",\n    updateOnDuplicate: false,\n    onConflictDoNothing: \"\",\n    onConflictWhere: false,\n    conflictFields: false\n  },\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true,\n    functionBased: false,\n    operator: false\n  },\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false,\n  escapeStringConstants: false\n};\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports[\"default\"] = AbstractDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L2luZGV4LmpzPzg4ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jbGFzcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjYW5CYWNrc2xhc2hFc2NhcGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5BYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0ge1xuICBcIkRFRkFVTFRcIjogdHJ1ZSxcbiAgXCJERUZBVUxUIFZBTFVFU1wiOiBmYWxzZSxcbiAgXCJWQUxVRVMgKClcIjogZmFsc2UsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IGZhbHNlLFxuICBcIk9OIERVUExJQ0FURSBLRVlcIjogdHJ1ZSxcbiAgXCJPUkRFUiBOVUxMU1wiOiBmYWxzZSxcbiAgXCJVTklPTlwiOiB0cnVlLFxuICBcIlVOSU9OIEFMTFwiOiB0cnVlLFxuICBcIlJJR0hUIEpPSU5cIjogdHJ1ZSxcbiAgcmV0dXJuVmFsdWVzOiBmYWxzZSxcbiAgYXV0b0luY3JlbWVudDoge1xuICAgIGlkZW50aXR5SW5zZXJ0OiBmYWxzZSxcbiAgICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gICAgdXBkYXRlOiB0cnVlXG4gIH0sXG4gIGJ1bGtEZWZhdWx0OiBmYWxzZSxcbiAgc2NoZW1hczogZmFsc2UsXG4gIHRyYW5zYWN0aW9uczogdHJ1ZSxcbiAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IHRydWUsXG4gIHRyYW5zYWN0aW9uT3B0aW9uczoge1xuICAgIHR5cGU6IGZhbHNlXG4gIH0sXG4gIG1pZ3JhdGlvbnM6IHRydWUsXG4gIHVwc2VydHM6IHRydWUsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiBcIlwiLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBmYWxzZSxcbiAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nOiBcIlwiLFxuICAgIG9uQ29uZmxpY3RXaGVyZTogZmFsc2UsXG4gICAgY29uZmxpY3RGaWVsZHM6IGZhbHNlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgcmVzdHJpY3Q6IHRydWUsXG4gICAgYWRkQ29uc3RyYWludDogdHJ1ZSxcbiAgICBkcm9wQ29uc3RyYWludDogdHJ1ZSxcbiAgICB1bmlxdWU6IHRydWUsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgY2hlY2s6IHRydWUsXG4gICAgZm9yZWlnbktleTogdHJ1ZSxcbiAgICBwcmltYXJ5S2V5OiB0cnVlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogdHJ1ZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgY29uY3VycmVudGx5OiBmYWxzZSxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICB1c2luZzogdHJ1ZSxcbiAgICBmdW5jdGlvbkJhc2VkOiBmYWxzZSxcbiAgICBvcGVyYXRvcjogZmFsc2VcbiAgfSxcbiAgZ3JvdXBlZExpbWl0OiB0cnVlLFxuICBpbmRleFZpYUFsdGVyOiBmYWxzZSxcbiAgSlNPTjogZmFsc2UsXG4gIGRlZmVycmFibGVDb25zdHJhaW50czogZmFsc2UsXG4gIGVzY2FwZVN0cmluZ0NvbnN0YW50czogZmFsc2Vcbn07XG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0RGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLkFic3RyYWN0RGlhbGVjdCA9IEFic3RyYWN0RGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdERpYWxlY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst util = __webpack_require__(/*! util */ \"util\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst SqlString = __webpack_require__(/*! ../../sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Model = __webpack_require__(/*! ../../model */ \"(rsc)/./node_modules/sequelize/lib/model.js\");\nconst Association = __webpack_require__(/*! ../../associations/base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst BelongsTo = __webpack_require__(/*! ../../associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst BelongsToMany = __webpack_require__(/*! ../../associations/belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst HasMany = __webpack_require__(/*! ../../associations/has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst sequelizeError = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst IndexHints = __webpack_require__(/*! ../../index-hints */ \"(rsc)/./node_modules/sequelize/lib/index-hints.js\");\nclass QueryGenerator {\n  constructor(options) {\n    if (!options.sequelize)\n      throw new Error(\"QueryGenerator initialized without options.sequelize\");\n    if (!options._dialect)\n      throw new Error(\"QueryGenerator initialized without options._dialect\");\n    this.sequelize = options.sequelize;\n    this.options = options.sequelize.options;\n    this.dialect = options._dialect.name;\n    this._dialect = options._dialect;\n    this._initQuoteIdentifier();\n  }\n  extractTableDetails(tableName, options) {\n    options = options || {};\n    tableName = tableName || {};\n    return {\n      schema: tableName.schema || options.schema || this.options.schema || \"public\",\n      tableName: _.isPlainObject(tableName) ? tableName.tableName : tableName,\n      delimiter: tableName.delimiter || options.delimiter || \".\"\n    };\n  }\n  addSchema(param) {\n    if (!param._schema)\n      return param.tableName || param;\n    const self = this;\n    return {\n      tableName: param.tableName || param,\n      table: param.tableName || param,\n      name: param.name || param,\n      schema: param._schema,\n      delimiter: param._schemaDelimiter || \".\",\n      toString() {\n        return self.quoteTable(this);\n      }\n    };\n  }\n  dropSchema(tableName, options) {\n    return this.dropTableQuery(tableName, options);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `DESCRIBE ${table};`;\n  }\n  dropTableQuery(tableName) {\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)};`;\n  }\n  renameTableQuery(before, after) {\n    return `ALTER TABLE ${this.quoteTable(before)} RENAME TO ${this.quoteTable(after)};`;\n  }\n  populateInsertQueryReturnIntoBinds() {\n  }\n  insertQuery(table, valueHash, modelAttributes, options) {\n    options = options || {};\n    _.defaults(options, this.options);\n    const modelAttributeMap = {};\n    const bind = options.bind || [];\n    const fields = [];\n    const returningModelAttributes = [];\n    const returnTypes = [];\n    const values = [];\n    const quotedTable = this.quoteTable(table);\n    const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n    const returnAttributes = [];\n    let query;\n    let valueQuery = \"\";\n    let emptyQuery = \"\";\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    let identityWrapperRequired = false;\n    let tmpTable = \"\";\n    if (modelAttributes) {\n      _.each(modelAttributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    if (this._dialect.supports[\"DEFAULT VALUES\"]) {\n      emptyQuery += \" DEFAULT VALUES\";\n    } else if (this._dialect.supports[\"VALUES ()\"]) {\n      emptyQuery += \" VALUES ()\";\n    }\n    if ((this._dialect.supports.returnValues || this._dialect.supports.returnIntoValues) && options.returning) {\n      const returnValues = this.generateReturnValues(modelAttributes, options);\n      returningModelAttributes.push(...returnValues.returnFields);\n      if (this._dialect.supports.returnIntoValues) {\n        returnTypes.push(...returnValues.returnTypes);\n      }\n      returningFragment = returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || \"\";\n      outputFragment = returnValues.outputFragment || \"\";\n    }\n    if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n      options.bindParam = false;\n    }\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      options.bindParam = false;\n    }\n    valueHash = Utils.removeNullValuesFromHash(valueHash, this.options.omitNull);\n    for (const key in valueHash) {\n      if (Object.prototype.hasOwnProperty.call(valueHash, key)) {\n        const value = valueHash[key];\n        fields.push(this.quoteIdentifier(key));\n        if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && value == null) {\n          if (!this._dialect.supports.autoIncrement.defaultValue) {\n            fields.splice(-1, 1);\n          } else if (this._dialect.supports.DEFAULT) {\n            values.push(\"DEFAULT\");\n          } else {\n            values.push(this.escape(null));\n          }\n        } else {\n          if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true) {\n            identityWrapperRequired = true;\n          }\n          if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n            values.push(this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"INSERT\" }));\n          } else {\n            values.push(this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"INSERT\" }, bindParam));\n          }\n        }\n      }\n    }\n    let onDuplicateKeyUpdate = \"\";\n    if (!_.isEmpty(options.conflictWhere) && !this._dialect.supports.inserts.onConflictWhere) {\n      throw new Error(\"missing dialect support for conflictWhere option\");\n    }\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n        const conflictKeys = options.upsertKeys.map((attr) => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        const fragments = [\n          \"ON CONFLICT\",\n          \"(\",\n          conflictKeys.join(\",\"),\n          \")\"\n        ];\n        if (!_.isEmpty(options.conflictWhere)) {\n          fragments.push(this.whereQuery(options.conflictWhere, options));\n        }\n        if (_.isEmpty(updateKeys)) {\n          fragments.push(\"DO NOTHING\");\n        } else {\n          fragments.push(\"DO UPDATE SET\", updateKeys.join(\",\"));\n        }\n        onDuplicateKeyUpdate = ` ${Utils.joinSQLFragments(fragments)}`;\n      } else {\n        const valueKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        if (_.isEmpty(valueKeys) && options.upsertKeys) {\n          valueKeys.push(...options.upsertKeys.map((attr) => `${this.quoteIdentifier(attr)}=${this.quoteIdentifier(attr)}`));\n        }\n        if (_.isEmpty(valueKeys)) {\n          throw new Error(\"No update values found for ON DUPLICATE KEY UPDATE clause, and no identifier fields could be found to use instead.\");\n        }\n        onDuplicateKeyUpdate += `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(\",\")}`;\n      }\n    }\n    const replacements = {\n      ignoreDuplicates: options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\",\n      onConflictDoNothing: options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\",\n      attributes: fields.join(\",\"),\n      output: outputFragment,\n      values: values.join(\",\"),\n      tmpTable\n    };\n    valueQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable} (${replacements.attributes})${replacements.output} VALUES (${replacements.values})${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${valueQuery}`;\n    emptyQuery = `${tmpTable}INSERT${replacements.ignoreDuplicates} INTO ${quotedTable}${replacements.output}${onDuplicateKeyUpdate}${replacements.onConflictDoNothing}${emptyQuery}`;\n    if (this._dialect.supports.EXCEPTION && options.exception) {\n      const dropFunction = \"DROP FUNCTION IF EXISTS pg_temp.testfunc()\";\n      if (returningModelAttributes.length === 0) {\n        returningModelAttributes.push(\"*\");\n      }\n      const delimiter = `$func_${uuidv4().replace(/-/g, \"\")}$`;\n      const selectQuery = `SELECT (testfunc.response).${returningModelAttributes.join(\", (testfunc.response).\")}, testfunc.sequelize_caught_exception FROM pg_temp.testfunc();`;\n      options.exception = \"WHEN unique_violation THEN GET STACKED DIAGNOSTICS sequelize_caught_exception = PG_EXCEPTION_DETAIL;\";\n      valueQuery = `CREATE OR REPLACE FUNCTION pg_temp.testfunc(OUT response ${quotedTable}, OUT sequelize_caught_exception text) RETURNS RECORD AS ${delimiter} BEGIN ${valueQuery} RETURNING * INTO response; EXCEPTION ${options.exception} END ${delimiter} LANGUAGE plpgsql; ${selectQuery} ${dropFunction}`;\n    } else {\n      valueQuery += returningFragment;\n      emptyQuery += returningFragment;\n    }\n    if (this._dialect.supports.returnIntoValues && options.returning) {\n      this.populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, bind.length, returnAttributes, options);\n    }\n    query = `${replacements.attributes.length ? valueQuery : emptyQuery}${returnAttributes.join(\",\")};`;\n    if (this._dialect.supports.finalTable) {\n      query = `SELECT * FROM FINAL TABLE(${replacements.attributes.length ? valueQuery : emptyQuery});`;\n    }\n    if (identityWrapperRequired && this._dialect.supports.autoIncrement.identityInsert) {\n      query = `SET IDENTITY_INSERT ${quotedTable} ON; ${query} SET IDENTITY_INSERT ${quotedTable} OFF;`;\n    }\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const serials = {};\n    const allAttributes = [];\n    let onDuplicateKeyUpdate = \"\";\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        if (!allAttributes.includes(key)) {\n          allAttributes.push(key);\n        }\n        if (fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true) {\n          serials[key] = true;\n        }\n      });\n    }\n    for (const fieldValueHash of fieldValueHashes) {\n      const values = allAttributes.map((key) => {\n        if (this._dialect.supports.bulkDefault && serials[key] === true) {\n          return fieldValueHash[key] != null ? fieldValueHash[key] : \"DEFAULT\";\n        }\n        return this.escape(fieldValueHash[key], fieldMappedAttributes[key], { context: \"INSERT\" });\n      });\n      tuples.push(`(${values.join(\",\")})`);\n    }\n    if (this._dialect.supports.inserts.updateOnDuplicate && options.updateOnDuplicate) {\n      if (this._dialect.supports.inserts.updateOnDuplicate == \" ON CONFLICT DO UPDATE SET\") {\n        const conflictKeys = options.upsertKeys.map((attr) => this.quoteIdentifier(attr));\n        const updateKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=EXCLUDED.${this.quoteIdentifier(attr)}`);\n        let whereClause = false;\n        if (options.conflictWhere) {\n          if (!this._dialect.supports.inserts.onConflictWhere) {\n            throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n          }\n          whereClause = this.whereQuery(options.conflictWhere, options);\n        }\n        onDuplicateKeyUpdate = [\n          \"ON CONFLICT\",\n          \"(\",\n          conflictKeys.join(\",\"),\n          \")\",\n          whereClause,\n          \"DO UPDATE SET\",\n          updateKeys.join(\",\")\n        ];\n      } else {\n        if (options.conflictWhere) {\n          throw new Error(`conflictWhere not supported for dialect ${this._dialect.name}`);\n        }\n        const valueKeys = options.updateOnDuplicate.map((attr) => `${this.quoteIdentifier(attr)}=VALUES(${this.quoteIdentifier(attr)})`);\n        onDuplicateKeyUpdate = `${this._dialect.supports.inserts.updateOnDuplicate} ${valueKeys.join(\",\")}`;\n      }\n    }\n    const ignoreDuplicates = options.ignoreDuplicates ? this._dialect.supports.inserts.ignoreDuplicates : \"\";\n    const attributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\");\n    const onConflictDoNothing = options.ignoreDuplicates ? this._dialect.supports.inserts.onConflictDoNothing : \"\";\n    let returning = \"\";\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(fieldMappedAttributes, options);\n      returning += returnValues.returningFragment;\n    }\n    return Utils.joinSQLFragments([\n      \"INSERT\",\n      ignoreDuplicates,\n      \"INTO\",\n      this.quoteTable(tableName),\n      `(${attributes})`,\n      \"VALUES\",\n      tuples.join(\",\"),\n      onDuplicateKeyUpdate,\n      onConflictDoNothing,\n      returning,\n      \";\"\n    ]);\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const values = [];\n    const bind = [];\n    const modelAttributeMap = {};\n    let outputFragment = \"\";\n    let tmpTable = \"\";\n    let suffix = \"\";\n    if (_.get(this, [\"sequelize\", \"options\", \"dialectOptions\", \"prependSearchPath\"]) || options.searchPath) {\n      options.bindParam = false;\n    }\n    const bindParam = options.bindParam === void 0 ? this.bindParam(bind) : options.bindParam;\n    if (this._dialect.supports[\"LIMIT ON UPDATE\"] && options.limit) {\n      if (![\"mssql\", \"db2\", \"oracle\"].includes(this.dialect)) {\n        suffix = ` LIMIT ${this.escape(options.limit)} `;\n      } else if (this.dialect === \"oracle\") {\n        if (where && (where.length && where.length > 0 || Object.keys(where).length > 0)) {\n          suffix += \" AND \";\n        } else {\n          suffix += \" WHERE \";\n        }\n        suffix += `rownum <= ${this.escape(options.limit)} `;\n      }\n    }\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      suffix += returnValues.returningFragment;\n      tmpTable = returnValues.tmpTable || \"\";\n      outputFragment = returnValues.outputFragment || \"\";\n      if (!this._dialect.supports.returnValues.output && options.returning) {\n        options.mapToModel = true;\n      }\n    }\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      if (modelAttributeMap && modelAttributeMap[key] && modelAttributeMap[key].autoIncrement === true && !this._dialect.supports.autoIncrement.update) {\n        continue;\n      }\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    const whereOptions = __spreadProps(__spreadValues({}, options), { bindParam });\n    if (values.length === 0) {\n      return \"\";\n    }\n    const query = `${tmpTable}UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")}${outputFragment} ${this.whereQuery(where, whereOptions)}${suffix}`.trim();\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = bind;\n    }\n    return result;\n  }\n  arithmeticQuery(operator, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = options || {};\n    _.defaults(options, { returning: true });\n    extraAttributesToBeUpdated = Utils.removeNullValuesFromHash(extraAttributesToBeUpdated, this.options.omitNull);\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    if (this._dialect.supports.returnValues && options.returning) {\n      const returnValues = this.generateReturnValues(null, options);\n      outputFragment = returnValues.outputFragment;\n      returningFragment = returnValues.returningFragment;\n    }\n    const updateSetSqlFragments = [];\n    for (const field in incrementAmountsByField) {\n      const incrementAmount = incrementAmountsByField[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedAmount = this.escape(incrementAmount);\n      updateSetSqlFragments.push(`${quotedField}=${quotedField}${operator} ${escapedAmount}`);\n    }\n    for (const field in extraAttributesToBeUpdated) {\n      const newValue = extraAttributesToBeUpdated[field];\n      const quotedField = this.quoteIdentifier(field);\n      const escapedValue = this.escape(newValue);\n      updateSetSqlFragments.push(`${quotedField}=${escapedValue}`);\n    }\n    return Utils.joinSQLFragments([\n      \"UPDATE\",\n      this.quoteTable(tableName),\n      \"SET\",\n      updateSetSqlFragments.join(\",\"),\n      outputFragment,\n      this.whereQuery(where),\n      returningFragment\n    ]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    options = options || {};\n    if (!Array.isArray(attributes)) {\n      options = attributes;\n      attributes = void 0;\n    } else {\n      options.fields = attributes;\n    }\n    options.prefix = options.prefix || rawTablename || tableName;\n    if (options.prefix && typeof options.prefix === \"string\") {\n      options.prefix = options.prefix.replace(/\\./g, \"_\");\n      options.prefix = options.prefix.replace(/(\"|')/g, \"\");\n    }\n    const fieldsSql = options.fields.map((field) => {\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (typeof field === \"string\") {\n        field = {\n          name: field\n        };\n      }\n      let result = \"\";\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${util.inspect(field)}`);\n      }\n      result += this.quoteIdentifier(field.name);\n      if (this._dialect.supports.index.collate && field.collate) {\n        result += ` COLLATE ${this.quoteIdentifier(field.collate)}`;\n      }\n      if (this._dialect.supports.index.operator) {\n        const operator = field.operator || options.operator;\n        if (operator) {\n          result += ` ${operator}`;\n        }\n      }\n      if (this._dialect.supports.index.length && field.length) {\n        result += `(${field.length})`;\n      }\n      if (field.order) {\n        result += ` ${field.order}`;\n      }\n      return result;\n    });\n    if (!options.name) {\n      options = Utils.nameIndex(options, options.prefix);\n    }\n    options = Model._conformIndex(options);\n    if (!this._dialect.supports.index.type) {\n      delete options.type;\n    }\n    if (options.where) {\n      options.where = this.whereQuery(options.where);\n    }\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    const concurrently = this._dialect.supports.index.concurrently && options.concurrently ? \"CONCURRENTLY\" : void 0;\n    let ind;\n    if (this._dialect.supports.indexViaAlter) {\n      ind = [\n        \"ALTER TABLE\",\n        tableName,\n        concurrently,\n        \"ADD\"\n      ];\n    } else {\n      ind = [\"CREATE\"];\n    }\n    ind = ind.concat(options.unique ? \"UNIQUE\" : \"\", options.type, \"INDEX\", !this._dialect.supports.indexViaAlter ? concurrently : void 0, this.quoteIdentifiers(options.name), this._dialect.supports.index.using === 1 && options.using ? `USING ${options.using}` : \"\", !this._dialect.supports.indexViaAlter ? `ON ${tableName}` : void 0, this._dialect.supports.index.using === 2 && options.using ? `USING ${options.using}` : \"\", `(${fieldsSql.join(\", \")})`, this._dialect.supports.index.parser && options.parser ? `WITH PARSER ${options.parser}` : void 0, this._dialect.supports.index.where && options.where ? options.where : void 0);\n    return _.compact(ind).join(\" \");\n  }\n  addConstraintQuery(tableName, options) {\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      tableName,\n      \"ADD\",\n      this.getConstraintSnippet(tableName, options || {}),\n      \";\"\n    ]);\n  }\n  getConstraintSnippet(tableName, options) {\n    let constraintSnippet, constraintName;\n    const fieldsSql = options.fields.map((field) => {\n      if (typeof field === \"string\") {\n        return this.quoteIdentifier(field);\n      }\n      if (field instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(field);\n      }\n      if (field.attribute) {\n        field.name = field.attribute;\n      }\n      if (!field.name) {\n        throw new Error(`The following index field has no name: ${field}`);\n      }\n      return this.quoteIdentifier(field.name);\n    });\n    const fieldsSqlQuotedString = fieldsSql.join(\", \");\n    const fieldsSqlString = fieldsSql.join(\"_\");\n    switch (options.type.toUpperCase()) {\n      case \"UNIQUE\":\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_uk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} UNIQUE (${fieldsSqlQuotedString})`;\n        break;\n      case \"CHECK\":\n        options.where = this.whereItemsQuery(options.where);\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_ck`);\n        constraintSnippet = `CONSTRAINT ${constraintName} CHECK (${options.where})`;\n        break;\n      case \"DEFAULT\":\n        if (options.defaultValue === void 0) {\n          throw new Error(\"Default value must be specified for DEFAULT CONSTRAINT\");\n        }\n        if (this._dialect.name !== \"mssql\") {\n          throw new Error(\"Default constraints are supported only for MSSQL dialect.\");\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_df`);\n        constraintSnippet = `CONSTRAINT ${constraintName} DEFAULT (${this.escape(options.defaultValue)}) FOR ${fieldsSql[0]}`;\n        break;\n      case \"PRIMARY KEY\":\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_pk`);\n        constraintSnippet = `CONSTRAINT ${constraintName} PRIMARY KEY (${fieldsSqlQuotedString})`;\n        break;\n      case \"FOREIGN KEY\":\n        const references = options.references;\n        if (!references || !references.table || !(references.field || references.fields)) {\n          throw new Error(\"references object with table and field must be specified\");\n        }\n        constraintName = this.quoteIdentifier(options.name || `${tableName}_${fieldsSqlString}_${references.table}_fk`);\n        const quotedReferences = typeof references.field !== \"undefined\" ? this.quoteIdentifier(references.field) : references.fields.map((f) => this.quoteIdentifier(f)).join(\", \");\n        const referencesSnippet = `${this.quoteTable(references.table)} (${quotedReferences})`;\n        constraintSnippet = `CONSTRAINT ${constraintName} `;\n        constraintSnippet += `FOREIGN KEY (${fieldsSqlQuotedString}) REFERENCES ${referencesSnippet}`;\n        if (options.onUpdate) {\n          constraintSnippet += ` ON UPDATE ${options.onUpdate.toUpperCase()}`;\n        }\n        if (options.onDelete) {\n          constraintSnippet += ` ON DELETE ${options.onDelete.toUpperCase()}`;\n        }\n        break;\n      default:\n        throw new Error(`${options.type} is invalid.`);\n    }\n    if (options.deferrable && [\"UNIQUE\", \"PRIMARY KEY\", \"FOREIGN KEY\"].includes(options.type.toUpperCase())) {\n      constraintSnippet += ` ${this.deferConstraintsQuery(options)}`;\n    }\n    return constraintSnippet;\n  }\n  removeConstraintQuery(tableName, constraintName) {\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      tableName,\n      \"DROP CONSTRAINT\",\n      this.quoteIdentifiers(constraintName)\n    ]);\n  }\n  quote(collection, parent, connector) {\n    const validOrderOptions = [\n      \"ASC\",\n      \"DESC\",\n      \"ASC NULLS LAST\",\n      \"DESC NULLS LAST\",\n      \"ASC NULLS FIRST\",\n      \"DESC NULLS FIRST\",\n      \"NULLS FIRST\",\n      \"NULLS LAST\"\n    ];\n    connector = connector || \".\";\n    if (typeof collection === \"string\") {\n      return this.quoteIdentifiers(collection);\n    }\n    if (Array.isArray(collection)) {\n      collection.forEach((item2, index) => {\n        const previous = collection[index - 1];\n        let previousAssociation;\n        let previousModel;\n        if (!previous && parent !== void 0) {\n          previousModel = parent;\n        } else if (previous && previous instanceof Association) {\n          previousAssociation = previous;\n          previousModel = previous.target;\n        }\n        if (previousModel && previousModel.prototype instanceof Model) {\n          let model;\n          let as;\n          if (typeof item2 === \"function\" && item2.prototype instanceof Model) {\n            model = item2;\n          } else if (_.isPlainObject(item2) && item2.model && item2.model.prototype instanceof Model) {\n            model = item2.model;\n            as = item2.as;\n          }\n          if (model) {\n            if (!as && previousAssociation && previousAssociation instanceof Association && previousAssociation.through && previousAssociation.through.model === model) {\n              item2 = new Association(previousModel, model, {\n                as: model.name\n              });\n            } else {\n              item2 = previousModel.getAssociationForAlias(model, as);\n              if (!item2) {\n                item2 = previousModel.getAssociationForAlias(model, model.name);\n              }\n            }\n            if (!(item2 instanceof Association)) {\n              throw new Error(util.format(\"Unable to find a valid association for model, '%s'\", model.name));\n            }\n          }\n        }\n        if (typeof item2 === \"string\") {\n          const orderIndex = validOrderOptions.indexOf(item2.toUpperCase());\n          if (index > 0 && orderIndex !== -1) {\n            item2 = this.sequelize.literal(` ${validOrderOptions[orderIndex]}`);\n          } else if (previousModel && previousModel.prototype instanceof Model) {\n            if (previousModel.associations !== void 0 && previousModel.associations[item2]) {\n              item2 = previousModel.associations[item2];\n            } else if (previousModel.rawAttributes !== void 0 && previousModel.rawAttributes[item2] && item2 !== previousModel.rawAttributes[item2].field) {\n              item2 = previousModel.rawAttributes[item2].field;\n            } else if (item2.includes(\".\") && previousModel.rawAttributes !== void 0) {\n              const itemSplit = item2.split(\".\");\n              if (previousModel.rawAttributes[itemSplit[0]].type instanceof DataTypes.JSON) {\n                const identifier = this.quoteIdentifiers(`${previousModel.name}.${previousModel.rawAttributes[itemSplit[0]].field}`);\n                const path = itemSplit.slice(1);\n                item2 = this.jsonPathExtractionQuery(identifier, path);\n                item2 = this.sequelize.literal(item2);\n              }\n            }\n          }\n        }\n        collection[index] = item2;\n      }, this);\n      const collectionLength = collection.length;\n      const tableNames = [];\n      let item;\n      let i = 0;\n      for (i = 0; i < collectionLength - 1; i++) {\n        item = collection[i];\n        if (typeof item === \"string\" || item._modelAttribute || item instanceof Utils.SequelizeMethod) {\n          break;\n        } else if (item instanceof Association) {\n          tableNames[i] = item.as;\n        }\n      }\n      let sql = \"\";\n      if (i > 0) {\n        sql += `${this.quoteIdentifier(tableNames.join(connector))}.`;\n      } else if (typeof collection[0] === \"string\" && parent) {\n        sql += `${this.quoteIdentifier(parent.name)}.`;\n      }\n      collection.slice(i).forEach((collectionItem) => {\n        sql += this.quote(collectionItem, parent, connector);\n      }, this);\n      return sql;\n    }\n    if (collection._modelAttribute) {\n      return `${this.quoteTable(collection.Model.name)}.${this.quoteIdentifier(collection.fieldName)}`;\n    }\n    if (collection instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(collection);\n    }\n    if (_.isPlainObject(collection) && collection.raw) {\n      throw new Error('The `{raw: \"...\"}` syntax is no longer supported.  Use `sequelize.literal` instead.');\n    }\n    throw new Error(`Unknown structure passed to order / group: ${util.inspect(collection)}`);\n  }\n  _initQuoteIdentifier() {\n    this._quoteIdentifier = this.quoteIdentifier;\n    this.quoteIdentifier = function(identifier, force) {\n      if (identifier === \"*\")\n        return identifier;\n      return this._quoteIdentifier(identifier, force);\n    };\n  }\n  quoteIdentifier(identifier, force) {\n    throw new Error(`quoteIdentifier for Dialect \"${this.dialect}\" is not implemented`);\n  }\n  quoteIdentifiers(identifiers) {\n    if (identifiers.includes(\".\")) {\n      identifiers = identifiers.split(\".\");\n      const head = identifiers.slice(0, identifiers.length - 1).join(\"->\");\n      const tail = identifiers[identifiers.length - 1];\n      return `${this.quoteIdentifier(head)}.${this.quoteIdentifier(tail)}`;\n    }\n    return this.quoteIdentifier(identifiers);\n  }\n  quoteAttribute(attribute, model) {\n    if (model && attribute in model.rawAttributes) {\n      return this.quoteIdentifier(attribute);\n    }\n    return this.quoteIdentifiers(attribute);\n  }\n  getAliasToken() {\n    return \"AS\";\n  }\n  quoteTable(param, alias) {\n    let table = \"\";\n    if (alias === true) {\n      alias = param.as || param.name || param;\n    }\n    if (_.isObject(param)) {\n      if (this._dialect.supports.schemas) {\n        if (param.schema) {\n          table += `${this.quoteIdentifier(param.schema)}.`;\n        }\n        table += this.quoteIdentifier(param.tableName);\n      } else {\n        if (param.schema) {\n          table += param.schema + (param.delimiter || \".\");\n        }\n        table += param.tableName;\n        table = this.quoteIdentifier(table);\n      }\n    } else {\n      table = this.quoteIdentifier(param);\n    }\n    if (alias) {\n      table += ` ${this.getAliasToken()} ${this.quoteIdentifier(alias)}`;\n    }\n    return table;\n  }\n  escape(value, field, options) {\n    options = options || {};\n    if (value !== null && value !== void 0) {\n      if (value instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(value);\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n        if (field.type.stringify) {\n          const simpleEscape = (escVal) => SqlString.escape(escVal, this.options.timezone, this.dialect);\n          value = field.type.stringify(value, { escape: simpleEscape, field, timezone: this.options.timezone, operation: options.operation });\n          if (field.type.escape === false) {\n            return value;\n          }\n        }\n      }\n    }\n    return SqlString.escape(value, this.options.timezone, this.dialect);\n  }\n  bindParam(bind) {\n    return (value) => {\n      bind.push(value);\n      return `$${bind.length}`;\n    };\n  }\n  format(value, field, options, bindParam) {\n    options = options || {};\n    if (value !== null && value !== void 0) {\n      if (value instanceof Utils.SequelizeMethod) {\n        throw new Error(\"Cannot pass SequelizeMethod as a bind parameter - use escape instead\");\n      }\n      if (field && field.type) {\n        this.validate(value, field, options);\n        if (field.type.bindParam) {\n          return field.type.bindParam(value, { escape: _.identity, field, timezone: this.options.timezone, operation: options.operation, bindParam });\n        }\n      }\n    }\n    return bindParam(value);\n  }\n  validate(value, field, options) {\n    if (this.typeValidation && field.type.validate && value) {\n      try {\n        if (options.isList && Array.isArray(value)) {\n          for (const item of value) {\n            field.type.validate(item, options);\n          }\n        } else {\n          field.type.validate(value, options);\n        }\n      } catch (error) {\n        if (error instanceof sequelizeError.ValidationError) {\n          error.errors.push(new sequelizeError.ValidationErrorItem(error.message, \"Validation error\", field.fieldName, value, null, `${field.type.key} validator`));\n        }\n        throw error;\n      }\n    }\n  }\n  isIdentifierQuoted(identifier) {\n    return /^\\s*(?:([`\"'])(?:(?!\\1).|\\1{2})*\\1\\.?)+\\s*$/i.test(identifier);\n  }\n  jsonPathExtractionQuery(column, path, isJson) {\n    let paths = _.toPath(path);\n    let pathStr;\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    switch (this.dialect) {\n      case \"mysql\":\n      case \"mariadb\":\n      case \"sqlite\":\n        if (this.dialect === \"mysql\") {\n          paths = paths.map((subPath) => {\n            return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n          });\n        }\n        pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n        if (this.dialect === \"sqlite\") {\n          return `json_extract(${quotedColumn},${pathStr})`;\n        }\n        return `json_unquote(json_extract(${quotedColumn},${pathStr}))`;\n      case \"postgres\":\n        const join = isJson ? \"#>\" : \"#>>\";\n        pathStr = this.escape(`{${paths.join(\",\")}}`);\n        return `(${quotedColumn}${join}${pathStr})`;\n      default:\n        throw new Error(`Unsupported ${this.dialect} for JSON operations`);\n    }\n  }\n  selectQuery(tableName, options, model) {\n    options = options || {};\n    const limit = options.limit;\n    const mainQueryItems = [];\n    const subQueryItems = [];\n    const subQuery = options.subQuery === void 0 ? limit && options.hasMultiAssociation : options.subQuery;\n    const attributes = {\n      main: options.attributes && options.attributes.slice(),\n      subQuery: null\n    };\n    const mainTable = {\n      name: tableName,\n      quotedName: null,\n      as: null,\n      model\n    };\n    const topLevelInfo = {\n      names: mainTable,\n      options,\n      subQuery\n    };\n    let mainJoinQueries = [];\n    let subJoinQueries = [];\n    let query;\n    if (this.options.minifyAliases && !options.aliasesMapping) {\n      options.aliasesMapping = /* @__PURE__ */ new Map();\n      options.aliasesByTable = {};\n      options.includeAliases = /* @__PURE__ */ new Map();\n    }\n    if (options.tableAs) {\n      mainTable.as = this.quoteIdentifier(options.tableAs);\n    } else if (!Array.isArray(mainTable.name) && mainTable.model) {\n      mainTable.as = this.quoteIdentifier(mainTable.model.name);\n    }\n    mainTable.quotedName = !Array.isArray(mainTable.name) ? this.quoteTable(mainTable.name) : tableName.map((t) => {\n      return Array.isArray(t) ? this.quoteTable(t[0], t[1]) : this.quoteTable(t, true);\n    }).join(\", \");\n    if (subQuery && attributes.main) {\n      for (const keyAtt of mainTable.model.primaryKeyAttributes) {\n        if (!attributes.main.some((attr) => keyAtt === attr || keyAtt === attr[0] || keyAtt === attr[1])) {\n          attributes.main.push(mainTable.model.rawAttributes[keyAtt].field ? [keyAtt, mainTable.model.rawAttributes[keyAtt].field] : keyAtt);\n        }\n      }\n    }\n    attributes.main = this.escapeAttributes(attributes.main, options, mainTable.as);\n    attributes.main = attributes.main || (options.include ? [`${mainTable.as}.*`] : [\"*\"]);\n    if (subQuery || options.groupedLimit) {\n      attributes.subQuery = attributes.main;\n      attributes.main = [`${mainTable.as || mainTable.quotedName}.*`];\n    }\n    if (options.include) {\n      for (const include of options.include) {\n        if (include.separate) {\n          continue;\n        }\n        const joinQueries = this.generateInclude(include, { externalAs: mainTable.as, internalAs: mainTable.as }, topLevelInfo);\n        subJoinQueries = subJoinQueries.concat(joinQueries.subQuery);\n        mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        if (joinQueries.attributes.main.length > 0) {\n          attributes.main = _.uniq(attributes.main.concat(joinQueries.attributes.main));\n        }\n        if (joinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = _.uniq(attributes.subQuery.concat(joinQueries.attributes.subQuery));\n        }\n      }\n    }\n    if (subQuery) {\n      subQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.subQuery, mainTable.quotedName, mainTable.as));\n      subQueryItems.push(subJoinQueries.join(\"\"));\n    } else {\n      if (options.groupedLimit) {\n        if (!mainTable.as) {\n          mainTable.as = mainTable.quotedName;\n        }\n        const where = __spreadValues({}, options.where);\n        let groupedLimitOrder, whereKey, include, groupedTableName = mainTable.as;\n        if (typeof options.groupedLimit.on === \"string\") {\n          whereKey = options.groupedLimit.on;\n        } else if (options.groupedLimit.on instanceof HasMany) {\n          whereKey = options.groupedLimit.on.foreignKeyField;\n        }\n        if (options.groupedLimit.on instanceof BelongsToMany) {\n          groupedTableName = options.groupedLimit.on.manyFromSource.as;\n          const groupedLimitOptions = Model._validateIncludedElements({\n            include: [{\n              association: options.groupedLimit.on.manyFromSource,\n              duplicating: false,\n              required: true,\n              where: __spreadValues({\n                [Op.placeholder]: true\n              }, options.groupedLimit.through && options.groupedLimit.through.where)\n            }],\n            model\n          });\n          options.hasJoin = true;\n          options.hasMultiAssociation = true;\n          options.includeMap = Object.assign(groupedLimitOptions.includeMap, options.includeMap);\n          options.includeNames = groupedLimitOptions.includeNames.concat(options.includeNames || []);\n          include = groupedLimitOptions.include;\n          if (Array.isArray(options.order)) {\n            options.order.forEach((order, i) => {\n              if (Array.isArray(order)) {\n                order = order[0];\n              }\n              let alias = `subquery_order_${i}`;\n              options.attributes.push([order, alias]);\n              alias = this.sequelize.literal(this.quote(alias));\n              if (Array.isArray(options.order[i])) {\n                options.order[i][0] = alias;\n              } else {\n                options.order[i] = alias;\n              }\n            });\n            groupedLimitOrder = options.order;\n          }\n        } else {\n          groupedLimitOrder = options.order;\n          if (!this._dialect.supports.topLevelOrderByRequired) {\n            delete options.order;\n          }\n          where[Op.placeholder] = true;\n        }\n        const baseQuery = `SELECT * FROM (${this.selectQuery(tableName, {\n          attributes: options.attributes,\n          offset: options.offset,\n          limit: options.groupedLimit.limit,\n          order: groupedLimitOrder,\n          aliasesMapping: options.aliasesMapping,\n          aliasesByTable: options.aliasesByTable,\n          where,\n          include,\n          model\n        }, model).replace(/;$/, \"\")}) ${this.getAliasToken()} sub`;\n        const placeHolder = this.whereItemQuery(Op.placeholder, true, { model });\n        const splicePos = baseQuery.indexOf(placeHolder);\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, `(${options.groupedLimit.values.map((value) => {\n          let groupWhere;\n          if (whereKey) {\n            groupWhere = {\n              [whereKey]: value\n            };\n          }\n          if (include) {\n            groupWhere = {\n              [options.groupedLimit.on.foreignIdentifierField]: value\n            };\n          }\n          return Utils.spliceStr(baseQuery, splicePos, placeHolder.length, this.getWhereConditions(groupWhere, groupedTableName));\n        }).join(this._dialect.supports[\"UNION ALL\"] ? \" UNION ALL \" : \" UNION \")})`, mainTable.as));\n      } else {\n        mainQueryItems.push(this.selectFromTableFragment(options, mainTable.model, attributes.main, mainTable.quotedName, mainTable.as));\n      }\n      mainQueryItems.push(mainJoinQueries.join(\"\"));\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"where\") && !options.groupedLimit) {\n      options.where = this.getWhereConditions(options.where, mainTable.as || tableName, model, options);\n      if (options.where) {\n        if (subQuery) {\n          subQueryItems.push(` WHERE ${options.where}`);\n        } else {\n          mainQueryItems.push(` WHERE ${options.where}`);\n          mainQueryItems.forEach((value, key) => {\n            if (value.startsWith(\"SELECT\")) {\n              mainQueryItems[key] = this.selectFromTableFragment(options, model, attributes.main, mainTable.quotedName, mainTable.as, options.where);\n            }\n          });\n        }\n      }\n    }\n    if (options.group) {\n      options.group = Array.isArray(options.group) ? options.group.map((t) => this.aliasGrouping(t, model, mainTable.as, options)).join(\", \") : this.aliasGrouping(options.group, model, mainTable.as, options);\n      if (subQuery && options.group) {\n        subQueryItems.push(` GROUP BY ${options.group}`);\n      } else if (options.group) {\n        mainQueryItems.push(` GROUP BY ${options.group}`);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"having\")) {\n      options.having = this.getWhereConditions(options.having, tableName, model, options, false);\n      if (options.having) {\n        if (subQuery) {\n          subQueryItems.push(` HAVING ${options.having}`);\n        } else {\n          mainQueryItems.push(` HAVING ${options.having}`);\n        }\n      }\n    }\n    if (options.order) {\n      const orders = this.getQueryOrders(options, model, subQuery);\n      if (orders.mainQueryOrder.length) {\n        mainQueryItems.push(` ORDER BY ${orders.mainQueryOrder.join(\", \")}`);\n      }\n      if (orders.subQueryOrder.length) {\n        subQueryItems.push(` ORDER BY ${orders.subQueryOrder.join(\", \")}`);\n      }\n    }\n    const limitOrder = this.addLimitAndOffset(options, mainTable.model);\n    if (limitOrder && !options.groupedLimit) {\n      if (subQuery) {\n        subQueryItems.push(limitOrder);\n      } else {\n        mainQueryItems.push(limitOrder);\n      }\n    }\n    if (subQuery) {\n      this._throwOnEmptyAttributes(attributes.main, { modelName: model && model.name, as: mainTable.as });\n      query = `SELECT ${attributes.main.join(\", \")} FROM (${subQueryItems.join(\"\")}) ${this.getAliasToken()} ${mainTable.as}${mainJoinQueries.join(\"\")}${mainQueryItems.join(\"\")}`;\n    } else {\n      query = mainQueryItems.join(\"\");\n    }\n    if (options.lock && this._dialect.supports.lock) {\n      let lock = options.lock;\n      if (typeof options.lock === \"object\") {\n        lock = options.lock.level;\n      }\n      if (this._dialect.supports.lockKey && [\"KEY SHARE\", \"NO KEY UPDATE\"].includes(lock)) {\n        query += ` FOR ${lock}`;\n      } else if (lock === \"SHARE\") {\n        query += ` ${this._dialect.supports.forShare}`;\n      } else {\n        query += \" FOR UPDATE\";\n      }\n      if (this._dialect.supports.lockOf && options.lock.of && options.lock.of.prototype instanceof Model) {\n        query += ` OF ${this.quoteTable(options.lock.of.name)}`;\n      }\n      if (this._dialect.supports.skipLocked && options.skipLocked) {\n        query += \" SKIP LOCKED\";\n      }\n    }\n    return `${query};`;\n  }\n  aliasGrouping(field, model, tableName, options) {\n    const src = Array.isArray(field) ? field[0] : field;\n    return this.quote(this._getAliasForField(tableName, src, options) || src, model);\n  }\n  escapeAttributes(attributes, options, mainTableAs) {\n    return attributes && attributes.map((attr) => {\n      let addTable = true;\n      if (attr instanceof Utils.SequelizeMethod) {\n        return this.handleSequelizeMethod(attr);\n      }\n      if (Array.isArray(attr)) {\n        if (attr.length !== 2) {\n          throw new Error(`${JSON.stringify(attr)} is not a valid attribute definition. Please use the following format: ['attribute definition', 'alias']`);\n        }\n        attr = attr.slice();\n        if (attr[0] instanceof Utils.SequelizeMethod) {\n          attr[0] = this.handleSequelizeMethod(attr[0]);\n          addTable = false;\n        } else if (this.options.attributeBehavior === \"escape\" || !attr[0].includes(\"(\") && !attr[0].includes(\")\")) {\n          attr[0] = this.quoteIdentifier(attr[0]);\n        } else if (this.options.attributeBehavior !== \"unsafe-legacy\") {\n          throw new Error(`Attributes cannot include parentheses in Sequelize 6:\nIn order to fix the vulnerability CVE-2023-22578, we had to remove support for treating attributes as raw SQL if they included parentheses.\nSequelize 7 escapes all attributes, even if they include parentheses.\nFor Sequelize 6, because we're introducing this change in a minor release, we've opted for throwing an error instead of silently escaping the attribute as a way to warn you about this change.\n\nHere is what you can do to fix this error:\n- Wrap the attribute in a literal() call. This will make Sequelize treat it as raw SQL.\n- Set the \"attributeBehavior\" sequelize option to \"escape\" to make Sequelize escape the attribute, like in Sequelize v7. We highly recommend this option.\n- Set the \"attributeBehavior\" sequelize option to \"unsafe-legacy\" to make Sequelize escape the attribute, like in Sequelize v5.\n\nWe sincerely apologize for the inconvenience this may cause you. You can find more information on the following threads:\nhttps://github.com/sequelize/sequelize/security/advisories/GHSA-f598-mfpv-gmfx\nhttps://github.com/sequelize/sequelize/discussions/15694`);\n        }\n        let alias = attr[1];\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, mainTableAs, options);\n        }\n        attr = [attr[0], this.quoteIdentifier(alias)].join(\" AS \");\n      } else {\n        attr = !attr.includes(Utils.TICK_CHAR) && !attr.includes('\"') ? this.quoteAttribute(attr, options.model) : this.escape(attr);\n      }\n      if (!_.isEmpty(options.include) && (!attr.includes(\".\") || options.dotNotation) && addTable) {\n        attr = `${mainTableAs}.${attr}`;\n      }\n      return attr;\n    });\n  }\n  generateInclude(include, parentTableName, topLevelInfo) {\n    const joinQueries = {\n      mainQuery: [],\n      subQuery: []\n    };\n    const mainChildIncludes = [];\n    const subChildIncludes = [];\n    let requiredMismatch = false;\n    const includeAs = {\n      internalAs: include.as,\n      externalAs: include.as\n    };\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let joinQuery;\n    topLevelInfo.options.keysEscaped = true;\n    if (topLevelInfo.names.name !== parentTableName.externalAs && topLevelInfo.names.as !== parentTableName.externalAs) {\n      includeAs.internalAs = `${parentTableName.internalAs}->${include.as}`;\n      includeAs.externalAs = `${parentTableName.externalAs}.${include.as}`;\n    }\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      include.model._expandAttributes(include);\n      Utils.mapFinderOptions(include, include.model);\n      const includeAttributes = include.attributes.map((attr) => {\n        let attrAs = attr;\n        let verbatim = false;\n        if (Array.isArray(attr) && attr.length === 2) {\n          if (attr[0] instanceof Utils.SequelizeMethod && (attr[0] instanceof Utils.Literal || attr[0] instanceof Utils.Cast || attr[0] instanceof Utils.Fn)) {\n            verbatim = true;\n          }\n          attr = attr.map((attr2) => attr2 instanceof Utils.SequelizeMethod ? this.handleSequelizeMethod(attr2) : attr2);\n          attrAs = attr[1];\n          attr = attr[0];\n        }\n        if (attr instanceof Utils.Literal) {\n          return attr.val;\n        }\n        if (attr instanceof Utils.Cast || attr instanceof Utils.Fn) {\n          throw new Error(\"Tried to select attributes using Sequelize.cast or Sequelize.fn without specifying an alias for the result, during eager loading. This means the attribute will not be added to the returned instance\");\n        }\n        let prefix;\n        if (verbatim === true) {\n          prefix = attr;\n        } else if (/#>>|->>/.test(attr)) {\n          prefix = `(${this.quoteIdentifier(includeAs.internalAs)}.${attr.replace(/\\(|\\)/g, \"\")})`;\n        } else if (/json_extract\\(/.test(attr)) {\n          prefix = attr.replace(/json_extract\\(/i, `json_extract(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else if (/json_value\\(/.test(attr)) {\n          prefix = attr.replace(/json_value\\(/i, `json_value(${this.quoteIdentifier(includeAs.internalAs)}.`);\n        } else {\n          prefix = `${this.quoteIdentifier(includeAs.internalAs)}.${this.quoteIdentifier(attr)}`;\n        }\n        let alias = `${includeAs.externalAs}.${attrAs}`;\n        if (this.options.minifyAliases) {\n          alias = this._getMinifiedAlias(alias, includeAs.internalAs, topLevelInfo.options);\n        }\n        return Utils.joinSQLFragments([\n          prefix,\n          \"AS\",\n          this.quoteIdentifier(alias, true)\n        ]);\n      });\n      if (include.subQuery && topLevelInfo.subQuery) {\n        for (const attr of includeAttributes) {\n          attributes.subQuery.push(attr);\n        }\n      } else {\n        for (const attr of includeAttributes) {\n          attributes.main.push(attr);\n        }\n      }\n    }\n    if (include.through) {\n      joinQuery = this.generateThroughJoin(include, includeAs, parentTableName.internalAs, topLevelInfo);\n    } else {\n      this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n      joinQuery = this.generateJoin(include, topLevelInfo);\n    }\n    if (joinQuery.attributes.main.length > 0) {\n      attributes.main = attributes.main.concat(joinQuery.attributes.main);\n    }\n    if (joinQuery.attributes.subQuery.length > 0) {\n      attributes.subQuery = attributes.subQuery.concat(joinQuery.attributes.subQuery);\n    }\n    if (include.include) {\n      for (const childInclude of include.include) {\n        if (childInclude.separate || childInclude._pseudo) {\n          continue;\n        }\n        const childJoinQueries = this.generateInclude(childInclude, includeAs, topLevelInfo);\n        if (include.required === false && childInclude.required === true) {\n          requiredMismatch = true;\n        }\n        if (childInclude.subQuery && topLevelInfo.subQuery) {\n          subChildIncludes.push(childJoinQueries.subQuery);\n        }\n        if (childJoinQueries.mainQuery) {\n          mainChildIncludes.push(childJoinQueries.mainQuery);\n        }\n        if (childJoinQueries.attributes.main.length > 0) {\n          attributes.main = attributes.main.concat(childJoinQueries.attributes.main);\n        }\n        if (childJoinQueries.attributes.subQuery.length > 0) {\n          attributes.subQuery = attributes.subQuery.concat(childJoinQueries.attributes.subQuery);\n        }\n      }\n    }\n    if (include.subQuery && topLevelInfo.subQuery) {\n      if (requiredMismatch && subChildIncludes.length > 0) {\n        joinQueries.subQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${subChildIncludes.join(\"\")} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.subQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (subChildIncludes.length > 0) {\n          joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n        }\n      }\n      joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n    } else {\n      if (requiredMismatch && mainChildIncludes.length > 0) {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ( ${joinQuery.body}${mainChildIncludes.join(\"\")} ) ON ${joinQuery.condition}`);\n      } else {\n        joinQueries.mainQuery.push(` ${joinQuery.join} ${joinQuery.body} ON ${joinQuery.condition}`);\n        if (mainChildIncludes.length > 0) {\n          joinQueries.mainQuery.push(mainChildIncludes.join(\"\"));\n        }\n      }\n      joinQueries.subQuery.push(subChildIncludes.join(\"\"));\n    }\n    return {\n      mainQuery: joinQueries.mainQuery.join(\"\"),\n      subQuery: joinQueries.subQuery.join(\"\"),\n      attributes\n    };\n  }\n  _getMinifiedAlias(alias, tableName, options) {\n    if (options.aliasesByTable[`${tableName}${alias}`]) {\n      return options.aliasesByTable[`${tableName}${alias}`];\n    }\n    if (alias.match(/subquery_order_[0-9]/)) {\n      return alias;\n    }\n    const minifiedAlias = `_${options.aliasesMapping.size}`;\n    options.aliasesMapping.set(minifiedAlias, alias);\n    options.aliasesByTable[`${tableName}${alias}`] = minifiedAlias;\n    return minifiedAlias;\n  }\n  _getAliasForField(tableName, field, options) {\n    if (this.options.minifyAliases) {\n      if (options.aliasesByTable[`${tableName}${field}`]) {\n        return options.aliasesByTable[`${tableName}${field}`];\n      }\n    }\n    return null;\n  }\n  generateJoin(include, topLevelInfo) {\n    const association = include.association;\n    const parent = include.parent;\n    const parentIsTop = !!parent && !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    let $parent;\n    let joinWhere;\n    const left = association.source;\n    const attrLeft = association instanceof BelongsTo ? association.identifier : association.sourceKeyAttribute || left.primaryKeyAttribute;\n    const fieldLeft = association instanceof BelongsTo ? association.identifierField : left.rawAttributes[association.sourceKeyAttribute || left.primaryKeyAttribute].field;\n    let asLeft;\n    const right = include.model;\n    const tableRight = right.getTableName();\n    const fieldRight = association instanceof BelongsTo ? right.rawAttributes[association.targetIdentifier || right.primaryKeyAttribute].field : association.identifierField;\n    let asRight = include.as;\n    while (($parent = $parent && $parent.parent || include.parent) && $parent.association) {\n      if (asLeft) {\n        asLeft = `${$parent.as}->${asLeft}`;\n      } else {\n        asLeft = $parent.as;\n      }\n    }\n    if (!asLeft)\n      asLeft = parent.as || parent.model.name;\n    else\n      asRight = `${asLeft}->${asRight}`;\n    let joinOn = `${this.quoteTable(asLeft)}.${this.quoteIdentifier(fieldLeft)}`;\n    const subqueryAttributes = [];\n    if (topLevelInfo.options.groupedLimit && parentIsTop || topLevelInfo.subQuery && include.parent.subQuery && !include.subQuery) {\n      if (parentIsTop) {\n        const tableName = this.quoteTable(parent.as || parent.model.name);\n        joinOn = this._getAliasForField(tableName, attrLeft, topLevelInfo.options) || `${tableName}.${this.quoteIdentifier(attrLeft)}`;\n        if (topLevelInfo.subQuery) {\n          const dbIdentifier = `${tableName}.${this.quoteIdentifier(fieldLeft)}`;\n          subqueryAttributes.push(dbIdentifier !== joinOn ? `${dbIdentifier} AS ${this.quoteIdentifier(attrLeft)}` : dbIdentifier);\n        }\n      } else {\n        const joinSource = `${asLeft.replace(/->/g, \".\")}.${attrLeft}`;\n        joinOn = this._getAliasForField(asLeft, joinSource, topLevelInfo.options) || this.quoteIdentifier(joinSource);\n      }\n    }\n    joinOn += ` = ${this.quoteIdentifier(asRight)}.${this.quoteIdentifier(fieldRight)}`;\n    if (include.on) {\n      joinOn = this.whereItemsQuery(include.on, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n    }\n    if (include.where) {\n      joinWhere = this.whereItemsQuery(include.where, {\n        prefix: this.sequelize.literal(this.quoteIdentifier(asRight)),\n        model: include.model\n      });\n      if (joinWhere) {\n        if (include.or) {\n          joinOn += ` OR ${joinWhere}`;\n        } else {\n          joinOn += ` AND ${joinWhere}`;\n        }\n      }\n    }\n    this.aliasAs(asRight, topLevelInfo);\n    return {\n      join: include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\",\n      body: this.quoteTable(tableRight, asRight),\n      condition: joinOn,\n      attributes: {\n        main: [],\n        subQuery: subqueryAttributes\n      }\n    };\n  }\n  generateReturnValues(modelAttributes, options) {\n    const returnFields = [];\n    const returnTypes = [];\n    let outputFragment = \"\";\n    let returningFragment = \"\";\n    let tmpTable = \"\";\n    if (Array.isArray(options.returning)) {\n      returnFields.push(...options.returning.map((field) => this.quoteIdentifier(field)));\n    } else if (modelAttributes) {\n      _.each(modelAttributes, (attribute) => {\n        if (!(attribute.type instanceof DataTypes.VIRTUAL)) {\n          returnFields.push(this.quoteIdentifier(attribute.field));\n          returnTypes.push(attribute.type);\n        }\n      });\n    }\n    if (_.isEmpty(returnFields)) {\n      returnFields.push(\"*\");\n    }\n    if (this._dialect.supports.returnValues.returning) {\n      returningFragment = ` RETURNING ${returnFields.join(\",\")}`;\n    } else if (this._dialect.supports.returnIntoValues) {\n      returningFragment = ` RETURNING ${returnFields.join(\",\")} INTO `;\n    } else if (this._dialect.supports.returnValues.output) {\n      outputFragment = ` OUTPUT ${returnFields.map((field) => `INSERTED.${field}`).join(\",\")}`;\n      if (options.hasTrigger && this._dialect.supports.tmpTableTrigger) {\n        const tmpColumns = returnFields.map((field, i) => `${field} ${returnTypes[i].toSql()}`);\n        tmpTable = `DECLARE @tmp TABLE (${tmpColumns.join(\",\")}); `;\n        outputFragment += \" INTO @tmp\";\n        returningFragment = \"; SELECT * FROM @tmp\";\n      }\n    }\n    return { outputFragment, returnFields, returnTypes, returningFragment, tmpTable };\n  }\n  generateThroughJoin(include, includeAs, parentTableName, topLevelInfo) {\n    const through = include.through;\n    const throughTable = through.model.getTableName();\n    const throughAs = `${includeAs.internalAs}->${through.as}`;\n    const externalThroughAs = `${includeAs.externalAs}.${through.as}`;\n    const throughAttributes = through.attributes.map((attr) => {\n      let alias = `${externalThroughAs}.${Array.isArray(attr) ? attr[1] : attr}`;\n      if (this.options.minifyAliases) {\n        alias = this._getMinifiedAlias(alias, throughAs, topLevelInfo.options);\n      }\n      return Utils.joinSQLFragments([\n        `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(Array.isArray(attr) ? attr[0] : attr)}`,\n        \"AS\",\n        this.quoteIdentifier(alias)\n      ]);\n    });\n    const association = include.association;\n    const parentIsTop = !include.parent.association && include.parent.model.name === topLevelInfo.options.model.name;\n    const tableSource = parentTableName;\n    const identSource = association.identifierField;\n    const tableTarget = includeAs.internalAs;\n    const identTarget = association.foreignIdentifierField;\n    const attrTarget = association.targetKeyField;\n    const joinType = include.required ? \"INNER JOIN\" : include.right && this._dialect.supports[\"RIGHT JOIN\"] ? \"RIGHT OUTER JOIN\" : \"LEFT OUTER JOIN\";\n    let joinBody;\n    let joinCondition;\n    const attributes = {\n      main: [],\n      subQuery: []\n    };\n    let attrSource = association.sourceKey;\n    let sourceJoinOn;\n    let targetJoinOn;\n    let throughWhere;\n    let targetWhere;\n    if (topLevelInfo.options.includeIgnoreAttributes !== false) {\n      for (const attr of throughAttributes) {\n        attributes.main.push(attr);\n      }\n    }\n    if (!topLevelInfo.subQuery) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && !include.parent.subQuery && include.parent.model !== topLevelInfo.options.mainModel) {\n      attrSource = association.sourceKeyField;\n    }\n    if (topLevelInfo.subQuery && !include.subQuery && include.parent.subQuery && !parentIsTop) {\n      const joinSource = this._getAliasForField(tableSource, `${tableSource}.${attrSource}`, topLevelInfo.options) || `${tableSource}.${attrSource}`;\n      sourceJoinOn = `${this.quoteIdentifier(joinSource)} = `;\n    } else {\n      const aliasedSource = this._getAliasForField(tableSource, attrSource, topLevelInfo.options) || attrSource;\n      sourceJoinOn = `${this.quoteTable(tableSource)}.${this.quoteIdentifier(aliasedSource)} = `;\n    }\n    sourceJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identSource)}`;\n    targetJoinOn = `${this.quoteIdentifier(tableTarget)}.${this.quoteIdentifier(attrTarget)} = `;\n    targetJoinOn += `${this.quoteIdentifier(throughAs)}.${this.quoteIdentifier(identTarget)}`;\n    if (through.where) {\n      throughWhere = this.getWhereConditions(through.where, this.sequelize.literal(this.quoteIdentifier(throughAs)), through.model);\n    }\n    this.aliasAs(includeAs.internalAs, topLevelInfo);\n    joinBody = `( ${this.quoteTable(throughTable, throughAs)} INNER JOIN ${this.quoteTable(include.model.getTableName(), includeAs.internalAs)} ON ${targetJoinOn}`;\n    if (throughWhere) {\n      joinBody += ` AND ${throughWhere}`;\n    }\n    joinBody += \")\";\n    joinCondition = sourceJoinOn;\n    if (include.where || include.through.where) {\n      if (include.where) {\n        targetWhere = this.getWhereConditions(include.where, this.sequelize.literal(this.quoteIdentifier(includeAs.internalAs)), include.model, topLevelInfo.options);\n        if (targetWhere) {\n          joinCondition += ` AND ${targetWhere}`;\n        }\n      }\n    }\n    this._generateSubQueryFilter(include, includeAs, topLevelInfo);\n    return {\n      join: joinType,\n      body: joinBody,\n      condition: joinCondition,\n      attributes\n    };\n  }\n  aliasAs(as, topLevelInfo) {\n    if (this.options.minifyAliases && as.length >= 64) {\n      const alias = `%${topLevelInfo.options.includeAliases.size}`;\n      topLevelInfo.options.includeAliases.set(alias, as);\n    }\n  }\n  _generateSubQueryFilter(include, includeAs, topLevelInfo) {\n    if (!topLevelInfo.subQuery || !include.subQueryFilter) {\n      return;\n    }\n    if (!topLevelInfo.options.where) {\n      topLevelInfo.options.where = {};\n    }\n    let parent = include;\n    let child = include;\n    let nestedIncludes = this._getRequiredClosure(include).include;\n    let query;\n    while (parent = parent.parent) {\n      if (parent.parent && !parent.required) {\n        return;\n      }\n      if (parent.subQueryFilter) {\n        return;\n      }\n      nestedIncludes = [__spreadProps(__spreadValues({}, child), { include: nestedIncludes, attributes: [] })];\n      child = parent;\n    }\n    const topInclude = nestedIncludes[0];\n    const topParent = topInclude.parent;\n    const topAssociation = topInclude.association;\n    topInclude.association = void 0;\n    if (topInclude.through && Object(topInclude.through.model) === topInclude.through.model) {\n      query = this.selectQuery(topInclude.through.model.getTableName(), {\n        attributes: [topInclude.through.model.primaryKeyField],\n        include: Model._validateIncludedElements({\n          model: topInclude.through.model,\n          include: [{\n            association: topAssociation.toTarget,\n            required: true,\n            where: topInclude.where,\n            include: topInclude.include\n          }]\n        }).include,\n        model: topInclude.through.model,\n        where: {\n          [Op.and]: [\n            this.sequelize.literal([\n              `${this.quoteTable(topParent.model.name)}.${this.quoteIdentifier(topParent.model.primaryKeyField)}`,\n              `${this.quoteIdentifier(topInclude.through.model.name)}.${this.quoteIdentifier(topAssociation.identifierField)}`\n            ].join(\" = \")),\n            topInclude.through.where\n          ]\n        },\n        limit: 1,\n        includeIgnoreAttributes: false\n      }, topInclude.through.model);\n    } else {\n      const isBelongsTo = topAssociation.associationType === \"BelongsTo\";\n      const sourceField = isBelongsTo ? topAssociation.identifierField : topAssociation.sourceKeyField || topParent.model.primaryKeyField;\n      const targetField = isBelongsTo ? topAssociation.sourceKeyField || topInclude.model.primaryKeyField : topAssociation.identifierField;\n      const join = [\n        `${this.quoteIdentifier(topInclude.as)}.${this.quoteIdentifier(targetField)}`,\n        `${this.quoteTable(topParent.as || topParent.model.name)}.${this.quoteIdentifier(sourceField)}`\n      ].join(\" = \");\n      query = this.selectQuery(topInclude.model.getTableName(), {\n        attributes: [targetField],\n        include: Model._validateIncludedElements(topInclude).include,\n        model: topInclude.model,\n        where: {\n          [Op.and]: [\n            topInclude.where,\n            { [Op.join]: this.sequelize.literal(join) }\n          ]\n        },\n        limit: 1,\n        tableAs: topInclude.as,\n        includeIgnoreAttributes: false\n      }, topInclude.model);\n    }\n    if (!topLevelInfo.options.where[Op.and]) {\n      topLevelInfo.options.where[Op.and] = [];\n    }\n    topLevelInfo.options.where[`__${includeAs.internalAs}`] = this.sequelize.literal([\n      \"(\",\n      query.replace(/;$/, \"\"),\n      \")\",\n      \"IS NOT NULL\"\n    ].join(\" \"));\n  }\n  _getRequiredClosure(include) {\n    const copy = __spreadProps(__spreadValues({}, include), { attributes: [], include: [] });\n    if (Array.isArray(include.include)) {\n      copy.include = include.include.filter((i) => i.required).map((inc) => this._getRequiredClosure(inc));\n    }\n    return copy;\n  }\n  getQueryOrders(options, model, subQuery) {\n    const mainQueryOrder = [];\n    const subQueryOrder = [];\n    if (Array.isArray(options.order)) {\n      for (let order of options.order) {\n        if (!Array.isArray(order)) {\n          order = [order];\n        }\n        if (subQuery && Array.isArray(order) && order[0] && !(order[0] instanceof Association) && !(typeof order[0] === \"function\" && order[0].prototype instanceof Model) && !(typeof order[0].model === \"function\" && order[0].model.prototype instanceof Model) && !(typeof order[0] === \"string\" && model && model.associations !== void 0 && model.associations[order[0]])) {\n          const field = model.rawAttributes[order[0]] ? model.rawAttributes[order[0]].field : order[0];\n          const subQueryAlias = this._getAliasForField(this.quoteIdentifier(model.name), field, options);\n          let parent = null;\n          let orderToQuote = [];\n          if (subQueryAlias === null) {\n            orderToQuote = order;\n            parent = model;\n          } else {\n            orderToQuote = [subQueryAlias, order.length > 1 ? order[1] : \"ASC\"];\n            parent = null;\n          }\n          subQueryOrder.push(this.quote(orderToQuote, parent, \"->\"));\n        }\n        if (options.attributes && model) {\n          const aliasedAttribute = options.attributes.find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === order[0] || attr[1] === order[0]));\n          if (aliasedAttribute) {\n            const modelName = this.quoteIdentifier(model.name);\n            const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n            order[0] = new Utils.Col(alias || aliasedAttribute[1]);\n          }\n        }\n        mainQueryOrder.push(this.quote(order, model, \"->\"));\n      }\n    } else if (options.order instanceof Utils.SequelizeMethod) {\n      const sql = this.quote(options.order, model, \"->\");\n      if (subQuery) {\n        subQueryOrder.push(sql);\n      }\n      mainQueryOrder.push(sql);\n    } else {\n      throw new Error(\"Order must be type of array or instance of a valid sequelize method.\");\n    }\n    return { mainQueryOrder, subQueryOrder };\n  }\n  _throwOnEmptyAttributes(attributes, extraInfo = {}) {\n    if (attributes.length > 0)\n      return;\n    const asPart = extraInfo.as && `as ${extraInfo.as}` || \"\";\n    const namePart = extraInfo.modelName && `for model '${extraInfo.modelName}'` || \"\";\n    const message = `Attempted a SELECT query ${namePart} ${asPart} without selecting any columns`;\n    throw new sequelizeError.QueryError(message.replace(/ +/g, \" \"));\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n    let fragment = `SELECT ${attributes.join(\", \")} FROM ${tables}`;\n    if (mainTableAs) {\n      fragment += ` ${this.getAliasToken()} ${mainTableAs}`;\n    }\n    if (options.indexHints && this._dialect.supports.indexHints) {\n      for (const hint of options.indexHints) {\n        if (IndexHints[hint.type]) {\n          fragment += ` ${IndexHints[hint.type]} INDEX (${hint.values.map((indexName) => this.quoteIdentifiers(indexName)).join(\",\")})`;\n        }\n      }\n    }\n    return fragment;\n  }\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n    if (options.offset != null && options.limit == null) {\n      fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + 1e13;\n    } else if (options.limit != null) {\n      if (options.offset != null) {\n        fragment += \" LIMIT \" + this.escape(options.offset) + \", \" + this.escape(options.limit);\n      } else {\n        fragment += \" LIMIT \" + this.escape(options.limit);\n      }\n    }\n    return fragment;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let result;\n    if (Object.prototype.hasOwnProperty.call(this.OperatorMap, smth.comparator)) {\n      smth.comparator = this.OperatorMap[smth.comparator];\n    }\n    if (smth instanceof Utils.Where) {\n      let value = smth.logic;\n      let key;\n      if (smth.attribute instanceof Utils.SequelizeMethod) {\n        key = this.getWhereConditions(smth.attribute, tableName, factory, options, prepend);\n      } else {\n        key = `${this.quoteTable(smth.attribute.Model.name)}.${this.quoteIdentifier(smth.attribute.field || smth.attribute.fieldName)}`;\n      }\n      if (value && value instanceof Utils.SequelizeMethod) {\n        value = this.getWhereConditions(value, tableName, factory, options, prepend);\n        if (value === \"NULL\") {\n          if (smth.comparator === \"=\") {\n            smth.comparator = \"IS\";\n          }\n          if (smth.comparator === \"!=\") {\n            smth.comparator = \"IS NOT\";\n          }\n        }\n        return [key, value].join(` ${smth.comparator} `);\n      }\n      if (_.isPlainObject(value)) {\n        return this.whereItemQuery(smth.attribute, value, {\n          model: factory\n        });\n      }\n      if ([this.OperatorMap[Op.between], this.OperatorMap[Op.notBetween]].includes(smth.comparator)) {\n        value = `${this.escape(value[0])} AND ${this.escape(value[1])}`;\n      } else if (typeof value === \"boolean\") {\n        value = this.booleanValue(value);\n      } else {\n        value = this.escape(value);\n      }\n      if (value === \"NULL\") {\n        if (smth.comparator === \"=\") {\n          smth.comparator = \"IS\";\n        }\n        if (smth.comparator === \"!=\") {\n          smth.comparator = \"IS NOT\";\n        }\n      }\n      return [key, value].join(` ${smth.comparator} `);\n    }\n    if (smth instanceof Utils.Literal) {\n      return smth.val;\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        result = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n      } else if (_.isPlainObject(smth.val)) {\n        result = this.whereItemsQuery(smth.val);\n      } else {\n        result = this.escape(smth.val);\n      }\n      return `CAST(${result} AS ${smth.type.toUpperCase()})`;\n    }\n    if (smth instanceof Utils.Fn) {\n      return `${smth.fn}(${smth.args.map((arg) => {\n        if (arg instanceof Utils.SequelizeMethod) {\n          return this.handleSequelizeMethod(arg, tableName, factory, options, prepend);\n        }\n        if (_.isPlainObject(arg)) {\n          return this.whereItemsQuery(arg);\n        }\n        return this.escape(typeof arg === \"string\" ? arg.replace(/\\$/g, \"$$$\") : arg);\n      }).join(\", \")})`;\n    }\n    if (smth instanceof Utils.Col) {\n      if (Array.isArray(smth.col) && !factory) {\n        throw new Error(\"Cannot call Sequelize.col() with array outside of order / group clause\");\n      }\n      if (smth.col.startsWith(\"*\")) {\n        return \"*\";\n      }\n      return this.quote(smth.col, factory);\n    }\n    return smth.toString(this, factory);\n  }\n  whereQuery(where, options) {\n    const query = this.whereItemsQuery(where, options);\n    if (query && query.length) {\n      return `WHERE ${query}`;\n    }\n    return \"\";\n  }\n  whereItemsQuery(where, options, binding) {\n    if (where === null || where === void 0 || Utils.getComplexSize(where) === 0) {\n      return \"\";\n    }\n    if (typeof where === \"string\") {\n      throw new Error(\"Support for `{where: 'raw query'}` has been removed.\");\n    }\n    const items = [];\n    binding = binding || \"AND\";\n    if (binding[0] !== \" \")\n      binding = ` ${binding} `;\n    if (_.isPlainObject(where)) {\n      Utils.getComplexKeys(where).forEach((prop) => {\n        const item = where[prop];\n        items.push(this.whereItemQuery(prop, item, options));\n      });\n    } else {\n      items.push(this.whereItemQuery(void 0, where, options));\n    }\n    return items.length && items.filter((item) => item && item.length).join(binding) || \"\";\n  }\n  whereItemQuery(key, value, options = {}) {\n    if (value === void 0) {\n      throw new Error(`WHERE parameter \"${key}\" has invalid \"undefined\" value`);\n    }\n    if (typeof key === \"string\" && key.includes(\".\") && options.model) {\n      const keyParts = key.split(\".\");\n      if (options.model.rawAttributes[keyParts[0]] && options.model.rawAttributes[keyParts[0]].type instanceof DataTypes.JSON) {\n        const tmp = {};\n        const field2 = options.model.rawAttributes[keyParts[0]];\n        _.set(tmp, keyParts.slice(1), value);\n        return this.whereItemQuery(field2.field || keyParts[0], tmp, __spreadValues({ field: field2 }, options));\n      }\n    }\n    const field = this._findField(key, options);\n    const fieldType = field && field.type || options.type;\n    const isPlainObject = _.isPlainObject(value);\n    const isArray = !isPlainObject && Array.isArray(value);\n    key = this.OperatorsAliasMap && this.OperatorsAliasMap[key] || key;\n    if (isPlainObject) {\n      value = this._replaceAliases(value);\n    }\n    const valueKeys = isPlainObject && Utils.getComplexKeys(value);\n    if (key === void 0) {\n      if (typeof value === \"string\") {\n        return value;\n      }\n      if (isPlainObject && valueKeys.length === 1) {\n        return this.whereItemQuery(valueKeys[0], value[valueKeys[0]], options);\n      }\n    }\n    if (value === null) {\n      const opValue2 = options.bindParam ? \"NULL\" : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.is], options.prefix);\n    }\n    if (!value) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    if (value instanceof Utils.SequelizeMethod && !(key !== void 0 && value instanceof Utils.Fn)) {\n      return this.handleSequelizeMethod(value);\n    }\n    if (key === void 0 && isArray) {\n      if (Utils.canTreatArrayAsAnd(value)) {\n        key = Op.and;\n      } else {\n        throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n      }\n    }\n    if (key === Op.or || key === Op.and || key === Op.not) {\n      return this._whereGroupBind(key, value, options);\n    }\n    if (value[Op.or]) {\n      return this._whereBind(this.OperatorMap[Op.or], key, value[Op.or], options);\n    }\n    if (value[Op.and]) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value[Op.and], options);\n    }\n    if (isArray && fieldType instanceof DataTypes.ARRAY) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(key, opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    if (isPlainObject && fieldType instanceof DataTypes.JSON && options.json !== false) {\n      return this._whereJSON(key, value, options);\n    }\n    if (isPlainObject && valueKeys.length > 1) {\n      return this._whereBind(this.OperatorMap[Op.and], key, value, options);\n    }\n    if (isArray) {\n      return this._whereParseSingleValueObject(key, field, Op.in, value, options);\n    }\n    if (isPlainObject) {\n      if (this.OperatorMap[valueKeys[0]]) {\n        return this._whereParseSingleValueObject(key, field, valueKeys[0], value[valueKeys[0]], options);\n      }\n      return this._whereParseSingleValueObject(key, field, this.OperatorMap[Op.eq], value, options);\n    }\n    if (key === Op.placeholder) {\n      const opValue2 = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n      return this._joinKeyValue(this.OperatorMap[key], opValue2, this.OperatorMap[Op.eq], options.prefix);\n    }\n    const opValue = options.bindParam ? this.format(value, field, options, options.bindParam) : this.escape(value, field);\n    return this._joinKeyValue(key, opValue, this.OperatorMap[Op.eq], options.prefix);\n  }\n  _findField(key, options) {\n    if (options.field) {\n      return options.field;\n    }\n    if (options.model && options.model.rawAttributes && options.model.rawAttributes[key]) {\n      return options.model.rawAttributes[key];\n    }\n    if (options.model && options.model.fieldRawAttributesMap && options.model.fieldRawAttributesMap[key]) {\n      return options.model.fieldRawAttributesMap[key];\n    }\n  }\n  _whereGroupBind(key, value, options) {\n    const binding = key === Op.or ? this.OperatorMap[Op.or] : this.OperatorMap[Op.and];\n    const outerBinding = key === Op.not ? \"NOT \" : \"\";\n    if (Array.isArray(value)) {\n      value = value.map((item) => {\n        let itemQuery = this.whereItemsQuery(item, options, this.OperatorMap[Op.and]);\n        if (itemQuery && itemQuery.length && (Array.isArray(item) || _.isPlainObject(item)) && Utils.getComplexSize(item) > 1) {\n          itemQuery = `(${itemQuery})`;\n        }\n        return itemQuery;\n      }).filter((item) => item && item.length);\n      value = value.length && value.join(binding);\n    } else {\n      value = this.whereItemsQuery(value, options, binding);\n    }\n    if ((key === Op.or || key === Op.not) && !value) {\n      return \"0 = 1\";\n    }\n    return value ? `${outerBinding}(${value})` : void 0;\n  }\n  _whereBind(binding, key, value, options) {\n    if (_.isPlainObject(value)) {\n      value = Utils.getComplexKeys(value).map((prop) => {\n        const item = value[prop];\n        return this.whereItemQuery(key, { [prop]: item }, options);\n      });\n    } else {\n      value = value.map((item) => this.whereItemQuery(key, item, options));\n    }\n    value = value.filter((item) => item && item.length);\n    return value.length ? `(${value.join(binding)})` : void 0;\n  }\n  _whereJSON(key, value, options) {\n    const items = [];\n    let baseKey = this.quoteIdentifier(key);\n    if (options.prefix) {\n      if (options.prefix instanceof Utils.Literal) {\n        baseKey = `${this.handleSequelizeMethod(options.prefix)}.${baseKey}`;\n      } else {\n        baseKey = `${this.quoteTable(options.prefix)}.${baseKey}`;\n      }\n    }\n    Utils.getOperators(value).forEach((op) => {\n      const where = {\n        [op]: value[op]\n      };\n      items.push(this.whereItemQuery(key, where, __spreadProps(__spreadValues({}, options), { json: false })));\n    });\n    _.forOwn(value, (item, prop) => {\n      this._traverseJSON(items, baseKey, prop, item, [prop]);\n    });\n    const result = items.join(this.OperatorMap[Op.and]);\n    return items.length > 1 ? `(${result})` : result;\n  }\n  _traverseJSON(items, baseKey, prop, item, path) {\n    let cast;\n    if (path[path.length - 1].includes(\"::\")) {\n      const tmp = path[path.length - 1].split(\"::\");\n      cast = tmp[1];\n      path[path.length - 1] = tmp[0];\n    }\n    let pathKey = this.jsonPathExtractionQuery(baseKey, path);\n    if (_.isPlainObject(item)) {\n      Utils.getOperators(item).forEach((op) => {\n        const value = this._toJSONValue(item[op]);\n        let isJson = false;\n        if (typeof value === \"string\" && op === Op.contains) {\n          try {\n            JSON.stringify(value);\n            isJson = true;\n          } catch (e) {\n          }\n        }\n        pathKey = this.jsonPathExtractionQuery(baseKey, path, isJson);\n        items.push(this.whereItemQuery(this._castKey(pathKey, value, cast), { [op]: value }));\n      });\n      _.forOwn(item, (value, itemProp) => {\n        this._traverseJSON(items, baseKey, itemProp, value, path.concat([itemProp]));\n      });\n      return;\n    }\n    item = this._toJSONValue(item);\n    items.push(this.whereItemQuery(this._castKey(pathKey, item, cast), { [Op.eq]: item }));\n  }\n  _toJSONValue(value) {\n    return value;\n  }\n  _castKey(key, value, cast, json) {\n    cast = cast || this._getJsonCast(Array.isArray(value) ? value[0] : value);\n    if (cast) {\n      return new Utils.Literal(this.handleSequelizeMethod(new Utils.Cast(new Utils.Literal(key), cast, json)));\n    }\n    return new Utils.Literal(key);\n  }\n  _getJsonCast(value) {\n    if (typeof value === \"number\") {\n      return \"double precision\";\n    }\n    if (value instanceof Date) {\n      return \"timestamptz\";\n    }\n    if (typeof value === \"boolean\") {\n      return \"boolean\";\n    }\n    return;\n  }\n  _joinKeyValue(key, value, comparator, prefix) {\n    if (!key) {\n      return value;\n    }\n    if (comparator === void 0) {\n      throw new Error(`${key} and ${value} has no comparator`);\n    }\n    key = this._getSafeKey(key, prefix);\n    return [key, value].join(` ${comparator} `);\n  }\n  _getSafeKey(key, prefix) {\n    if (key instanceof Utils.SequelizeMethod) {\n      key = this.handleSequelizeMethod(key);\n      return this._prefixKey(this.handleSequelizeMethod(key), prefix);\n    }\n    if (Utils.isColString(key)) {\n      key = key.substr(1, key.length - 2).split(\".\");\n      if (key.length > 2) {\n        key = [\n          key.slice(0, -1).join(\"->\"),\n          key[key.length - 1]\n        ];\n      }\n      return key.map((identifier) => this.quoteIdentifier(identifier)).join(\".\");\n    }\n    return this._prefixKey(this.quoteIdentifier(key), prefix);\n  }\n  _prefixKey(key, prefix) {\n    if (prefix) {\n      if (prefix instanceof Utils.Literal) {\n        return [this.handleSequelizeMethod(prefix), key].join(\".\");\n      }\n      return [this.quoteTable(prefix), key].join(\".\");\n    }\n    return key;\n  }\n  _whereParseSingleValueObject(key, field, prop, value, options) {\n    if (prop === Op.not) {\n      if (Array.isArray(value)) {\n        prop = Op.notIn;\n      } else if (value !== null && value !== true && value !== false) {\n        prop = Op.ne;\n      }\n    }\n    let comparator = this.OperatorMap[prop] || this.OperatorMap[Op.eq];\n    switch (prop) {\n      case Op.in:\n      case Op.notIn:\n        if (value instanceof Utils.Literal) {\n          return this._joinKeyValue(key, value.val, comparator, options.prefix);\n        }\n        if (value.length) {\n          return this._joinKeyValue(key, `(${value.map((item) => this.escape(item, field)).join(\", \")})`, comparator, options.prefix);\n        }\n        if (comparator === this.OperatorMap[Op.in]) {\n          return this._joinKeyValue(key, \"(NULL)\", comparator, options.prefix);\n        }\n        return \"\";\n      case Op.any:\n      case Op.all:\n        comparator = `${this.OperatorMap[Op.eq]} ${comparator}`;\n        if (value[Op.values]) {\n          return this._joinKeyValue(key, `(VALUES ${value[Op.values].map((item) => `(${this.escape(item)})`).join(\", \")})`, comparator, options.prefix);\n        }\n        return this._joinKeyValue(key, `(${this.escape(value, field)})`, comparator, options.prefix);\n      case Op.between:\n      case Op.notBetween:\n        return this._joinKeyValue(key, `${this.escape(value[0], field)} AND ${this.escape(value[1], field)}`, comparator, options.prefix);\n      case Op.raw:\n        throw new Error(\"The `$raw` where property is no longer supported.  Use `sequelize.literal` instead.\");\n      case Op.col:\n        comparator = this.OperatorMap[Op.eq];\n        value = value.split(\".\");\n        if (value.length > 2) {\n          value = [\n            value.slice(0, -1).join(\"->\"),\n            value[value.length - 1]\n          ];\n        }\n        return this._joinKeyValue(key, value.map((identifier) => this.quoteIdentifier(identifier)).join(\".\"), comparator, options.prefix);\n      case Op.startsWith:\n      case Op.endsWith:\n      case Op.substring:\n        comparator = this.OperatorMap[Op.like];\n        if (value instanceof Utils.Literal) {\n          value = value.val;\n        }\n        let pattern = `${value}%`;\n        if (prop === Op.endsWith)\n          pattern = `%${value}`;\n        if (prop === Op.substring)\n          pattern = `%${value}%`;\n        return this._joinKeyValue(key, this.escape(pattern), comparator, options.prefix);\n    }\n    const escapeOptions = {\n      acceptStrings: comparator.includes(this.OperatorMap[Op.like])\n    };\n    if (_.isPlainObject(value)) {\n      if (value[Op.col]) {\n        return this._joinKeyValue(key, this.whereItemQuery(null, value), comparator, options.prefix);\n      }\n      if (value[Op.any]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.any], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.any]}`, options.prefix);\n      }\n      if (value[Op.all]) {\n        escapeOptions.isList = true;\n        return this._joinKeyValue(key, `(${this.escape(value[Op.all], field, escapeOptions)})`, `${comparator} ${this.OperatorMap[Op.all]}`, options.prefix);\n      }\n    }\n    if (value === null && comparator === this.OperatorMap[Op.eq]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.is], options.prefix);\n    }\n    if (value === null && comparator === this.OperatorMap[Op.ne]) {\n      return this._joinKeyValue(key, this.escape(value, field, escapeOptions), this.OperatorMap[Op.not], options.prefix);\n    }\n    return this._joinKeyValue(key, this.escape(value, field, escapeOptions), comparator, options.prefix);\n  }\n  getWhereConditions(smth, tableName, factory, options, prepend) {\n    const where = {};\n    if (Array.isArray(tableName)) {\n      tableName = tableName[0];\n      if (Array.isArray(tableName)) {\n        tableName = tableName[1];\n      }\n    }\n    options = options || {};\n    if (prepend === void 0) {\n      prepend = true;\n    }\n    if (smth && smth instanceof Utils.SequelizeMethod) {\n      return this.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (_.isPlainObject(smth)) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName,\n        type: options.type\n      });\n    }\n    if (typeof smth === \"number\" || typeof smth === \"bigint\") {\n      let primaryKeys = factory ? Object.keys(factory.primaryKeys) : [];\n      if (primaryKeys.length > 0) {\n        primaryKeys = primaryKeys[0];\n      } else {\n        primaryKeys = \"id\";\n      }\n      where[primaryKeys] = smth;\n      return this.whereItemsQuery(where, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (typeof smth === \"string\") {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    if (Buffer.isBuffer(smth)) {\n      return this.escape(smth);\n    }\n    if (Array.isArray(smth)) {\n      if (smth.length === 0 || smth.length > 0 && smth[0].length === 0)\n        return \"1=1\";\n      if (Utils.canTreatArrayAsAnd(smth)) {\n        const _smth = { [Op.and]: smth };\n        return this.getWhereConditions(_smth, tableName, factory, options, prepend);\n      }\n      throw new Error(\"Support for literal replacements in the `where` object has been removed.\");\n    }\n    if (smth == null) {\n      return this.whereItemsQuery(smth, {\n        model: factory,\n        prefix: prepend && tableName\n      });\n    }\n    throw new Error(`Unsupported where option value: ${util.inspect(smth)}. Please refer to the Sequelize documentation to learn more about which values are accepted as part of the where option.`);\n  }\n  parseConditionObject(conditions, path) {\n    path = path || [];\n    return _.reduce(conditions, (result, value, key) => {\n      if (_.isObject(value)) {\n        return result.concat(this.parseConditionObject(value, path.concat(key)));\n      }\n      result.push({ path: path.concat(key), value });\n      return result;\n    }, []);\n  }\n  booleanValue(value) {\n    return value;\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result\";\n  }\n}\nObject.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/operators */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js\"));\nObject.assign(QueryGenerator.prototype, __webpack_require__(/*! ./query-generator/transaction */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js\"));\nmodule.exports = QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixlQUFlLHdGQUFrQjtBQUNqQyxjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsMEZBQTBCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLDBFQUFrQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHdGQUF5QjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBK0I7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsOEdBQW9DO0FBQ2xFLGdCQUFnQixtQkFBTyxDQUFDLGdHQUE2QjtBQUNyRCxXQUFXLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3BDLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFjO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCLFlBQVksd0JBQXdCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csbUJBQW1CO0FBQ3ZILFlBQVk7QUFDWixvR0FBb0csbUJBQW1CO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsMkJBQTJCLFlBQVksMkJBQTJCO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckUsUUFBUTtBQUNSLHFFQUFxRSwyQkFBMkIsVUFBVSwyQkFBMkI7QUFDckk7QUFDQSxnRUFBZ0UsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtEQUFrRCxFQUFFLG9CQUFvQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLFFBQVEsK0JBQStCLE9BQU8sYUFBYSxHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixVQUFVLG9CQUFvQixHQUFHLHFCQUFxQixFQUFFLGlDQUFpQyxFQUFFLFdBQVc7QUFDalAsb0JBQW9CLFNBQVMsUUFBUSwrQkFBK0IsT0FBTyxZQUFZLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUsaUNBQWlDLEVBQUUsV0FBVztBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQjtBQUM1RCx3REFBd0Qsd0RBQXdELDhEQUE4RDtBQUM5SywrSEFBK0g7QUFDL0gsK0VBQStFLFlBQVksMkRBQTJELFdBQVcsUUFBUSxZQUFZLDJCQUEyQixZQUFZLG1CQUFtQixNQUFNLFdBQVcsa0JBQWtCLEVBQUUsYUFBYSxFQUFFLGFBQWE7QUFDaFQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQXlELEVBQUUsNEJBQTRCO0FBQ3RHO0FBQ0EsMkNBQTJDLHlEQUF5RCxFQUFFO0FBQ3RHO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYSxJQUFJLEVBQUUsT0FBTyxzQkFBc0IsYUFBYSxJQUFJO0FBQ3RHO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLG1CQUFtQjtBQUNqRyxPQUFPO0FBQ1Asc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwyQkFBMkIsWUFBWSwyQkFBMkI7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLG1CQUFtQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGO0FBQ0EscUVBQXFFLDJCQUEyQixVQUFVLDJCQUEyQjtBQUNySSxrQ0FBa0Msa0RBQWtELEVBQUUsb0JBQW9CO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLEVBQUU7QUFDckosUUFBUTtBQUNSLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLGFBQWE7QUFDaEs7QUFDQTtBQUNBLHdEQUF3RCxjQUFjLFdBQVc7QUFDakY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsU0FBUyw0QkFBNEIsTUFBTSxpQkFBaUIsRUFBRSxnQkFBZ0IsRUFBRSxxQ0FBcUMsRUFBRSxPQUFPO0FBQzVKLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWSxHQUFHLFlBQVksRUFBRSxVQUFVLEVBQUUsY0FBYztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVksR0FBRyxhQUFhO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxUEFBcVAsY0FBYyxzREFBc0QsVUFBVSxpRkFBaUYsY0FBYyxZQUFZLHFCQUFxQiwyRUFBMkUsZUFBZTtBQUM3aEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxNQUFNO0FBQ3hFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZ0JBQWdCLFVBQVUsc0JBQXNCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLEdBQUcsZ0JBQWdCO0FBQzlGLDBDQUEwQyxnQkFBZ0IsU0FBUyxjQUFjO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQjtBQUM5RiwwQ0FBMEMsZ0JBQWdCLFdBQVcsa0NBQWtDLFFBQVEsYUFBYTtBQUM1SDtBQUNBO0FBQ0EsaUVBQWlFLFVBQVUsR0FBRyxnQkFBZ0I7QUFDOUYsMENBQTBDLGdCQUFnQixlQUFlLHNCQUFzQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsVUFBVSxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQjtBQUNsSDtBQUNBLHFDQUFxQyxtQ0FBbUMsR0FBRyxpQkFBaUI7QUFDNUYsMENBQTBDLGdCQUFnQjtBQUMxRCw2Q0FBNkMsc0JBQXNCLGVBQWUsa0JBQWtCO0FBQ3BHO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSw0REFBNEQsbUJBQW1CLEdBQUcsZ0RBQWdEO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRSxRQUFRO0FBQ1Isa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QyxHQUFHLDJDQUEyQztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQSxrRUFBa0UseUJBQXlCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLEVBQUUsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRGQUE0RjtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxR0FBcUc7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1SUFBdUksZ0JBQWdCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLCtHQUErRyxNQUFNO0FBQ3JIO0FBQ0EsaUNBQWlDLGFBQWEsR0FBRyxRQUFRO0FBQ3pEO0FBQ0EsNENBQTRDLGFBQWEsR0FBRyxRQUFRO0FBQ3BFO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxpQkFBaUI7QUFDbkQsbUJBQW1CLGFBQWEsRUFBRSxLQUFLLEVBQUUsUUFBUTtBQUNqRDtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG9EQUFvRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQW1CLFFBQVEsSUFBSSxzQkFBc0I7QUFDOUQsd0VBQXdFLE9BQU87QUFDL0U7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3RUFBd0U7QUFDakYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRCxVQUFVO0FBQ1Ysd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsUUFBUTtBQUNSLHlDQUF5QyxjQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELFVBQVU7QUFDVix5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQSx3Q0FBd0MsZ0NBQWdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrREFBa0Q7QUFDeEcsd0JBQXdCLDRCQUE0QixRQUFRLHVCQUF1QixJQUFJLHNCQUFzQixFQUFFLGFBQWEsRUFBRSx5QkFBeUIsRUFBRSx3QkFBd0I7QUFDakwsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QixRQUFRO0FBQ1IscUJBQXFCLGdDQUFnQztBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxHQUFHLEtBQUs7QUFDdEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQixJQUFJLFdBQVc7QUFDMUUsZ0NBQWdDLDJCQUEyQixHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVCQUF1QiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDaEcsVUFBVTtBQUNWLG1FQUFtRSwyQ0FBMkM7QUFDOUcsVUFBVTtBQUNWLCtEQUErRCwyQ0FBMkM7QUFDMUcsVUFBVTtBQUNWLHNCQUFzQiwyQ0FBMkMsR0FBRywyQkFBMkI7QUFDL0Y7QUFDQSx1QkFBdUIscUJBQXFCLEdBQUcsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixJQUFJLGVBQWUsRUFBRSwyQkFBMkIsT0FBTyxvQkFBb0I7QUFDakksUUFBUTtBQUNSLHNDQUFzQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsS0FBSyxvQkFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVDQUF1QyxnQkFBZ0IsSUFBSSxlQUFlLEVBQUUsNEJBQTRCLE9BQU8sb0JBQW9CO0FBQ25JLFFBQVE7QUFDUix1Q0FBdUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEtBQUssb0JBQW9CO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVUsRUFBRSxNQUFNO0FBQ3BELHVDQUF1QyxVQUFVLEVBQUUsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0QkFBNEI7QUFDMUQ7QUFDQSw4QkFBOEIsVUFBVSxFQUFFLE1BQU07QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVSxFQUFFLE1BQU07QUFDdEQseUNBQXlDLFVBQVUsRUFBRSxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxJQUFJLE9BQU87QUFDMUMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPLElBQUksUUFBUTtBQUN0QyxvQkFBb0Isd0JBQXdCLEdBQUcsZ0NBQWdDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGLFVBQVUsR0FBRywrQkFBK0I7QUFDckk7QUFDQSxrQ0FBa0MsVUFBVSxHQUFHLGdDQUFnQztBQUMvRSwrREFBK0QsY0FBYyxLQUFLLCtCQUErQjtBQUNqSDtBQUNBLFFBQVE7QUFDUiw4QkFBOEIsMkJBQTJCLEdBQUcsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOEJBQThCLEdBQUcsaUNBQWlDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLFVBQVU7QUFDViw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCO0FBQy9ELE1BQU07QUFDTix3Q0FBd0Msd0JBQXdCO0FBQ2hFLE1BQU07QUFDTixrQ0FBa0Msd0NBQXdDLE1BQU0sYUFBYTtBQUM3RjtBQUNBLDZEQUE2RCxPQUFPLEVBQUUsdUJBQXVCO0FBQzdGLDBDQUEwQyxxQkFBcUIsR0FBRztBQUNsRTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQixJQUFJLFdBQVc7QUFDN0QsaUNBQWlDLHFCQUFxQixHQUFHLFdBQVc7QUFDcEU7QUFDQSxxQkFBcUIsa0JBQWtCLEdBQUcscUNBQXFDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0MsR0FBRywyREFBMkQ7QUFDekc7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFlBQVksR0FBRyxXQUFXLCtCQUErQixZQUFZLEdBQUcsV0FBVztBQUNuSix3QkFBd0Isa0NBQWtDO0FBQzFELE1BQU07QUFDTjtBQUNBLHdCQUF3Qiw2QkFBNkIsR0FBRyxxQ0FBcUM7QUFDN0Y7QUFDQSx1QkFBdUIsZ0NBQWdDLEdBQUcsa0NBQWtDO0FBQzVGLHNCQUFzQixrQ0FBa0MsR0FBRyxrQ0FBa0M7QUFDN0YsdUJBQXVCLGdDQUFnQyxHQUFHLGtDQUFrQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQ0FBMEMsYUFBYSxxRUFBcUUsS0FBSyxhQUFhO0FBQ2xLO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVkseUNBQXlDO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0MsR0FBRyxzREFBc0Q7QUFDaEgsaUJBQWlCLG9EQUFvRCxHQUFHLHFEQUFxRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9DQUFvQyxHQUFHLGtDQUFrQztBQUNwRixXQUFXLHNEQUFzRCxHQUFHLGtDQUFrQztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjLDZCQUE2QjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQsMERBQTBELG9CQUFvQjtBQUM5RSxnREFBZ0QsVUFBVSxFQUFFLFFBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlEQUFpRDtBQUNoRyw2QkFBNkIsdUJBQXVCLE9BQU8sT0FBTztBQUNsRTtBQUNBLHNCQUFzQixzQkFBc0IsRUFBRSxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QixTQUFTLDJFQUEyRTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUJBQWlCLDJDQUEyQyxHQUFHLHVFQUF1RTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QixNQUFNLHNCQUFzQjtBQUN0RSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUSxLQUFLLHdCQUF3QjtBQUMxRDtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsR0FBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGVBQWU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYSxHQUFHLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hELE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQTJDLEdBQUcsUUFBUTtBQUMzRSxRQUFRO0FBQ1IscUJBQXFCLGdDQUFnQyxHQUFHLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLGNBQWMsYUFBYTtBQUMzRyxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGFBQWE7QUFDM0YsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGVBQWU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSyxNQUFNLE9BQU87QUFDM0M7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseURBQXlEO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QixFQUFFLFdBQVc7QUFDOUQ7QUFDQSxvREFBb0QsbUNBQW1DLGtCQUFrQixlQUFlO0FBQ3hIO0FBQ0EsMkNBQTJDLDBCQUEwQjtBQUNyRTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4QixNQUFNLDZCQUE2QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxPQUFPLFlBQVksRUFBRSx5QkFBeUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFpRCxPQUFPLFlBQVksRUFBRSx5QkFBeUI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdURBQXVELG1CQUFtQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLHNIQUE2QjtBQUM3RSx3Q0FBd0MsbUJBQU8sQ0FBQywwSEFBK0I7QUFDL0U7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yLmpzPzBlODYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgdXVpZHY0ID0gcmVxdWlyZShcInV1aWRcIikudjQ7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbnNcIik7XG5jb25zdCBTcWxTdHJpbmcgPSByZXF1aXJlKFwiLi4vLi4vc3FsLXN0cmluZ1wiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgTW9kZWwgPSByZXF1aXJlKFwiLi4vLi4vbW9kZWxcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi9hc3NvY2lhdGlvbnMvYmFzZVwiKTtcbmNvbnN0IEJlbG9uZ3NUbyA9IHJlcXVpcmUoXCIuLi8uLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10b1wiKTtcbmNvbnN0IEJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKFwiLi4vLi4vYXNzb2NpYXRpb25zL2JlbG9uZ3MtdG8tbWFueVwiKTtcbmNvbnN0IEhhc01hbnkgPSByZXF1aXJlKFwiLi4vLi4vYXNzb2NpYXRpb25zL2hhcy1tYW55XCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3IgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgSW5kZXhIaW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbmRleC1oaW50c1wiKTtcbmNsYXNzIFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5zZXF1ZWxpemUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeUdlbmVyYXRvciBpbml0aWFsaXplZCB3aXRob3V0IG9wdGlvbnMuc2VxdWVsaXplXCIpO1xuICAgIGlmICghb3B0aW9ucy5fZGlhbGVjdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXJ5R2VuZXJhdG9yIGluaXRpYWxpemVkIHdpdGhvdXQgb3B0aW9ucy5fZGlhbGVjdFwiKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IG9wdGlvbnMuc2VxdWVsaXplO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2VxdWVsaXplLm9wdGlvbnM7XG4gICAgdGhpcy5kaWFsZWN0ID0gb3B0aW9ucy5fZGlhbGVjdC5uYW1lO1xuICAgIHRoaXMuX2RpYWxlY3QgPSBvcHRpb25zLl9kaWFsZWN0O1xuICAgIHRoaXMuX2luaXRRdW90ZUlkZW50aWZpZXIoKTtcbiAgfVxuICBleHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hIHx8IHRoaXMub3B0aW9ucy5zY2hlbWEgfHwgXCJwdWJsaWNcIixcbiAgICAgIHRhYmxlTmFtZTogXy5pc1BsYWluT2JqZWN0KHRhYmxlTmFtZSkgPyB0YWJsZU5hbWUudGFibGVOYW1lIDogdGFibGVOYW1lLFxuICAgICAgZGVsaW1pdGVyOiB0YWJsZU5hbWUuZGVsaW1pdGVyIHx8IG9wdGlvbnMuZGVsaW1pdGVyIHx8IFwiLlwiXG4gICAgfTtcbiAgfVxuICBhZGRTY2hlbWEocGFyYW0pIHtcbiAgICBpZiAoIXBhcmFtLl9zY2hlbWEpXG4gICAgICByZXR1cm4gcGFyYW0udGFibGVOYW1lIHx8IHBhcmFtO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICB0YWJsZU5hbWU6IHBhcmFtLnRhYmxlTmFtZSB8fCBwYXJhbSxcbiAgICAgIHRhYmxlOiBwYXJhbS50YWJsZU5hbWUgfHwgcGFyYW0sXG4gICAgICBuYW1lOiBwYXJhbS5uYW1lIHx8IHBhcmFtLFxuICAgICAgc2NoZW1hOiBwYXJhbS5fc2NoZW1hLFxuICAgICAgZGVsaW1pdGVyOiBwYXJhbS5fc2NoZW1hRGVsaW1pdGVyIHx8IFwiLlwiLFxuICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnF1b3RlVGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkcm9wU2NoZW1hKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXJcbiAgICB9KSk7XG4gICAgcmV0dXJuIGBERVNDUklCRSAke3RhYmxlfTtgO1xuICB9XG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX07YDtcbiAgfVxuICByZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKGJlZm9yZSl9IFJFTkFNRSBUTyAke3RoaXMucXVvdGVUYWJsZShhZnRlcil9O2A7XG4gIH1cbiAgcG9wdWxhdGVJbnNlcnRRdWVyeVJldHVybkludG9CaW5kcygpIHtcbiAgfVxuICBpbnNlcnRRdWVyeSh0YWJsZSwgdmFsdWVIYXNoLCBtb2RlbEF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHRoaXMub3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZWxBdHRyaWJ1dGVNYXAgPSB7fTtcbiAgICBjb25zdCBiaW5kID0gb3B0aW9ucy5iaW5kIHx8IFtdO1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGNvbnN0IHJldHVybmluZ01vZGVsQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IHJldHVyblR5cGVzID0gW107XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGUpO1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtID09PSB2b2lkIDAgPyB0aGlzLmJpbmRQYXJhbShiaW5kKSA6IG9wdGlvbnMuYmluZFBhcmFtO1xuICAgIGNvbnN0IHJldHVybkF0dHJpYnV0ZXMgPSBbXTtcbiAgICBsZXQgcXVlcnk7XG4gICAgbGV0IHZhbHVlUXVlcnkgPSBcIlwiO1xuICAgIGxldCBlbXB0eVF1ZXJ5ID0gXCJcIjtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IGlkZW50aXR5V3JhcHBlclJlcXVpcmVkID0gZmFsc2U7XG4gICAgbGV0IHRtcFRhYmxlID0gXCJcIjtcbiAgICBpZiAobW9kZWxBdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2gobW9kZWxBdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0c1tcIkRFRkFVTFQgVkFMVUVTXCJdKSB7XG4gICAgICBlbXB0eVF1ZXJ5ICs9IFwiIERFRkFVTFQgVkFMVUVTXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiVkFMVUVTICgpXCJdKSB7XG4gICAgICBlbXB0eVF1ZXJ5ICs9IFwiIFZBTFVFUyAoKVwiO1xuICAgIH1cbiAgICBpZiAoKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzIHx8IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuSW50b1ZhbHVlcykgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybmluZ01vZGVsQXR0cmlidXRlcy5wdXNoKC4uLnJldHVyblZhbHVlcy5yZXR1cm5GaWVsZHMpO1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuSW50b1ZhbHVlcykge1xuICAgICAgICByZXR1cm5UeXBlcy5wdXNoKC4uLnJldHVyblZhbHVlcy5yZXR1cm5UeXBlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICAgIHRtcFRhYmxlID0gcmV0dXJuVmFsdWVzLnRtcFRhYmxlIHx8IFwiXCI7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudCB8fCBcIlwiO1xuICAgIH1cbiAgICBpZiAoXy5nZXQodGhpcywgW1wic2VxdWVsaXplXCIsIFwib3B0aW9uc1wiLCBcImRpYWxlY3RPcHRpb25zXCIsIFwicHJlcGVuZFNlYXJjaFBhdGhcIl0pIHx8IG9wdGlvbnMuc2VhcmNoUGF0aCkge1xuICAgICAgb3B0aW9ucy5iaW5kUGFyYW0gPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuRVhDRVBUSU9OICYmIG9wdGlvbnMuZXhjZXB0aW9uKSB7XG4gICAgICBvcHRpb25zLmJpbmRQYXJhbSA9IGZhbHNlO1xuICAgIH1cbiAgICB2YWx1ZUhhc2ggPSBVdGlscy5yZW1vdmVOdWxsVmFsdWVzRnJvbUhhc2godmFsdWVIYXNoLCB0aGlzLm9wdGlvbnMub21pdE51bGwpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlSGFzaCkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZUhhc2gsIGtleSkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZUhhc2hba2V5XTtcbiAgICAgICAgZmllbGRzLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSk7XG4gICAgICAgIGlmIChtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmF1dG9JbmNyZW1lbnQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBmaWVsZHMuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuREVGQVVMVCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goXCJERUZBVUxUXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmVzY2FwZShudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWRlbnRpdHlXcmFwcGVyUmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJJTlNFUlRcIiB9KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIklOU0VSVFwiIH0sIGJpbmRQYXJhbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBcIlwiO1xuICAgIGlmICghXy5pc0VtcHR5KG9wdGlvbnMuY29uZmxpY3RXaGVyZSkgJiYgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0V2hlcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgZGlhbGVjdCBzdXBwb3J0IGZvciBjb25mbGljdFdoZXJlIG9wdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSAmJiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlID09IFwiIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVRcIikge1xuICAgICAgICBjb25zdCBjb25mbGljdEtleXMgPSBvcHRpb25zLnVwc2VydEtleXMubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcCgoYXR0cikgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PUVYQ0xVREVELiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCk7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50cyA9IFtcbiAgICAgICAgICBcIk9OIENPTkZMSUNUXCIsXG4gICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgY29uZmxpY3RLZXlzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgIFwiKVwiXG4gICAgICAgIF07XG4gICAgICAgIGlmICghXy5pc0VtcHR5KG9wdGlvbnMuY29uZmxpY3RXaGVyZSkpIHtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaCh0aGlzLndoZXJlUXVlcnkob3B0aW9ucy5jb25mbGljdFdoZXJlLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNFbXB0eSh1cGRhdGVLZXlzKSkge1xuICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiRE8gTk9USElOR1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudHMucHVzaChcIkRPIFVQREFURSBTRVRcIiwgdXBkYXRlS2V5cy5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBgICR7VXRpbHMuam9pblNRTEZyYWdtZW50cyhmcmFnbWVudHMpfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB2YWx1ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcCgoYXR0cikgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PVZBTFVFUygke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSlgKTtcbiAgICAgICAgaWYgKF8uaXNFbXB0eSh2YWx1ZUtleXMpICYmIG9wdGlvbnMudXBzZXJ0S2V5cykge1xuICAgICAgICAgIHZhbHVlS2V5cy5wdXNoKC4uLm9wdGlvbnMudXBzZXJ0S2V5cy5tYXAoKGF0dHIpID0+IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfT0ke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfWApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXy5pc0VtcHR5KHZhbHVlS2V5cykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB1cGRhdGUgdmFsdWVzIGZvdW5kIGZvciBPTiBEVVBMSUNBVEUgS0VZIFVQREFURSBjbGF1c2UsIGFuZCBubyBpZGVudGlmaWVyIGZpZWxkcyBjb3VsZCBiZSBmb3VuZCB0byB1c2UgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgKz0gYCR7dGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlfSAke3ZhbHVlS2V5cy5qb2luKFwiLFwiKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXBsYWNlbWVudHMgPSB7XG4gICAgICBpZ25vcmVEdXBsaWNhdGVzOiBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMuaWdub3JlRHVwbGljYXRlcyA6IFwiXCIsXG4gICAgICBvbkNvbmZsaWN0RG9Ob3RoaW5nOiBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdERvTm90aGluZyA6IFwiXCIsXG4gICAgICBhdHRyaWJ1dGVzOiBmaWVsZHMuam9pbihcIixcIiksXG4gICAgICBvdXRwdXQ6IG91dHB1dEZyYWdtZW50LFxuICAgICAgdmFsdWVzOiB2YWx1ZXMuam9pbihcIixcIiksXG4gICAgICB0bXBUYWJsZVxuICAgIH07XG4gICAgdmFsdWVRdWVyeSA9IGAke3RtcFRhYmxlfUlOU0VSVCR7cmVwbGFjZW1lbnRzLmlnbm9yZUR1cGxpY2F0ZXN9IElOVE8gJHtxdW90ZWRUYWJsZX0gKCR7cmVwbGFjZW1lbnRzLmF0dHJpYnV0ZXN9KSR7cmVwbGFjZW1lbnRzLm91dHB1dH0gVkFMVUVTICgke3JlcGxhY2VtZW50cy52YWx1ZXN9KSR7b25EdXBsaWNhdGVLZXlVcGRhdGV9JHtyZXBsYWNlbWVudHMub25Db25mbGljdERvTm90aGluZ30ke3ZhbHVlUXVlcnl9YDtcbiAgICBlbXB0eVF1ZXJ5ID0gYCR7dG1wVGFibGV9SU5TRVJUJHtyZXBsYWNlbWVudHMuaWdub3JlRHVwbGljYXRlc30gSU5UTyAke3F1b3RlZFRhYmxlfSR7cmVwbGFjZW1lbnRzLm91dHB1dH0ke29uRHVwbGljYXRlS2V5VXBkYXRlfSR7cmVwbGFjZW1lbnRzLm9uQ29uZmxpY3REb05vdGhpbmd9JHtlbXB0eVF1ZXJ5fWA7XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuRVhDRVBUSU9OICYmIG9wdGlvbnMuZXhjZXB0aW9uKSB7XG4gICAgICBjb25zdCBkcm9wRnVuY3Rpb24gPSBcIkRST1AgRlVOQ1RJT04gSUYgRVhJU1RTIHBnX3RlbXAudGVzdGZ1bmMoKVwiO1xuICAgICAgaWYgKHJldHVybmluZ01vZGVsQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLnB1c2goXCIqXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsaW1pdGVyID0gYCRmdW5jXyR7dXVpZHY0KCkucmVwbGFjZSgvLS9nLCBcIlwiKX0kYDtcbiAgICAgIGNvbnN0IHNlbGVjdFF1ZXJ5ID0gYFNFTEVDVCAodGVzdGZ1bmMucmVzcG9uc2UpLiR7cmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLmpvaW4oXCIsICh0ZXN0ZnVuYy5yZXNwb25zZSkuXCIpfSwgdGVzdGZ1bmMuc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gRlJPTSBwZ190ZW1wLnRlc3RmdW5jKCk7YDtcbiAgICAgIG9wdGlvbnMuZXhjZXB0aW9uID0gXCJXSEVOIHVuaXF1ZV92aW9sYXRpb24gVEhFTiBHRVQgU1RBQ0tFRCBESUFHTk9TVElDUyBzZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiA9IFBHX0VYQ0VQVElPTl9ERVRBSUw7XCI7XG4gICAgICB2YWx1ZVF1ZXJ5ID0gYENSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OIHBnX3RlbXAudGVzdGZ1bmMoT1VUIHJlc3BvbnNlICR7cXVvdGVkVGFibGV9LCBPVVQgc2VxdWVsaXplX2NhdWdodF9leGNlcHRpb24gdGV4dCkgUkVUVVJOUyBSRUNPUkQgQVMgJHtkZWxpbWl0ZXJ9IEJFR0lOICR7dmFsdWVRdWVyeX0gUkVUVVJOSU5HICogSU5UTyByZXNwb25zZTsgRVhDRVBUSU9OICR7b3B0aW9ucy5leGNlcHRpb259IEVORCAke2RlbGltaXRlcn0gTEFOR1VBR0UgcGxwZ3NxbDsgJHtzZWxlY3RRdWVyeX0gJHtkcm9wRnVuY3Rpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVRdWVyeSArPSByZXR1cm5pbmdGcmFnbWVudDtcbiAgICAgIGVtcHR5UXVlcnkgKz0gcmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVybkludG9WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIHRoaXMucG9wdWxhdGVJbnNlcnRRdWVyeVJldHVybkludG9CaW5kcyhyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMsIHJldHVyblR5cGVzLCBiaW5kLmxlbmd0aCwgcmV0dXJuQXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHF1ZXJ5ID0gYCR7cmVwbGFjZW1lbnRzLmF0dHJpYnV0ZXMubGVuZ3RoID8gdmFsdWVRdWVyeSA6IGVtcHR5UXVlcnl9JHtyZXR1cm5BdHRyaWJ1dGVzLmpvaW4oXCIsXCIpfTtgO1xuICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmZpbmFsVGFibGUpIHtcbiAgICAgIHF1ZXJ5ID0gYFNFTEVDVCAqIEZST00gRklOQUwgVEFCTEUoJHtyZXBsYWNlbWVudHMuYXR0cmlidXRlcy5sZW5ndGggPyB2YWx1ZVF1ZXJ5IDogZW1wdHlRdWVyeX0pO2A7XG4gICAgfVxuICAgIGlmIChpZGVudGl0eVdyYXBwZXJSZXF1aXJlZCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmF1dG9JbmNyZW1lbnQuaWRlbnRpdHlJbnNlcnQpIHtcbiAgICAgIHF1ZXJ5ID0gYFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT047ICR7cXVlcnl9IFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT0ZGO2A7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHsgcXVlcnkgfTtcbiAgICBpZiAob3B0aW9ucy5iaW5kUGFyYW0gIT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuYmluZCA9IGJpbmQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRWYWx1ZUhhc2hlcywgb3B0aW9ucywgZmllbGRNYXBwZWRBdHRyaWJ1dGVzKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgZmllbGRNYXBwZWRBdHRyaWJ1dGVzID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGNvbnN0IHR1cGxlcyA9IFtdO1xuICAgIGNvbnN0IHNlcmlhbHMgPSB7fTtcbiAgICBjb25zdCBhbGxBdHRyaWJ1dGVzID0gW107XG4gICAgbGV0IG9uRHVwbGljYXRlS2V5VXBkYXRlID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWVIYXNoIG9mIGZpZWxkVmFsdWVIYXNoZXMpIHtcbiAgICAgIF8uZm9yT3duKGZpZWxkVmFsdWVIYXNoLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWFsbEF0dHJpYnV0ZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGFsbEF0dHJpYnV0ZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XSAmJiBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgc2VyaWFsc1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmllbGRWYWx1ZUhhc2ggb2YgZmllbGRWYWx1ZUhhc2hlcykge1xuICAgICAgY29uc3QgdmFsdWVzID0gYWxsQXR0cmlidXRlcy5tYXAoKGtleSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5idWxrRGVmYXVsdCAmJiBzZXJpYWxzW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZUhhc2hba2V5XSAhPSBudWxsID8gZmllbGRWYWx1ZUhhc2hba2V5XSA6IFwiREVGQVVMVFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZShmaWVsZFZhbHVlSGFzaFtrZXldLCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XSwgeyBjb250ZXh0OiBcIklOU0VSVFwiIH0pO1xuICAgICAgfSk7XG4gICAgICB0dXBsZXMucHVzaChgKCR7dmFsdWVzLmpvaW4oXCIsXCIpfSlgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy51cGRhdGVPbkR1cGxpY2F0ZSAmJiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbnNlcnRzLnVwZGF0ZU9uRHVwbGljYXRlID09IFwiIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVRcIikge1xuICAgICAgICBjb25zdCBjb25mbGljdEtleXMgPSBvcHRpb25zLnVwc2VydEtleXMubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcCgoYXR0cikgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PUVYQ0xVREVELiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9YCk7XG4gICAgICAgIGxldCB3aGVyZUNsYXVzZSA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5jb25mbGljdFdoZXJlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdFdoZXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0V2hlcmUgbm90IHN1cHBvcnRlZCBmb3IgZGlhbGVjdCAke3RoaXMuX2RpYWxlY3QubmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hlcmVDbGF1c2UgPSB0aGlzLndoZXJlUXVlcnkob3B0aW9ucy5jb25mbGljdFdoZXJlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBvbkR1cGxpY2F0ZUtleVVwZGF0ZSA9IFtcbiAgICAgICAgICBcIk9OIENPTkZMSUNUXCIsXG4gICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgY29uZmxpY3RLZXlzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgIFwiKVwiLFxuICAgICAgICAgIHdoZXJlQ2xhdXNlLFxuICAgICAgICAgIFwiRE8gVVBEQVRFIFNFVFwiLFxuICAgICAgICAgIHVwZGF0ZUtleXMuam9pbihcIixcIilcbiAgICAgICAgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbmZsaWN0V2hlcmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbmZsaWN0V2hlcmUgbm90IHN1cHBvcnRlZCBmb3IgZGlhbGVjdCAke3RoaXMuX2RpYWxlY3QubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZUtleXMgPSBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLm1hcCgoYXR0cikgPT4gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9PVZBTFVFUygke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSlgKTtcbiAgICAgICAgb25EdXBsaWNhdGVLZXlVcGRhdGUgPSBgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMudXBkYXRlT25EdXBsaWNhdGV9ICR7dmFsdWVLZXlzLmpvaW4oXCIsXCIpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlnbm9yZUR1cGxpY2F0ZXMgPSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgPyB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMuaWdub3JlRHVwbGljYXRlcyA6IFwiXCI7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIixcIik7XG4gICAgY29uc3Qgb25Db25mbGljdERvTm90aGluZyA9IG9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA/IHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5vbkNvbmZsaWN0RG9Ob3RoaW5nIDogXCJcIjtcbiAgICBsZXQgcmV0dXJuaW5nID0gXCJcIjtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMoZmllbGRNYXBwZWRBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybmluZyArPSByZXR1cm5WYWx1ZXMucmV0dXJuaW5nRnJhZ21lbnQ7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiSU5TRVJUXCIsXG4gICAgICBpZ25vcmVEdXBsaWNhdGVzLFxuICAgICAgXCJJTlRPXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGAoJHthdHRyaWJ1dGVzfSlgLFxuICAgICAgXCJWQUxVRVNcIixcbiAgICAgIHR1cGxlcy5qb2luKFwiLFwiKSxcbiAgICAgIG9uRHVwbGljYXRlS2V5VXBkYXRlLFxuICAgICAgb25Db25mbGljdERvTm90aGluZyxcbiAgICAgIHJldHVybmluZyxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICBhdHRyVmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMub21pdE51bGwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGJpbmQgPSBbXTtcbiAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZU1hcCA9IHt9O1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IHRtcFRhYmxlID0gXCJcIjtcbiAgICBsZXQgc3VmZml4ID0gXCJcIjtcbiAgICBpZiAoXy5nZXQodGhpcywgW1wic2VxdWVsaXplXCIsIFwib3B0aW9uc1wiLCBcImRpYWxlY3RPcHRpb25zXCIsIFwicHJlcGVuZFNlYXJjaFBhdGhcIl0pIHx8IG9wdGlvbnMuc2VhcmNoUGF0aCkge1xuICAgICAgb3B0aW9ucy5iaW5kUGFyYW0gPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYmluZFBhcmFtID0gb3B0aW9ucy5iaW5kUGFyYW0gPT09IHZvaWQgMCA/IHRoaXMuYmluZFBhcmFtKGJpbmQpIDogb3B0aW9ucy5iaW5kUGFyYW07XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHNbXCJMSU1JVCBPTiBVUERBVEVcIl0gJiYgb3B0aW9ucy5saW1pdCkge1xuICAgICAgaWYgKCFbXCJtc3NxbFwiLCBcImRiMlwiLCBcIm9yYWNsZVwiXS5pbmNsdWRlcyh0aGlzLmRpYWxlY3QpKSB7XG4gICAgICAgIHN1ZmZpeCA9IGAgTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gYDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kaWFsZWN0ID09PSBcIm9yYWNsZVwiKSB7XG4gICAgICAgIGlmICh3aGVyZSAmJiAod2hlcmUubGVuZ3RoICYmIHdoZXJlLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXMod2hlcmUpLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgc3VmZml4ICs9IFwiIEFORCBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWZmaXggKz0gXCIgV0hFUkUgXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3VmZml4ICs9IGByb3dudW0gPD0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gYDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzICYmIG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICBjb25zdCByZXR1cm5WYWx1ZXMgPSB0aGlzLmdlbmVyYXRlUmV0dXJuVmFsdWVzKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgc3VmZml4ICs9IHJldHVyblZhbHVlcy5yZXR1cm5pbmdGcmFnbWVudDtcbiAgICAgIHRtcFRhYmxlID0gcmV0dXJuVmFsdWVzLnRtcFRhYmxlIHx8IFwiXCI7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudCB8fCBcIlwiO1xuICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcy5vdXRwdXQgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgb3B0aW9ucy5tYXBUb01vZGVsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgIF8uZWFjaChhdHRyaWJ1dGVzLCAoYXR0cmlidXRlLCBrZXkpID0+IHtcbiAgICAgICAgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSA9IGF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2F0dHJpYnV0ZS5maWVsZF0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyVmFsdWVIYXNoKSB7XG4gICAgICBpZiAobW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldLmF1dG9JbmNyZW1lbnQgPT09IHRydWUgJiYgIXRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuYXV0b0luY3JlbWVudC51cGRhdGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJWYWx1ZUhhc2hba2V5XTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCB8fCBvcHRpb25zLmJpbmRQYXJhbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdmFsdWVzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX09JHt0aGlzLmVzY2FwZSh2YWx1ZSwgbW9kZWxBdHRyaWJ1dGVNYXAgJiYgbW9kZWxBdHRyaWJ1dGVNYXBba2V5XSB8fCB2b2lkIDAsIHsgY29udGV4dDogXCJVUERBVEVcIiB9KX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5mb3JtYXQodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiVVBEQVRFXCIgfSwgYmluZFBhcmFtKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2hlcmVPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgYmluZFBhcmFtIH0pO1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgcXVlcnkgPSBgJHt0bXBUYWJsZX1VUERBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gU0VUICR7dmFsdWVzLmpvaW4oXCIsXCIpfSR7b3V0cHV0RnJhZ21lbnR9ICR7dGhpcy53aGVyZVF1ZXJ5KHdoZXJlLCB3aGVyZU9wdGlvbnMpfSR7c3VmZml4fWAudHJpbSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgcXVlcnkgfTtcbiAgICBpZiAob3B0aW9ucy5iaW5kUGFyYW0gIT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuYmluZCA9IGJpbmQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXJpdGhtZXRpY1F1ZXJ5KG9wZXJhdG9yLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgcmV0dXJuaW5nOiB0cnVlIH0pO1xuICAgIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCB0aGlzLm9wdGlvbnMub21pdE51bGwpO1xuICAgIGxldCBvdXRwdXRGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IHJldHVybmluZ0ZyYWdtZW50ID0gXCJcIjtcbiAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5WYWx1ZXMgJiYgb3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIGNvbnN0IHJldHVyblZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobnVsbCwgb3B0aW9ucyk7XG4gICAgICBvdXRwdXRGcmFnbWVudCA9IHJldHVyblZhbHVlcy5vdXRwdXRGcmFnbWVudDtcbiAgICAgIHJldHVybmluZ0ZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLnJldHVybmluZ0ZyYWdtZW50O1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVTZXRTcWxGcmFnbWVudHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIGluY3JlbWVudEFtb3VudHNCeUZpZWxkKSB7XG4gICAgICBjb25zdCBpbmNyZW1lbnRBbW91bnQgPSBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZFtmaWVsZF07XG4gICAgICBjb25zdCBxdW90ZWRGaWVsZCA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKTtcbiAgICAgIGNvbnN0IGVzY2FwZWRBbW91bnQgPSB0aGlzLmVzY2FwZShpbmNyZW1lbnRBbW91bnQpO1xuICAgICAgdXBkYXRlU2V0U3FsRnJhZ21lbnRzLnB1c2goYCR7cXVvdGVkRmllbGR9PSR7cXVvdGVkRmllbGR9JHtvcGVyYXRvcn0gJHtlc2NhcGVkQW1vdW50fWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkKSB7XG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkW2ZpZWxkXTtcbiAgICAgIGNvbnN0IHF1b3RlZEZpZWxkID0gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpO1xuICAgICAgY29uc3QgZXNjYXBlZFZhbHVlID0gdGhpcy5lc2NhcGUobmV3VmFsdWUpO1xuICAgICAgdXBkYXRlU2V0U3FsRnJhZ21lbnRzLnB1c2goYCR7cXVvdGVkRmllbGR9PSR7ZXNjYXBlZFZhbHVlfWApO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlVQREFURVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIlNFVFwiLFxuICAgICAgdXBkYXRlU2V0U3FsRnJhZ21lbnRzLmpvaW4oXCIsXCIpLFxuICAgICAgb3V0cHV0RnJhZ21lbnQsXG4gICAgICB0aGlzLndoZXJlUXVlcnkod2hlcmUpLFxuICAgICAgcmV0dXJuaW5nRnJhZ21lbnRcbiAgICBdKTtcbiAgfVxuICBhZGRJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgcmF3VGFibGVuYW1lKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICBvcHRpb25zID0gYXR0cmlidXRlcztcbiAgICAgIGF0dHJpYnV0ZXMgPSB2b2lkIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuZmllbGRzID0gYXR0cmlidXRlcztcbiAgICB9XG4gICAgb3B0aW9ucy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCByYXdUYWJsZW5hbWUgfHwgdGFibGVOYW1lO1xuICAgIGlmIChvcHRpb25zLnByZWZpeCAmJiB0eXBlb2Ygb3B0aW9ucy5wcmVmaXggPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXgucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcbiAgICAgIG9wdGlvbnMucHJlZml4ID0gb3B0aW9ucy5wcmVmaXgucmVwbGFjZSgvKFwifCcpL2csIFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZHNTcWwgPSBvcHRpb25zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZmllbGQgPSB7XG4gICAgICAgICAgbmFtZTogZmllbGRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgaWYgKGZpZWxkLmF0dHJpYnV0ZSkge1xuICAgICAgICBmaWVsZC5uYW1lID0gZmllbGQuYXR0cmlidXRlO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWVsZC5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBpbmRleCBmaWVsZCBoYXMgbm8gbmFtZTogJHt1dGlsLmluc3BlY3QoZmllbGQpfWApO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkLm5hbWUpO1xuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXguY29sbGF0ZSAmJiBmaWVsZC5jb2xsYXRlKSB7XG4gICAgICAgIHJlc3VsdCArPSBgIENPTExBVEUgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZC5jb2xsYXRlKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgub3BlcmF0b3IpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSBmaWVsZC5vcGVyYXRvciB8fCBvcHRpb25zLm9wZXJhdG9yO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCAke29wZXJhdG9yfWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4Lmxlbmd0aCAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAoJHtmaWVsZC5sZW5ndGh9KWA7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQub3JkZXIpIHtcbiAgICAgICAgcmVzdWx0ICs9IGAgJHtmaWVsZC5vcmRlcn1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgb3B0aW9ucyA9IFV0aWxzLm5hbWVJbmRleChvcHRpb25zLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBNb2RlbC5fY29uZm9ybUluZGV4KG9wdGlvbnMpO1xuICAgIGlmICghdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC50eXBlKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy50eXBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy53aGVyZSkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHRoaXMud2hlcmVRdWVyeShvcHRpb25zLndoZXJlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgY29uY3VycmVudGx5ID0gdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleC5jb25jdXJyZW50bHkgJiYgb3B0aW9ucy5jb25jdXJyZW50bHkgPyBcIkNPTkNVUlJFTlRMWVwiIDogdm9pZCAwO1xuICAgIGxldCBpbmQ7XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhWaWFBbHRlcikge1xuICAgICAgaW5kID0gW1xuICAgICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgY29uY3VycmVudGx5LFxuICAgICAgICBcIkFERFwiXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmQgPSBbXCJDUkVBVEVcIl07XG4gICAgfVxuICAgIGluZCA9IGluZC5jb25jYXQob3B0aW9ucy51bmlxdWUgPyBcIlVOSVFVRVwiIDogXCJcIiwgb3B0aW9ucy50eXBlLCBcIklOREVYXCIsICF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4VmlhQWx0ZXIgPyBjb25jdXJyZW50bHkgOiB2b2lkIDAsIHRoaXMucXVvdGVJZGVudGlmaWVycyhvcHRpb25zLm5hbWUpLCB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnVzaW5nID09PSAxICYmIG9wdGlvbnMudXNpbmcgPyBgVVNJTkcgJHtvcHRpb25zLnVzaW5nfWAgOiBcIlwiLCAhdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5pbmRleFZpYUFsdGVyID8gYE9OICR7dGFibGVOYW1lfWAgOiB2b2lkIDAsIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgudXNpbmcgPT09IDIgJiYgb3B0aW9ucy51c2luZyA/IGBVU0lORyAke29wdGlvbnMudXNpbmd9YCA6IFwiXCIsIGAoJHtmaWVsZHNTcWwuam9pbihcIiwgXCIpfSlgLCB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmluZGV4LnBhcnNlciAmJiBvcHRpb25zLnBhcnNlciA/IGBXSVRIIFBBUlNFUiAke29wdGlvbnMucGFyc2VyfWAgOiB2b2lkIDAsIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXgud2hlcmUgJiYgb3B0aW9ucy53aGVyZSA/IG9wdGlvbnMud2hlcmUgOiB2b2lkIDApO1xuICAgIHJldHVybiBfLmNvbXBhY3QoaW5kKS5qb2luKFwiIFwiKTtcbiAgfVxuICBhZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGFibGVOYW1lLFxuICAgICAgXCJBRERcIixcbiAgICAgIHRoaXMuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zIHx8IHt9KSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgbGV0IGNvbnN0cmFpbnRTbmlwcGV0LCBjb25zdHJhaW50TmFtZTtcbiAgICBjb25zdCBmaWVsZHNTcWwgPSBvcHRpb25zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCk7XG4gICAgICB9XG4gICAgICBpZiAoZmllbGQgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGZpZWxkKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWVsZC5hdHRyaWJ1dGUpIHtcbiAgICAgICAgZmllbGQubmFtZSA9IGZpZWxkLmF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZmllbGQubmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBmb2xsb3dpbmcgaW5kZXggZmllbGQgaGFzIG5vIG5hbWU6ICR7ZmllbGR9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQubmFtZSk7XG4gICAgfSk7XG4gICAgY29uc3QgZmllbGRzU3FsUXVvdGVkU3RyaW5nID0gZmllbGRzU3FsLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBmaWVsZHNTcWxTdHJpbmcgPSBmaWVsZHNTcWwuam9pbihcIl9cIik7XG4gICAgc3dpdGNoIChvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSkge1xuICAgICAgY2FzZSBcIlVOSVFVRVwiOlxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV91a2ApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IFVOSVFVRSAoJHtmaWVsZHNTcWxRdW90ZWRTdHJpbmd9KWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkNIRUNLXCI6XG4gICAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLndoZXJlSXRlbXNRdWVyeShvcHRpb25zLndoZXJlKTtcbiAgICAgICAgY29uc3RyYWludE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLm5hbWUgfHwgYCR7dGFibGVOYW1lfV8ke2ZpZWxkc1NxbFN0cmluZ31fY2tgKTtcbiAgICAgICAgY29uc3RyYWludFNuaXBwZXQgPSBgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnROYW1lfSBDSEVDSyAoJHtvcHRpb25zLndoZXJlfSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJERUZBVUxUXCI6XG4gICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSBtdXN0IGJlIHNwZWNpZmllZCBmb3IgREVGQVVMVCBDT05TVFJBSU5UXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kaWFsZWN0Lm5hbWUgIT09IFwibXNzcWxcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgY29uc3RyYWludHMgYXJlIHN1cHBvcnRlZCBvbmx5IGZvciBNU1NRTCBkaWFsZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJhaW50TmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMubmFtZSB8fCBgJHt0YWJsZU5hbWV9XyR7ZmllbGRzU3FsU3RyaW5nfV9kZmApO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IERFRkFVTFQgKCR7dGhpcy5lc2NhcGUob3B0aW9ucy5kZWZhdWx0VmFsdWUpfSkgRk9SICR7ZmllbGRzU3FsWzBdfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBSSU1BUlkgS0VZXCI6XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9X3BrYCk7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ID0gYENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX0gUFJJTUFSWSBLRVkgKCR7ZmllbGRzU3FsUXVvdGVkU3RyaW5nfSlgO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJGT1JFSUdOIEtFWVwiOlxuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gb3B0aW9ucy5yZWZlcmVuY2VzO1xuICAgICAgICBpZiAoIXJlZmVyZW5jZXMgfHwgIXJlZmVyZW5jZXMudGFibGUgfHwgIShyZWZlcmVuY2VzLmZpZWxkIHx8IHJlZmVyZW5jZXMuZmllbGRzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlZmVyZW5jZXMgb2JqZWN0IHdpdGggdGFibGUgYW5kIGZpZWxkIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0cmFpbnROYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5uYW1lIHx8IGAke3RhYmxlTmFtZX1fJHtmaWVsZHNTcWxTdHJpbmd9XyR7cmVmZXJlbmNlcy50YWJsZX1fZmtgKTtcbiAgICAgICAgY29uc3QgcXVvdGVkUmVmZXJlbmNlcyA9IHR5cGVvZiByZWZlcmVuY2VzLmZpZWxkICE9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5xdW90ZUlkZW50aWZpZXIocmVmZXJlbmNlcy5maWVsZCkgOiByZWZlcmVuY2VzLmZpZWxkcy5tYXAoKGYpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGYpKS5qb2luKFwiLCBcIik7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXNTbmlwcGV0ID0gYCR7dGhpcy5xdW90ZVRhYmxlKHJlZmVyZW5jZXMudGFibGUpfSAoJHtxdW90ZWRSZWZlcmVuY2VzfSlgO1xuICAgICAgICBjb25zdHJhaW50U25pcHBldCA9IGBDT05TVFJBSU5UICR7Y29uc3RyYWludE5hbWV9IGA7XG4gICAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGBGT1JFSUdOIEtFWSAoJHtmaWVsZHNTcWxRdW90ZWRTdHJpbmd9KSBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlc1NuaXBwZXR9YDtcbiAgICAgICAgaWYgKG9wdGlvbnMub25VcGRhdGUpIHtcbiAgICAgICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIE9OIFVQREFURSAke29wdGlvbnMub25VcGRhdGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm9uRGVsZXRlKSB7XG4gICAgICAgICAgY29uc3RyYWludFNuaXBwZXQgKz0gYCBPTiBERUxFVEUgJHtvcHRpb25zLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvcHRpb25zLnR5cGV9IGlzIGludmFsaWQuYCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRlZmVycmFibGUgJiYgW1wiVU5JUVVFXCIsIFwiUFJJTUFSWSBLRVlcIiwgXCJGT1JFSUdOIEtFWVwiXS5pbmNsdWRlcyhvcHRpb25zLnR5cGUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgJHt0aGlzLmRlZmVyQ29uc3RyYWludHNRdWVyeShvcHRpb25zKX1gO1xuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludFNuaXBwZXQ7XG4gIH1cbiAgcmVtb3ZlQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKHRhYmxlTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBcIkRST1AgQ09OU1RSQUlOVFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXJzKGNvbnN0cmFpbnROYW1lKVxuICAgIF0pO1xuICB9XG4gIHF1b3RlKGNvbGxlY3Rpb24sIHBhcmVudCwgY29ubmVjdG9yKSB7XG4gICAgY29uc3QgdmFsaWRPcmRlck9wdGlvbnMgPSBbXG4gICAgICBcIkFTQ1wiLFxuICAgICAgXCJERVNDXCIsXG4gICAgICBcIkFTQyBOVUxMUyBMQVNUXCIsXG4gICAgICBcIkRFU0MgTlVMTFMgTEFTVFwiLFxuICAgICAgXCJBU0MgTlVMTFMgRklSU1RcIixcbiAgICAgIFwiREVTQyBOVUxMUyBGSVJTVFwiLFxuICAgICAgXCJOVUxMUyBGSVJTVFwiLFxuICAgICAgXCJOVUxMUyBMQVNUXCJcbiAgICBdO1xuICAgIGNvbm5lY3RvciA9IGNvbm5lY3RvciB8fCBcIi5cIjtcbiAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcnMoY29sbGVjdGlvbik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICBjb2xsZWN0aW9uLmZvckVhY2goKGl0ZW0yLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91cyA9IGNvbGxlY3Rpb25baW5kZXggLSAxXTtcbiAgICAgICAgbGV0IHByZXZpb3VzQXNzb2NpYXRpb247XG4gICAgICAgIGxldCBwcmV2aW91c01vZGVsO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIHBhcmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcHJldmlvdXNNb2RlbCA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cyBpbnN0YW5jZW9mIEFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgcHJldmlvdXNBc3NvY2lhdGlvbiA9IHByZXZpb3VzO1xuICAgICAgICAgIHByZXZpb3VzTW9kZWwgPSBwcmV2aW91cy50YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzTW9kZWwgJiYgcHJldmlvdXNNb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgICBsZXQgYXM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtMiA9PT0gXCJmdW5jdGlvblwiICYmIGl0ZW0yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgICBtb2RlbCA9IGl0ZW0yO1xuICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KGl0ZW0yKSAmJiBpdGVtMi5tb2RlbCAmJiBpdGVtMi5tb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgbW9kZWwgPSBpdGVtMi5tb2RlbDtcbiAgICAgICAgICAgIGFzID0gaXRlbTIuYXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgaWYgKCFhcyAmJiBwcmV2aW91c0Fzc29jaWF0aW9uICYmIHByZXZpb3VzQXNzb2NpYXRpb24gaW5zdGFuY2VvZiBBc3NvY2lhdGlvbiAmJiBwcmV2aW91c0Fzc29jaWF0aW9uLnRocm91Z2ggJiYgcHJldmlvdXNBc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsID09PSBtb2RlbCkge1xuICAgICAgICAgICAgICBpdGVtMiA9IG5ldyBBc3NvY2lhdGlvbihwcmV2aW91c01vZGVsLCBtb2RlbCwge1xuICAgICAgICAgICAgICAgIGFzOiBtb2RlbC5uYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbTIgPSBwcmV2aW91c01vZGVsLmdldEFzc29jaWF0aW9uRm9yQWxpYXMobW9kZWwsIGFzKTtcbiAgICAgICAgICAgICAgaWYgKCFpdGVtMikge1xuICAgICAgICAgICAgICAgIGl0ZW0yID0gcHJldmlvdXNNb2RlbC5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKG1vZGVsLCBtb2RlbC5uYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoaXRlbTIgaW5zdGFuY2VvZiBBc3NvY2lhdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KFwiVW5hYmxlIHRvIGZpbmQgYSB2YWxpZCBhc3NvY2lhdGlvbiBmb3IgbW9kZWwsICclcydcIiwgbW9kZWwubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc3Qgb3JkZXJJbmRleCA9IHZhbGlkT3JkZXJPcHRpb25zLmluZGV4T2YoaXRlbTIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiBvcmRlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgaXRlbTIgPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKGAgJHt2YWxpZE9yZGVyT3B0aW9uc1tvcmRlckluZGV4XX1gKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzTW9kZWwgJiYgcHJldmlvdXNNb2RlbC5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzTW9kZWwuYXNzb2NpYXRpb25zICE9PSB2b2lkIDAgJiYgcHJldmlvdXNNb2RlbC5hc3NvY2lhdGlvbnNbaXRlbTJdKSB7XG4gICAgICAgICAgICAgIGl0ZW0yID0gcHJldmlvdXNNb2RlbC5hc3NvY2lhdGlvbnNbaXRlbTJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXMgIT09IHZvaWQgMCAmJiBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbTJdICYmIGl0ZW0yICE9PSBwcmV2aW91c01vZGVsLnJhd0F0dHJpYnV0ZXNbaXRlbTJdLmZpZWxkKSB7XG4gICAgICAgICAgICAgIGl0ZW0yID0gcHJldmlvdXNNb2RlbC5yYXdBdHRyaWJ1dGVzW2l0ZW0yXS5maWVsZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbTIuaW5jbHVkZXMoXCIuXCIpICYmIHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW1TcGxpdCA9IGl0ZW0yLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgaWYgKHByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtU3BsaXRbMF1dLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnMoYCR7cHJldmlvdXNNb2RlbC5uYW1lfS4ke3ByZXZpb3VzTW9kZWwucmF3QXR0cmlidXRlc1tpdGVtU3BsaXRbMF1dLmZpZWxkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBpdGVtU3BsaXQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaXRlbTIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGlkZW50aWZpZXIsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGl0ZW0yID0gdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChpdGVtMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdGlvbltpbmRleF0gPSBpdGVtMjtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgY29uc3QgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgY29uc3QgdGFibGVOYW1lcyA9IFtdO1xuICAgICAgbGV0IGl0ZW07XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY29sbGVjdGlvbkxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpdGVtID0gY29sbGVjdGlvbltpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiIHx8IGl0ZW0uX21vZGVsQXR0cmlidXRlIHx8IGl0ZW0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pIHtcbiAgICAgICAgICB0YWJsZU5hbWVzW2ldID0gaXRlbS5hcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHNxbCA9IFwiXCI7XG4gICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgc3FsICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlTmFtZXMuam9pbihjb25uZWN0b3IpKX0uYDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbGxlY3Rpb25bMF0gPT09IFwic3RyaW5nXCIgJiYgcGFyZW50KSB7XG4gICAgICAgIHNxbCArPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihwYXJlbnQubmFtZSl9LmA7XG4gICAgICB9XG4gICAgICBjb2xsZWN0aW9uLnNsaWNlKGkpLmZvckVhY2goKGNvbGxlY3Rpb25JdGVtKSA9PiB7XG4gICAgICAgIHNxbCArPSB0aGlzLnF1b3RlKGNvbGxlY3Rpb25JdGVtLCBwYXJlbnQsIGNvbm5lY3Rvcik7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBzcWw7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0aW9uLl9tb2RlbEF0dHJpYnV0ZSkge1xuICAgICAgcmV0dXJuIGAke3RoaXMucXVvdGVUYWJsZShjb2xsZWN0aW9uLk1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGNvbGxlY3Rpb24uZmllbGROYW1lKX1gO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGNvbGxlY3Rpb24pICYmIGNvbGxlY3Rpb24ucmF3KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBge3JhdzogXCIuLi5cIn1gIHN5bnRheCBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAgVXNlIGBzZXF1ZWxpemUubGl0ZXJhbGAgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cnVjdHVyZSBwYXNzZWQgdG8gb3JkZXIgLyBncm91cDogJHt1dGlsLmluc3BlY3QoY29sbGVjdGlvbil9YCk7XG4gIH1cbiAgX2luaXRRdW90ZUlkZW50aWZpZXIoKSB7XG4gICAgdGhpcy5fcXVvdGVJZGVudGlmaWVyID0gdGhpcy5xdW90ZUlkZW50aWZpZXI7XG4gICAgdGhpcy5xdW90ZUlkZW50aWZpZXIgPSBmdW5jdGlvbihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgICAgaWYgKGlkZW50aWZpZXIgPT09IFwiKlwiKVxuICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgIHJldHVybiB0aGlzLl9xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpO1xuICAgIH07XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBxdW90ZUlkZW50aWZpZXIgZm9yIERpYWxlY3QgXCIke3RoaXMuZGlhbGVjdH1cIiBpcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXJzKGlkZW50aWZpZXJzKSB7XG4gICAgaWYgKGlkZW50aWZpZXJzLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgaWRlbnRpZmllcnMgPSBpZGVudGlmaWVycy5zcGxpdChcIi5cIik7XG4gICAgICBjb25zdCBoZWFkID0gaWRlbnRpZmllcnMuc2xpY2UoMCwgaWRlbnRpZmllcnMubGVuZ3RoIC0gMSkuam9pbihcIi0+XCIpO1xuICAgICAgY29uc3QgdGFpbCA9IGlkZW50aWZpZXJzW2lkZW50aWZpZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGhlYWQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRhaWwpfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVycyk7XG4gIH1cbiAgcXVvdGVBdHRyaWJ1dGUoYXR0cmlidXRlLCBtb2RlbCkge1xuICAgIGlmIChtb2RlbCAmJiBhdHRyaWJ1dGUgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcnMoYXR0cmlidXRlKTtcbiAgfVxuICBnZXRBbGlhc1Rva2VuKCkge1xuICAgIHJldHVybiBcIkFTXCI7XG4gIH1cbiAgcXVvdGVUYWJsZShwYXJhbSwgYWxpYXMpIHtcbiAgICBsZXQgdGFibGUgPSBcIlwiO1xuICAgIGlmIChhbGlhcyA9PT0gdHJ1ZSkge1xuICAgICAgYWxpYXMgPSBwYXJhbS5hcyB8fCBwYXJhbS5uYW1lIHx8IHBhcmFtO1xuICAgIH1cbiAgICBpZiAoXy5pc09iamVjdChwYXJhbSkpIHtcbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnNjaGVtYXMpIHtcbiAgICAgICAgaWYgKHBhcmFtLnNjaGVtYSkge1xuICAgICAgICAgIHRhYmxlICs9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHBhcmFtLnNjaGVtYSl9LmA7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUgKz0gdGhpcy5xdW90ZUlkZW50aWZpZXIocGFyYW0udGFibGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJhbS5zY2hlbWEpIHtcbiAgICAgICAgICB0YWJsZSArPSBwYXJhbS5zY2hlbWEgKyAocGFyYW0uZGVsaW1pdGVyIHx8IFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZSArPSBwYXJhbS50YWJsZU5hbWU7XG4gICAgICAgIHRhYmxlID0gdGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YWJsZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHBhcmFtKTtcbiAgICB9XG4gICAgaWYgKGFsaWFzKSB7XG4gICAgICB0YWJsZSArPSBgICR7dGhpcy5nZXRBbGlhc1Rva2VuKCl9ICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMpfWA7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZTtcbiAgfVxuICBlc2NhcGUodmFsdWUsIGZpZWxkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZmllbGQudHlwZS5zdHJpbmdpZnkpIHtcbiAgICAgICAgICBjb25zdCBzaW1wbGVFc2NhcGUgPSAoZXNjVmFsKSA9PiBTcWxTdHJpbmcuZXNjYXBlKGVzY1ZhbCwgdGhpcy5vcHRpb25zLnRpbWV6b25lLCB0aGlzLmRpYWxlY3QpO1xuICAgICAgICAgIHZhbHVlID0gZmllbGQudHlwZS5zdHJpbmdpZnkodmFsdWUsIHsgZXNjYXBlOiBzaW1wbGVFc2NhcGUsIGZpZWxkLCB0aW1lem9uZTogdGhpcy5vcHRpb25zLnRpbWV6b25lLCBvcGVyYXRpb246IG9wdGlvbnMub3BlcmF0aW9uIH0pO1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlLmVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGUodmFsdWUsIHRoaXMub3B0aW9ucy50aW1lem9uZSwgdGhpcy5kaWFsZWN0KTtcbiAgfVxuICBiaW5kUGFyYW0oYmluZCkge1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGJpbmQucHVzaCh2YWx1ZSk7XG4gICAgICByZXR1cm4gYCQke2JpbmQubGVuZ3RofWA7XG4gICAgfTtcbiAgfVxuICBmb3JtYXQodmFsdWUsIGZpZWxkLCBvcHRpb25zLCBiaW5kUGFyYW0pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwYXNzIFNlcXVlbGl6ZU1ldGhvZCBhcyBhIGJpbmQgcGFyYW1ldGVyIC0gdXNlIGVzY2FwZSBpbnN0ZWFkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLnR5cGUpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSwgZmllbGQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZmllbGQudHlwZS5iaW5kUGFyYW0pIHtcbiAgICAgICAgICByZXR1cm4gZmllbGQudHlwZS5iaW5kUGFyYW0odmFsdWUsIHsgZXNjYXBlOiBfLmlkZW50aXR5LCBmaWVsZCwgdGltZXpvbmU6IHRoaXMub3B0aW9ucy50aW1lem9uZSwgb3BlcmF0aW9uOiBvcHRpb25zLm9wZXJhdGlvbiwgYmluZFBhcmFtIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiaW5kUGFyYW0odmFsdWUpO1xuICB9XG4gIHZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLnR5cGVWYWxpZGF0aW9uICYmIGZpZWxkLnR5cGUudmFsaWRhdGUgJiYgdmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlzTGlzdCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgZmllbGQudHlwZS52YWxpZGF0ZShpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmllbGQudHlwZS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgIGVycm9yLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKGVycm9yLm1lc3NhZ2UsIFwiVmFsaWRhdGlvbiBlcnJvclwiLCBmaWVsZC5maWVsZE5hbWUsIHZhbHVlLCBudWxsLCBgJHtmaWVsZC50eXBlLmtleX0gdmFsaWRhdG9yYCkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc0lkZW50aWZpZXJRdW90ZWQoaWRlbnRpZmllcikge1xuICAgIHJldHVybiAvXlxccyooPzooW2BcIiddKSg/Oig/IVxcMSkufFxcMXsyfSkqXFwxXFwuPykrXFxzKiQvaS50ZXN0KGlkZW50aWZpZXIpO1xuICB9XG4gIGpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aCwgaXNKc29uKSB7XG4gICAgbGV0IHBhdGhzID0gXy50b1BhdGgocGF0aCk7XG4gICAgbGV0IHBhdGhTdHI7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uID0gdGhpcy5pc0lkZW50aWZpZXJRdW90ZWQoY29sdW1uKSA/IGNvbHVtbiA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbik7XG4gICAgc3dpdGNoICh0aGlzLmRpYWxlY3QpIHtcbiAgICAgIGNhc2UgXCJteXNxbFwiOlxuICAgICAgY2FzZSBcIm1hcmlhZGJcIjpcbiAgICAgIGNhc2UgXCJzcWxpdGVcIjpcbiAgICAgICAgaWYgKHRoaXMuZGlhbGVjdCA9PT0gXCJteXNxbFwiKSB7XG4gICAgICAgICAgcGF0aHMgPSBwYXRocy5tYXAoKHN1YlBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAvXFxELy50ZXN0KHN1YlBhdGgpID8gVXRpbHMuYWRkVGlja3Moc3ViUGF0aCwgJ1wiJykgOiBzdWJQYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhdGhTdHIgPSB0aGlzLmVzY2FwZShbXCIkXCJdLmNvbmNhdChwYXRocykuam9pbihcIi5cIikucmVwbGFjZSgvXFwuKFxcZCspKD86KD89XFwuKXwkKS9nLCAoX18sIGRpZ2l0KSA9PiBgWyR7ZGlnaXR9XWApKTtcbiAgICAgICAgaWYgKHRoaXMuZGlhbGVjdCA9PT0gXCJzcWxpdGVcIikge1xuICAgICAgICAgIHJldHVybiBganNvbl9leHRyYWN0KCR7cXVvdGVkQ29sdW1ufSwke3BhdGhTdHJ9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBqc29uX3VucXVvdGUoanNvbl9leHRyYWN0KCR7cXVvdGVkQ29sdW1ufSwke3BhdGhTdHJ9KSlgO1xuICAgICAgY2FzZSBcInBvc3RncmVzXCI6XG4gICAgICAgIGNvbnN0IGpvaW4gPSBpc0pzb24gPyBcIiM+XCIgOiBcIiM+PlwiO1xuICAgICAgICBwYXRoU3RyID0gdGhpcy5lc2NhcGUoYHske3BhdGhzLmpvaW4oXCIsXCIpfX1gKTtcbiAgICAgICAgcmV0dXJuIGAoJHtxdW90ZWRDb2x1bW59JHtqb2lufSR7cGF0aFN0cn0pYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgJHt0aGlzLmRpYWxlY3R9IGZvciBKU09OIG9wZXJhdGlvbnNgKTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICBjb25zdCBtYWluUXVlcnlJdGVtcyA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5SXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdWJRdWVyeSA9IG9wdGlvbnMuc3ViUXVlcnkgPT09IHZvaWQgMCA/IGxpbWl0ICYmIG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbiA6IG9wdGlvbnMuc3ViUXVlcnk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IG9wdGlvbnMuYXR0cmlidXRlcyAmJiBvcHRpb25zLmF0dHJpYnV0ZXMuc2xpY2UoKSxcbiAgICAgIHN1YlF1ZXJ5OiBudWxsXG4gICAgfTtcbiAgICBjb25zdCBtYWluVGFibGUgPSB7XG4gICAgICBuYW1lOiB0YWJsZU5hbWUsXG4gICAgICBxdW90ZWROYW1lOiBudWxsLFxuICAgICAgYXM6IG51bGwsXG4gICAgICBtb2RlbFxuICAgIH07XG4gICAgY29uc3QgdG9wTGV2ZWxJbmZvID0ge1xuICAgICAgbmFtZXM6IG1haW5UYWJsZSxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzdWJRdWVyeVxuICAgIH07XG4gICAgbGV0IG1haW5Kb2luUXVlcmllcyA9IFtdO1xuICAgIGxldCBzdWJKb2luUXVlcmllcyA9IFtdO1xuICAgIGxldCBxdWVyeTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMgJiYgIW9wdGlvbnMuYWxpYXNlc01hcHBpbmcpIHtcbiAgICAgIG9wdGlvbnMuYWxpYXNlc01hcHBpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgb3B0aW9ucy5hbGlhc2VzQnlUYWJsZSA9IHt9O1xuICAgICAgb3B0aW9ucy5pbmNsdWRlQWxpYXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRhYmxlQXMpIHtcbiAgICAgIG1haW5UYWJsZS5hcyA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMudGFibGVBcyk7XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtYWluVGFibGUubmFtZSkgJiYgbWFpblRhYmxlLm1vZGVsKSB7XG4gICAgICBtYWluVGFibGUuYXMgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihtYWluVGFibGUubW9kZWwubmFtZSk7XG4gICAgfVxuICAgIG1haW5UYWJsZS5xdW90ZWROYW1lID0gIUFycmF5LmlzQXJyYXkobWFpblRhYmxlLm5hbWUpID8gdGhpcy5xdW90ZVRhYmxlKG1haW5UYWJsZS5uYW1lKSA6IHRhYmxlTmFtZS5tYXAoKHQpID0+IHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdGhpcy5xdW90ZVRhYmxlKHRbMF0sIHRbMV0pIDogdGhpcy5xdW90ZVRhYmxlKHQsIHRydWUpO1xuICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAoc3ViUXVlcnkgJiYgYXR0cmlidXRlcy5tYWluKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleUF0dCBvZiBtYWluVGFibGUubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLm1haW4uc29tZSgoYXR0cikgPT4ga2V5QXR0ID09PSBhdHRyIHx8IGtleUF0dCA9PT0gYXR0clswXSB8fCBrZXlBdHQgPT09IGF0dHJbMV0pKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5tYWluLnB1c2gobWFpblRhYmxlLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5QXR0XS5maWVsZCA/IFtrZXlBdHQsIG1haW5UYWJsZS5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleUF0dF0uZmllbGRdIDoga2V5QXR0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGVzLm1haW4gPSB0aGlzLmVzY2FwZUF0dHJpYnV0ZXMoYXR0cmlidXRlcy5tYWluLCBvcHRpb25zLCBtYWluVGFibGUuYXMpO1xuICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbiB8fCAob3B0aW9ucy5pbmNsdWRlID8gW2Ake21haW5UYWJsZS5hc30uKmBdIDogW1wiKlwiXSk7XG4gICAgaWYgKHN1YlF1ZXJ5IHx8IG9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICBhdHRyaWJ1dGVzLnN1YlF1ZXJ5ID0gYXR0cmlidXRlcy5tYWluO1xuICAgICAgYXR0cmlidXRlcy5tYWluID0gW2Ake21haW5UYWJsZS5hcyB8fCBtYWluVGFibGUucXVvdGVkTmFtZX0uKmBdO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLnNlcGFyYXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgam9pblF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCB7IGV4dGVybmFsQXM6IG1haW5UYWJsZS5hcywgaW50ZXJuYWxBczogbWFpblRhYmxlLmFzIH0sIHRvcExldmVsSW5mbyk7XG4gICAgICAgIHN1YkpvaW5RdWVyaWVzID0gc3ViSm9pblF1ZXJpZXMuY29uY2F0KGpvaW5RdWVyaWVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgbWFpbkpvaW5RdWVyaWVzID0gbWFpbkpvaW5RdWVyaWVzLmNvbmNhdChqb2luUXVlcmllcy5tYWluUXVlcnkpO1xuICAgICAgICBpZiAoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5tYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4gPSBfLnVuaXEoYXR0cmlidXRlcy5tYWluLmNvbmNhdChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pblF1ZXJpZXMuYXR0cmlidXRlcy5zdWJRdWVyeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IF8udW5pcShhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChqb2luUXVlcmllcy5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICBzdWJRdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMuc3ViUXVlcnksIG1haW5UYWJsZS5xdW90ZWROYW1lLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChzdWJKb2luUXVlcmllcy5qb2luKFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICAgIGlmICghbWFpblRhYmxlLmFzKSB7XG4gICAgICAgICAgbWFpblRhYmxlLmFzID0gbWFpblRhYmxlLnF1b3RlZE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2hlcmUgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy53aGVyZSk7XG4gICAgICAgIGxldCBncm91cGVkTGltaXRPcmRlciwgd2hlcmVLZXksIGluY2x1ZGUsIGdyb3VwZWRUYWJsZU5hbWUgPSBtYWluVGFibGUuYXM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ncm91cGVkTGltaXQub24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB3aGVyZUtleSA9IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uIGluc3RhbmNlb2YgSGFzTWFueSkge1xuICAgICAgICAgIHdoZXJlS2V5ID0gb3B0aW9ucy5ncm91cGVkTGltaXQub24uZm9yZWlnbktleUZpZWxkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdyb3VwZWRMaW1pdC5vbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICBncm91cGVkVGFibGVOYW1lID0gb3B0aW9ucy5ncm91cGVkTGltaXQub24ubWFueUZyb21Tb3VyY2UuYXM7XG4gICAgICAgICAgY29uc3QgZ3JvdXBlZExpbWl0T3B0aW9ucyA9IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMoe1xuICAgICAgICAgICAgaW5jbHVkZTogW3tcbiAgICAgICAgICAgICAgYXNzb2NpYXRpb246IG9wdGlvbnMuZ3JvdXBlZExpbWl0Lm9uLm1hbnlGcm9tU291cmNlLFxuICAgICAgICAgICAgICBkdXBsaWNhdGluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICAgICAgICB3aGVyZTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgICAgIFtPcC5wbGFjZWhvbGRlcl06IHRydWVcbiAgICAgICAgICAgICAgfSwgb3B0aW9ucy5ncm91cGVkTGltaXQudGhyb3VnaCAmJiBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoLndoZXJlKVxuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICBtb2RlbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG9wdGlvbnMuaGFzSm9pbiA9IHRydWU7XG4gICAgICAgICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICBvcHRpb25zLmluY2x1ZGVNYXAgPSBPYmplY3QuYXNzaWduKGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZU1hcCwgb3B0aW9ucy5pbmNsdWRlTWFwKTtcbiAgICAgICAgICBvcHRpb25zLmluY2x1ZGVOYW1lcyA9IGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZU5hbWVzLmNvbmNhdChvcHRpb25zLmluY2x1ZGVOYW1lcyB8fCBbXSk7XG4gICAgICAgICAgaW5jbHVkZSA9IGdyb3VwZWRMaW1pdE9wdGlvbnMuaW5jbHVkZTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyKSkge1xuICAgICAgICAgICAgb3B0aW9ucy5vcmRlci5mb3JFYWNoKChvcmRlciwgaSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmRlcikpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IG9yZGVyWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBhbGlhcyA9IGBzdWJxdWVyeV9vcmRlcl8ke2l9YDtcbiAgICAgICAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzLnB1c2goW29yZGVyLCBhbGlhc10pO1xuICAgICAgICAgICAgICBhbGlhcyA9IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZShhbGlhcykpO1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyW2ldKSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub3JkZXJbaV1bMF0gPSBhbGlhcztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9yZGVyW2ldID0gYWxpYXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZ3JvdXBlZExpbWl0T3JkZXIgPSBvcHRpb25zLm9yZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cGVkTGltaXRPcmRlciA9IG9wdGlvbnMub3JkZXI7XG4gICAgICAgICAgaWYgKCF0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnRvcExldmVsT3JkZXJCeVJlcXVpcmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5vcmRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hlcmVbT3AucGxhY2Vob2xkZXJdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlUXVlcnkgPSBgU0VMRUNUICogRlJPTSAoJHt0aGlzLnNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmdyb3VwZWRMaW1pdC5saW1pdCxcbiAgICAgICAgICBvcmRlcjogZ3JvdXBlZExpbWl0T3JkZXIsXG4gICAgICAgICAgYWxpYXNlc01hcHBpbmc6IG9wdGlvbnMuYWxpYXNlc01hcHBpbmcsXG4gICAgICAgICAgYWxpYXNlc0J5VGFibGU6IG9wdGlvbnMuYWxpYXNlc0J5VGFibGUsXG4gICAgICAgICAgd2hlcmUsXG4gICAgICAgICAgaW5jbHVkZSxcbiAgICAgICAgICBtb2RlbFxuICAgICAgICB9LCBtb2RlbCkucmVwbGFjZSgvOyQvLCBcIlwiKX0pICR7dGhpcy5nZXRBbGlhc1Rva2VuKCl9IHN1YmA7XG4gICAgICAgIGNvbnN0IHBsYWNlSG9sZGVyID0gdGhpcy53aGVyZUl0ZW1RdWVyeShPcC5wbGFjZWhvbGRlciwgdHJ1ZSwgeyBtb2RlbCB9KTtcbiAgICAgICAgY29uc3Qgc3BsaWNlUG9zID0gYmFzZVF1ZXJ5LmluZGV4T2YocGxhY2VIb2xkZXIpO1xuICAgICAgICBtYWluUXVlcnlJdGVtcy5wdXNoKHRoaXMuc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbWFpblRhYmxlLm1vZGVsLCBhdHRyaWJ1dGVzLm1haW4sIGAoJHtvcHRpb25zLmdyb3VwZWRMaW1pdC52YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGxldCBncm91cFdoZXJlO1xuICAgICAgICAgIGlmICh3aGVyZUtleSkge1xuICAgICAgICAgICAgZ3JvdXBXaGVyZSA9IHtcbiAgICAgICAgICAgICAgW3doZXJlS2V5XTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgICBncm91cFdoZXJlID0ge1xuICAgICAgICAgICAgICBbb3B0aW9ucy5ncm91cGVkTGltaXQub24uZm9yZWlnbklkZW50aWZpZXJGaWVsZF06IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gVXRpbHMuc3BsaWNlU3RyKGJhc2VRdWVyeSwgc3BsaWNlUG9zLCBwbGFjZUhvbGRlci5sZW5ndGgsIHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKGdyb3VwV2hlcmUsIGdyb3VwZWRUYWJsZU5hbWUpKTtcbiAgICAgICAgfSkuam9pbih0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiVU5JT04gQUxMXCJdID8gXCIgVU5JT04gQUxMIFwiIDogXCIgVU5JT04gXCIpfSlgLCBtYWluVGFibGUuYXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2godGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtYWluVGFibGUubW9kZWwsIGF0dHJpYnV0ZXMubWFpbiwgbWFpblRhYmxlLnF1b3RlZE5hbWUsIG1haW5UYWJsZS5hcykpO1xuICAgICAgfVxuICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChtYWluSm9pblF1ZXJpZXMuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJ3aGVyZVwiKSAmJiAhb3B0aW9ucy5ncm91cGVkTGltaXQpIHtcbiAgICAgIG9wdGlvbnMud2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhvcHRpb25zLndoZXJlLCBtYWluVGFibGUuYXMgfHwgdGFibGVOYW1lLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy53aGVyZSkge1xuICAgICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBXSEVSRSAke29wdGlvbnMud2hlcmV9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIFdIRVJFICR7b3B0aW9ucy53aGVyZX1gKTtcbiAgICAgICAgICBtYWluUXVlcnlJdGVtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChcIlNFTEVDVFwiKSkge1xuICAgICAgICAgICAgICBtYWluUXVlcnlJdGVtc1trZXldID0gdGhpcy5zZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcy5tYWluLCBtYWluVGFibGUucXVvdGVkTmFtZSwgbWFpblRhYmxlLmFzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ncm91cCkge1xuICAgICAgb3B0aW9ucy5ncm91cCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5ncm91cCkgPyBvcHRpb25zLmdyb3VwLm1hcCgodCkgPT4gdGhpcy5hbGlhc0dyb3VwaW5nKHQsIG1vZGVsLCBtYWluVGFibGUuYXMsIG9wdGlvbnMpKS5qb2luKFwiLCBcIikgOiB0aGlzLmFsaWFzR3JvdXBpbmcob3B0aW9ucy5ncm91cCwgbW9kZWwsIG1haW5UYWJsZS5hcywgb3B0aW9ucyk7XG4gICAgICBpZiAoc3ViUXVlcnkgJiYgb3B0aW9ucy5ncm91cCkge1xuICAgICAgICBzdWJRdWVyeUl0ZW1zLnB1c2goYCBHUk9VUCBCWSAke29wdGlvbnMuZ3JvdXB9YCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIEdST1VQIEJZICR7b3B0aW9ucy5ncm91cH1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImhhdmluZ1wiKSkge1xuICAgICAgb3B0aW9ucy5oYXZpbmcgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhvcHRpb25zLmhhdmluZywgdGFibGVOYW1lLCBtb2RlbCwgb3B0aW9ucywgZmFsc2UpO1xuICAgICAgaWYgKG9wdGlvbnMuaGF2aW5nKSB7XG4gICAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICAgIHN1YlF1ZXJ5SXRlbXMucHVzaChgIEhBVklORyAke29wdGlvbnMuaGF2aW5nfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1haW5RdWVyeUl0ZW1zLnB1c2goYCBIQVZJTkcgJHtvcHRpb25zLmhhdmluZ31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgY29uc3Qgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgc3ViUXVlcnkpO1xuICAgICAgaWYgKG9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChgIE9SREVSIEJZICR7b3JkZXJzLm1haW5RdWVyeU9yZGVyLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGAgT1JERVIgQlkgJHtvcmRlcnMuc3ViUXVlcnlPcmRlci5qb2luKFwiLCBcIil9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0T3JkZXIgPSB0aGlzLmFkZExpbWl0QW5kT2Zmc2V0KG9wdGlvbnMsIG1haW5UYWJsZS5tb2RlbCk7XG4gICAgaWYgKGxpbWl0T3JkZXIgJiYgIW9wdGlvbnMuZ3JvdXBlZExpbWl0KSB7XG4gICAgICBpZiAoc3ViUXVlcnkpIHtcbiAgICAgICAgc3ViUXVlcnlJdGVtcy5wdXNoKGxpbWl0T3JkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFpblF1ZXJ5SXRlbXMucHVzaChsaW1pdE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN1YlF1ZXJ5KSB7XG4gICAgICB0aGlzLl90aHJvd09uRW1wdHlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMubWFpbiwgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGUuYXMgfSk7XG4gICAgICBxdWVyeSA9IGBTRUxFQ1QgJHthdHRyaWJ1dGVzLm1haW4uam9pbihcIiwgXCIpfSBGUk9NICgke3N1YlF1ZXJ5SXRlbXMuam9pbihcIlwiKX0pICR7dGhpcy5nZXRBbGlhc1Rva2VuKCl9ICR7bWFpblRhYmxlLmFzfSR7bWFpbkpvaW5RdWVyaWVzLmpvaW4oXCJcIil9JHttYWluUXVlcnlJdGVtcy5qb2luKFwiXCIpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5ID0gbWFpblF1ZXJ5SXRlbXMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubG9jayAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2spIHtcbiAgICAgIGxldCBsb2NrID0gb3B0aW9ucy5sb2NrO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2sgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbG9jayA9IG9wdGlvbnMubG9jay5sZXZlbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmxvY2tLZXkgJiYgW1wiS0VZIFNIQVJFXCIsIFwiTk8gS0VZIFVQREFURVwiXS5pbmNsdWRlcyhsb2NrKSkge1xuICAgICAgICBxdWVyeSArPSBgIEZPUiAke2xvY2t9YDtcbiAgICAgIH0gZWxzZSBpZiAobG9jayA9PT0gXCJTSEFSRVwiKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGAgJHt0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLmZvclNoYXJlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeSArPSBcIiBGT1IgVVBEQVRFXCI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5sb2NrT2YgJiYgb3B0aW9ucy5sb2NrLm9mICYmIG9wdGlvbnMubG9jay5vZi5wcm90b3R5cGUgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICBxdWVyeSArPSBgIE9GICR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMubG9jay5vZi5uYW1lKX1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuc2tpcExvY2tlZCAmJiBvcHRpb25zLnNraXBMb2NrZWQpIHtcbiAgICAgICAgcXVlcnkgKz0gXCIgU0tJUCBMT0NLRURcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG4gIGFsaWFzR3JvdXBpbmcoZmllbGQsIG1vZGVsLCB0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcmMgPSBBcnJheS5pc0FycmF5KGZpZWxkKSA/IGZpZWxkWzBdIDogZmllbGQ7XG4gICAgcmV0dXJuIHRoaXMucXVvdGUodGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZU5hbWUsIHNyYywgb3B0aW9ucykgfHwgc3JjLCBtb2RlbCk7XG4gIH1cbiAgZXNjYXBlQXR0cmlidXRlcyhhdHRyaWJ1dGVzLCBvcHRpb25zLCBtYWluVGFibGVBcykge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB7XG4gICAgICBsZXQgYWRkVGFibGUgPSB0cnVlO1xuICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikpIHtcbiAgICAgICAgaWYgKGF0dHIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke0pTT04uc3RyaW5naWZ5KGF0dHIpfSBpcyBub3QgYSB2YWxpZCBhdHRyaWJ1dGUgZGVmaW5pdGlvbi4gUGxlYXNlIHVzZSB0aGUgZm9sbG93aW5nIGZvcm1hdDogWydhdHRyaWJ1dGUgZGVmaW5pdGlvbicsICdhbGlhcyddYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IGF0dHIuc2xpY2UoKTtcbiAgICAgICAgaWYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgICBhdHRyWzBdID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QoYXR0clswXSk7XG4gICAgICAgICAgYWRkVGFibGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRlQmVoYXZpb3IgPT09IFwiZXNjYXBlXCIgfHwgIWF0dHJbMF0uaW5jbHVkZXMoXCIoXCIpICYmICFhdHRyWzBdLmluY2x1ZGVzKFwiKVwiKSkge1xuICAgICAgICAgIGF0dHJbMF0gPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuYXR0cmlidXRlQmVoYXZpb3IgIT09IFwidW5zYWZlLWxlZ2FjeVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGVzIGNhbm5vdCBpbmNsdWRlIHBhcmVudGhlc2VzIGluIFNlcXVlbGl6ZSA2OlxuSW4gb3JkZXIgdG8gZml4IHRoZSB2dWxuZXJhYmlsaXR5IENWRS0yMDIzLTIyNTc4LCB3ZSBoYWQgdG8gcmVtb3ZlIHN1cHBvcnQgZm9yIHRyZWF0aW5nIGF0dHJpYnV0ZXMgYXMgcmF3IFNRTCBpZiB0aGV5IGluY2x1ZGVkIHBhcmVudGhlc2VzLlxuU2VxdWVsaXplIDcgZXNjYXBlcyBhbGwgYXR0cmlidXRlcywgZXZlbiBpZiB0aGV5IGluY2x1ZGUgcGFyZW50aGVzZXMuXG5Gb3IgU2VxdWVsaXplIDYsIGJlY2F1c2Ugd2UncmUgaW50cm9kdWNpbmcgdGhpcyBjaGFuZ2UgaW4gYSBtaW5vciByZWxlYXNlLCB3ZSd2ZSBvcHRlZCBmb3IgdGhyb3dpbmcgYW4gZXJyb3IgaW5zdGVhZCBvZiBzaWxlbnRseSBlc2NhcGluZyB0aGUgYXR0cmlidXRlIGFzIGEgd2F5IHRvIHdhcm4geW91IGFib3V0IHRoaXMgY2hhbmdlLlxuXG5IZXJlIGlzIHdoYXQgeW91IGNhbiBkbyB0byBmaXggdGhpcyBlcnJvcjpcbi0gV3JhcCB0aGUgYXR0cmlidXRlIGluIGEgbGl0ZXJhbCgpIGNhbGwuIFRoaXMgd2lsbCBtYWtlIFNlcXVlbGl6ZSB0cmVhdCBpdCBhcyByYXcgU1FMLlxuLSBTZXQgdGhlIFwiYXR0cmlidXRlQmVoYXZpb3JcIiBzZXF1ZWxpemUgb3B0aW9uIHRvIFwiZXNjYXBlXCIgdG8gbWFrZSBTZXF1ZWxpemUgZXNjYXBlIHRoZSBhdHRyaWJ1dGUsIGxpa2UgaW4gU2VxdWVsaXplIHY3LiBXZSBoaWdobHkgcmVjb21tZW5kIHRoaXMgb3B0aW9uLlxuLSBTZXQgdGhlIFwiYXR0cmlidXRlQmVoYXZpb3JcIiBzZXF1ZWxpemUgb3B0aW9uIHRvIFwidW5zYWZlLWxlZ2FjeVwiIHRvIG1ha2UgU2VxdWVsaXplIGVzY2FwZSB0aGUgYXR0cmlidXRlLCBsaWtlIGluIFNlcXVlbGl6ZSB2NS5cblxuV2Ugc2luY2VyZWx5IGFwb2xvZ2l6ZSBmb3IgdGhlIGluY29udmVuaWVuY2UgdGhpcyBtYXkgY2F1c2UgeW91LiBZb3UgY2FuIGZpbmQgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgZm9sbG93aW5nIHRocmVhZHM6XG5odHRwczovL2dpdGh1Yi5jb20vc2VxdWVsaXplL3NlcXVlbGl6ZS9zZWN1cml0eS9hZHZpc29yaWVzL0dIU0EtZjU5OC1tZnB2LWdtZnhcbmh0dHBzOi8vZ2l0aHViLmNvbS9zZXF1ZWxpemUvc2VxdWVsaXplL2Rpc2N1c3Npb25zLzE1Njk0YCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWFzID0gYXR0clsxXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgICAgYWxpYXMgPSB0aGlzLl9nZXRNaW5pZmllZEFsaWFzKGFsaWFzLCBtYWluVGFibGVBcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYXR0ciA9IFthdHRyWzBdLCB0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhcyldLmpvaW4oXCIgQVMgXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0ciA9ICFhdHRyLmluY2x1ZGVzKFV0aWxzLlRJQ0tfQ0hBUikgJiYgIWF0dHIuaW5jbHVkZXMoJ1wiJykgPyB0aGlzLnF1b3RlQXR0cmlidXRlKGF0dHIsIG9wdGlvbnMubW9kZWwpIDogdGhpcy5lc2NhcGUoYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNFbXB0eShvcHRpb25zLmluY2x1ZGUpICYmICghYXR0ci5pbmNsdWRlcyhcIi5cIikgfHwgb3B0aW9ucy5kb3ROb3RhdGlvbikgJiYgYWRkVGFibGUpIHtcbiAgICAgICAgYXR0ciA9IGAke21haW5UYWJsZUFzfS4ke2F0dHJ9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCBwYXJlbnRUYWJsZU5hbWUsIHRvcExldmVsSW5mbykge1xuICAgIGNvbnN0IGpvaW5RdWVyaWVzID0ge1xuICAgICAgbWFpblF1ZXJ5OiBbXSxcbiAgICAgIHN1YlF1ZXJ5OiBbXVxuICAgIH07XG4gICAgY29uc3QgbWFpbkNoaWxkSW5jbHVkZXMgPSBbXTtcbiAgICBjb25zdCBzdWJDaGlsZEluY2x1ZGVzID0gW107XG4gICAgbGV0IHJlcXVpcmVkTWlzbWF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCBpbmNsdWRlQXMgPSB7XG4gICAgICBpbnRlcm5hbEFzOiBpbmNsdWRlLmFzLFxuICAgICAgZXh0ZXJuYWxBczogaW5jbHVkZS5hc1xuICAgIH07XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBsZXQgam9pblF1ZXJ5O1xuICAgIHRvcExldmVsSW5mby5vcHRpb25zLmtleXNFc2NhcGVkID0gdHJ1ZTtcbiAgICBpZiAodG9wTGV2ZWxJbmZvLm5hbWVzLm5hbWUgIT09IHBhcmVudFRhYmxlTmFtZS5leHRlcm5hbEFzICYmIHRvcExldmVsSW5mby5uYW1lcy5hcyAhPT0gcGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXMpIHtcbiAgICAgIGluY2x1ZGVBcy5pbnRlcm5hbEFzID0gYCR7cGFyZW50VGFibGVOYW1lLmludGVybmFsQXN9LT4ke2luY2x1ZGUuYXN9YDtcbiAgICAgIGluY2x1ZGVBcy5leHRlcm5hbEFzID0gYCR7cGFyZW50VGFibGVOYW1lLmV4dGVybmFsQXN9LiR7aW5jbHVkZS5hc31gO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXMgIT09IGZhbHNlKSB7XG4gICAgICBpbmNsdWRlLm1vZGVsLl9leHBhbmRBdHRyaWJ1dGVzKGluY2x1ZGUpO1xuICAgICAgVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICAgIGNvbnN0IGluY2x1ZGVBdHRyaWJ1dGVzID0gaW5jbHVkZS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4ge1xuICAgICAgICBsZXQgYXR0ckFzID0gYXR0cjtcbiAgICAgICAgbGV0IHZlcmJhdGltID0gZmFsc2U7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHIpICYmIGF0dHIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgaWYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgJiYgKGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsIHx8IGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5DYXN0IHx8IGF0dHJbMF0gaW5zdGFuY2VvZiBVdGlscy5GbikpIHtcbiAgICAgICAgICAgIHZlcmJhdGltID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0ciA9IGF0dHIubWFwKChhdHRyMikgPT4gYXR0cjIgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgPyB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhdHRyMikgOiBhdHRyMik7XG4gICAgICAgICAgYXR0ckFzID0gYXR0clsxXTtcbiAgICAgICAgICBhdHRyID0gYXR0clswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0ciBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICByZXR1cm4gYXR0ci52YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5DYXN0IHx8IGF0dHIgaW5zdGFuY2VvZiBVdGlscy5Gbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIHNlbGVjdCBhdHRyaWJ1dGVzIHVzaW5nIFNlcXVlbGl6ZS5jYXN0IG9yIFNlcXVlbGl6ZS5mbiB3aXRob3V0IHNwZWNpZnlpbmcgYW4gYWxpYXMgZm9yIHRoZSByZXN1bHQsIGR1cmluZyBlYWdlciBsb2FkaW5nLiBUaGlzIG1lYW5zIHRoZSBhdHRyaWJ1dGUgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIHJldHVybmVkIGluc3RhbmNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVmaXg7XG4gICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHByZWZpeCA9IGF0dHI7XG4gICAgICAgIH0gZWxzZSBpZiAoLyM+PnwtPj4vLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5jbHVkZUFzLmludGVybmFsQXMpfS4ke2F0dHIucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKX0pYDtcbiAgICAgICAgfSBlbHNlIGlmICgvanNvbl9leHRyYWN0XFwoLy50ZXN0KGF0dHIpKSB7XG4gICAgICAgICAgcHJlZml4ID0gYXR0ci5yZXBsYWNlKC9qc29uX2V4dHJhY3RcXCgvaSwgYGpzb25fZXh0cmFjdCgke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uYCk7XG4gICAgICAgIH0gZWxzZSBpZiAoL2pzb25fdmFsdWVcXCgvLnRlc3QoYXR0cikpIHtcbiAgICAgICAgICBwcmVmaXggPSBhdHRyLnJlcGxhY2UoL2pzb25fdmFsdWVcXCgvaSwgYGpzb25fdmFsdWUoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcyl9LmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZWZpeCA9IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluY2x1ZGVBcy5pbnRlcm5hbEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbGlhcyA9IGAke2luY2x1ZGVBcy5leHRlcm5hbEFzfS4ke2F0dHJBc31gO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1pbmlmeUFsaWFzZXMpIHtcbiAgICAgICAgICBhbGlhcyA9IHRoaXMuX2dldE1pbmlmaWVkQWxpYXMoYWxpYXMsIGluY2x1ZGVBcy5pbnRlcm5hbEFzLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICBcIkFTXCIsXG4gICAgICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYWxpYXMsIHRydWUpXG4gICAgICAgIF0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSAmJiB0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIGluY2x1ZGVBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeS5wdXNoKGF0dHIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgaW5jbHVkZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzLm1haW4ucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5jbHVkZS50aHJvdWdoKSB7XG4gICAgICBqb2luUXVlcnkgPSB0aGlzLmdlbmVyYXRlVGhyb3VnaEpvaW4oaW5jbHVkZSwgaW5jbHVkZUFzLCBwYXJlbnRUYWJsZU5hbWUuaW50ZXJuYWxBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVTdWJRdWVyeUZpbHRlcihpbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG4gICAgICBqb2luUXVlcnkgPSB0aGlzLmdlbmVyYXRlSm9pbihpbmNsdWRlLCB0b3BMZXZlbEluZm8pO1xuICAgIH1cbiAgICBpZiAoam9pblF1ZXJ5LmF0dHJpYnV0ZXMubWFpbi5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyaWJ1dGVzLm1haW4gPSBhdHRyaWJ1dGVzLm1haW4uY29uY2F0KGpvaW5RdWVyeS5hdHRyaWJ1dGVzLm1haW4pO1xuICAgIH1cbiAgICBpZiAoam9pblF1ZXJ5LmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlcy5zdWJRdWVyeSA9IGF0dHJpYnV0ZXMuc3ViUXVlcnkuY29uY2F0KGpvaW5RdWVyeS5hdHRyaWJ1dGVzLnN1YlF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZEluY2x1ZGUgb2YgaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgIGlmIChjaGlsZEluY2x1ZGUuc2VwYXJhdGUgfHwgY2hpbGRJbmNsdWRlLl9wc2V1ZG8pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZEpvaW5RdWVyaWVzID0gdGhpcy5nZW5lcmF0ZUluY2x1ZGUoY2hpbGRJbmNsdWRlLCBpbmNsdWRlQXMsIHRvcExldmVsSW5mbyk7XG4gICAgICAgIGlmIChpbmNsdWRlLnJlcXVpcmVkID09PSBmYWxzZSAmJiBjaGlsZEluY2x1ZGUucmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgICByZXF1aXJlZE1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRJbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgICAgIHN1YkNoaWxkSW5jbHVkZXMucHVzaChjaGlsZEpvaW5RdWVyaWVzLnN1YlF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5tYWluUXVlcnkpIHtcbiAgICAgICAgICBtYWluQ2hpbGRJbmNsdWRlcy5wdXNoKGNoaWxkSm9pblF1ZXJpZXMubWFpblF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMubWFpbiA9IGF0dHJpYnV0ZXMubWFpbi5jb25jYXQoY2hpbGRKb2luUXVlcmllcy5hdHRyaWJ1dGVzLm1haW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0dHJpYnV0ZXMuc3ViUXVlcnkgPSBhdHRyaWJ1dGVzLnN1YlF1ZXJ5LmNvbmNhdChjaGlsZEpvaW5RdWVyaWVzLmF0dHJpYnV0ZXMuc3ViUXVlcnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5ICYmIHRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgaWYgKHJlcXVpcmVkTWlzbWF0Y2ggJiYgc3ViQ2hpbGRJbmNsdWRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAoICR7am9pblF1ZXJ5LmJvZHl9JHtzdWJDaGlsZEluY2x1ZGVzLmpvaW4oXCJcIil9ICkgT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgam9pblF1ZXJpZXMuc3ViUXVlcnkucHVzaChgICR7am9pblF1ZXJ5LmpvaW59ICR7am9pblF1ZXJ5LmJvZHl9IE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgICAgaWYgKHN1YkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LnB1c2goc3ViQ2hpbGRJbmNsdWRlcy5qb2luKFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2gobWFpbkNoaWxkSW5jbHVkZXMuam9pbihcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZXF1aXJlZE1pc21hdGNoICYmIG1haW5DaGlsZEluY2x1ZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgam9pblF1ZXJpZXMubWFpblF1ZXJ5LnB1c2goYCAke2pvaW5RdWVyeS5qb2lufSAoICR7am9pblF1ZXJ5LmJvZHl9JHttYWluQ2hpbGRJbmNsdWRlcy5qb2luKFwiXCIpfSApIE9OICR7am9pblF1ZXJ5LmNvbmRpdGlvbn1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKGAgJHtqb2luUXVlcnkuam9pbn0gJHtqb2luUXVlcnkuYm9keX0gT04gJHtqb2luUXVlcnkuY29uZGl0aW9ufWApO1xuICAgICAgICBpZiAobWFpbkNoaWxkSW5jbHVkZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGpvaW5RdWVyaWVzLm1haW5RdWVyeS5wdXNoKG1haW5DaGlsZEluY2x1ZGVzLmpvaW4oXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqb2luUXVlcmllcy5zdWJRdWVyeS5wdXNoKHN1YkNoaWxkSW5jbHVkZXMuam9pbihcIlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtYWluUXVlcnk6IGpvaW5RdWVyaWVzLm1haW5RdWVyeS5qb2luKFwiXCIpLFxuICAgICAgc3ViUXVlcnk6IGpvaW5RdWVyaWVzLnN1YlF1ZXJ5LmpvaW4oXCJcIiksXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfTtcbiAgfVxuICBfZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgdGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7YWxpYXN9YF0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFsaWFzZXNCeVRhYmxlW2Ake3RhYmxlTmFtZX0ke2FsaWFzfWBdO1xuICAgIH1cbiAgICBpZiAoYWxpYXMubWF0Y2goL3N1YnF1ZXJ5X29yZGVyX1swLTldLykpIHtcbiAgICAgIHJldHVybiBhbGlhcztcbiAgICB9XG4gICAgY29uc3QgbWluaWZpZWRBbGlhcyA9IGBfJHtvcHRpb25zLmFsaWFzZXNNYXBwaW5nLnNpemV9YDtcbiAgICBvcHRpb25zLmFsaWFzZXNNYXBwaW5nLnNldChtaW5pZmllZEFsaWFzLCBhbGlhcyk7XG4gICAgb3B0aW9ucy5hbGlhc2VzQnlUYWJsZVtgJHt0YWJsZU5hbWV9JHthbGlhc31gXSA9IG1pbmlmaWVkQWxpYXM7XG4gICAgcmV0dXJuIG1pbmlmaWVkQWxpYXM7XG4gIH1cbiAgX2dldEFsaWFzRm9yRmllbGQodGFibGVOYW1lLCBmaWVsZCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubWluaWZ5QWxpYXNlcykge1xuICAgICAgaWYgKG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7ZmllbGR9YF0pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYWxpYXNlc0J5VGFibGVbYCR7dGFibGVOYW1lfSR7ZmllbGR9YF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdlbmVyYXRlSm9pbihpbmNsdWRlLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCBhc3NvY2lhdGlvbiA9IGluY2x1ZGUuYXNzb2NpYXRpb247XG4gICAgY29uc3QgcGFyZW50ID0gaW5jbHVkZS5wYXJlbnQ7XG4gICAgY29uc3QgcGFyZW50SXNUb3AgPSAhIXBhcmVudCAmJiAhaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gJiYgaW5jbHVkZS5wYXJlbnQubW9kZWwubmFtZSA9PT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubW9kZWwubmFtZTtcbiAgICBsZXQgJHBhcmVudDtcbiAgICBsZXQgam9pbldoZXJlO1xuICAgIGNvbnN0IGxlZnQgPSBhc3NvY2lhdGlvbi5zb3VyY2U7XG4gICAgY29uc3QgYXR0ckxlZnQgPSBhc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbyA/IGFzc29jaWF0aW9uLmlkZW50aWZpZXIgOiBhc3NvY2lhdGlvbi5zb3VyY2VLZXlBdHRyaWJ1dGUgfHwgbGVmdC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IGZpZWxkTGVmdCA9IGFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvID8gYXNzb2NpYXRpb24uaWRlbnRpZmllckZpZWxkIDogbGVmdC5yYXdBdHRyaWJ1dGVzW2Fzc29jaWF0aW9uLnNvdXJjZUtleUF0dHJpYnV0ZSB8fCBsZWZ0LnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkO1xuICAgIGxldCBhc0xlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSBpbmNsdWRlLm1vZGVsO1xuICAgIGNvbnN0IHRhYmxlUmlnaHQgPSByaWdodC5nZXRUYWJsZU5hbWUoKTtcbiAgICBjb25zdCBmaWVsZFJpZ2h0ID0gYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gPyByaWdodC5yYXdBdHRyaWJ1dGVzW2Fzc29jaWF0aW9uLnRhcmdldElkZW50aWZpZXIgfHwgcmlnaHQucHJpbWFyeUtleUF0dHJpYnV0ZV0uZmllbGQgOiBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgbGV0IGFzUmlnaHQgPSBpbmNsdWRlLmFzO1xuICAgIHdoaWxlICgoJHBhcmVudCA9ICRwYXJlbnQgJiYgJHBhcmVudC5wYXJlbnQgfHwgaW5jbHVkZS5wYXJlbnQpICYmICRwYXJlbnQuYXNzb2NpYXRpb24pIHtcbiAgICAgIGlmIChhc0xlZnQpIHtcbiAgICAgICAgYXNMZWZ0ID0gYCR7JHBhcmVudC5hc30tPiR7YXNMZWZ0fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc0xlZnQgPSAkcGFyZW50LmFzO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFzTGVmdClcbiAgICAgIGFzTGVmdCA9IHBhcmVudC5hcyB8fCBwYXJlbnQubW9kZWwubmFtZTtcbiAgICBlbHNlXG4gICAgICBhc1JpZ2h0ID0gYCR7YXNMZWZ0fS0+JHthc1JpZ2h0fWA7XG4gICAgbGV0IGpvaW5PbiA9IGAke3RoaXMucXVvdGVUYWJsZShhc0xlZnQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkTGVmdCl9YDtcbiAgICBjb25zdCBzdWJxdWVyeUF0dHJpYnV0ZXMgPSBbXTtcbiAgICBpZiAodG9wTGV2ZWxJbmZvLm9wdGlvbnMuZ3JvdXBlZExpbWl0ICYmIHBhcmVudElzVG9wIHx8IHRvcExldmVsSW5mby5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiAhaW5jbHVkZS5zdWJRdWVyeSkge1xuICAgICAgaWYgKHBhcmVudElzVG9wKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShwYXJlbnQuYXMgfHwgcGFyZW50Lm1vZGVsLm5hbWUpO1xuICAgICAgICBqb2luT24gPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKHRhYmxlTmFtZSwgYXR0ckxlZnQsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBgJHt0YWJsZU5hbWV9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckxlZnQpfWA7XG4gICAgICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkpIHtcbiAgICAgICAgICBjb25zdCBkYklkZW50aWZpZXIgPSBgJHt0YWJsZU5hbWV9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGRMZWZ0KX1gO1xuICAgICAgICAgIHN1YnF1ZXJ5QXR0cmlidXRlcy5wdXNoKGRiSWRlbnRpZmllciAhPT0gam9pbk9uID8gYCR7ZGJJZGVudGlmaWVyfSBBUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJMZWZ0KX1gIDogZGJJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgam9pblNvdXJjZSA9IGAke2FzTGVmdC5yZXBsYWNlKC8tPi9nLCBcIi5cIil9LiR7YXR0ckxlZnR9YDtcbiAgICAgICAgam9pbk9uID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZChhc0xlZnQsIGpvaW5Tb3VyY2UsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCB0aGlzLnF1b3RlSWRlbnRpZmllcihqb2luU291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgam9pbk9uICs9IGAgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkUmlnaHQpfWA7XG4gICAgaWYgKGluY2x1ZGUub24pIHtcbiAgICAgIGpvaW5PbiA9IHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGluY2x1ZGUub24sIHtcbiAgICAgICAgcHJlZml4OiB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKHRoaXMucXVvdGVJZGVudGlmaWVyKGFzUmlnaHQpKSxcbiAgICAgICAgbW9kZWw6IGluY2x1ZGUubW9kZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZS53aGVyZSkge1xuICAgICAgam9pbldoZXJlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaW5jbHVkZS53aGVyZSwge1xuICAgICAgICBwcmVmaXg6IHRoaXMuc2VxdWVsaXplLmxpdGVyYWwodGhpcy5xdW90ZUlkZW50aWZpZXIoYXNSaWdodCkpLFxuICAgICAgICBtb2RlbDogaW5jbHVkZS5tb2RlbFxuICAgICAgfSk7XG4gICAgICBpZiAoam9pbldoZXJlKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLm9yKSB7XG4gICAgICAgICAgam9pbk9uICs9IGAgT1IgJHtqb2luV2hlcmV9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqb2luT24gKz0gYCBBTkQgJHtqb2luV2hlcmV9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFsaWFzQXMoYXNSaWdodCwgdG9wTGV2ZWxJbmZvKTtcbiAgICByZXR1cm4ge1xuICAgICAgam9pbjogaW5jbHVkZS5yZXF1aXJlZCA/IFwiSU5ORVIgSk9JTlwiIDogaW5jbHVkZS5yaWdodCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiUklHSFQgSk9JTlwiXSA/IFwiUklHSFQgT1VURVIgSk9JTlwiIDogXCJMRUZUIE9VVEVSIEpPSU5cIixcbiAgICAgIGJvZHk6IHRoaXMucXVvdGVUYWJsZSh0YWJsZVJpZ2h0LCBhc1JpZ2h0KSxcbiAgICAgIGNvbmRpdGlvbjogam9pbk9uLFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBtYWluOiBbXSxcbiAgICAgICAgc3ViUXVlcnk6IHN1YnF1ZXJ5QXR0cmlidXRlc1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVSZXR1cm5WYWx1ZXMobW9kZWxBdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmV0dXJuRmllbGRzID0gW107XG4gICAgY29uc3QgcmV0dXJuVHlwZXMgPSBbXTtcbiAgICBsZXQgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCByZXR1cm5pbmdGcmFnbWVudCA9IFwiXCI7XG4gICAgbGV0IHRtcFRhYmxlID0gXCJcIjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJldHVybmluZykpIHtcbiAgICAgIHJldHVybkZpZWxkcy5wdXNoKC4uLm9wdGlvbnMucmV0dXJuaW5nLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkpO1xuICAgIH0gZWxzZSBpZiAobW9kZWxBdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2gobW9kZWxBdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiB7XG4gICAgICAgIGlmICghKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlZJUlRVQUwpKSB7XG4gICAgICAgICAgcmV0dXJuRmllbGRzLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLmZpZWxkKSk7XG4gICAgICAgICAgcmV0dXJuVHlwZXMucHVzaChhdHRyaWJ1dGUudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXy5pc0VtcHR5KHJldHVybkZpZWxkcykpIHtcbiAgICAgIHJldHVybkZpZWxkcy5wdXNoKFwiKlwiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMucmV0dXJuVmFsdWVzLnJldHVybmluZykge1xuICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSBgIFJFVFVSTklORyAke3JldHVybkZpZWxkcy5qb2luKFwiLFwiKX1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlhbGVjdC5zdXBwb3J0cy5yZXR1cm5JbnRvVmFsdWVzKSB7XG4gICAgICByZXR1cm5pbmdGcmFnbWVudCA9IGAgUkVUVVJOSU5HICR7cmV0dXJuRmllbGRzLmpvaW4oXCIsXCIpfSBJTlRPIGA7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9kaWFsZWN0LnN1cHBvcnRzLnJldHVyblZhbHVlcy5vdXRwdXQpIHtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gYCBPVVRQVVQgJHtyZXR1cm5GaWVsZHMubWFwKChmaWVsZCkgPT4gYElOU0VSVEVELiR7ZmllbGR9YCkuam9pbihcIixcIil9YDtcbiAgICAgIGlmIChvcHRpb25zLmhhc1RyaWdnZXIgJiYgdGhpcy5fZGlhbGVjdC5zdXBwb3J0cy50bXBUYWJsZVRyaWdnZXIpIHtcbiAgICAgICAgY29uc3QgdG1wQ29sdW1ucyA9IHJldHVybkZpZWxkcy5tYXAoKGZpZWxkLCBpKSA9PiBgJHtmaWVsZH0gJHtyZXR1cm5UeXBlc1tpXS50b1NxbCgpfWApO1xuICAgICAgICB0bXBUYWJsZSA9IGBERUNMQVJFIEB0bXAgVEFCTEUgKCR7dG1wQ29sdW1ucy5qb2luKFwiLFwiKX0pOyBgO1xuICAgICAgICBvdXRwdXRGcmFnbWVudCArPSBcIiBJTlRPIEB0bXBcIjtcbiAgICAgICAgcmV0dXJuaW5nRnJhZ21lbnQgPSBcIjsgU0VMRUNUICogRlJPTSBAdG1wXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG91dHB1dEZyYWdtZW50LCByZXR1cm5GaWVsZHMsIHJldHVyblR5cGVzLCByZXR1cm5pbmdGcmFnbWVudCwgdG1wVGFibGUgfTtcbiAgfVxuICBnZW5lcmF0ZVRocm91Z2hKb2luKGluY2x1ZGUsIGluY2x1ZGVBcywgcGFyZW50VGFibGVOYW1lLCB0b3BMZXZlbEluZm8pIHtcbiAgICBjb25zdCB0aHJvdWdoID0gaW5jbHVkZS50aHJvdWdoO1xuICAgIGNvbnN0IHRocm91Z2hUYWJsZSA9IHRocm91Z2gubW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgY29uc3QgdGhyb3VnaEFzID0gYCR7aW5jbHVkZUFzLmludGVybmFsQXN9LT4ke3Rocm91Z2guYXN9YDtcbiAgICBjb25zdCBleHRlcm5hbFRocm91Z2hBcyA9IGAke2luY2x1ZGVBcy5leHRlcm5hbEFzfS4ke3Rocm91Z2guYXN9YDtcbiAgICBjb25zdCB0aHJvdWdoQXR0cmlidXRlcyA9IHRocm91Z2guYXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHtcbiAgICAgIGxldCBhbGlhcyA9IGAke2V4dGVybmFsVGhyb3VnaEFzfS4ke0FycmF5LmlzQXJyYXkoYXR0cikgPyBhdHRyWzFdIDogYXR0cn1gO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzKSB7XG4gICAgICAgIGFsaWFzID0gdGhpcy5fZ2V0TWluaWZpZWRBbGlhcyhhbGlhcywgdGhyb3VnaEFzLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRocm91Z2hBcyl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoQXJyYXkuaXNBcnJheShhdHRyKSA/IGF0dHJbMF0gOiBhdHRyKX1gLFxuICAgICAgICBcIkFTXCIsXG4gICAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGFsaWFzKVxuICAgICAgXSk7XG4gICAgfSk7XG4gICAgY29uc3QgYXNzb2NpYXRpb24gPSBpbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIGNvbnN0IHBhcmVudElzVG9wID0gIWluY2x1ZGUucGFyZW50LmFzc29jaWF0aW9uICYmIGluY2x1ZGUucGFyZW50Lm1vZGVsLm5hbWUgPT09IHRvcExldmVsSW5mby5vcHRpb25zLm1vZGVsLm5hbWU7XG4gICAgY29uc3QgdGFibGVTb3VyY2UgPSBwYXJlbnRUYWJsZU5hbWU7XG4gICAgY29uc3QgaWRlbnRTb3VyY2UgPSBhc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgY29uc3QgdGFibGVUYXJnZXQgPSBpbmNsdWRlQXMuaW50ZXJuYWxBcztcbiAgICBjb25zdCBpZGVudFRhcmdldCA9IGFzc29jaWF0aW9uLmZvcmVpZ25JZGVudGlmaWVyRmllbGQ7XG4gICAgY29uc3QgYXR0clRhcmdldCA9IGFzc29jaWF0aW9uLnRhcmdldEtleUZpZWxkO1xuICAgIGNvbnN0IGpvaW5UeXBlID0gaW5jbHVkZS5yZXF1aXJlZCA/IFwiSU5ORVIgSk9JTlwiIDogaW5jbHVkZS5yaWdodCAmJiB0aGlzLl9kaWFsZWN0LnN1cHBvcnRzW1wiUklHSFQgSk9JTlwiXSA/IFwiUklHSFQgT1VURVIgSk9JTlwiIDogXCJMRUZUIE9VVEVSIEpPSU5cIjtcbiAgICBsZXQgam9pbkJvZHk7XG4gICAgbGV0IGpvaW5Db25kaXRpb247XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHtcbiAgICAgIG1haW46IFtdLFxuICAgICAgc3ViUXVlcnk6IFtdXG4gICAgfTtcbiAgICBsZXQgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleTtcbiAgICBsZXQgc291cmNlSm9pbk9uO1xuICAgIGxldCB0YXJnZXRKb2luT247XG4gICAgbGV0IHRocm91Z2hXaGVyZTtcbiAgICBsZXQgdGFyZ2V0V2hlcmU7XG4gICAgaWYgKHRvcExldmVsSW5mby5vcHRpb25zLmluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzICE9PSBmYWxzZSkge1xuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIHRocm91Z2hBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMubWFpbi5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRvcExldmVsSW5mby5zdWJRdWVyeSkge1xuICAgICAgYXR0clNvdXJjZSA9IGFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxJbmZvLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnN1YlF1ZXJ5ICYmICFpbmNsdWRlLnBhcmVudC5zdWJRdWVyeSAmJiBpbmNsdWRlLnBhcmVudC5tb2RlbCAhPT0gdG9wTGV2ZWxJbmZvLm9wdGlvbnMubWFpbk1vZGVsKSB7XG4gICAgICBhdHRyU291cmNlID0gYXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQ7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbEluZm8uc3ViUXVlcnkgJiYgIWluY2x1ZGUuc3ViUXVlcnkgJiYgaW5jbHVkZS5wYXJlbnQuc3ViUXVlcnkgJiYgIXBhcmVudElzVG9wKSB7XG4gICAgICBjb25zdCBqb2luU291cmNlID0gdGhpcy5fZ2V0QWxpYXNGb3JGaWVsZCh0YWJsZVNvdXJjZSwgYCR7dGFibGVTb3VyY2V9LiR7YXR0clNvdXJjZX1gLCB0b3BMZXZlbEluZm8ub3B0aW9ucykgfHwgYCR7dGFibGVTb3VyY2V9LiR7YXR0clNvdXJjZX1gO1xuICAgICAgc291cmNlSm9pbk9uID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoam9pblNvdXJjZSl9ID0gYDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxpYXNlZFNvdXJjZSA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGFibGVTb3VyY2UsIGF0dHJTb3VyY2UsIHRvcExldmVsSW5mby5vcHRpb25zKSB8fCBhdHRyU291cmNlO1xuICAgICAgc291cmNlSm9pbk9uID0gYCR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlU291cmNlKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhbGlhc2VkU291cmNlKX0gPSBgO1xuICAgIH1cbiAgICBzb3VyY2VKb2luT24gKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudFNvdXJjZSl9YDtcbiAgICB0YXJnZXRKb2luT24gPSBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZVRhcmdldCl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0clRhcmdldCl9ID0gYDtcbiAgICB0YXJnZXRKb2luT24gKz0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGhyb3VnaEFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpZGVudFRhcmdldCl9YDtcbiAgICBpZiAodGhyb3VnaC53aGVyZSkge1xuICAgICAgdGhyb3VnaFdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnModGhyb3VnaC53aGVyZSwgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcih0aHJvdWdoQXMpKSwgdGhyb3VnaC5tb2RlbCk7XG4gICAgfVxuICAgIHRoaXMuYWxpYXNBcyhpbmNsdWRlQXMuaW50ZXJuYWxBcywgdG9wTGV2ZWxJbmZvKTtcbiAgICBqb2luQm9keSA9IGAoICR7dGhpcy5xdW90ZVRhYmxlKHRocm91Z2hUYWJsZSwgdGhyb3VnaEFzKX0gSU5ORVIgSk9JTiAke3RoaXMucXVvdGVUYWJsZShpbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCBpbmNsdWRlQXMuaW50ZXJuYWxBcyl9IE9OICR7dGFyZ2V0Sm9pbk9ufWA7XG4gICAgaWYgKHRocm91Z2hXaGVyZSkge1xuICAgICAgam9pbkJvZHkgKz0gYCBBTkQgJHt0aHJvdWdoV2hlcmV9YDtcbiAgICB9XG4gICAgam9pbkJvZHkgKz0gXCIpXCI7XG4gICAgam9pbkNvbmRpdGlvbiA9IHNvdXJjZUpvaW5PbjtcbiAgICBpZiAoaW5jbHVkZS53aGVyZSB8fCBpbmNsdWRlLnRocm91Z2gud2hlcmUpIHtcbiAgICAgIGlmIChpbmNsdWRlLndoZXJlKSB7XG4gICAgICAgIHRhcmdldFdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMoaW5jbHVkZS53aGVyZSwgdGhpcy5zZXF1ZWxpemUubGl0ZXJhbCh0aGlzLnF1b3RlSWRlbnRpZmllcihpbmNsdWRlQXMuaW50ZXJuYWxBcykpLCBpbmNsdWRlLm1vZGVsLCB0b3BMZXZlbEluZm8ub3B0aW9ucyk7XG4gICAgICAgIGlmICh0YXJnZXRXaGVyZSkge1xuICAgICAgICAgIGpvaW5Db25kaXRpb24gKz0gYCBBTkQgJHt0YXJnZXRXaGVyZX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2dlbmVyYXRlU3ViUXVlcnlGaWx0ZXIoaW5jbHVkZSwgaW5jbHVkZUFzLCB0b3BMZXZlbEluZm8pO1xuICAgIHJldHVybiB7XG4gICAgICBqb2luOiBqb2luVHlwZSxcbiAgICAgIGJvZHk6IGpvaW5Cb2R5LFxuICAgICAgY29uZGl0aW9uOiBqb2luQ29uZGl0aW9uLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH07XG4gIH1cbiAgYWxpYXNBcyhhcywgdG9wTGV2ZWxJbmZvKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5taW5pZnlBbGlhc2VzICYmIGFzLmxlbmd0aCA+PSA2NCkge1xuICAgICAgY29uc3QgYWxpYXMgPSBgJSR7dG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMuc2l6ZX1gO1xuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMuc2V0KGFsaWFzLCBhcyk7XG4gICAgfVxuICB9XG4gIF9nZW5lcmF0ZVN1YlF1ZXJ5RmlsdGVyKGluY2x1ZGUsIGluY2x1ZGVBcywgdG9wTGV2ZWxJbmZvKSB7XG4gICAgaWYgKCF0b3BMZXZlbEluZm8uc3ViUXVlcnkgfHwgIWluY2x1ZGUuc3ViUXVlcnlGaWx0ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZSkge1xuICAgICAgdG9wTGV2ZWxJbmZvLm9wdGlvbnMud2hlcmUgPSB7fTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IGluY2x1ZGU7XG4gICAgbGV0IGNoaWxkID0gaW5jbHVkZTtcbiAgICBsZXQgbmVzdGVkSW5jbHVkZXMgPSB0aGlzLl9nZXRSZXF1aXJlZENsb3N1cmUoaW5jbHVkZSkuaW5jbHVkZTtcbiAgICBsZXQgcXVlcnk7XG4gICAgd2hpbGUgKHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQucGFyZW50ICYmICFwYXJlbnQucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudC5zdWJRdWVyeUZpbHRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuZXN0ZWRJbmNsdWRlcyA9IFtfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBjaGlsZCksIHsgaW5jbHVkZTogbmVzdGVkSW5jbHVkZXMsIGF0dHJpYnV0ZXM6IFtdIH0pXTtcbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgICBjb25zdCB0b3BJbmNsdWRlID0gbmVzdGVkSW5jbHVkZXNbMF07XG4gICAgY29uc3QgdG9wUGFyZW50ID0gdG9wSW5jbHVkZS5wYXJlbnQ7XG4gICAgY29uc3QgdG9wQXNzb2NpYXRpb24gPSB0b3BJbmNsdWRlLmFzc29jaWF0aW9uO1xuICAgIHRvcEluY2x1ZGUuYXNzb2NpYXRpb24gPSB2b2lkIDA7XG4gICAgaWYgKHRvcEluY2x1ZGUudGhyb3VnaCAmJiBPYmplY3QodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKSA9PT0gdG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsKSB7XG4gICAgICBxdWVyeSA9IHRoaXMuc2VsZWN0UXVlcnkodG9wSW5jbHVkZS50aHJvdWdoLm1vZGVsLmdldFRhYmxlTmFtZSgpLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFt0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwucHJpbWFyeUtleUZpZWxkXSxcbiAgICAgICAgaW5jbHVkZTogTW9kZWwuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyh7XG4gICAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCxcbiAgICAgICAgICBpbmNsdWRlOiBbe1xuICAgICAgICAgICAgYXNzb2NpYXRpb246IHRvcEFzc29jaWF0aW9uLnRvVGFyZ2V0LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgICAgICB3aGVyZTogdG9wSW5jbHVkZS53aGVyZSxcbiAgICAgICAgICAgIGluY2x1ZGU6IHRvcEluY2x1ZGUuaW5jbHVkZVxuICAgICAgICAgIH1dXG4gICAgICAgIH0pLmluY2x1ZGUsXG4gICAgICAgIG1vZGVsOiB0b3BJbmNsdWRlLnRocm91Z2gubW9kZWwsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgICAgIHRoaXMuc2VxdWVsaXplLmxpdGVyYWwoW1xuICAgICAgICAgICAgICBgJHt0aGlzLnF1b3RlVGFibGUodG9wUGFyZW50Lm1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcFBhcmVudC5tb2RlbC5wcmltYXJ5S2V5RmllbGQpfWAsXG4gICAgICAgICAgICAgIGAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQpfWBcbiAgICAgICAgICAgIF0uam9pbihcIiA9IFwiKSksXG4gICAgICAgICAgICB0b3BJbmNsdWRlLnRocm91Z2gud2hlcmVcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIGxpbWl0OiAxLFxuICAgICAgICBpbmNsdWRlSWdub3JlQXR0cmlidXRlczogZmFsc2VcbiAgICAgIH0sIHRvcEluY2x1ZGUudGhyb3VnaC5tb2RlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzQmVsb25nc1RvID0gdG9wQXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlID09PSBcIkJlbG9uZ3NUb1wiO1xuICAgICAgY29uc3Qgc291cmNlRmllbGQgPSBpc0JlbG9uZ3NUbyA/IHRvcEFzc29jaWF0aW9uLmlkZW50aWZpZXJGaWVsZCA6IHRvcEFzc29jaWF0aW9uLnNvdXJjZUtleUZpZWxkIHx8IHRvcFBhcmVudC5tb2RlbC5wcmltYXJ5S2V5RmllbGQ7XG4gICAgICBjb25zdCB0YXJnZXRGaWVsZCA9IGlzQmVsb25nc1RvID8gdG9wQXNzb2NpYXRpb24uc291cmNlS2V5RmllbGQgfHwgdG9wSW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5RmllbGQgOiB0b3BBc3NvY2lhdGlvbi5pZGVudGlmaWVyRmllbGQ7XG4gICAgICBjb25zdCBqb2luID0gW1xuICAgICAgICBgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0b3BJbmNsdWRlLmFzKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YXJnZXRGaWVsZCl9YCxcbiAgICAgICAgYCR7dGhpcy5xdW90ZVRhYmxlKHRvcFBhcmVudC5hcyB8fCB0b3BQYXJlbnQubW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc291cmNlRmllbGQpfWBcbiAgICAgIF0uam9pbihcIiA9IFwiKTtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5zZWxlY3RRdWVyeSh0b3BJbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IFt0YXJnZXRGaWVsZF0sXG4gICAgICAgIGluY2x1ZGU6IE1vZGVsLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHModG9wSW5jbHVkZSkuaW5jbHVkZSxcbiAgICAgICAgbW9kZWw6IHRvcEluY2x1ZGUubW9kZWwsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgW09wLmFuZF06IFtcbiAgICAgICAgICAgIHRvcEluY2x1ZGUud2hlcmUsXG4gICAgICAgICAgICB7IFtPcC5qb2luXTogdGhpcy5zZXF1ZWxpemUubGl0ZXJhbChqb2luKSB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgdGFibGVBczogdG9wSW5jbHVkZS5hcyxcbiAgICAgICAgaW5jbHVkZUlnbm9yZUF0dHJpYnV0ZXM6IGZhbHNlXG4gICAgICB9LCB0b3BJbmNsdWRlLm1vZGVsKTtcbiAgICB9XG4gICAgaWYgKCF0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtPcC5hbmRdKSB7XG4gICAgICB0b3BMZXZlbEluZm8ub3B0aW9ucy53aGVyZVtPcC5hbmRdID0gW107XG4gICAgfVxuICAgIHRvcExldmVsSW5mby5vcHRpb25zLndoZXJlW2BfXyR7aW5jbHVkZUFzLmludGVybmFsQXN9YF0gPSB0aGlzLnNlcXVlbGl6ZS5saXRlcmFsKFtcbiAgICAgIFwiKFwiLFxuICAgICAgcXVlcnkucmVwbGFjZSgvOyQvLCBcIlwiKSxcbiAgICAgIFwiKVwiLFxuICAgICAgXCJJUyBOT1QgTlVMTFwiXG4gICAgXS5qb2luKFwiIFwiKSk7XG4gIH1cbiAgX2dldFJlcXVpcmVkQ2xvc3VyZShpbmNsdWRlKSB7XG4gICAgY29uc3QgY29weSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIGluY2x1ZGUpLCB7IGF0dHJpYnV0ZXM6IFtdLCBpbmNsdWRlOiBbXSB9KTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbmNsdWRlLmluY2x1ZGUpKSB7XG4gICAgICBjb3B5LmluY2x1ZGUgPSBpbmNsdWRlLmluY2x1ZGUuZmlsdGVyKChpKSA9PiBpLnJlcXVpcmVkKS5tYXAoKGluYykgPT4gdGhpcy5fZ2V0UmVxdWlyZWRDbG9zdXJlKGluYykpO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfVxuICBnZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgc3ViUXVlcnkpIHtcbiAgICBjb25zdCBtYWluUXVlcnlPcmRlciA9IFtdO1xuICAgIGNvbnN0IHN1YlF1ZXJ5T3JkZXIgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLm9yZGVyKSkge1xuICAgICAgZm9yIChsZXQgb3JkZXIgb2Ygb3B0aW9ucy5vcmRlcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3JkZXIpKSB7XG4gICAgICAgICAgb3JkZXIgPSBbb3JkZXJdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJRdWVyeSAmJiBBcnJheS5pc0FycmF5KG9yZGVyKSAmJiBvcmRlclswXSAmJiAhKG9yZGVyWzBdIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pICYmICEodHlwZW9mIG9yZGVyWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgb3JkZXJbMF0ucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpICYmICEodHlwZW9mIG9yZGVyWzBdLm1vZGVsID09PSBcImZ1bmN0aW9uXCIgJiYgb3JkZXJbMF0ubW9kZWwucHJvdG90eXBlIGluc3RhbmNlb2YgTW9kZWwpICYmICEodHlwZW9mIG9yZGVyWzBdID09PSBcInN0cmluZ1wiICYmIG1vZGVsICYmIG1vZGVsLmFzc29jaWF0aW9ucyAhPT0gdm9pZCAwICYmIG1vZGVsLmFzc29jaWF0aW9uc1tvcmRlclswXV0pKSB7XG4gICAgICAgICAgY29uc3QgZmllbGQgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzW29yZGVyWzBdXSA/IG1vZGVsLnJhd0F0dHJpYnV0ZXNbb3JkZXJbMF1dLmZpZWxkIDogb3JkZXJbMF07XG4gICAgICAgICAgY29uc3Qgc3ViUXVlcnlBbGlhcyA9IHRoaXMuX2dldEFsaWFzRm9yRmllbGQodGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwubmFtZSksIGZpZWxkLCBvcHRpb25zKTtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICBsZXQgb3JkZXJUb1F1b3RlID0gW107XG4gICAgICAgICAgaWYgKHN1YlF1ZXJ5QWxpYXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9yZGVyVG9RdW90ZSA9IG9yZGVyO1xuICAgICAgICAgICAgcGFyZW50ID0gbW9kZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9yZGVyVG9RdW90ZSA9IFtzdWJRdWVyeUFsaWFzLCBvcmRlci5sZW5ndGggPiAxID8gb3JkZXJbMV0gOiBcIkFTQ1wiXTtcbiAgICAgICAgICAgIHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YlF1ZXJ5T3JkZXIucHVzaCh0aGlzLnF1b3RlKG9yZGVyVG9RdW90ZSwgcGFyZW50LCBcIi0+XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzICYmIG1vZGVsKSB7XG4gICAgICAgICAgY29uc3QgYWxpYXNlZEF0dHJpYnV0ZSA9IG9wdGlvbnMuYXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBBcnJheS5pc0FycmF5KGF0dHIpICYmIGF0dHJbMV0gJiYgKGF0dHJbMF0gPT09IG9yZGVyWzBdIHx8IGF0dHJbMV0gPT09IG9yZGVyWzBdKSk7XG4gICAgICAgICAgaWYgKGFsaWFzZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG1vZGVsLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKG1vZGVsTmFtZSwgYWxpYXNlZEF0dHJpYnV0ZVsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBvcmRlclswXSA9IG5ldyBVdGlscy5Db2woYWxpYXMgfHwgYWxpYXNlZEF0dHJpYnV0ZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1haW5RdWVyeU9yZGVyLnB1c2godGhpcy5xdW90ZShvcmRlciwgbW9kZWwsIFwiLT5cIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vcmRlciBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgY29uc3Qgc3FsID0gdGhpcy5xdW90ZShvcHRpb25zLm9yZGVyLCBtb2RlbCwgXCItPlwiKTtcbiAgICAgIGlmIChzdWJRdWVyeSkge1xuICAgICAgICBzdWJRdWVyeU9yZGVyLnB1c2goc3FsKTtcbiAgICAgIH1cbiAgICAgIG1haW5RdWVyeU9yZGVyLnB1c2goc3FsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3JkZXIgbXVzdCBiZSB0eXBlIG9mIGFycmF5IG9yIGluc3RhbmNlIG9mIGEgdmFsaWQgc2VxdWVsaXplIG1ldGhvZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB7IG1haW5RdWVyeU9yZGVyLCBzdWJRdWVyeU9yZGVyIH07XG4gIH1cbiAgX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgZXh0cmFJbmZvID0ge30pIHtcbiAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFzUGFydCA9IGV4dHJhSW5mby5hcyAmJiBgYXMgJHtleHRyYUluZm8uYXN9YCB8fCBcIlwiO1xuICAgIGNvbnN0IG5hbWVQYXJ0ID0gZXh0cmFJbmZvLm1vZGVsTmFtZSAmJiBgZm9yIG1vZGVsICcke2V4dHJhSW5mby5tb2RlbE5hbWV9J2AgfHwgXCJcIjtcbiAgICBjb25zdCBtZXNzYWdlID0gYEF0dGVtcHRlZCBhIFNFTEVDVCBxdWVyeSAke25hbWVQYXJ0fSAke2FzUGFydH0gd2l0aG91dCBzZWxlY3RpbmcgYW55IGNvbHVtbnNgO1xuICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvci5RdWVyeUVycm9yKG1lc3NhZ2UucmVwbGFjZSgvICsvZywgXCIgXCIpKTtcbiAgfVxuICBzZWxlY3RGcm9tVGFibGVGcmFnbWVudChvcHRpb25zLCBtb2RlbCwgYXR0cmlidXRlcywgdGFibGVzLCBtYWluVGFibGVBcykge1xuICAgIHRoaXMuX3Rocm93T25FbXB0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgeyBtb2RlbE5hbWU6IG1vZGVsICYmIG1vZGVsLm5hbWUsIGFzOiBtYWluVGFibGVBcyB9KTtcbiAgICBsZXQgZnJhZ21lbnQgPSBgU0VMRUNUICR7YXR0cmlidXRlcy5qb2luKFwiLCBcIil9IEZST00gJHt0YWJsZXN9YDtcbiAgICBpZiAobWFpblRhYmxlQXMpIHtcbiAgICAgIGZyYWdtZW50ICs9IGAgJHt0aGlzLmdldEFsaWFzVG9rZW4oKX0gJHttYWluVGFibGVBc31gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmRleEhpbnRzICYmIHRoaXMuX2RpYWxlY3Quc3VwcG9ydHMuaW5kZXhIaW50cykge1xuICAgICAgZm9yIChjb25zdCBoaW50IG9mIG9wdGlvbnMuaW5kZXhIaW50cykge1xuICAgICAgICBpZiAoSW5kZXhIaW50c1toaW50LnR5cGVdKSB7XG4gICAgICAgICAgZnJhZ21lbnQgKz0gYCAke0luZGV4SGludHNbaGludC50eXBlXX0gSU5ERVggKCR7aGludC52YWx1ZXMubWFwKChpbmRleE5hbWUpID0+IHRoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpKS5qb2luKFwiLFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwgJiYgb3B0aW9ucy5saW1pdCA9PSBudWxsKSB7XG4gICAgICBmcmFnbWVudCArPSBcIiBMSU1JVCBcIiArIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KSArIFwiLCBcIiArIDFlMTM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmxpbWl0ICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIGZyYWdtZW50ICs9IFwiIExJTUlUIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpICsgXCIsIFwiICsgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudCArPSBcIiBMSU1JVCBcIiArIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLk9wZXJhdG9yTWFwLCBzbXRoLmNvbXBhcmF0b3IpKSB7XG4gICAgICBzbXRoLmNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW3NtdGguY29tcGFyYXRvcl07XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuV2hlcmUpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHNtdGgubG9naWM7XG4gICAgICBsZXQga2V5O1xuICAgICAgaWYgKHNtdGguYXR0cmlidXRlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIGtleSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHNtdGguYXR0cmlidXRlLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gYCR7dGhpcy5xdW90ZVRhYmxlKHNtdGguYXR0cmlidXRlLk1vZGVsLm5hbWUpfS4ke3RoaXMucXVvdGVJZGVudGlmaWVyKHNtdGguYXR0cmlidXRlLmZpZWxkIHx8IHNtdGguYXR0cmlidXRlLmZpZWxkTmFtZSl9YDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHZhbHVlLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgICBpZiAodmFsdWUgPT09IFwiTlVMTFwiKSB7XG4gICAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgIHNtdGguY29tcGFyYXRvciA9IFwiSVNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCIhPVwiKSB7XG4gICAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSBcIklTIE5PVFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2tleSwgdmFsdWVdLmpvaW4oYCAke3NtdGguY29tcGFyYXRvcn0gYCk7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShzbXRoLmF0dHJpYnV0ZSwgdmFsdWUsIHtcbiAgICAgICAgICBtb2RlbDogZmFjdG9yeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChbdGhpcy5PcGVyYXRvck1hcFtPcC5iZXR3ZWVuXSwgdGhpcy5PcGVyYXRvck1hcFtPcC5ub3RCZXR3ZWVuXV0uaW5jbHVkZXMoc210aC5jb21wYXJhdG9yKSkge1xuICAgICAgICB2YWx1ZSA9IGAke3RoaXMuZXNjYXBlKHZhbHVlWzBdKX0gQU5EICR7dGhpcy5lc2NhcGUodmFsdWVbMV0pfWA7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmJvb2xlYW5WYWx1ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuZXNjYXBlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJOVUxMXCIpIHtcbiAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICBzbXRoLmNvbXBhcmF0b3IgPSBcIklTXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGguY29tcGFyYXRvciA9PT0gXCIhPVwiKSB7XG4gICAgICAgICAgc210aC5jb21wYXJhdG9yID0gXCJJUyBOT1RcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXS5qb2luKGAgJHtzbXRoLmNvbXBhcmF0b3J9IGApO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgIHJldHVybiBzbXRoLnZhbDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoc210aC52YWwgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aC52YWwsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNQbGFpbk9iamVjdChzbXRoLnZhbCkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoc210aC52YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5lc2NhcGUoc210aC52YWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBDQVNUKCR7cmVzdWx0fSBBUyAke3NtdGgudHlwZS50b1VwcGVyQ2FzZSgpfSlgO1xuICAgIH1cbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkZuKSB7XG4gICAgICByZXR1cm4gYCR7c210aC5mbn0oJHtzbXRoLmFyZ3MubWFwKChhcmcpID0+IHtcbiAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChhcmcsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXNjYXBlKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIgPyBhcmcucmVwbGFjZSgvXFwkL2csIFwiJCQkXCIpIDogYXJnKTtcbiAgICAgIH0pLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Db2wpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNtdGguY29sKSAmJiAhZmFjdG9yeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBTZXF1ZWxpemUuY29sKCkgd2l0aCBhcnJheSBvdXRzaWRlIG9mIG9yZGVyIC8gZ3JvdXAgY2xhdXNlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGguY29sLnN0YXJ0c1dpdGgoXCIqXCIpKSB7XG4gICAgICAgIHJldHVybiBcIipcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnF1b3RlKHNtdGguY29sLCBmYWN0b3J5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNtdGgudG9TdHJpbmcodGhpcywgZmFjdG9yeSk7XG4gIH1cbiAgd2hlcmVRdWVyeSh3aGVyZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkod2hlcmUsIG9wdGlvbnMpO1xuICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBgV0hFUkUgJHtxdWVyeX1gO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICB3aGVyZUl0ZW1zUXVlcnkod2hlcmUsIG9wdGlvbnMsIGJpbmRpbmcpIHtcbiAgICBpZiAod2hlcmUgPT09IG51bGwgfHwgd2hlcmUgPT09IHZvaWQgMCB8fCBVdGlscy5nZXRDb21wbGV4U2l6ZSh3aGVyZSkgPT09IDApIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdoZXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwb3J0IGZvciBge3doZXJlOiAncmF3IHF1ZXJ5J31gIGhhcyBiZWVuIHJlbW92ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGJpbmRpbmcgPSBiaW5kaW5nIHx8IFwiQU5EXCI7XG4gICAgaWYgKGJpbmRpbmdbMF0gIT09IFwiIFwiKVxuICAgICAgYmluZGluZyA9IGAgJHtiaW5kaW5nfSBgO1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qod2hlcmUpKSB7XG4gICAgICBVdGlscy5nZXRDb21wbGV4S2V5cyh3aGVyZSkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gd2hlcmVbcHJvcF07XG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeShwcm9wLCBpdGVtLCBvcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLndoZXJlSXRlbVF1ZXJ5KHZvaWQgMCwgd2hlcmUsIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zLmxlbmd0aCAmJiBpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gJiYgaXRlbS5sZW5ndGgpLmpvaW4oYmluZGluZykgfHwgXCJcIjtcbiAgfVxuICB3aGVyZUl0ZW1RdWVyeShrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXSEVSRSBwYXJhbWV0ZXIgXCIke2tleX1cIiBoYXMgaW52YWxpZCBcInVuZGVmaW5lZFwiIHZhbHVlYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5pbmNsdWRlcyhcIi5cIikgJiYgb3B0aW9ucy5tb2RlbCkge1xuICAgICAgY29uc3Qga2V5UGFydHMgPSBrZXkuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV0gJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleVBhcnRzWzBdXS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgY29uc3QgdG1wID0ge307XG4gICAgICAgIGNvbnN0IGZpZWxkMiA9IG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXlQYXJ0c1swXV07XG4gICAgICAgIF8uc2V0KHRtcCwga2V5UGFydHMuc2xpY2UoMSksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtUXVlcnkoZmllbGQyLmZpZWxkIHx8IGtleVBhcnRzWzBdLCB0bXAsIF9fc3ByZWFkVmFsdWVzKHsgZmllbGQ6IGZpZWxkMiB9LCBvcHRpb25zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gdGhpcy5fZmluZEZpZWxkKGtleSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZmllbGRUeXBlID0gZmllbGQgJiYgZmllbGQudHlwZSB8fCBvcHRpb25zLnR5cGU7XG4gICAgY29uc3QgaXNQbGFpbk9iamVjdCA9IF8uaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgY29uc3QgaXNBcnJheSA9ICFpc1BsYWluT2JqZWN0ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICAgIGtleSA9IHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgJiYgdGhpcy5PcGVyYXRvcnNBbGlhc01hcFtrZXldIHx8IGtleTtcbiAgICBpZiAoaXNQbGFpbk9iamVjdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9yZXBsYWNlQWxpYXNlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlS2V5cyA9IGlzUGxhaW5PYmplY3QgJiYgVXRpbHMuZ2V0Q29tcGxleEtleXModmFsdWUpO1xuICAgIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCAmJiB2YWx1ZUtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbVF1ZXJ5KHZhbHVlS2V5c1swXSwgdmFsdWVbdmFsdWVLZXlzWzBdXSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgb3BWYWx1ZTIgPSBvcHRpb25zLmJpbmRQYXJhbSA/IFwiTlVMTFwiIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlMiwgdGhpcy5PcGVyYXRvck1hcFtPcC5pc10sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgY29uc3Qgb3BWYWx1ZTIgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBvcFZhbHVlMiwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kICYmICEoa2V5ICE9PSB2b2lkIDAgJiYgdmFsdWUgaW5zdGFuY2VvZiBVdGlscy5GbikpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZCh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChrZXkgPT09IHZvaWQgMCAmJiBpc0FycmF5KSB7XG4gICAgICBpZiAoVXRpbHMuY2FuVHJlYXRBcnJheUFzQW5kKHZhbHVlKSkge1xuICAgICAgICBrZXkgPSBPcC5hbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdXBwb3J0IGZvciBsaXRlcmFsIHJlcGxhY2VtZW50cyBpbiB0aGUgYHdoZXJlYCBvYmplY3QgaGFzIGJlZW4gcmVtb3ZlZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXkgPT09IE9wLm9yIHx8IGtleSA9PT0gT3AuYW5kIHx8IGtleSA9PT0gT3Aubm90KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVHcm91cEJpbmQoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZVtPcC5vcl0pIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5vcl0sIGtleSwgdmFsdWVbT3Aub3JdLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlW09wLmFuZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUJpbmQodGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdLCBrZXksIHZhbHVlW09wLmFuZF0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSAmJiBmaWVsZFR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQVJSQVkpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUyID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZTIsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIGZpZWxkVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OICYmIG9wdGlvbnMuanNvbiAhPT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl93aGVyZUpTT04oa2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0ICYmIHZhbHVlS2V5cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVCaW5kKHRoaXMuT3BlcmF0b3JNYXBbT3AuYW5kXSwga2V5LCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fd2hlcmVQYXJzZVNpbmdsZVZhbHVlT2JqZWN0KGtleSwgZmllbGQsIE9wLmluLCB2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KSB7XG4gICAgICBpZiAodGhpcy5PcGVyYXRvck1hcFt2YWx1ZUtleXNbMF1dKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgdmFsdWVLZXlzWzBdLCB2YWx1ZVt2YWx1ZUtleXNbMF1dLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl93aGVyZVBhcnNlU2luZ2xlVmFsdWVPYmplY3Qoa2V5LCBmaWVsZCwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gT3AucGxhY2Vob2xkZXIpIHtcbiAgICAgIGNvbnN0IG9wVmFsdWUyID0gb3B0aW9ucy5iaW5kUGFyYW0gPyB0aGlzLmZvcm1hdCh2YWx1ZSwgZmllbGQsIG9wdGlvbnMsIG9wdGlvbnMuYmluZFBhcmFtKSA6IHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCk7XG4gICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKHRoaXMuT3BlcmF0b3JNYXBba2V5XSwgb3BWYWx1ZTIsIHRoaXMuT3BlcmF0b3JNYXBbT3AuZXFdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGNvbnN0IG9wVmFsdWUgPSBvcHRpb25zLmJpbmRQYXJhbSA/IHRoaXMuZm9ybWF0KHZhbHVlLCBmaWVsZCwgb3B0aW9ucywgb3B0aW9ucy5iaW5kUGFyYW0pIDogdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkKTtcbiAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgb3BWYWx1ZSwgdGhpcy5PcGVyYXRvck1hcFtPcC5lcV0sIG9wdGlvbnMucHJlZml4KTtcbiAgfVxuICBfZmluZEZpZWxkKGtleSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmZpZWxkKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5maWVsZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzICYmIG9wdGlvbnMubW9kZWwucmF3QXR0cmlidXRlc1trZXldKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwICYmIG9wdGlvbnMubW9kZWwuZmllbGRSYXdBdHRyaWJ1dGVzTWFwW2tleV0pIHtcbiAgICAgIHJldHVybiBvcHRpb25zLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcFtrZXldO1xuICAgIH1cbiAgfVxuICBfd2hlcmVHcm91cEJpbmQoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBrZXkgPT09IE9wLm9yID8gdGhpcy5PcGVyYXRvck1hcFtPcC5vcl0gOiB0aGlzLk9wZXJhdG9yTWFwW09wLmFuZF07XG4gICAgY29uc3Qgb3V0ZXJCaW5kaW5nID0ga2V5ID09PSBPcC5ub3QgPyBcIk5PVCBcIiA6IFwiXCI7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICBsZXQgaXRlbVF1ZXJ5ID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkoaXRlbSwgb3B0aW9ucywgdGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdKTtcbiAgICAgICAgaWYgKGl0ZW1RdWVyeSAmJiBpdGVtUXVlcnkubGVuZ3RoICYmIChBcnJheS5pc0FycmF5KGl0ZW0pIHx8IF8uaXNQbGFpbk9iamVjdChpdGVtKSkgJiYgVXRpbHMuZ2V0Q29tcGxleFNpemUoaXRlbSkgPiAxKSB7XG4gICAgICAgICAgaXRlbVF1ZXJ5ID0gYCgke2l0ZW1RdWVyeX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbVF1ZXJ5O1xuICAgICAgfSkuZmlsdGVyKChpdGVtKSA9PiBpdGVtICYmIGl0ZW0ubGVuZ3RoKTtcbiAgICAgIHZhbHVlID0gdmFsdWUubGVuZ3RoICYmIHZhbHVlLmpvaW4oYmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdGhpcy53aGVyZUl0ZW1zUXVlcnkodmFsdWUsIG9wdGlvbnMsIGJpbmRpbmcpO1xuICAgIH1cbiAgICBpZiAoKGtleSA9PT0gT3Aub3IgfHwga2V5ID09PSBPcC5ub3QpICYmICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIFwiMCA9IDFcIjtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID8gYCR7b3V0ZXJCaW5kaW5nfSgke3ZhbHVlfSlgIDogdm9pZCAwO1xuICB9XG4gIF93aGVyZUJpbmQoYmluZGluZywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IFV0aWxzLmdldENvbXBsZXhLZXlzKHZhbHVlKS5tYXAoKHByb3ApID0+IHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHZhbHVlW3Byb3BdO1xuICAgICAgICByZXR1cm4gdGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIHsgW3Byb3BdOiBpdGVtIH0sIG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gdmFsdWUubWFwKChpdGVtKSA9PiB0aGlzLndoZXJlSXRlbVF1ZXJ5KGtleSwgaXRlbSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAmJiBpdGVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA/IGAoJHt2YWx1ZS5qb2luKGJpbmRpbmcpfSlgIDogdm9pZCAwO1xuICB9XG4gIF93aGVyZUpTT04oa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGJhc2VLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgIGlmIChvcHRpb25zLnByZWZpeCkge1xuICAgICAgaWYgKG9wdGlvbnMucHJlZml4IGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICBiYXNlS2V5ID0gYCR7dGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2Qob3B0aW9ucy5wcmVmaXgpfS4ke2Jhc2VLZXl9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VLZXkgPSBgJHt0aGlzLnF1b3RlVGFibGUob3B0aW9ucy5wcmVmaXgpfS4ke2Jhc2VLZXl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgVXRpbHMuZ2V0T3BlcmF0b3JzKHZhbHVlKS5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgY29uc3Qgd2hlcmUgPSB7XG4gICAgICAgIFtvcF06IHZhbHVlW29wXVxuICAgICAgfTtcbiAgICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeShrZXksIHdoZXJlLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBqc29uOiBmYWxzZSB9KSkpO1xuICAgIH0pO1xuICAgIF8uZm9yT3duKHZhbHVlLCAoaXRlbSwgcHJvcCkgPT4ge1xuICAgICAgdGhpcy5fdHJhdmVyc2VKU09OKGl0ZW1zLCBiYXNlS2V5LCBwcm9wLCBpdGVtLCBbcHJvcF0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW1zLmpvaW4odGhpcy5PcGVyYXRvck1hcFtPcC5hbmRdKTtcbiAgICByZXR1cm4gaXRlbXMubGVuZ3RoID4gMSA/IGAoJHtyZXN1bHR9KWAgOiByZXN1bHQ7XG4gIH1cbiAgX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgcHJvcCwgaXRlbSwgcGF0aCkge1xuICAgIGxldCBjYXN0O1xuICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0uaW5jbHVkZXMoXCI6OlwiKSkge1xuICAgICAgY29uc3QgdG1wID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdLnNwbGl0KFwiOjpcIik7XG4gICAgICBjYXN0ID0gdG1wWzFdO1xuICAgICAgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID0gdG1wWzBdO1xuICAgIH1cbiAgICBsZXQgcGF0aEtleSA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoYmFzZUtleSwgcGF0aCk7XG4gICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgVXRpbHMuZ2V0T3BlcmF0b3JzKGl0ZW0pLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdG9KU09OVmFsdWUoaXRlbVtvcF0pO1xuICAgICAgICBsZXQgaXNKc29uID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgb3AgPT09IE9wLmNvbnRhaW5zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIGlzSnNvbiA9IHRydWU7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRoS2V5ID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShiYXNlS2V5LCBwYXRoLCBpc0pzb24pO1xuICAgICAgICBpdGVtcy5wdXNoKHRoaXMud2hlcmVJdGVtUXVlcnkodGhpcy5fY2FzdEtleShwYXRoS2V5LCB2YWx1ZSwgY2FzdCksIHsgW29wXTogdmFsdWUgfSkpO1xuICAgICAgfSk7XG4gICAgICBfLmZvck93bihpdGVtLCAodmFsdWUsIGl0ZW1Qcm9wKSA9PiB7XG4gICAgICAgIHRoaXMuX3RyYXZlcnNlSlNPTihpdGVtcywgYmFzZUtleSwgaXRlbVByb3AsIHZhbHVlLCBwYXRoLmNvbmNhdChbaXRlbVByb3BdKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbSA9IHRoaXMuX3RvSlNPTlZhbHVlKGl0ZW0pO1xuICAgIGl0ZW1zLnB1c2godGhpcy53aGVyZUl0ZW1RdWVyeSh0aGlzLl9jYXN0S2V5KHBhdGhLZXksIGl0ZW0sIGNhc3QpLCB7IFtPcC5lcV06IGl0ZW0gfSkpO1xuICB9XG4gIF90b0pTT05WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfY2FzdEtleShrZXksIHZhbHVlLCBjYXN0LCBqc29uKSB7XG4gICAgY2FzdCA9IGNhc3QgfHwgdGhpcy5fZ2V0SnNvbkNhc3QoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVswXSA6IHZhbHVlKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgcmV0dXJuIG5ldyBVdGlscy5MaXRlcmFsKHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKG5ldyBVdGlscy5DYXN0KG5ldyBVdGlscy5MaXRlcmFsKGtleSksIGNhc3QsIGpzb24pKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVXRpbHMuTGl0ZXJhbChrZXkpO1xuICB9XG4gIF9nZXRKc29uQ2FzdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiBcImRvdWJsZSBwcmVjaXNpb25cIjtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIFwidGltZXN0YW1wdHpcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIF9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciwgcHJlZml4KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmF0b3IgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleX0gYW5kICR7dmFsdWV9IGhhcyBubyBjb21wYXJhdG9yYCk7XG4gICAgfVxuICAgIGtleSA9IHRoaXMuX2dldFNhZmVLZXkoa2V5LCBwcmVmaXgpO1xuICAgIHJldHVybiBba2V5LCB2YWx1ZV0uam9pbihgICR7Y29tcGFyYXRvcn0gYCk7XG4gIH1cbiAgX2dldFNhZmVLZXkoa2V5LCBwcmVmaXgpIHtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICBrZXkgPSB0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChrZXkpO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeEtleSh0aGlzLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChrZXkpLCBwcmVmaXgpO1xuICAgIH1cbiAgICBpZiAoVXRpbHMuaXNDb2xTdHJpbmcoa2V5KSkge1xuICAgICAga2V5ID0ga2V5LnN1YnN0cigxLCBrZXkubGVuZ3RoIC0gMikuc3BsaXQoXCIuXCIpO1xuICAgICAgaWYgKGtleS5sZW5ndGggPiAyKSB7XG4gICAgICAgIGtleSA9IFtcbiAgICAgICAgICBrZXkuc2xpY2UoMCwgLTEpLmpvaW4oXCItPlwiKSxcbiAgICAgICAgICBrZXlba2V5Lmxlbmd0aCAtIDFdXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5Lm1hcCgoaWRlbnRpZmllcikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJlZml4S2V5KHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksIHByZWZpeCk7XG4gIH1cbiAgX3ByZWZpeEtleShrZXksIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGlmIChwcmVmaXggaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5oYW5kbGVTZXF1ZWxpemVNZXRob2QocHJlZml4KSwga2V5XS5qb2luKFwiLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdGhpcy5xdW90ZVRhYmxlKHByZWZpeCksIGtleV0uam9pbihcIi5cIik7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgX3doZXJlUGFyc2VTaW5nbGVWYWx1ZU9iamVjdChrZXksIGZpZWxkLCBwcm9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChwcm9wID09PSBPcC5ub3QpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBwcm9wID0gT3Aubm90SW47XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICBwcm9wID0gT3AubmU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtwcm9wXSB8fCB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXTtcbiAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgIGNhc2UgT3AuaW46XG4gICAgICBjYXNlIE9wLm5vdEluOlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5MaXRlcmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHZhbHVlLnZhbCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3ZhbHVlLm1hcCgoaXRlbSkgPT4gdGhpcy5lc2NhcGUoaXRlbSwgZmllbGQpKS5qb2luKFwiLCBcIil9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyYXRvciA9PT0gdGhpcy5PcGVyYXRvck1hcFtPcC5pbl0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgXCIoTlVMTClcIiwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgY2FzZSBPcC5hbnk6XG4gICAgICBjYXNlIE9wLmFsbDpcbiAgICAgICAgY29tcGFyYXRvciA9IGAke3RoaXMuT3BlcmF0b3JNYXBbT3AuZXFdfSAke2NvbXBhcmF0b3J9YDtcbiAgICAgICAgaWYgKHZhbHVlW09wLnZhbHVlc10pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYChWQUxVRVMgJHt2YWx1ZVtPcC52YWx1ZXNdLm1hcCgoaXRlbSkgPT4gYCgke3RoaXMuZXNjYXBlKGl0ZW0pfSlgKS5qb2luKFwiLCBcIil9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgYCgke3RoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCl9KWAsIGNvbXBhcmF0b3IsIG9wdGlvbnMucHJlZml4KTtcbiAgICAgIGNhc2UgT3AuYmV0d2VlbjpcbiAgICAgIGNhc2UgT3Aubm90QmV0d2VlbjpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIGAke3RoaXMuZXNjYXBlKHZhbHVlWzBdLCBmaWVsZCl9IEFORCAke3RoaXMuZXNjYXBlKHZhbHVlWzFdLCBmaWVsZCl9YCwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5yYXc6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgJHJhd2Agd2hlcmUgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gIFVzZSBgc2VxdWVsaXplLmxpdGVyYWxgIGluc3RlYWQuXCIpO1xuICAgICAgY2FzZSBPcC5jb2w6XG4gICAgICAgIGNvbXBhcmF0b3IgPSB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFsdWUgPSBbXG4gICAgICAgICAgICB2YWx1ZS5zbGljZSgwLCAtMSkuam9pbihcIi0+XCIpLFxuICAgICAgICAgICAgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCB2YWx1ZS5tYXAoKGlkZW50aWZpZXIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIpKS5qb2luKFwiLlwiKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICAgICAgY2FzZSBPcC5zdGFydHNXaXRoOlxuICAgICAgY2FzZSBPcC5lbmRzV2l0aDpcbiAgICAgIGNhc2UgT3Auc3Vic3RyaW5nOlxuICAgICAgICBjb21wYXJhdG9yID0gdGhpcy5PcGVyYXRvck1hcFtPcC5saWtlXTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuTGl0ZXJhbCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXR0ZXJuID0gYCR7dmFsdWV9JWA7XG4gICAgICAgIGlmIChwcm9wID09PSBPcC5lbmRzV2l0aClcbiAgICAgICAgICBwYXR0ZXJuID0gYCUke3ZhbHVlfWA7XG4gICAgICAgIGlmIChwcm9wID09PSBPcC5zdWJzdHJpbmcpXG4gICAgICAgICAgcGF0dGVybiA9IGAlJHt2YWx1ZX0lYDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHBhdHRlcm4pLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGNvbnN0IGVzY2FwZU9wdGlvbnMgPSB7XG4gICAgICBhY2NlcHRTdHJpbmdzOiBjb21wYXJhdG9yLmluY2x1ZGVzKHRoaXMuT3BlcmF0b3JNYXBbT3AubGlrZV0pXG4gICAgfTtcbiAgICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlW09wLmNvbF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMud2hlcmVJdGVtUXVlcnkobnVsbCwgdmFsdWUpLCBjb21wYXJhdG9yLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbT3AuYW55XSkge1xuICAgICAgICBlc2NhcGVPcHRpb25zLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWVbT3AuYW55XSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpfSlgLCBgJHtjb21wYXJhdG9yfSAke3RoaXMuT3BlcmF0b3JNYXBbT3AuYW55XX1gLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVbT3AuYWxsXSkge1xuICAgICAgICBlc2NhcGVPcHRpb25zLmlzTGlzdCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLl9qb2luS2V5VmFsdWUoa2V5LCBgKCR7dGhpcy5lc2NhcGUodmFsdWVbT3AuYWxsXSwgZmllbGQsIGVzY2FwZU9wdGlvbnMpfSlgLCBgJHtjb21wYXJhdG9yfSAke3RoaXMuT3BlcmF0b3JNYXBbT3AuYWxsXX1gLCBvcHRpb25zLnByZWZpeCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLmVxXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIHRoaXMuT3BlcmF0b3JNYXBbT3AuaXNdLCBvcHRpb25zLnByZWZpeCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCAmJiBjb21wYXJhdG9yID09PSB0aGlzLk9wZXJhdG9yTWFwW09wLm5lXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2pvaW5LZXlWYWx1ZShrZXksIHRoaXMuZXNjYXBlKHZhbHVlLCBmaWVsZCwgZXNjYXBlT3B0aW9ucyksIHRoaXMuT3BlcmF0b3JNYXBbT3Aubm90XSwgb3B0aW9ucy5wcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fam9pbktleVZhbHVlKGtleSwgdGhpcy5lc2NhcGUodmFsdWUsIGZpZWxkLCBlc2NhcGVPcHRpb25zKSwgY29tcGFyYXRvciwgb3B0aW9ucy5wcmVmaXgpO1xuICB9XG4gIGdldFdoZXJlQ29uZGl0aW9ucyhzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpIHtcbiAgICBjb25zdCB3aGVyZSA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRhYmxlTmFtZSkpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRhYmxlTmFtZVswXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gdGFibGVOYW1lWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAocHJlcGVuZCA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmVwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHNtdGggJiYgc210aCBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgfVxuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qoc210aCkpIHtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeShzbXRoLCB7XG4gICAgICAgIG1vZGVsOiBmYWN0b3J5LFxuICAgICAgICBwcmVmaXg6IHByZXBlbmQgJiYgdGFibGVOYW1lLFxuICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNtdGggPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNtdGggPT09IFwiYmlnaW50XCIpIHtcbiAgICAgIGxldCBwcmltYXJ5S2V5cyA9IGZhY3RvcnkgPyBPYmplY3Qua2V5cyhmYWN0b3J5LnByaW1hcnlLZXlzKSA6IFtdO1xuICAgICAgaWYgKHByaW1hcnlLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcHJpbWFyeUtleXMgPSBwcmltYXJ5S2V5c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByaW1hcnlLZXlzID0gXCJpZFwiO1xuICAgICAgfVxuICAgICAgd2hlcmVbcHJpbWFyeUtleXNdID0gc210aDtcbiAgICAgIHJldHVybiB0aGlzLndoZXJlSXRlbXNRdWVyeSh3aGVyZSwge1xuICAgICAgICBtb2RlbDogZmFjdG9yeSxcbiAgICAgICAgcHJlZml4OiBwcmVwZW5kICYmIHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc210aCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNtdGgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5lc2NhcGUoc210aCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNtdGgpKSB7XG4gICAgICBpZiAoc210aC5sZW5ndGggPT09IDAgfHwgc210aC5sZW5ndGggPiAwICYmIHNtdGhbMF0ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gXCIxPTFcIjtcbiAgICAgIGlmIChVdGlscy5jYW5UcmVhdEFycmF5QXNBbmQoc210aCkpIHtcbiAgICAgICAgY29uc3QgX3NtdGggPSB7IFtPcC5hbmRdOiBzbXRoIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyhfc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN1cHBvcnQgZm9yIGxpdGVyYWwgcmVwbGFjZW1lbnRzIGluIHRoZSBgd2hlcmVgIG9iamVjdCBoYXMgYmVlbiByZW1vdmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKHNtdGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMud2hlcmVJdGVtc1F1ZXJ5KHNtdGgsIHtcbiAgICAgICAgbW9kZWw6IGZhY3RvcnksXG4gICAgICAgIHByZWZpeDogcHJlcGVuZCAmJiB0YWJsZU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHdoZXJlIG9wdGlvbiB2YWx1ZTogJHt1dGlsLmluc3BlY3Qoc210aCl9LiBQbGVhc2UgcmVmZXIgdG8gdGhlIFNlcXVlbGl6ZSBkb2N1bWVudGF0aW9uIHRvIGxlYXJuIG1vcmUgYWJvdXQgd2hpY2ggdmFsdWVzIGFyZSBhY2NlcHRlZCBhcyBwYXJ0IG9mIHRoZSB3aGVyZSBvcHRpb24uYCk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25PYmplY3QoY29uZGl0aW9ucywgcGF0aCkge1xuICAgIHBhdGggPSBwYXRoIHx8IFtdO1xuICAgIHJldHVybiBfLnJlZHVjZShjb25kaXRpb25zLCAocmVzdWx0LCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQodGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdCh2YWx1ZSwgcGF0aC5jb25jYXQoa2V5KSkpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goeyBwYXRoOiBwYXRoLmNvbmNhdChrZXkpLCB2YWx1ZSB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG4gIGJvb2xlYW5WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBhdXRoVGVzdFF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCAxKzEgQVMgcmVzdWx0XCI7XG4gIH1cbn1cbk9iamVjdC5hc3NpZ24oUXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLCByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzXCIpKTtcbk9iamVjdC5hc3NpZ24oUXVlcnlHZW5lcmF0b3IucHJvdG90eXBlLCByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb25cIikpO1xubW9kdWxlLmV4cG9ydHMgPSBRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Op = __webpack_require__(/*! ../../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst Utils = __webpack_require__(/*! ../../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst OperatorHelpers = {\n  OperatorMap: {\n    [Op.eq]: \"=\",\n    [Op.ne]: \"!=\",\n    [Op.gte]: \">=\",\n    [Op.gt]: \">\",\n    [Op.lte]: \"<=\",\n    [Op.lt]: \"<\",\n    [Op.not]: \"IS NOT\",\n    [Op.is]: \"IS\",\n    [Op.in]: \"IN\",\n    [Op.notIn]: \"NOT IN\",\n    [Op.like]: \"LIKE\",\n    [Op.notLike]: \"NOT LIKE\",\n    [Op.iLike]: \"ILIKE\",\n    [Op.notILike]: \"NOT ILIKE\",\n    [Op.startsWith]: \"LIKE\",\n    [Op.endsWith]: \"LIKE\",\n    [Op.substring]: \"LIKE\",\n    [Op.regexp]: \"~\",\n    [Op.notRegexp]: \"!~\",\n    [Op.iRegexp]: \"~*\",\n    [Op.notIRegexp]: \"!~*\",\n    [Op.between]: \"BETWEEN\",\n    [Op.notBetween]: \"NOT BETWEEN\",\n    [Op.overlap]: \"&&\",\n    [Op.contains]: \"@>\",\n    [Op.contained]: \"<@\",\n    [Op.adjacent]: \"-|-\",\n    [Op.strictLeft]: \"<<\",\n    [Op.strictRight]: \">>\",\n    [Op.noExtendRight]: \"&<\",\n    [Op.noExtendLeft]: \"&>\",\n    [Op.any]: \"ANY\",\n    [Op.all]: \"ALL\",\n    [Op.and]: \" AND \",\n    [Op.or]: \" OR \",\n    [Op.col]: \"COL\",\n    [Op.placeholder]: \"$$PLACEHOLDER$$\",\n    [Op.match]: \"@@\"\n  },\n  OperatorsAliasMap: {},\n  setOperatorsAliases(aliases) {\n    if (!aliases || _.isEmpty(aliases)) {\n      this.OperatorsAliasMap = false;\n    } else {\n      this.OperatorsAliasMap = __spreadValues({}, aliases);\n    }\n  },\n  _replaceAliases(orig) {\n    const obj = {};\n    if (!this.OperatorsAliasMap) {\n      return orig;\n    }\n    Utils.getOperators(orig).forEach((op) => {\n      const item = orig[op];\n      if (_.isPlainObject(item)) {\n        obj[op] = this._replaceAliases(item);\n      } else {\n        obj[op] = item;\n      }\n    });\n    _.forOwn(orig, (item, prop) => {\n      prop = this.OperatorsAliasMap[prop] || prop;\n      if (_.isPlainObject(item)) {\n        item = this._replaceAliases(item);\n      }\n      obj[prop] = item;\n    });\n    return obj;\n  }\n};\nmodule.exports = OperatorHelpers;\n//# sourceMappingURL=operators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3Ivb3BlcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixXQUFXLG1CQUFPLENBQUMsMkVBQW9CO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0Q7QUFDaEQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvci9vcGVyYXRvcnMuanM/MzdiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHNcIik7XG5jb25zdCBPcGVyYXRvckhlbHBlcnMgPSB7XG4gIE9wZXJhdG9yTWFwOiB7XG4gICAgW09wLmVxXTogXCI9XCIsXG4gICAgW09wLm5lXTogXCIhPVwiLFxuICAgIFtPcC5ndGVdOiBcIj49XCIsXG4gICAgW09wLmd0XTogXCI+XCIsXG4gICAgW09wLmx0ZV06IFwiPD1cIixcbiAgICBbT3AubHRdOiBcIjxcIixcbiAgICBbT3Aubm90XTogXCJJUyBOT1RcIixcbiAgICBbT3AuaXNdOiBcIklTXCIsXG4gICAgW09wLmluXTogXCJJTlwiLFxuICAgIFtPcC5ub3RJbl06IFwiTk9UIElOXCIsXG4gICAgW09wLmxpa2VdOiBcIkxJS0VcIixcbiAgICBbT3Aubm90TGlrZV06IFwiTk9UIExJS0VcIixcbiAgICBbT3AuaUxpa2VdOiBcIklMSUtFXCIsXG4gICAgW09wLm5vdElMaWtlXTogXCJOT1QgSUxJS0VcIixcbiAgICBbT3Auc3RhcnRzV2l0aF06IFwiTElLRVwiLFxuICAgIFtPcC5lbmRzV2l0aF06IFwiTElLRVwiLFxuICAgIFtPcC5zdWJzdHJpbmddOiBcIkxJS0VcIixcbiAgICBbT3AucmVnZXhwXTogXCJ+XCIsXG4gICAgW09wLm5vdFJlZ2V4cF06IFwiIX5cIixcbiAgICBbT3AuaVJlZ2V4cF06IFwifipcIixcbiAgICBbT3Aubm90SVJlZ2V4cF06IFwiIX4qXCIsXG4gICAgW09wLmJldHdlZW5dOiBcIkJFVFdFRU5cIixcbiAgICBbT3Aubm90QmV0d2Vlbl06IFwiTk9UIEJFVFdFRU5cIixcbiAgICBbT3Aub3ZlcmxhcF06IFwiJiZcIixcbiAgICBbT3AuY29udGFpbnNdOiBcIkA+XCIsXG4gICAgW09wLmNvbnRhaW5lZF06IFwiPEBcIixcbiAgICBbT3AuYWRqYWNlbnRdOiBcIi18LVwiLFxuICAgIFtPcC5zdHJpY3RMZWZ0XTogXCI8PFwiLFxuICAgIFtPcC5zdHJpY3RSaWdodF06IFwiPj5cIixcbiAgICBbT3Aubm9FeHRlbmRSaWdodF06IFwiJjxcIixcbiAgICBbT3Aubm9FeHRlbmRMZWZ0XTogXCImPlwiLFxuICAgIFtPcC5hbnldOiBcIkFOWVwiLFxuICAgIFtPcC5hbGxdOiBcIkFMTFwiLFxuICAgIFtPcC5hbmRdOiBcIiBBTkQgXCIsXG4gICAgW09wLm9yXTogXCIgT1IgXCIsXG4gICAgW09wLmNvbF06IFwiQ09MXCIsXG4gICAgW09wLnBsYWNlaG9sZGVyXTogXCIkJFBMQUNFSE9MREVSJCRcIixcbiAgICBbT3AubWF0Y2hdOiBcIkBAXCJcbiAgfSxcbiAgT3BlcmF0b3JzQWxpYXNNYXA6IHt9LFxuICBzZXRPcGVyYXRvcnNBbGlhc2VzKGFsaWFzZXMpIHtcbiAgICBpZiAoIWFsaWFzZXMgfHwgXy5pc0VtcHR5KGFsaWFzZXMpKSB7XG4gICAgICB0aGlzLk9wZXJhdG9yc0FsaWFzTWFwID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuT3BlcmF0b3JzQWxpYXNNYXAgPSBfX3NwcmVhZFZhbHVlcyh7fSwgYWxpYXNlcyk7XG4gICAgfVxuICB9LFxuICBfcmVwbGFjZUFsaWFzZXMob3JpZykge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGlmICghdGhpcy5PcGVyYXRvcnNBbGlhc01hcCkge1xuICAgICAgcmV0dXJuIG9yaWc7XG4gICAgfVxuICAgIFV0aWxzLmdldE9wZXJhdG9ycyhvcmlnKS5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IG9yaWdbb3BdO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChpdGVtKSkge1xuICAgICAgICBvYmpbb3BdID0gdGhpcy5fcmVwbGFjZUFsaWFzZXMoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbb3BdID0gaXRlbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfLmZvck93bihvcmlnLCAoaXRlbSwgcHJvcCkgPT4ge1xuICAgICAgcHJvcCA9IHRoaXMuT3BlcmF0b3JzQWxpYXNNYXBbcHJvcF0gfHwgcHJvcDtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoaXRlbSkpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMuX3JlcGxhY2VBbGlhc2VzKGl0ZW0pO1xuICAgICAgfVxuICAgICAgb2JqW3Byb3BdID0gaXRlbTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRvckhlbHBlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcGVyYXRvcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/operators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst TransactionQueries = {\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    return `SET TRANSACTION ISOLATION LEVEL ${value};`;\n  },\n  generateTransactionId() {\n    return uuidv4();\n  },\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n    return \"START TRANSACTION;\";\n  },\n  deferConstraintsQuery() {\n  },\n  setConstraintQuery() {\n  },\n  setDeferredQuery() {\n  },\n  setImmediateQuery() {\n  },\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT;\";\n  },\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name, true)};`;\n    }\n    return \"ROLLBACK;\";\n  }\n};\nmodule.exports = TransactionQueries;\n//# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3IvdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLHdGQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQSw4QkFBOEI7QUFDOUIsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0NBQXNDLDhDQUE4QztBQUNwRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yL3RyYW5zYWN0aW9uLmpzPzVhYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB1dWlkdjQgPSByZXF1aXJlKFwidXVpZFwiKS52NDtcbmNvbnN0IFRyYW5zYWN0aW9uUXVlcmllcyA9IHtcbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYFNFVCBUUkFOU0FDVElPTiBJU09MQVRJT04gTEVWRUwgJHt2YWx1ZX07YDtcbiAgfSxcbiAgZ2VuZXJhdGVUcmFuc2FjdGlvbklkKCkge1xuICAgIHJldHVybiB1dWlkdjQoKTtcbiAgfSxcbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lLCB0cnVlKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiU1RBUlQgVFJBTlNBQ1RJT047XCI7XG4gIH0sXG4gIGRlZmVyQ29uc3RyYWludHNRdWVyeSgpIHtcbiAgfSxcbiAgc2V0Q29uc3RyYWludFF1ZXJ5KCkge1xuICB9LFxuICBzZXREZWZlcnJlZFF1ZXJ5KCkge1xuICB9LFxuICBzZXRJbW1lZGlhdGVRdWVyeSgpIHtcbiAgfSxcbiAgY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFwiQ09NTUlUO1wiO1xuICB9LFxuICByb2xsYmFja1RyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFJPTExCQUNLIFRPIFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUsIHRydWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gXCJST0xMQkFDSztcIjtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25RdWVyaWVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropAllSchemas(options) {\n    options = options || {};\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map((schemaName) => this.dropSchema(schemaName, options)));\n  }\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map((value) => value.schema_name ? value.schema_name : value));\n  }\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), { type: QueryTypes.VERSION }));\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n    const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWTABLES\n    }));\n    return out.length === 1;\n  }\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), { cascade: true }));\n      }\n    }\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { supportsSearchPath: false }));\n  }\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWINDEXES }));\n  }\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.FOREIGNKEYS });\n    const results = await Promise.all(tableNames.map((tableName) => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      result[tableName] = Array.isArray(results[i]) ? results[i].map((r) => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SHOWCONSTRAINTS }));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance)\n      results[0].isNewRecord = false;\n    return results;\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n      const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n        const indexKey = indexKeys.find((fields) => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\")\n      identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances)\n        continue;\n      if (!Array.isArray(instances))\n        instances = [instances];\n      for (const _instance of instances)\n        await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n    if (typeof identifier === \"object\")\n      where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), { type: QueryTypes.SELECT, model });\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n    const result = data ? data[attributeSelector] : null;\n    if (!options || !options.dataType) {\n      return result;\n    }\n    const dataType = options.dataType;\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  ensureEnums() {\n  }\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n    if (transaction.parent || !value) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql)\n      return;\n    return await this.sequelize.query(sql, options);\n  }\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), { transaction: transaction.parent || transaction });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n    if (transaction.parent) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n}\nexports.QueryInterface = QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQW1CO0FBQy9DLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsY0FBYywwQkFBMEI7QUFDako7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjLGVBQWU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUIsR0FBRyxvQkFBb0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDJCQUEyQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSwwQ0FBMEM7QUFDekc7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxVQUFVLDBDQUEwQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFdBQVcsMEJBQTBCLFdBQVc7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxjQUFjLDJCQUEyQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYyw4QkFBOEI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjLDhCQUE4QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUIsR0FBRyxvQkFBb0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsY0FBYyxrQ0FBa0M7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsK0ZBQStGLDRCQUE0QjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUUsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsZ0RBQWdEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxnREFBZ0Q7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2UuanM/NWJiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY2xhc3MgUXVlcnlJbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUsIHF1ZXJ5R2VuZXJhdG9yKSB7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IHF1ZXJ5R2VuZXJhdG9yO1xuICB9XG4gIGFzeW5jIGNyZWF0ZURhdGFiYXNlKGRhdGFiYXNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkcm9wRGF0YWJhc2UoZGF0YWJhc2UsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBjcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVTY2hlbWEoc2NoZW1hKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkcm9wU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcFNjaGVtYShzY2hlbWEpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRyb3BBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIXRoaXMucXVlcnlHZW5lcmF0b3IuX2RpYWxlY3Quc3VwcG9ydHMuc2NoZW1hcykge1xuICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLmRyb3Aob3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYXMgPSBhd2FpdCB0aGlzLnNob3dBbGxTY2hlbWFzKG9wdGlvbnMpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChzY2hlbWFzLm1hcCgoc2NoZW1hTmFtZSkgPT4gdGhpcy5kcm9wU2NoZW1hKHNjaGVtYU5hbWUsIG9wdGlvbnMpKSk7XG4gIH1cbiAgYXN5bmMgc2hvd0FsbFNjaGVtYXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgdHlwZTogdGhpcy5zZXF1ZWxpemUuUXVlcnlUeXBlcy5TRUxFQ1RcbiAgICB9KTtcbiAgICBjb25zdCBzaG93U2NoZW1hc1NxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd1NjaGVtYXNRdWVyeShvcHRpb25zKTtcbiAgICBjb25zdCBzY2hlbWFOYW1lcyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNob3dTY2hlbWFzU3FsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gXy5mbGF0dGVuKHNjaGVtYU5hbWVzLm1hcCgodmFsdWUpID0+IHZhbHVlLnNjaGVtYV9uYW1lID8gdmFsdWUuc2NoZW1hX25hbWUgOiB2YWx1ZSkpO1xuICB9XG4gIGFzeW5jIGRhdGFiYXNlVmVyc2lvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IudmVyc2lvblF1ZXJ5KCksIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuVkVSU0lPTiB9KSk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVGFibGUodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIGxldCBzcWwgPSBcIlwiO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmZvck93bihvcHRpb25zLnVuaXF1ZUtleXMsICh1bmlxdWVLZXkpID0+IHtcbiAgICAgICAgaWYgKHVuaXF1ZUtleS5jdXN0b21JbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdW5pcXVlS2V5LmN1c3RvbUluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtb2RlbCkge1xuICAgICAgb3B0aW9ucy51bmlxdWVLZXlzID0gb3B0aW9ucy51bmlxdWVLZXlzIHx8IG1vZGVsLnVuaXF1ZUtleXM7XG4gICAgfVxuICAgIGF0dHJpYnV0ZXMgPSBfLm1hcFZhbHVlcyhhdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiB0aGlzLnNlcXVlbGl6ZS5ub3JtYWxpemVBdHRyaWJ1dGUoYXR0cmlidXRlKSk7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKTtcbiAgICBpZiAoIXRhYmxlTmFtZS5zY2hlbWEgJiYgKG9wdGlvbnMuc2NoZW1hIHx8ICEhbW9kZWwgJiYgbW9kZWwuX3NjaGVtYSkpIHtcbiAgICAgIHRhYmxlTmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkU2NoZW1hKHtcbiAgICAgICAgdGFibGVOYW1lLFxuICAgICAgICBfc2NoZW1hOiAhIW1vZGVsICYmIG1vZGVsLl9zY2hlbWEgfHwgb3B0aW9ucy5zY2hlbWFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywge1xuICAgICAgdGFibGU6IHRhYmxlTmFtZSxcbiAgICAgIGNvbnRleHQ6IFwiY3JlYXRlVGFibGVcIixcbiAgICAgIHdpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHM6IG9wdGlvbnMud2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50c1xuICAgIH0pO1xuICAgIHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHRhYmxlRXhpc3RzKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IudGFibGVFeGlzdHNRdWVyeSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IG91dCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV1RBQkxFU1xuICAgIH0pKTtcbiAgICByZXR1cm4gb3V0Lmxlbmd0aCA9PT0gMTtcbiAgfVxuICBhc3luYyBkcm9wVGFibGUodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLmNhc2NhZGUgPSBvcHRpb25zLmNhc2NhZGUgfHwgb3B0aW9ucy5mb3JjZSB8fCBmYWxzZTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBfZHJvcEFsbFRhYmxlcyh0YWJsZU5hbWVzLCBza2lwLCBvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCB0YWJsZU5hbWUgb2YgdGFibGVOYW1lcykge1xuICAgICAgaWYgKCFza2lwLmluY2x1ZGVzKHRhYmxlTmFtZS50YWJsZU5hbWUgfHwgdGFibGVOYW1lKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmRyb3BUYWJsZSh0YWJsZU5hbWUsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGNhc2NhZGU6IHRydWUgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkcm9wQWxsVGFibGVzKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBza2lwID0gb3B0aW9ucy5za2lwIHx8IFtdO1xuICAgIGNvbnN0IHRhYmxlTmFtZXMgPSBhd2FpdCB0aGlzLnNob3dBbGxUYWJsZXMob3B0aW9ucyk7XG4gICAgY29uc3QgZm9yZWlnbktleXMgPSBhd2FpdCB0aGlzLmdldEZvcmVpZ25LZXlzRm9yVGFibGVzKHRhYmxlTmFtZXMsIG9wdGlvbnMpO1xuICAgIGZvciAoY29uc3QgdGFibGVOYW1lIG9mIHRhYmxlTmFtZXMpIHtcbiAgICAgIGxldCBub3JtYWxpemVkVGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgICAgaWYgKF8uaXNPYmplY3QodGFibGVOYW1lKSkge1xuICAgICAgICBub3JtYWxpemVkVGFibGVOYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHt0YWJsZU5hbWUudGFibGVOYW1lfWA7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGZvcmVpZ25LZXkgb2YgZm9yZWlnbktleXNbbm9ybWFsaXplZFRhYmxlTmFtZV0pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9kcm9wQWxsVGFibGVzKHRhYmxlTmFtZXMsIHNraXAsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHJlbmFtZVRhYmxlKGJlZm9yZSwgYWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZVRhYmxlUXVlcnkoYmVmb3JlLCBhZnRlcik7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2hvd0FsbFRhYmxlcyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNIT1dUQUJMRVNcbiAgICB9KTtcbiAgICBjb25zdCBzaG93VGFibGVzU3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93VGFibGVzUXVlcnkodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKTtcbiAgICBjb25zdCB0YWJsZU5hbWVzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc2hvd1RhYmxlc1NxbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF8uZmxhdHRlbih0YWJsZU5hbWVzKTtcbiAgfVxuICBhc3luYyBkZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSBudWxsO1xuICAgIGxldCBzY2hlbWFEZWxpbWl0ZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hIHx8IG51bGw7XG4gICAgICBzY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zLnNjaGVtYURlbGltaXRlciB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJvYmplY3RcIiAmJiB0YWJsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IHRhYmxlTmFtZS5zY2hlbWE7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5ERVNDUklCRSB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoXy5pc0VtcHR5KGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUub3JpZ2luYWwgJiYgZS5vcmlnaW5hbC5jb2RlID09PSBcIkVSX05PX1NVQ0hfVEFCTEVcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZENvbHVtbih0YWJsZSwga2V5LCBhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRhYmxlIHx8ICFrZXkgfHwgIWF0dHJpYnV0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkQ29sdW1uIHRha2VzIGF0IGxlYXN0IDMgYXJndW1lbnRzICh0YWJsZSwgYXR0cmlidXRlIG5hbWUsIGF0dHJpYnV0ZSBkZWZpbml0aW9uKVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgYXR0cmlidXRlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgYXR0cmlidXRlKSwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSksIG9wdGlvbnMpO1xuICB9XG4gIG5vcm1hbGl6ZUF0dHJpYnV0ZShkYXRhVHlwZU9yT3B0aW9ucykge1xuICAgIGxldCBhdHRyaWJ1dGU7XG4gICAgaWYgKE9iamVjdC52YWx1ZXMoRGF0YVR5cGVzKS5pbmNsdWRlcyhkYXRhVHlwZU9yT3B0aW9ucykpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHsgdHlwZTogZGF0YVR5cGVPck9wdGlvbnMsIGFsbG93TnVsbDogdHJ1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGUgPSBkYXRhVHlwZU9yT3B0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyMiwgZm9yY2UpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllcjIsIGZvcmNlKTtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXJzKGlkZW50aWZpZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVycyhpZGVudGlmaWVycyk7XG4gIH1cbiAgYXN5bmMgY2hhbmdlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgZGF0YVR5cGVPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKHtcbiAgICAgIFthdHRyaWJ1dGVOYW1lXTogdGhpcy5ub3JtYWxpemVBdHRyaWJ1dGUoZGF0YVR5cGVPck9wdGlvbnMpXG4gICAgfSwge1xuICAgICAgY29udGV4dDogXCJjaGFuZ2VDb2x1bW5cIixcbiAgICAgIHRhYmxlOiB0YWJsZU5hbWVcbiAgICB9KTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgcXVlcnkpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGFzc2VydFRhYmxlSGFzQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKGRlc2NyaXB0aW9uW2NvbHVtbk5hbWVdKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVGFibGUgJHt0YWJsZU5hbWV9IGRvZXNuJ3QgaGF2ZSB0aGUgY29sdW1uICR7Y29sdW1uTmFtZX1gKTtcbiAgfVxuICBhc3luYyByZW5hbWVDb2x1bW4odGFibGVOYW1lLCBhdHRyTmFtZUJlZm9yZSwgYXR0ck5hbWVBZnRlciwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgdGhpcy5hc3NlcnRUYWJsZUhhc0NvbHVtbih0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCBvcHRpb25zKSlbYXR0ck5hbWVCZWZvcmVdO1xuICAgIGNvbnN0IF9vcHRpb25zID0ge307XG4gICAgX29wdGlvbnNbYXR0ck5hbWVBZnRlcl0gPSB7XG4gICAgICBhdHRyaWJ1dGU6IGF0dHJOYW1lQWZ0ZXIsXG4gICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICBhbGxvd051bGw6IGRhdGEuYWxsb3dOdWxsLFxuICAgICAgZGVmYXVsdFZhbHVlOiBkYXRhLmRlZmF1bHRWYWx1ZVxuICAgIH07XG4gICAgaWYgKGRhdGEuZGVmYXVsdFZhbHVlID09PSBudWxsICYmICFkYXRhLmFsbG93TnVsbCkge1xuICAgICAgZGVsZXRlIF9vcHRpb25zW2F0dHJOYW1lQWZ0ZXJdLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5yZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJOYW1lQmVmb3JlLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmF0dHJpYnV0ZXNUb1NRTChfb3B0aW9ucykpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGFkZEluZGV4KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgcmF3VGFibGVuYW1lKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICByYXdUYWJsZW5hbWUgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IGF0dHJpYnV0ZXM7XG4gICAgICBhdHRyaWJ1dGVzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgfVxuICAgIGlmICghcmF3VGFibGVuYW1lKSB7XG4gICAgICByYXdUYWJsZW5hbWUgPSB0YWJsZU5hbWU7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5maWVsZHMgPSBhdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYWRkSW5kZXhRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMsIHJhd1RhYmxlbmFtZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgc3VwcG9ydHNTZWFyY2hQYXRoOiBmYWxzZSB9KSk7XG4gIH1cbiAgYXN5bmMgc2hvd0luZGV4KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc2hvd0luZGV4ZXNRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV0lOREVYRVMgfSkpO1xuICB9XG4gIGFzeW5jIGdldEZvcmVpZ25LZXlzRm9yVGFibGVzKHRhYmxlTmFtZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFibGVOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVMgfSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRhYmxlTmFtZXMubWFwKCh0YWJsZU5hbWUpID0+IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSksIG9wdGlvbnMpKSk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgdGFibGVOYW1lcy5mb3JFYWNoKCh0YWJsZU5hbWUsIGkpID0+IHtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHt0YWJsZU5hbWUudGFibGVOYW1lfWA7XG4gICAgICB9XG4gICAgICByZXN1bHRbdGFibGVOYW1lXSA9IEFycmF5LmlzQXJyYXkocmVzdWx0c1tpXSkgPyByZXN1bHRzW2ldLm1hcCgocikgPT4gci5jb25zdHJhaW50X25hbWUpIDogW3Jlc3VsdHNbaV0gJiYgcmVzdWx0c1tpXS5jb25zdHJhaW50X25hbWVdO1xuICAgICAgcmVzdWx0W3RhYmxlTmFtZV0gPSByZXN1bHRbdGFibGVOYW1lXS5maWx0ZXIoXy5pZGVudGl0eSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHF1ZXJ5T3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLkZPUkVJR05LRVlTXG4gICAgfSk7XG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lLCB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2UpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgcXVlcnlPcHRpb25zKTtcbiAgfVxuICBhc3luYyByZW1vdmVJbmRleCh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgYWRkQ29uc3RyYWludCh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZHMgbXVzdCBiZSBzcGVjaWZpZWQgdGhyb3VnaCBvcHRpb25zLmZpZWxkc1wiKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnN0cmFpbnQgdHlwZSBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMudHlwZVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHNob3dDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHR5cGU6IFF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTIH0pKTtcbiAgfVxuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5yZW1vdmVDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSksIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGluc2VydChpbnN0YW5jZSwgdGFibGVOYW1lLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuaGFzVHJpZ2dlciA9IGluc3RhbmNlICYmIGluc3RhbmNlLmNvbnN0cnVjdG9yLm9wdGlvbnMuaGFzVHJpZ2dlcjtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgdmFsdWVzLCBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLklOU0VSVDtcbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKGluc3RhbmNlKVxuICAgICAgcmVzdWx0c1swXS5pc05ld1JlY29yZCA9IGZhbHNlO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IG9wdGlvbnMuY29uZmxpY3RGaWVsZHMgfHwgW107XG4gICAgaWYgKG9wdGlvbnMudXBzZXJ0S2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHByaW1hcnlLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKChpdGVtKSA9PiBpdGVtLmZpZWxkKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnVuaXF1ZUtleXMpLmZpbHRlcigoYykgPT4gYy5maWVsZHMubGVuZ3RoID4gMCkubWFwKChjKSA9PiBjLmZpZWxkcyk7XG4gICAgICBjb25zdCBpbmRleEtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLl9pbmRleGVzKS5maWx0ZXIoKGMpID0+IGMudW5pcXVlICYmIGMuZmllbGRzLmxlbmd0aCA+IDApLm1hcCgoYykgPT4gYy5maWVsZHMpO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHVuaXF1ZUtleXMuZmluZCgoZmllbGRzKSA9PiBmaWVsZHMuaW5jbHVkZXMoZmllbGQpKTtcbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IHVuaXF1ZUtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleEtleSA9IGluZGV4S2V5cy5maW5kKChmaWVsZHMpID0+IGZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpO1xuICAgICAgICBpZiAoaW5kZXhLZXkpIHtcbiAgICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBpbmRleEtleTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudXBzZXJ0S2V5cy5sZW5ndGggPT09IDAgfHwgXy5pbnRlcnNlY3Rpb24ob3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSwgcHJpbWFyeUtleXMpLmxlbmd0aCkge1xuICAgICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBwcmltYXJ5S2V5cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXBzZXJ0S2V5cyA9IF8udW5pcShvcHRpb25zLnVwc2VydEtleXMpO1xuICAgIH1cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCBtb2RlbC5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBidWxrSW5zZXJ0KHRhYmxlTmFtZSwgcmVjb3Jkcywgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5JTlNFUlQ7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuYnVsa0luc2VydFF1ZXJ5KHRhYmxlTmFtZSwgcmVjb3Jkcywgb3B0aW9ucywgYXR0cmlidXRlcyksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHRzWzBdO1xuICB9XG4gIGFzeW5jIHVwZGF0ZShpbnN0YW5jZSwgdGFibGVOYW1lLCB2YWx1ZXMsIGlkZW50aWZpZXIyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBvcHRpb25zLmhhc1RyaWdnZXIgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLmhhc1RyaWdnZXI7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIHZhbHVlcywgaWRlbnRpZmllcjIsIG9wdGlvbnMsIGluc3RhbmNlLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICAgIG9wdGlvbnMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBidWxrVXBkYXRlKHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyMiwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyMiA9PT0gXCJvYmplY3RcIilcbiAgICAgIGlkZW50aWZpZXIyID0gVXRpbHMuY2xvbmVEZWVwKGlkZW50aWZpZXIyKTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgdmFsdWVzLCBpZGVudGlmaWVyMiwgb3B0aW9ucywgYXR0cmlidXRlcyk7XG4gICAgY29uc3QgdGFibGUgPSBfLmlzT2JqZWN0KHRhYmxlTmFtZSkgPyB0YWJsZU5hbWUgOiB7IHRhYmxlTmFtZSB9O1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbCA/IG9wdGlvbnMubW9kZWwgOiBfLmZpbmQodGhpcy5zZXF1ZWxpemUubW9kZWxNYW5hZ2VyLm1vZGVscywgeyB0YWJsZU5hbWU6IHRhYmxlLnRhYmxlTmFtZSB9KTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG4gICAgb3B0aW9ucy5tb2RlbCA9IG1vZGVsO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRlbGV0ZShpbnN0YW5jZSwgdGFibGVOYW1lLCBpZGVudGlmaWVyMiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhc2NhZGVzID0gW107XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZWxldGVRdWVyeSh0YWJsZU5hbWUsIGlkZW50aWZpZXIyLCB7fSwgaW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgaWYgKCEhaW5zdGFuY2UuY29uc3RydWN0b3IgJiYgISFpbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICBsZXQgYXNzb2NpYXRpb247XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFzc29jaWF0aW9uID0gaW5zdGFuY2UuY29uc3RydWN0b3IuYXNzb2NpYXRpb25zW2tleXNbaV1dO1xuICAgICAgICBpZiAoYXNzb2NpYXRpb24ub3B0aW9ucyAmJiBhc3NvY2lhdGlvbi5vcHRpb25zLm9uRGVsZXRlICYmIGFzc29jaWF0aW9uLm9wdGlvbnMub25EZWxldGUudG9Mb3dlckNhc2UoKSA9PT0gXCJjYXNjYWRlXCIgJiYgYXNzb2NpYXRpb24ub3B0aW9ucy51c2VIb29rcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNhc2NhZGVzLnB1c2goYXNzb2NpYXRpb24uYWNjZXNzb3JzLmdldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBjYXNjYWRlIG9mIGNhc2NhZGVzKSB7XG4gICAgICBsZXQgaW5zdGFuY2VzID0gYXdhaXQgaW5zdGFuY2VbY2FzY2FkZV0ob3B0aW9ucyk7XG4gICAgICBpZiAoIWluc3RhbmNlcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSlcbiAgICAgICAgaW5zdGFuY2VzID0gW2luc3RhbmNlc107XG4gICAgICBmb3IgKGNvbnN0IF9pbnN0YW5jZSBvZiBpbnN0YW5jZXMpXG4gICAgICAgIGF3YWl0IF9pbnN0YW5jZS5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgYnVsa0RlbGV0ZSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zLCBtb2RlbCkge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywgeyBsaW1pdDogbnVsbCB9KTtcbiAgICBpZiAob3B0aW9ucy50cnVuY2F0ZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IudHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09IFwib2JqZWN0XCIpXG4gICAgICB3aGVyZSA9IFV0aWxzLmNsb25lRGVlcCh3aGVyZSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucywgbW9kZWwpLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzZWxlY3QobW9kZWwsIHRhYmxlTmFtZSwgb3B0aW9uc0FyZykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zQXJnKSwgeyB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCwgbW9kZWwgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3Iuc2VsZWN0UXVlcnkodGFibGVOYW1lLCBvcHRpb25zLCBtb2RlbCksIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGluY3JlbWVudChtb2RlbCwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFyaXRobWV0aWNRdWVyeShcIitcIiwgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQREFURTtcbiAgICBvcHRpb25zLm1vZGVsID0gbW9kZWw7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZGVjcmVtZW50KG1vZGVsLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXJpdGhtZXRpY1F1ZXJ5KFwiLVwiLCB0YWJsZU5hbWUsIHdoZXJlLCBpbmNyZW1lbnRBbW91bnRzQnlGaWVsZCwgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWQsIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBEQVRFO1xuICAgIG9wdGlvbnMubW9kZWwgPSBtb2RlbDtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyByYXdTZWxlY3QodGFibGVOYW1lLCBvcHRpb25zLCBhdHRyaWJ1dGVTZWxlY3RvciwgTW9kZWwpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIHJhdzogdHJ1ZSxcbiAgICAgIHBsYWluOiB0cnVlLFxuICAgICAgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1RcbiAgICB9KTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNlbGVjdFF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucywgTW9kZWwpO1xuICAgIGlmIChhdHRyaWJ1dGVTZWxlY3RvciA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcGFzcyBhbiBhdHRyaWJ1dGUgc2VsZWN0b3IhXCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGxhaW4pIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBkYXRhID8gZGF0YVthdHRyaWJ1dGVTZWxlY3Rvcl0gOiBudWxsO1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5kYXRhVHlwZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgZGF0YVR5cGUgPSBvcHRpb25zLmRhdGFUeXBlO1xuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5ERUNJTUFMIHx8IGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkZMT0FUKSB7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5JTlRFR0VSIHx8IGRhdGFUeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkJJR0lOVCkge1xuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQocmVzdWx0LCAxMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFKSB7XG4gICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmICEocmVzdWx0IGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgY3JlYXRlVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCB0aW1pbmdUeXBlLCBmaXJlT25BcnJheSwgZnVuY3Rpb25OYW1lLCBmdW5jdGlvblBhcmFtcywgb3B0aW9uc0FycmF5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUsIHRpbWluZ1R5cGUsIGZpcmVPbkFycmF5LCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCBvcHRpb25zQXJyYXkpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmIChzcWwpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkcm9wVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wVHJpZ2dlcih0YWJsZU5hbWUsIHRyaWdnZXJOYW1lKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVuYW1lVHJpZ2dlcih0YWJsZU5hbWUsIG9sZFRyaWdnZXJOYW1lLCBuZXdUcmlnZ2VyTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lVHJpZ2dlcih0YWJsZU5hbWUsIG9sZFRyaWdnZXJOYW1lLCBuZXdUcmlnZ2VyTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zLCByZXR1cm5UeXBlLCBsYW5ndWFnZSwgYm9keSwgb3B0aW9uc0FycmF5LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UsIGJvZHksIG9wdGlvbnNBcnJheSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRyb3BGdW5jdGlvbihmdW5jdGlvbk5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoc3FsKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcmVuYW1lRnVuY3Rpb24ob2xkRnVuY3Rpb25OYW1lLCBwYXJhbXMsIG5ld0Z1bmN0aW9uTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVuYW1lRnVuY3Rpb24ob2xkRnVuY3Rpb25OYW1lLCBwYXJhbXMsIG5ld0Z1bmN0aW9uTmFtZSk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGVuc3VyZUVudW1zKCkge1xuICB9XG4gIGFzeW5jIHNldElzb2xhdGlvbkxldmVsKHRyYW5zYWN0aW9uLCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHNldCBpc29sYXRpb24gbGV2ZWwgZm9yIGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhXCIpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50IHx8ICF2YWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbiB9KTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUsIHtcbiAgICAgIHBhcmVudDogdHJhbnNhY3Rpb24ucGFyZW50XG4gICAgfSk7XG4gICAgaWYgKCFzcWwpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc3RhcnRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICghdHJhbnNhY3Rpb24gfHwgISh0cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHN0YXJ0IGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbiB9KTtcbiAgICBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUgPSB0cmFuc2FjdGlvbi5wYXJlbnQgPyB0cmFuc2FjdGlvbi5uYW1lIDogdm9pZCAwO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3Iuc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkZWZlckNvbnN0cmFpbnRzKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvbi5wYXJlbnQgfHwgdHJhbnNhY3Rpb24gfSk7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kZWZlckNvbnN0cmFpbnRzUXVlcnkob3B0aW9ucyk7XG4gICAgaWYgKHNxbCkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbW1pdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbiB8fCAhKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgVHJhbnNhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29tbWl0IGEgdHJhbnNhY3Rpb24gd2l0aG91dCB0cmFuc2FjdGlvbiBvYmplY3QhXCIpO1xuICAgIH1cbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uLnBhcmVudCB8fCB0cmFuc2FjdGlvbixcbiAgICAgIHN1cHBvcnRzU2VhcmNoUGF0aDogZmFsc2UsXG4gICAgICBjb21wbGV0ZXNUcmFuc2FjdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgdHJhbnNhY3Rpb24uZmluaXNoZWQgPSBcImNvbW1pdFwiO1xuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICB9XG4gIGFzeW5jIHJvbGxiYWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uIHx8ICEodHJhbnNhY3Rpb24gaW5zdGFuY2VvZiBUcmFuc2FjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByb2xsYmFjayBhIHRyYW5zYWN0aW9uIHdpdGhvdXQgdHJhbnNhY3Rpb24gb2JqZWN0IVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7XG4gICAgICB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb24ucGFyZW50IHx8IHRyYW5zYWN0aW9uLFxuICAgICAgc3VwcG9ydHNTZWFyY2hQYXRoOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlc1RyYW5zYWN0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lID0gdHJhbnNhY3Rpb24ucGFyZW50ID8gdHJhbnNhY3Rpb24ubmFtZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbik7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gICAgdHJhbnNhY3Rpb24uZmluaXNoZWQgPSBcInJvbGxiYWNrXCI7XG4gICAgcmV0dXJuIGF3YWl0IHByb21pc2U7XG4gIH1cbn1cbmV4cG9ydHMuUXVlcnlJbnRlcmZhY2UgPSBRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/abstract/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst SqlString = __webpack_require__(/*! ../../sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst Dot = __webpack_require__(/*! dottie */ \"(rsc)/./node_modules/dottie/dottie.js\");\nconst deprecations = __webpack_require__(/*! ../../utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst uuid = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst { safeStringifyJson } = __webpack_require__(/*! ../../utils.js */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nclass AbstractQuery {\n  constructor(connection, sequelize, options) {\n    this.uuid = uuid();\n    this.connection = connection;\n    this.instance = options.instance;\n    this.model = options.model;\n    this.sequelize = sequelize;\n    this.options = __spreadValues({\n      plain: false,\n      raw: false,\n      logging: console.log\n    }, options);\n    this.checkLoggingOption();\n    if (options.rawErrors) {\n      this.formatError = AbstractQuery.prototype.formatError;\n    }\n  }\n  static formatBindParameters(sql, values, dialect, replacementFunc, options) {\n    if (!values) {\n      return [sql, []];\n    }\n    options = options || {};\n    if (typeof replacementFunc !== \"function\") {\n      options = replacementFunc || {};\n      replacementFunc = void 0;\n    }\n    if (!replacementFunc) {\n      if (options.skipValueReplace) {\n        replacementFunc = (match, key, values2) => {\n          if (values2[key] !== void 0) {\n            return match;\n          }\n          return void 0;\n        };\n      } else {\n        replacementFunc = (match, key, values2, timeZone2, dialect2) => {\n          if (values2[key] !== void 0) {\n            return SqlString.escape(values2[key], timeZone2, dialect2);\n          }\n          return void 0;\n        };\n      }\n    } else if (options.skipValueReplace) {\n      const origReplacementFunc = replacementFunc;\n      replacementFunc = (match, key, values2, timeZone2, dialect2, options2) => {\n        if (origReplacementFunc(match, key, values2, timeZone2, dialect2, options2) !== void 0) {\n          return match;\n        }\n        return void 0;\n      };\n    }\n    const timeZone = null;\n    const list = Array.isArray(values);\n    sql = sql.replace(/\\B\\$(\\$|\\w+)/g, (match, key) => {\n      if (key === \"$\") {\n        return options.skipUnescape ? match : key;\n      }\n      let replVal;\n      if (list) {\n        if (key.match(/^[1-9]\\d*$/)) {\n          key = key - 1;\n          replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n        }\n      } else if (!key.match(/^\\d*$/)) {\n        replVal = replacementFunc(match, key, values, timeZone, dialect, options);\n      }\n      if (replVal === void 0) {\n        throw new Error(`Named bind parameter \"${match}\" has no value in the given object.`);\n      }\n      return replVal;\n    });\n    return [sql, []];\n  }\n  formatError(error, errStack) {\n    error.stack = errStack;\n    return error;\n  }\n  run() {\n    throw new Error(\"The run method wasn't overwritten!\");\n  }\n  checkLoggingOption() {\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.log;\n    }\n  }\n  getInsertIdField() {\n    return \"insertId\";\n  }\n  getUniqueConstraintErrorMessage(field) {\n    let message = field ? `${field} must be unique` : \"Must be unique\";\n    if (field && this.model) {\n      for (const key of Object.keys(this.model.uniqueKeys)) {\n        if (this.model.uniqueKeys[key].fields.includes(field.replace(/\"/g, \"\"))) {\n          if (this.model.uniqueKeys[key].msg) {\n            message = this.model.uniqueKeys[key].msg;\n          }\n        }\n      }\n    }\n    return message;\n  }\n  isRawQuery() {\n    return this.options.type === QueryTypes.RAW;\n  }\n  isVersionQuery() {\n    return this.options.type === QueryTypes.VERSION;\n  }\n  isUpsertQuery() {\n    return this.options.type === QueryTypes.UPSERT;\n  }\n  isInsertQuery(results, metaData) {\n    let result = true;\n    if (this.options.type === QueryTypes.INSERT) {\n      return true;\n    }\n    result = result && this.sql.toLowerCase().startsWith(\"insert into\");\n    result = result && (!results || Object.prototype.hasOwnProperty.call(results, this.getInsertIdField()));\n    result = result && (!metaData || Object.prototype.hasOwnProperty.call(metaData, this.getInsertIdField()));\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      id = id || results && results[this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n  isShowTablesQuery() {\n    return this.options.type === QueryTypes.SHOWTABLES;\n  }\n  handleShowTablesQuery(results) {\n    return _.flatten(results.map((resultSet) => Object.values(resultSet)));\n  }\n  isShowIndexesQuery() {\n    return this.options.type === QueryTypes.SHOWINDEXES;\n  }\n  isShowConstraintsQuery() {\n    return this.options.type === QueryTypes.SHOWCONSTRAINTS;\n  }\n  isDescribeQuery() {\n    return this.options.type === QueryTypes.DESCRIBE;\n  }\n  isSelectQuery() {\n    return this.options.type === QueryTypes.SELECT;\n  }\n  isBulkUpdateQuery() {\n    return this.options.type === QueryTypes.BULKUPDATE;\n  }\n  isBulkDeleteQuery() {\n    return this.options.type === QueryTypes.BULKDELETE;\n  }\n  isForeignKeysQuery() {\n    return this.options.type === QueryTypes.FOREIGNKEYS;\n  }\n  isUpdateQuery() {\n    return this.options.type === QueryTypes.UPDATE;\n  }\n  handleSelectQuery(results) {\n    let result = null;\n    if (this.options.fieldMap) {\n      const fieldMap = this.options.fieldMap;\n      results = results.map((result2) => _.reduce(fieldMap, (result3, name, field) => {\n        if (result3[field] !== void 0 && name !== field) {\n          result3[name] = result3[field];\n          delete result3[field];\n        }\n        return result3;\n      }, result2));\n    }\n    if (this.options.raw) {\n      result = results.map((result2) => {\n        let o = {};\n        for (const key in result2) {\n          if (Object.prototype.hasOwnProperty.call(result2, key)) {\n            o[key] = result2[key];\n          }\n        }\n        if (this.options.nest) {\n          o = Dot.transform(o);\n        }\n        return o;\n      });\n    } else if (this.options.hasJoin === true) {\n      results = AbstractQuery._groupJoinData(results, {\n        model: this.model,\n        includeMap: this.options.includeMap,\n        includeNames: this.options.includeNames\n      }, {\n        checkExisting: this.options.hasMultiAssociation\n      });\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        include: this.options.include,\n        includeNames: this.options.includeNames,\n        includeMap: this.options.includeMap,\n        includeValidated: true,\n        attributes: this.options.originalAttributes || this.options.attributes,\n        raw: true\n      });\n    } else {\n      result = this.model.bulkBuild(results, {\n        isNewRecord: false,\n        raw: true,\n        attributes: this.options.originalAttributes || this.options.attributes\n      });\n    }\n    if (this.options.plain) {\n      result = result.length === 0 ? null : result[0];\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"show\");\n    result = result || this.sql.toLowerCase().startsWith(\"describe\");\n    return result;\n  }\n  isCallQuery() {\n    return this.sql.toLowerCase().startsWith(\"call\");\n  }\n  _logQuery(sql, debugContext, parameters) {\n    const { connection, options } = this;\n    const benchmark = this.sequelize.options.benchmark || options.benchmark;\n    const logQueryParameters = this.sequelize.options.logQueryParameters || options.logQueryParameters;\n    const startTime = Date.now();\n    let logParameter = \"\";\n    if (logQueryParameters && parameters) {\n      const delimiter = sql.endsWith(\";\") ? \"\" : \";\";\n      let paramStr;\n      if (Array.isArray(parameters)) {\n        paramStr = parameters.map((p) => safeStringifyJson(p)).join(\", \");\n      } else {\n        paramStr = safeStringifyJson(parameters);\n      }\n      logParameter = `${delimiter} ${paramStr}`;\n    }\n    const fmt = `(${connection.uuid || \"default\"}): ${sql}${logParameter}`;\n    const msg = `Executing ${fmt}`;\n    debugContext(msg);\n    if (!benchmark) {\n      this.sequelize.log(`Executing ${fmt}`, options);\n    }\n    return () => {\n      const afterMsg = `Executed ${fmt}`;\n      debugContext(afterMsg);\n      if (benchmark) {\n        this.sequelize.log(afterMsg, Date.now() - startTime, options);\n      }\n    };\n  }\n  static _groupJoinData(rows, includeOptions, options) {\n    if (!rows.length) {\n      return [];\n    }\n    let i;\n    let length;\n    let $i;\n    let $length;\n    let rowsI;\n    let row;\n    const rowsLength = rows.length;\n    let keys;\n    let key;\n    let keyI;\n    let keyLength;\n    let prevKey;\n    let values;\n    let topValues;\n    let topExists;\n    const checkExisting = options.checkExisting;\n    let itemHash;\n    let parentHash;\n    let topHash;\n    const results = checkExisting ? [] : new Array(rowsLength);\n    const resultMap = {};\n    const includeMap = {};\n    let $keyPrefix;\n    let $keyPrefixString;\n    let $prevKeyPrefixString;\n    let $prevKeyPrefix;\n    let $lastKeyPrefix;\n    let $current;\n    let $parent;\n    let previousPiece;\n    const buildIncludeMap = (piece) => {\n      if (Object.prototype.hasOwnProperty.call($current.includeMap, piece)) {\n        includeMap[key] = $current = $current.includeMap[piece];\n        if (previousPiece) {\n          previousPiece = `${previousPiece}.${piece}`;\n        } else {\n          previousPiece = piece;\n        }\n        includeMap[previousPiece] = $current;\n      }\n    };\n    const keyPrefixStringMemo = {};\n    const keyPrefixString = (key2, memo) => {\n      if (!Object.prototype.hasOwnProperty.call(memo, key2)) {\n        memo[key2] = key2.substr(0, key2.lastIndexOf(\".\"));\n      }\n      return memo[key2];\n    };\n    const removeKeyPrefixMemo = {};\n    const removeKeyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(removeKeyPrefixMemo, key2)) {\n        const index = key2.lastIndexOf(\".\");\n        removeKeyPrefixMemo[key2] = key2.substr(index === -1 ? 0 : index + 1);\n      }\n      return removeKeyPrefixMemo[key2];\n    };\n    const keyPrefixMemo = {};\n    const keyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, key2)) {\n        const prefixString = keyPrefixString(key2, keyPrefixStringMemo);\n        if (!Object.prototype.hasOwnProperty.call(keyPrefixMemo, prefixString)) {\n          keyPrefixMemo[prefixString] = prefixString ? prefixString.split(\".\") : [];\n        }\n        keyPrefixMemo[key2] = keyPrefixMemo[prefixString];\n      }\n      return keyPrefixMemo[key2];\n    };\n    const lastKeyPrefixMemo = {};\n    const lastKeyPrefix = (key2) => {\n      if (!Object.prototype.hasOwnProperty.call(lastKeyPrefixMemo, key2)) {\n        const prefix2 = keyPrefix(key2);\n        const length2 = prefix2.length;\n        lastKeyPrefixMemo[key2] = !length2 ? \"\" : prefix2[length2 - 1];\n      }\n      return lastKeyPrefixMemo[key2];\n    };\n    const getUniqueKeyAttributes = (model) => {\n      let uniqueKeyAttributes2 = _.chain(model.uniqueKeys);\n      uniqueKeyAttributes2 = uniqueKeyAttributes2.result(`${uniqueKeyAttributes2.findKey()}.fields`).map((field) => _.findKey(model.attributes, (chr) => chr.field === field)).value();\n      return uniqueKeyAttributes2;\n    };\n    const stringify = (obj) => obj instanceof Buffer ? obj.toString(\"hex\") : obj;\n    let primaryKeyAttributes;\n    let uniqueKeyAttributes;\n    let prefix;\n    for (rowsI = 0; rowsI < rowsLength; rowsI++) {\n      row = rows[rowsI];\n      if (rowsI === 0) {\n        keys = _.sortBy(Object.keys(row), (item) => [item.split(\".\").length]);\n        keyLength = keys.length;\n      }\n      if (checkExisting) {\n        topExists = false;\n        $length = includeOptions.model.primaryKeyAttributes.length;\n        topHash = \"\";\n        if ($length === 1) {\n          topHash = stringify(row[includeOptions.model.primaryKeyAttributes[0]]);\n        } else if ($length > 1) {\n          for ($i = 0; $i < $length; $i++) {\n            topHash += stringify(row[includeOptions.model.primaryKeyAttributes[$i]]);\n          }\n        } else if (!_.isEmpty(includeOptions.model.uniqueKeys)) {\n          uniqueKeyAttributes = getUniqueKeyAttributes(includeOptions.model);\n          for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n            topHash += row[uniqueKeyAttributes[$i]];\n          }\n        }\n      }\n      topValues = values = {};\n      $prevKeyPrefix = void 0;\n      for (keyI = 0; keyI < keyLength; keyI++) {\n        key = keys[keyI];\n        $keyPrefixString = keyPrefixString(key, keyPrefixStringMemo);\n        $keyPrefix = keyPrefix(key);\n        if (rowsI === 0 && !Object.prototype.hasOwnProperty.call(includeMap, key)) {\n          if (!$keyPrefix.length) {\n            includeMap[key] = includeMap[\"\"] = includeOptions;\n          } else {\n            $current = includeOptions;\n            previousPiece = void 0;\n            $keyPrefix.forEach(buildIncludeMap);\n          }\n        }\n        if ($prevKeyPrefix !== void 0 && $prevKeyPrefix !== $keyPrefix) {\n          if (checkExisting) {\n            length = $prevKeyPrefix.length;\n            $parent = null;\n            parentHash = null;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n                primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n                $length = primaryKeyAttributes.length;\n                itemHash = prefix;\n                if ($length === 1) {\n                  itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n                } else if ($length > 1) {\n                  for ($i = 0; $i < $length; $i++) {\n                    itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n                  }\n                } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n                  uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n                  for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                    itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n                  }\n                }\n                if (!parentHash) {\n                  parentHash = topHash;\n                }\n                itemHash = parentHash + itemHash;\n                $parent = prefix;\n                if (i < length - 1) {\n                  parentHash = itemHash;\n                }\n              }\n            } else {\n              itemHash = topHash;\n            }\n            if (itemHash === topHash) {\n              if (!resultMap[itemHash]) {\n                resultMap[itemHash] = values;\n              } else {\n                topExists = true;\n              }\n            } else if (!resultMap[itemHash]) {\n              $parent = resultMap[parentHash];\n              $lastKeyPrefix = lastKeyPrefix(prevKey);\n              if (includeMap[prevKey].association.isSingleAssociation) {\n                if ($parent) {\n                  $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n                }\n              } else {\n                if (!$parent[$lastKeyPrefix]) {\n                  $parent[$lastKeyPrefix] = [];\n                }\n                $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n              }\n            }\n            values = {};\n          } else {\n            $current = topValues;\n            length = $keyPrefix.length;\n            if (length) {\n              for (i = 0; i < length; i++) {\n                if (i === length - 1) {\n                  values = $current[$keyPrefix[i]] = {};\n                }\n                $current = $current[$keyPrefix[i]] || {};\n              }\n            }\n          }\n        }\n        values[removeKeyPrefix(key)] = row[key];\n        prevKey = key;\n        $prevKeyPrefix = $keyPrefix;\n        $prevKeyPrefixString = $keyPrefixString;\n      }\n      if (checkExisting) {\n        length = $prevKeyPrefix.length;\n        $parent = null;\n        parentHash = null;\n        if (length) {\n          for (i = 0; i < length; i++) {\n            prefix = $parent ? `${$parent}.${$prevKeyPrefix[i]}` : $prevKeyPrefix[i];\n            primaryKeyAttributes = includeMap[prefix].model.primaryKeyAttributes;\n            $length = primaryKeyAttributes.length;\n            itemHash = prefix;\n            if ($length === 1) {\n              itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[0]}`]);\n            } else if ($length > 0) {\n              for ($i = 0; $i < $length; $i++) {\n                itemHash += stringify(row[`${prefix}.${primaryKeyAttributes[$i]}`]);\n              }\n            } else if (!_.isEmpty(includeMap[prefix].model.uniqueKeys)) {\n              uniqueKeyAttributes = getUniqueKeyAttributes(includeMap[prefix].model);\n              for ($i = 0; $i < uniqueKeyAttributes.length; $i++) {\n                itemHash += row[`${prefix}.${uniqueKeyAttributes[$i]}`];\n              }\n            }\n            if (!parentHash) {\n              parentHash = topHash;\n            }\n            itemHash = parentHash + itemHash;\n            $parent = prefix;\n            if (i < length - 1) {\n              parentHash = itemHash;\n            }\n          }\n        } else {\n          itemHash = topHash;\n        }\n        if (itemHash === topHash) {\n          if (!resultMap[itemHash]) {\n            resultMap[itemHash] = values;\n          } else {\n            topExists = true;\n          }\n        } else if (!resultMap[itemHash]) {\n          $parent = resultMap[parentHash];\n          $lastKeyPrefix = lastKeyPrefix(prevKey);\n          if (includeMap[prevKey].association.isSingleAssociation) {\n            if ($parent) {\n              $parent[$lastKeyPrefix] = resultMap[itemHash] = values;\n            }\n          } else {\n            if (!$parent[$lastKeyPrefix]) {\n              $parent[$lastKeyPrefix] = [];\n            }\n            $parent[$lastKeyPrefix].push(resultMap[itemHash] = values);\n          }\n        }\n        if (!topExists) {\n          results.push(topValues);\n        }\n      } else {\n        results[rowsI] = topValues;\n      }\n    }\n    return results;\n  }\n}\nmodule.exports = AbstractQuery;\nmodule.exports.AbstractQuery = AbstractQuery;\nmodule.exports[\"default\"] = AbstractQuery;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9hYnN0cmFjdC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMscURBQVE7QUFDNUIscUJBQXFCLG1CQUFPLENBQUMsMEZBQTBCO0FBQ3ZELGFBQWEsd0ZBQWtCO0FBQy9CLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxNQUFNO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxFQUFFLFNBQVM7QUFDOUM7QUFDQSxvQkFBb0IsNkJBQTZCLEtBQUssSUFBSSxFQUFFLGFBQWE7QUFDekUsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0E7QUFDQSxtQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWMsR0FBRyxNQUFNO0FBQ3BELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsK0JBQStCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEMsc0NBQXNDLFFBQVEsR0FBRyxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTyxHQUFHLHdCQUF3QjtBQUNqRixrQkFBa0I7QUFDbEIsK0JBQStCLGNBQWM7QUFDN0MsaURBQWlELE9BQU8sR0FBRyx5QkFBeUI7QUFDcEY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFLHVDQUF1QyxPQUFPLEdBQUcsd0JBQXdCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxrQ0FBa0MsUUFBUSxHQUFHLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPLEdBQUcsd0JBQXdCO0FBQzdFLGNBQWM7QUFDZCwyQkFBMkIsY0FBYztBQUN6Qyw2Q0FBNkMsT0FBTyxHQUFHLHlCQUF5QjtBQUNoRjtBQUNBLGNBQWM7QUFDZDtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQsbUNBQW1DLE9BQU8sR0FBRyx3QkFBd0I7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LmpzP2JkNjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFNxbFN0cmluZyA9IHJlcXVpcmUoXCIuLi8uLi9zcWwtc3RyaW5nXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IERvdCA9IHJlcXVpcmUoXCJkb3R0aWVcIik7XG5jb25zdCBkZXByZWNhdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvZGVwcmVjYXRpb25zXCIpO1xuY29uc3QgdXVpZCA9IHJlcXVpcmUoXCJ1dWlkXCIpLnY0O1xuY29uc3QgeyBzYWZlU3RyaW5naWZ5SnNvbiB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzLmpzXCIpO1xuY2xhc3MgQWJzdHJhY3RRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudXVpZCA9IHV1aWQoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIHRoaXMuaW5zdGFuY2UgPSBvcHRpb25zLmluc3RhbmNlO1xuICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIHBsYWluOiBmYWxzZSxcbiAgICAgIHJhdzogZmFsc2UsXG4gICAgICBsb2dnaW5nOiBjb25zb2xlLmxvZ1xuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuY2hlY2tMb2dnaW5nT3B0aW9uKCk7XG4gICAgaWYgKG9wdGlvbnMucmF3RXJyb3JzKSB7XG4gICAgICB0aGlzLmZvcm1hdEVycm9yID0gQWJzdHJhY3RRdWVyeS5wcm90b3R5cGUuZm9ybWF0RXJyb3I7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jLCBvcHRpb25zKSB7XG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBbc3FsLCBbXV07XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnRGdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9wdGlvbnMgPSByZXBsYWNlbWVudEZ1bmMgfHwge307XG4gICAgICByZXBsYWNlbWVudEZ1bmMgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICghcmVwbGFjZW1lbnRGdW5jKSB7XG4gICAgICBpZiAob3B0aW9ucy5za2lwVmFsdWVSZXBsYWNlKSB7XG4gICAgICAgIHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlczJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzMiwgdGltZVpvbmUyLCBkaWFsZWN0MikgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZXMyW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIFNxbFN0cmluZy5lc2NhcGUodmFsdWVzMltrZXldLCB0aW1lWm9uZTIsIGRpYWxlY3QyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2tpcFZhbHVlUmVwbGFjZSkge1xuICAgICAgY29uc3Qgb3JpZ1JlcGxhY2VtZW50RnVuYyA9IHJlcGxhY2VtZW50RnVuYztcbiAgICAgIHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyLCB0aW1lWm9uZTIsIGRpYWxlY3QyLCBvcHRpb25zMikgPT4ge1xuICAgICAgICBpZiAob3JpZ1JlcGxhY2VtZW50RnVuYyhtYXRjaCwga2V5LCB2YWx1ZXMyLCB0aW1lWm9uZTIsIGRpYWxlY3QyLCBvcHRpb25zMikgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGltZVpvbmUgPSBudWxsO1xuICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHZhbHVlcyk7XG4gICAgc3FsID0gc3FsLnJlcGxhY2UoL1xcQlxcJChcXCR8XFx3KykvZywgKG1hdGNoLCBrZXkpID0+IHtcbiAgICAgIGlmIChrZXkgPT09IFwiJFwiKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnNraXBVbmVzY2FwZSA/IG1hdGNoIDoga2V5O1xuICAgICAgfVxuICAgICAgbGV0IHJlcGxWYWw7XG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICBpZiAoa2V5Lm1hdGNoKC9eWzEtOV1cXGQqJC8pKSB7XG4gICAgICAgICAga2V5ID0ga2V5IC0gMTtcbiAgICAgICAgICByZXBsVmFsID0gcmVwbGFjZW1lbnRGdW5jKG1hdGNoLCBrZXksIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFrZXkubWF0Y2goL15cXGQqJC8pKSB7XG4gICAgICAgIHJlcGxWYWwgPSByZXBsYWNlbWVudEZ1bmMobWF0Y2gsIGtleSwgdmFsdWVzLCB0aW1lWm9uZSwgZGlhbGVjdCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAocmVwbFZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTmFtZWQgYmluZCBwYXJhbWV0ZXIgXCIke21hdGNofVwiIGhhcyBubyB2YWx1ZSBpbiB0aGUgZ2l2ZW4gb2JqZWN0LmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGxWYWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtzcWwsIFtdXTtcbiAgfVxuICBmb3JtYXRFcnJvcihlcnJvciwgZXJyU3RhY2spIHtcbiAgICBlcnJvci5zdGFjayA9IGVyclN0YWNrO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBydW4oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJ1biBtZXRob2Qgd2Fzbid0IG92ZXJ3cml0dGVuIVwiKTtcbiAgfVxuICBjaGVja0xvZ2dpbmdPcHRpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2dnaW5nID09PSB0cnVlKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9UcnVlTG9nZ2luZygpO1xuICAgICAgdGhpcy5vcHRpb25zLmxvZ2dpbmcgPSBjb25zb2xlLmxvZztcbiAgICB9XG4gIH1cbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gXCJpbnNlcnRJZFwiO1xuICB9XG4gIGdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGZpZWxkID8gYCR7ZmllbGR9IG11c3QgYmUgdW5pcXVlYCA6IFwiTXVzdCBiZSB1bmlxdWVcIjtcbiAgICBpZiAoZmllbGQgJiYgdGhpcy5tb2RlbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModGhpcy5tb2RlbC51bmlxdWVLZXlzKSkge1xuICAgICAgICBpZiAodGhpcy5tb2RlbC51bmlxdWVLZXlzW2tleV0uZmllbGRzLmluY2x1ZGVzKGZpZWxkLnJlcGxhY2UoL1wiL2csIFwiXCIpKSkge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnVuaXF1ZUtleXNba2V5XS5tc2cpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSB0aGlzLm1vZGVsLnVuaXF1ZUtleXNba2V5XS5tc2c7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIGlzUmF3UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlJBVztcbiAgfVxuICBpc1ZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuVkVSU0lPTjtcbiAgfVxuICBpc1Vwc2VydFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gIH1cbiAgaXNJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0cnVlO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5JTlNFUlQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQgJiYgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiaW5zZXJ0IGludG9cIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICYmICghcmVzdWx0cyB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0cywgdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCkpKTtcbiAgICByZXN1bHQgPSByZXN1bHQgJiYgKCFtZXRhRGF0YSB8fCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWV0YURhdGEsIHRoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBoYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICBjb25zdCBhdXRvSW5jcmVtZW50QXR0cmlidXRlID0gdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlO1xuICAgICAgbGV0IGlkID0gbnVsbDtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgbWV0YURhdGEgJiYgbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgdGhpcy5pbnN0YW5jZVthdXRvSW5jcmVtZW50QXR0cmlidXRlXSA9IGlkO1xuICAgIH1cbiAgfVxuICBpc1Nob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnR5cGUgPT09IFF1ZXJ5VHlwZXMuU0hPV1RBQkxFUztcbiAgfVxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiBfLmZsYXR0ZW4ocmVzdWx0cy5tYXAoKHJlc3VsdFNldCkgPT4gT2JqZWN0LnZhbHVlcyhyZXN1bHRTZXQpKSk7XG4gIH1cbiAgaXNTaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TSE9XSU5ERVhFUztcbiAgfVxuICBpc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TSE9XQ09OU1RSQUlOVFM7XG4gIH1cbiAgaXNEZXNjcmliZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5ERVNDUklCRTtcbiAgfVxuICBpc1NlbGVjdFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5TRUxFQ1Q7XG4gIH1cbiAgaXNCdWxrVXBkYXRlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG4gIH1cbiAgaXNCdWxrRGVsZXRlUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkJVTEtERUxFVEU7XG4gIH1cbiAgaXNGb3JlaWduS2V5c1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5GT1JFSUdOS0VZUztcbiAgfVxuICBpc1VwZGF0ZVF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5VUERBVEU7XG4gIH1cbiAgaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0cykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZmllbGRNYXApIHtcbiAgICAgIGNvbnN0IGZpZWxkTWFwID0gdGhpcy5vcHRpb25zLmZpZWxkTWFwO1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMubWFwKChyZXN1bHQyKSA9PiBfLnJlZHVjZShmaWVsZE1hcCwgKHJlc3VsdDMsIG5hbWUsIGZpZWxkKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQzW2ZpZWxkXSAhPT0gdm9pZCAwICYmIG5hbWUgIT09IGZpZWxkKSB7XG4gICAgICAgICAgcmVzdWx0M1tuYW1lXSA9IHJlc3VsdDNbZmllbGRdO1xuICAgICAgICAgIGRlbGV0ZSByZXN1bHQzW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MztcbiAgICAgIH0sIHJlc3VsdDIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYXcpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHMubWFwKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIGxldCBvID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdDIpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdDIsIGtleSkpIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHJlc3VsdDJba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5uZXN0KSB7XG4gICAgICAgICAgbyA9IERvdC50cmFuc2Zvcm0obyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5oYXNKb2luID09PSB0cnVlKSB7XG4gICAgICByZXN1bHRzID0gQWJzdHJhY3RRdWVyeS5fZ3JvdXBKb2luRGF0YShyZXN1bHRzLCB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLFxuICAgICAgICBpbmNsdWRlTWFwOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU1hcCxcbiAgICAgICAgaW5jbHVkZU5hbWVzOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU5hbWVzXG4gICAgICB9LCB7XG4gICAgICAgIGNoZWNrRXhpc3Rpbmc6IHRoaXMub3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uXG4gICAgICB9KTtcbiAgICAgIHJlc3VsdCA9IHRoaXMubW9kZWwuYnVsa0J1aWxkKHJlc3VsdHMsIHtcbiAgICAgICAgaXNOZXdSZWNvcmQ6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlOiB0aGlzLm9wdGlvbnMuaW5jbHVkZSxcbiAgICAgICAgaW5jbHVkZU5hbWVzOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU5hbWVzLFxuICAgICAgICBpbmNsdWRlTWFwOiB0aGlzLm9wdGlvbnMuaW5jbHVkZU1hcCxcbiAgICAgICAgaW5jbHVkZVZhbGlkYXRlZDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdGhpcy5vcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyB8fCB0aGlzLm9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgcmF3OiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5idWxrQnVpbGQocmVzdWx0cywge1xuICAgICAgICBpc05ld1JlY29yZDogZmFsc2UsXG4gICAgICAgIHJhdzogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdGhpcy5vcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyB8fCB0aGlzLm9wdGlvbnMuYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMucGxhaW4pIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzdWx0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzU2hvd09yRGVzY3JpYmVRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNob3dcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImRlc2NyaWJlXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNDYWxsUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImNhbGxcIik7XG4gIH1cbiAgX2xvZ1F1ZXJ5KHNxbCwgZGVidWdDb250ZXh0LCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGJlbmNobWFyayA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuYmVuY2htYXJrIHx8IG9wdGlvbnMuYmVuY2htYXJrO1xuICAgIGNvbnN0IGxvZ1F1ZXJ5UGFyYW1ldGVycyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMubG9nUXVlcnlQYXJhbWV0ZXJzIHx8IG9wdGlvbnMubG9nUXVlcnlQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGxvZ1BhcmFtZXRlciA9IFwiXCI7XG4gICAgaWYgKGxvZ1F1ZXJ5UGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBzcWwuZW5kc1dpdGgoXCI7XCIpID8gXCJcIiA6IFwiO1wiO1xuICAgICAgbGV0IHBhcmFtU3RyO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgICAgcGFyYW1TdHIgPSBwYXJhbWV0ZXJzLm1hcCgocCkgPT4gc2FmZVN0cmluZ2lmeUpzb24ocCkpLmpvaW4oXCIsIFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtU3RyID0gc2FmZVN0cmluZ2lmeUpzb24ocGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgICBsb2dQYXJhbWV0ZXIgPSBgJHtkZWxpbWl0ZXJ9ICR7cGFyYW1TdHJ9YDtcbiAgICB9XG4gICAgY29uc3QgZm10ID0gYCgke2Nvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiAke3NxbH0ke2xvZ1BhcmFtZXRlcn1gO1xuICAgIGNvbnN0IG1zZyA9IGBFeGVjdXRpbmcgJHtmbXR9YDtcbiAgICBkZWJ1Z0NvbnRleHQobXNnKTtcbiAgICBpZiAoIWJlbmNobWFyaykge1xuICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGBFeGVjdXRpbmcgJHtmbXR9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBhZnRlck1zZyA9IGBFeGVjdXRlZCAke2ZtdH1gO1xuICAgICAgZGVidWdDb250ZXh0KGFmdGVyTXNnKTtcbiAgICAgIGlmIChiZW5jaG1hcmspIHtcbiAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGFmdGVyTXNnLCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBfZ3JvdXBKb2luRGF0YShyb3dzLCBpbmNsdWRlT3B0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICghcm93cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IGk7XG4gICAgbGV0IGxlbmd0aDtcbiAgICBsZXQgJGk7XG4gICAgbGV0ICRsZW5ndGg7XG4gICAgbGV0IHJvd3NJO1xuICAgIGxldCByb3c7XG4gICAgY29uc3Qgcm93c0xlbmd0aCA9IHJvd3MubGVuZ3RoO1xuICAgIGxldCBrZXlzO1xuICAgIGxldCBrZXk7XG4gICAgbGV0IGtleUk7XG4gICAgbGV0IGtleUxlbmd0aDtcbiAgICBsZXQgcHJldktleTtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCB0b3BWYWx1ZXM7XG4gICAgbGV0IHRvcEV4aXN0cztcbiAgICBjb25zdCBjaGVja0V4aXN0aW5nID0gb3B0aW9ucy5jaGVja0V4aXN0aW5nO1xuICAgIGxldCBpdGVtSGFzaDtcbiAgICBsZXQgcGFyZW50SGFzaDtcbiAgICBsZXQgdG9wSGFzaDtcbiAgICBjb25zdCByZXN1bHRzID0gY2hlY2tFeGlzdGluZyA/IFtdIDogbmV3IEFycmF5KHJvd3NMZW5ndGgpO1xuICAgIGNvbnN0IHJlc3VsdE1hcCA9IHt9O1xuICAgIGNvbnN0IGluY2x1ZGVNYXAgPSB7fTtcbiAgICBsZXQgJGtleVByZWZpeDtcbiAgICBsZXQgJGtleVByZWZpeFN0cmluZztcbiAgICBsZXQgJHByZXZLZXlQcmVmaXhTdHJpbmc7XG4gICAgbGV0ICRwcmV2S2V5UHJlZml4O1xuICAgIGxldCAkbGFzdEtleVByZWZpeDtcbiAgICBsZXQgJGN1cnJlbnQ7XG4gICAgbGV0ICRwYXJlbnQ7XG4gICAgbGV0IHByZXZpb3VzUGllY2U7XG4gICAgY29uc3QgYnVpbGRJbmNsdWRlTWFwID0gKHBpZWNlKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCRjdXJyZW50LmluY2x1ZGVNYXAsIHBpZWNlKSkge1xuICAgICAgICBpbmNsdWRlTWFwW2tleV0gPSAkY3VycmVudCA9ICRjdXJyZW50LmluY2x1ZGVNYXBbcGllY2VdO1xuICAgICAgICBpZiAocHJldmlvdXNQaWVjZSkge1xuICAgICAgICAgIHByZXZpb3VzUGllY2UgPSBgJHtwcmV2aW91c1BpZWNlfS4ke3BpZWNlfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNQaWVjZSA9IHBpZWNlO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1ZGVNYXBbcHJldmlvdXNQaWVjZV0gPSAkY3VycmVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGtleVByZWZpeFN0cmluZ01lbW8gPSB7fTtcbiAgICBjb25zdCBrZXlQcmVmaXhTdHJpbmcgPSAoa2V5MiwgbWVtbykgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWVtbywga2V5MikpIHtcbiAgICAgICAgbWVtb1trZXkyXSA9IGtleTIuc3Vic3RyKDAsIGtleTIubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vW2tleTJdO1xuICAgIH07XG4gICAgY29uc3QgcmVtb3ZlS2V5UHJlZml4TWVtbyA9IHt9O1xuICAgIGNvbnN0IHJlbW92ZUtleVByZWZpeCA9IChrZXkyKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZW1vdmVLZXlQcmVmaXhNZW1vLCBrZXkyKSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGtleTIubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgICByZW1vdmVLZXlQcmVmaXhNZW1vW2tleTJdID0ga2V5Mi5zdWJzdHIoaW5kZXggPT09IC0xID8gMCA6IGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlS2V5UHJlZml4TWVtb1trZXkyXTtcbiAgICB9O1xuICAgIGNvbnN0IGtleVByZWZpeE1lbW8gPSB7fTtcbiAgICBjb25zdCBrZXlQcmVmaXggPSAoa2V5MikgPT4ge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa2V5UHJlZml4TWVtbywga2V5MikpIHtcbiAgICAgICAgY29uc3QgcHJlZml4U3RyaW5nID0ga2V5UHJlZml4U3RyaW5nKGtleTIsIGtleVByZWZpeFN0cmluZ01lbW8pO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChrZXlQcmVmaXhNZW1vLCBwcmVmaXhTdHJpbmcpKSB7XG4gICAgICAgICAga2V5UHJlZml4TWVtb1twcmVmaXhTdHJpbmddID0gcHJlZml4U3RyaW5nID8gcHJlZml4U3RyaW5nLnNwbGl0KFwiLlwiKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGtleVByZWZpeE1lbW9ba2V5Ml0gPSBrZXlQcmVmaXhNZW1vW3ByZWZpeFN0cmluZ107XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5UHJlZml4TWVtb1trZXkyXTtcbiAgICB9O1xuICAgIGNvbnN0IGxhc3RLZXlQcmVmaXhNZW1vID0ge307XG4gICAgY29uc3QgbGFzdEtleVByZWZpeCA9IChrZXkyKSA9PiB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsYXN0S2V5UHJlZml4TWVtbywga2V5MikpIHtcbiAgICAgICAgY29uc3QgcHJlZml4MiA9IGtleVByZWZpeChrZXkyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IHByZWZpeDIubGVuZ3RoO1xuICAgICAgICBsYXN0S2V5UHJlZml4TWVtb1trZXkyXSA9ICFsZW5ndGgyID8gXCJcIiA6IHByZWZpeDJbbGVuZ3RoMiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RLZXlQcmVmaXhNZW1vW2tleTJdO1xuICAgIH07XG4gICAgY29uc3QgZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyA9IChtb2RlbCkgPT4ge1xuICAgICAgbGV0IHVuaXF1ZUtleUF0dHJpYnV0ZXMyID0gXy5jaGFpbihtb2RlbC51bmlxdWVLZXlzKTtcbiAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMyID0gdW5pcXVlS2V5QXR0cmlidXRlczIucmVzdWx0KGAke3VuaXF1ZUtleUF0dHJpYnV0ZXMyLmZpbmRLZXkoKX0uZmllbGRzYCkubWFwKChmaWVsZCkgPT4gXy5maW5kS2V5KG1vZGVsLmF0dHJpYnV0ZXMsIChjaHIpID0+IGNoci5maWVsZCA9PT0gZmllbGQpKS52YWx1ZSgpO1xuICAgICAgcmV0dXJuIHVuaXF1ZUtleUF0dHJpYnV0ZXMyO1xuICAgIH07XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgQnVmZmVyID8gb2JqLnRvU3RyaW5nKFwiaGV4XCIpIDogb2JqO1xuICAgIGxldCBwcmltYXJ5S2V5QXR0cmlidXRlcztcbiAgICBsZXQgdW5pcXVlS2V5QXR0cmlidXRlcztcbiAgICBsZXQgcHJlZml4O1xuICAgIGZvciAocm93c0kgPSAwOyByb3dzSSA8IHJvd3NMZW5ndGg7IHJvd3NJKyspIHtcbiAgICAgIHJvdyA9IHJvd3Nbcm93c0ldO1xuICAgICAgaWYgKHJvd3NJID09PSAwKSB7XG4gICAgICAgIGtleXMgPSBfLnNvcnRCeShPYmplY3Qua2V5cyhyb3cpLCAoaXRlbSkgPT4gW2l0ZW0uc3BsaXQoXCIuXCIpLmxlbmd0aF0pO1xuICAgICAgICBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0V4aXN0aW5nKSB7XG4gICAgICAgIHRvcEV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAkbGVuZ3RoID0gaW5jbHVkZU9wdGlvbnMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICB0b3BIYXNoID0gXCJcIjtcbiAgICAgICAgaWYgKCRsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0b3BIYXNoID0gc3RyaW5naWZ5KHJvd1tpbmNsdWRlT3B0aW9ucy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlc1swXV0pO1xuICAgICAgICB9IGVsc2UgaWYgKCRsZW5ndGggPiAxKSB7XG4gICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgJGxlbmd0aDsgJGkrKykge1xuICAgICAgICAgICAgdG9wSGFzaCArPSBzdHJpbmdpZnkocm93W2luY2x1ZGVPcHRpb25zLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzWyRpXV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghXy5pc0VtcHR5KGluY2x1ZGVPcHRpb25zLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgICAgdW5pcXVlS2V5QXR0cmlidXRlcyA9IGdldFVuaXF1ZUtleUF0dHJpYnV0ZXMoaW5jbHVkZU9wdGlvbnMubW9kZWwpO1xuICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8IHVuaXF1ZUtleUF0dHJpYnV0ZXMubGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICB0b3BIYXNoICs9IHJvd1t1bmlxdWVLZXlBdHRyaWJ1dGVzWyRpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0b3BWYWx1ZXMgPSB2YWx1ZXMgPSB7fTtcbiAgICAgICRwcmV2S2V5UHJlZml4ID0gdm9pZCAwO1xuICAgICAgZm9yIChrZXlJID0gMDsga2V5SSA8IGtleUxlbmd0aDsga2V5SSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNba2V5SV07XG4gICAgICAgICRrZXlQcmVmaXhTdHJpbmcgPSBrZXlQcmVmaXhTdHJpbmcoa2V5LCBrZXlQcmVmaXhTdHJpbmdNZW1vKTtcbiAgICAgICAgJGtleVByZWZpeCA9IGtleVByZWZpeChrZXkpO1xuICAgICAgICBpZiAocm93c0kgPT09IDAgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmNsdWRlTWFwLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKCEka2V5UHJlZml4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaW5jbHVkZU1hcFtrZXldID0gaW5jbHVkZU1hcFtcIlwiXSA9IGluY2x1ZGVPcHRpb25zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkY3VycmVudCA9IGluY2x1ZGVPcHRpb25zO1xuICAgICAgICAgICAgcHJldmlvdXNQaWVjZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICRrZXlQcmVmaXguZm9yRWFjaChidWlsZEluY2x1ZGVNYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJHByZXZLZXlQcmVmaXggIT09IHZvaWQgMCAmJiAkcHJldktleVByZWZpeCAhPT0gJGtleVByZWZpeCkge1xuICAgICAgICAgIGlmIChjaGVja0V4aXN0aW5nKSB7XG4gICAgICAgICAgICBsZW5ndGggPSAkcHJldktleVByZWZpeC5sZW5ndGg7XG4gICAgICAgICAgICAkcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHBhcmVudEhhc2ggPSBudWxsO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSAkcGFyZW50ID8gYCR7JHBhcmVudH0uJHskcHJldktleVByZWZpeFtpXX1gIDogJHByZXZLZXlQcmVmaXhbaV07XG4gICAgICAgICAgICAgICAgcHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgJGxlbmd0aCA9IHByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpdGVtSGFzaCA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbMF19YF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8ICRsZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gc3RyaW5naWZ5KHJvd1tgJHtwcmVmaXh9LiR7cHJpbWFyeUtleUF0dHJpYnV0ZXNbJGldfWBdKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFfLmlzRW1wdHkoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgICAgICAgICAgICB1bmlxdWVLZXlBdHRyaWJ1dGVzID0gZ2V0VW5pcXVlS2V5QXR0cmlidXRlcyhpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwpO1xuICAgICAgICAgICAgICAgICAgZm9yICgkaSA9IDA7ICRpIDwgdW5pcXVlS2V5QXR0cmlidXRlcy5sZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gcm93W2Ake3ByZWZpeH0uJHt1bmlxdWVLZXlBdHRyaWJ1dGVzWyRpXX1gXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRIYXNoKSB7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRIYXNoID0gdG9wSGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggPSBwYXJlbnRIYXNoICsgaXRlbUhhc2g7XG4gICAgICAgICAgICAgICAgJHBhcmVudCA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgIHBhcmVudEhhc2ggPSBpdGVtSGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGl0ZW1IYXNoID0gdG9wSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtSGFzaCA9PT0gdG9wSGFzaCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcEV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAgICAgJHBhcmVudCA9IHJlc3VsdE1hcFtwYXJlbnRIYXNoXTtcbiAgICAgICAgICAgICAgJGxhc3RLZXlQcmVmaXggPSBsYXN0S2V5UHJlZml4KHByZXZLZXkpO1xuICAgICAgICAgICAgICBpZiAoaW5jbHVkZU1hcFtwcmV2S2V5XS5hc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdID0gcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEkcGFyZW50WyRsYXN0S2V5UHJlZml4XSkge1xuICAgICAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0ucHVzaChyZXN1bHRNYXBbaXRlbUhhc2hdID0gdmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRjdXJyZW50ID0gdG9wVmFsdWVzO1xuICAgICAgICAgICAgbGVuZ3RoID0gJGtleVByZWZpeC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMgPSAkY3VycmVudFska2V5UHJlZml4W2ldXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkY3VycmVudCA9ICRjdXJyZW50WyRrZXlQcmVmaXhbaV1dIHx8IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1tyZW1vdmVLZXlQcmVmaXgoa2V5KV0gPSByb3dba2V5XTtcbiAgICAgICAgcHJldktleSA9IGtleTtcbiAgICAgICAgJHByZXZLZXlQcmVmaXggPSAka2V5UHJlZml4O1xuICAgICAgICAkcHJldktleVByZWZpeFN0cmluZyA9ICRrZXlQcmVmaXhTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tFeGlzdGluZykge1xuICAgICAgICBsZW5ndGggPSAkcHJldktleVByZWZpeC5sZW5ndGg7XG4gICAgICAgICRwYXJlbnQgPSBudWxsO1xuICAgICAgICBwYXJlbnRIYXNoID0gbnVsbDtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcHJlZml4ID0gJHBhcmVudCA/IGAkeyRwYXJlbnR9LiR7JHByZXZLZXlQcmVmaXhbaV19YCA6ICRwcmV2S2V5UHJlZml4W2ldO1xuICAgICAgICAgICAgcHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBpbmNsdWRlTWFwW3ByZWZpeF0ubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAkbGVuZ3RoID0gcHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgaXRlbUhhc2ggPSBwcmVmaXg7XG4gICAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1swXX1gXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCRsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8ICRsZW5ndGg7ICRpKyspIHtcbiAgICAgICAgICAgICAgICBpdGVtSGFzaCArPSBzdHJpbmdpZnkocm93W2Ake3ByZWZpeH0uJHtwcmltYXJ5S2V5QXR0cmlidXRlc1skaV19YF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFfLmlzRW1wdHkoaW5jbHVkZU1hcFtwcmVmaXhdLm1vZGVsLnVuaXF1ZUtleXMpKSB7XG4gICAgICAgICAgICAgIHVuaXF1ZUtleUF0dHJpYnV0ZXMgPSBnZXRVbmlxdWVLZXlBdHRyaWJ1dGVzKGluY2x1ZGVNYXBbcHJlZml4XS5tb2RlbCk7XG4gICAgICAgICAgICAgIGZvciAoJGkgPSAwOyAkaSA8IHVuaXF1ZUtleUF0dHJpYnV0ZXMubGVuZ3RoOyAkaSsrKSB7XG4gICAgICAgICAgICAgICAgaXRlbUhhc2ggKz0gcm93W2Ake3ByZWZpeH0uJHt1bmlxdWVLZXlBdHRyaWJ1dGVzWyRpXX1gXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwYXJlbnRIYXNoKSB7XG4gICAgICAgICAgICAgIHBhcmVudEhhc2ggPSB0b3BIYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbUhhc2ggPSBwYXJlbnRIYXNoICsgaXRlbUhhc2g7XG4gICAgICAgICAgICAkcGFyZW50ID0gcHJlZml4O1xuICAgICAgICAgICAgaWYgKGkgPCBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIHBhcmVudEhhc2ggPSBpdGVtSGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbUhhc2ggPSB0b3BIYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtSGFzaCA9PT0gdG9wSGFzaCkge1xuICAgICAgICAgIGlmICghcmVzdWx0TWFwW2l0ZW1IYXNoXSkge1xuICAgICAgICAgICAgcmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wRXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlc3VsdE1hcFtpdGVtSGFzaF0pIHtcbiAgICAgICAgICAkcGFyZW50ID0gcmVzdWx0TWFwW3BhcmVudEhhc2hdO1xuICAgICAgICAgICRsYXN0S2V5UHJlZml4ID0gbGFzdEtleVByZWZpeChwcmV2S2V5KTtcbiAgICAgICAgICBpZiAoaW5jbHVkZU1hcFtwcmV2S2V5XS5hc3NvY2lhdGlvbi5pc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoJHBhcmVudCkge1xuICAgICAgICAgICAgICAkcGFyZW50WyRsYXN0S2V5UHJlZml4XSA9IHJlc3VsdE1hcFtpdGVtSGFzaF0gPSB2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghJHBhcmVudFskbGFzdEtleVByZWZpeF0pIHtcbiAgICAgICAgICAgICAgJHBhcmVudFskbGFzdEtleVByZWZpeF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICRwYXJlbnRbJGxhc3RLZXlQcmVmaXhdLnB1c2gocmVzdWx0TWFwW2l0ZW1IYXNoXSA9IHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdG9wRXhpc3RzKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHRvcFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHNbcm93c0ldID0gdG9wVmFsdWVzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuQWJzdHJhY3RRdWVyeSA9IEFic3RyYWN0UXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/connection-manager.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/connection-manager.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").db2);\nconst debug = logger.debugContext(\"connection:db2\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"db2\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"ibm_db\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      database: config.database,\n      hostname: config.host,\n      port: config.port,\n      uid: config.username,\n      pwd: config.password\n    };\n    if (config.ssl) {\n      connectionConfig[\"security\"] = config.ssl;\n    }\n    if (config.sslcertificate) {\n      connectionConfig[\"SSLServerCertificate\"] = config.sslcertificate;\n    }\n    if (config.dialectOptions) {\n      for (const key of Object.keys(config.dialectOptions)) {\n        connectionConfig[key] = config.dialectOptions[key];\n      }\n    }\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = new this.lib.Database();\n        connection2.lib = this.lib;\n        connection2.open(connectionConfig, (error) => {\n          if (error) {\n            if (error.message && error.message.includes(\"SQL30081N\")) {\n              return reject(new sequelizeErrors.ConnectionRefusedError(error));\n            }\n            return reject(new sequelizeErrors.ConnectionError(error));\n          }\n          return resolve(connection2);\n        });\n      });\n      return connection;\n    } catch (err) {\n      throw new sequelizeErrors.ConnectionError(err);\n    }\n  }\n  disconnect(connection) {\n    if (connection.connected) {\n      connection.close((error) => {\n        if (error) {\n          debug(error);\n        } else {\n          debug(\"connection closed\");\n        }\n      });\n    }\n    return Promise.resolve();\n  }\n  validate(connection) {\n    return connection && connection.connected;\n  }\n  _disconnect(connection) {\n    return this.dialect.connectionManager.disconnect(connection);\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLGtCQUFrQixxR0FBK0I7QUFDakQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvY29ubmVjdGlvbi1tYW5hZ2VyLmpzP2JhYjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLmRiMjtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246ZGIyXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJkYjJcIik7XG5jbGFzcyBDb25uZWN0aW9uTWFuYWdlciBleHRlbmRzIEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihkaWFsZWN0LCBzZXF1ZWxpemUpIHtcbiAgICBzZXF1ZWxpemUuY29uZmlnLnBvcnQgPSBzZXF1ZWxpemUuY29uZmlnLnBvcnQgfHwgMzMwNjtcbiAgICBzdXBlcihkaWFsZWN0LCBzZXF1ZWxpemUpO1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJpYm1fZGJcIik7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIHN0YXRpYyBfdHlwZWNhc3QoZmllbGQsIG5leHQpIHtcbiAgICBpZiAocGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKGZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0ge1xuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSxcbiAgICAgIGhvc3RuYW1lOiBjb25maWcuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0LFxuICAgICAgdWlkOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBwd2Q6IGNvbmZpZy5wYXNzd29yZFxuICAgIH07XG4gICAgaWYgKGNvbmZpZy5zc2wpIHtcbiAgICAgIGNvbm5lY3Rpb25Db25maWdbXCJzZWN1cml0eVwiXSA9IGNvbmZpZy5zc2w7XG4gICAgfVxuICAgIGlmIChjb25maWcuc3NsY2VydGlmaWNhdGUpIHtcbiAgICAgIGNvbm5lY3Rpb25Db25maWdbXCJTU0xTZXJ2ZXJDZXJ0aWZpY2F0ZVwiXSA9IGNvbmZpZy5zc2xjZXJ0aWZpY2F0ZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29uZmlnLmRpYWxlY3RPcHRpb25zKSkge1xuICAgICAgICBjb25uZWN0aW9uQ29uZmlnW2tleV0gPSBjb25maWcuZGlhbGVjdE9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24yID0gbmV3IHRoaXMubGliLkRhdGFiYXNlKCk7XG4gICAgICAgIGNvbm5lY3Rpb24yLmxpYiA9IHRoaXMubGliO1xuICAgICAgICBjb25uZWN0aW9uMi5vcGVuKGNvbm5lY3Rpb25Db25maWcsIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIlNRTDMwMDgxTlwiKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShjb25uZWN0aW9uMik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3RlZCkge1xuICAgICAgY29ubmVjdGlvbi5jbG9zZSgoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgZGVidWcoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uY29ubmVjdGVkO1xuICB9XG4gIF9kaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/data-types.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/data-types.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0008478.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`Db2 does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.db2 = [\"TIMESTAMP\"];\n  BaseTypes.STRING.types.db2 = [\"VARCHAR\"];\n  BaseTypes.CHAR.types.db2 = [\"CHAR\"];\n  BaseTypes.TEXT.types.db2 = [\"VARCHAR\", \"CLOB\"];\n  BaseTypes.TINYINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.SMALLINT.types.db2 = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.db2 = [\"INTEGER\"];\n  BaseTypes.INTEGER.types.db2 = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.db2 = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.db2 = [\"DOUBLE\", \"REAL\", \"FLOAT\"];\n  BaseTypes.TIME.types.db2 = [\"TIME\"];\n  BaseTypes.DATEONLY.types.db2 = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.db2 = [\"BOOLEAN\", \"BOOL\", \"SMALLINT\", \"BIT\"];\n  BaseTypes.BLOB.types.db2 = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.db2 = [\"DECIMAL\"];\n  BaseTypes.UUID.types.db2 = [\"CHAR () FOR BIT DATA\"];\n  BaseTypes.ENUM.types.db2 = [\"VARCHAR\"];\n  BaseTypes.REAL.types.db2 = [\"REAL\"];\n  BaseTypes.DOUBLE.types.db2 = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.db2 = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          return \"BLOB(255)\";\n        }\n        if (this._length.toLowerCase() === \"medium\") {\n          return \"BLOB(16M)\";\n        }\n        if (this._length.toLowerCase() === \"long\") {\n          return \"BLOB(2G)\";\n        }\n        return `BLOB(${this._length})`;\n      }\n      return \"BLOB\";\n    }\n    escape(blob) {\n      return `BLOB('${blob.toString().replace(/'/g, \"''\")}')`;\n    }\n    _stringify(value) {\n      if (Buffer.isBuffer(value)) {\n        return `BLOB('${value.toString().replace(/'/g, \"''\")}')`;\n      }\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n      const hex = value.toString(\"hex\");\n      return this._hexify(hex);\n    }\n    _hexify(hex) {\n      return `x'${hex}'`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        if (this._length <= 4e3) {\n          return `VARCHAR(${this._length})`;\n        }\n        return `CLOB(${this._length})`;\n      }\n      if (this._length < 255) {\n        return `CHAR(${this._length}) FOR BIT DATA`;\n      }\n      if (this._length <= 4e3) {\n        return `VARCHAR(${this._length}) FOR BIT DATA`;\n      }\n      return `BLOB(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._hexify(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      let len = 0;\n      if (this._length) {\n        switch (this._length.toLowerCase()) {\n          case \"tiny\":\n            len = 256;\n            break;\n          case \"medium\":\n            len = 8192;\n            break;\n          case \"long\":\n            len = 65536;\n            break;\n        }\n        if (isNaN(this._length)) {\n          this._length = 32672;\n        }\n        if (len > 0) {\n          this._length = len;\n        }\n      } else {\n        this._length = 32672;\n      }\n      if (this._length > 32672) {\n        len = `CLOB(${this._length})`;\n      } else {\n        len = `VARCHAR(${this._length})`;\n      }\n      warn(`Db2 does not support TEXT datatype. ${len} will be used instead.`);\n      return len;\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          value = value === \"true\" ? true : value === \"false\" ? false : value;\n          value = value === \"\u0001\" ? true : value === \"\\0\" ? false : value;\n        } else if (typeof value === \"number\") {\n          value = value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) FOR BIT DATA\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"CURRENT TIME\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      if (this._length < 0) {\n        this._length = 0;\n      }\n      if (this._length > 6) {\n        this._length = 6;\n      }\n      return `TIMESTAMP${this._length ? `(${this._length})` : \"\"}`;\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length > 0) {\n        let msec = \".\";\n        for (let i = 0; i < this._length && i < 6; i++) {\n          msec += \"S\";\n        }\n        return date.format(`YYYY-MM-DD HH:mm:ss${msec}`);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value) {\n      if (typeof value !== \"string\") {\n        value = value.string();\n      }\n      if (value === null) {\n        return value;\n      }\n      value = new Date(momentTz.utc(value));\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return momentTz(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Db2 does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"Db2 does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"Db2 does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"Db2 does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"db2 does not support DOUBLE with options. Plain DOUBLE will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"DOUBLE\";\n    }\n  }\n  DOUBLE.prototype.key = DOUBLE.key = \"DOUBLE\";\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    DOUBLE,\n    \"DOUBLE PRECISION\": DOUBLE,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYSx5QkFBeUIsYUFBYTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyxRQUFRO0FBQ1IseUJBQXlCLGFBQWE7QUFDdEM7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CLGFBQWEsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvZGF0YS10eXBlcy5qcz9mNzI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh2b2lkIDAsIFwiaHR0cHM6Ly93d3cuaWJtLmNvbS9zdXBwb3J0L2tub3dsZWRnZWNlbnRlci9TU0VQR0dfMTEuMS4wL2NvbS5pYm0uZGIyLmx1dy5zcWwucmVmLmRvYy9kb2MvcjAwMDg0NzguaHRtbFwiKTtcbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5fbGVuZ3RoIHx8IGRhdGFUeXBlLm9wdGlvbnMubGVuZ3RoIHx8IGRhdGFUeXBlLl91bnNpZ25lZCB8fCBkYXRhVHlwZS5femVyb2ZpbGwpIHtcbiAgICAgIHdhcm4oYERiMiBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggb3B0aW9ucy4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLmRiMiA9IFtcIlRJTUVTVEFNUFwiXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5kYjIgPSBbXCJWQVJDSEFSXCJdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5kYjIgPSBbXCJDSEFSXCJdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5kYjIgPSBbXCJWQVJDSEFSXCIsIFwiQ0xPQlwiXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMuZGIyID0gW1wiU01BTExJTlRcIl07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5kYjIgPSBbXCJTTUFMTElOVFwiXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5kYjIgPSBbXCJJTlRFR0VSXCJdO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5kYjIgPSBbXCJJTlRFR0VSXCJdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLmRiMiA9IFtcIkJJR0lOVFwiXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLmRiMiA9IFtcIkRPVUJMRVwiLCBcIlJFQUxcIiwgXCJGTE9BVFwiXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMuZGIyID0gW1wiVElNRVwiXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLmRiMiA9IFtcIkRBVEVcIl07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLmRiMiA9IFtcIkJPT0xFQU5cIiwgXCJCT09MXCIsIFwiU01BTExJTlRcIiwgXCJCSVRcIl07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLmRiMiA9IFtcIkJMT0JcIl07XG4gIEJhc2VUeXBlcy5ERUNJTUFMLnR5cGVzLmRiMiA9IFtcIkRFQ0lNQUxcIl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLmRiMiA9IFtcIkNIQVIgKCkgRk9SIEJJVCBEQVRBXCJdO1xuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5kYjIgPSBbXCJWQVJDSEFSXCJdO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5kYjIgPSBbXCJSRUFMXCJdO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLmRiMiA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLmRiMiA9IGZhbHNlO1xuICBjbGFzcyBCTE9CIGV4dGVuZHMgQmFzZVR5cGVzLkJMT0Ige1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICBpZiAodGhpcy5fbGVuZ3RoLnRvTG93ZXJDYXNlKCkgPT09IFwidGlueVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQkxPQigyNTUpXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSBcIm1lZGl1bVwiKSB7XG4gICAgICAgICAgcmV0dXJuIFwiQkxPQigxNk0pXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSBcImxvbmdcIikge1xuICAgICAgICAgIHJldHVybiBcIkJMT0IoMkcpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBCTE9CKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiQkxPQlwiO1xuICAgIH1cbiAgICBlc2NhcGUoYmxvYikge1xuICAgICAgcmV0dXJuIGBCTE9CKCcke2Jsb2IudG9TdHJpbmcoKS5yZXBsYWNlKC8nL2csIFwiJydcIil9JylgO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYEJMT0IoJyR7dmFsdWUudG9TdHJpbmcoKS5yZXBsYWNlKC8nL2csIFwiJydcIil9JylgO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhleCA9IHZhbHVlLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIHRoaXMuX2hleGlmeShoZXgpO1xuICAgIH1cbiAgICBfaGV4aWZ5KGhleCkge1xuICAgICAgcmV0dXJuIGB4JyR7aGV4fSdgO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICghdGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW5ndGggPD0gNGUzKSB7XG4gICAgICAgICAgcmV0dXJuIGBWQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQ0xPQigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPCAyNTUpIHtcbiAgICAgICAgcmV0dXJuIGBDSEFSKCR7dGhpcy5fbGVuZ3RofSkgRk9SIEJJVCBEQVRBYDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPD0gNGUzKSB7XG4gICAgICAgIHJldHVybiBgVkFSQ0hBUigke3RoaXMuX2xlbmd0aH0pIEZPUiBCSVQgREFUQWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYEJMT0IoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIEJMT0IucHJvdG90eXBlLl9oZXhpZnkodmFsdWUudG9TdHJpbmcoXCJoZXhcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX2JpbmFyeSA/IEJ1ZmZlci5mcm9tKHZhbHVlKSA6IHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgU1RSSU5HLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSBcInRpbnlcIjpcbiAgICAgICAgICAgIGxlbiA9IDI1NjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJtZWRpdW1cIjpcbiAgICAgICAgICAgIGxlbiA9IDgxOTI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgICAgICAgbGVuID0gNjU1MzY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4odGhpcy5fbGVuZ3RoKSkge1xuICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IDMyNjcyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAzMjY3MjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9sZW5ndGggPiAzMjY3Mikge1xuICAgICAgICBsZW4gPSBgQ0xPQigke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IGBWQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgd2FybihgRGIyIGRvZXMgbm90IHN1cHBvcnQgVEVYVCBkYXRhdHlwZS4gJHtsZW59IHdpbGwgYmUgdXNlZCBpbnN0ZWFkLmApO1xuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJPT0xFQU5cIjtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZSA9PT0gXCJmYWxzZVwiID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBcIlx1MDAwMVwiID8gdHJ1ZSA6IHZhbHVlID09PSBcIlxcMFwiID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSAxID8gdHJ1ZSA6IHZhbHVlID09PSAwID8gZmFsc2UgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCT09MRUFOLnBhcnNlID0gQk9PTEVBTi5wcm90b3R5cGUuX3Nhbml0aXplO1xuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ0hBUigzNikgRk9SIEJJVCBEQVRBXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIE5PVyBleHRlbmRzIEJhc2VUeXBlcy5OT1cge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ1VSUkVOVCBUSU1FXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIDwgMCkge1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IDYpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gNjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgVElNRVNUQU1QJHt0aGlzLl9sZW5ndGggPyBgKCR7dGhpcy5fbGVuZ3RofSlgIDogXCJcIn1gO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IG1zZWMgPSBcIi5cIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9sZW5ndGggJiYgaSA8IDY7IGkrKykge1xuICAgICAgICAgIG1zZWMgKz0gXCJTXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KGBZWVlZLU1NLUREIEhIOm1tOnNzJHttc2VjfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzc1wiKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBuZXcgRGF0ZShtb21lbnRUei51dGModmFsdWUpKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1vbWVudFR6KHZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIEJJR0lOVCBleHRlbmRzIEJhc2VUeXBlcy5CSUdJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIHx8IHRoaXMub3B0aW9ucy5sZW5ndGggfHwgdGhpcy5fdW5zaWduZWQgfHwgdGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIkRiMiBkb2VzIG5vdCBzdXBwb3J0IFJFQUwgd2l0aCBvcHRpb25zLiBQbGFpbiBgUkVBTGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKHRoaXMuX2RlY2ltYWxzKSB7XG4gICAgICAgIHdhcm4oXCJEYjIgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB3aXRoIGRlY2ltYWxzLiBQbGFpbiBgRkxPQVRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHdhcm4oXCJEYjIgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB1bnNpZ25lZC4gYFVOU0lHTkVEYCB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJEYjIgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB6ZXJvZmlsbC4gYFpFUk9GSUxMYCB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVkFSQ0hBUigyNTUpXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIERPVUJMRSBleHRlbmRzIEJhc2VUeXBlcy5ET1VCTEUge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCB8fCB0aGlzLm9wdGlvbnMubGVuZ3RoIHx8IHRoaXMuX3Vuc2lnbmVkIHx8IHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJkYjIgZG9lcyBub3Qgc3VwcG9ydCBET1VCTEUgd2l0aCBvcHRpb25zLiBQbGFpbiBET1VCTEUgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJET1VCTEVcIjtcbiAgICB9XG4gIH1cbiAgRE9VQkxFLnByb3RvdHlwZS5rZXkgPSBET1VCTEUua2V5ID0gXCJET1VCTEVcIjtcbiAgcmV0dXJuIHtcbiAgICBCTE9CLFxuICAgIEJPT0xFQU4sXG4gICAgRU5VTSxcbiAgICBTVFJJTkcsXG4gICAgVVVJRCxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIE5PVyxcbiAgICBUSU5ZSU5ULFxuICAgIFNNQUxMSU5ULFxuICAgIElOVEVHRVIsXG4gICAgRE9VQkxFLFxuICAgIFwiRE9VQkxFIFBSRUNJU0lPTlwiOiBET1VCTEUsXG4gICAgQklHSU5ULFxuICAgIFJFQUwsXG4gICAgRkxPQVQsXG4gICAgVEVYVFxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").db2);\nconst { Db2QueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/query-interface.js\");\nclass Db2Dialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new Db2QueryInterface(sequelize, this.queryGenerator);\n  }\n}\nDb2Dialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT\": true,\n  \"DEFAULT VALUES\": false,\n  \"VALUES ()\": false,\n  \"LIMIT ON UPDATE\": false,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: false,\n  schemas: true,\n  finalTable: true,\n  autoIncrement: {\n    identityInsert: false,\n    defaultValue: false,\n    update: true\n  },\n  constraints: {\n    restrict: true,\n    default: false\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nDb2Dialect.prototype.defaultVersion = \"1.0.0\";\nDb2Dialect.prototype.Query = Query;\nDb2Dialect.prototype.name = \"db2\";\nDb2Dialect.prototype.TICK_CHAR = '\"';\nDb2Dialect.prototype.TICK_CHAR_LEFT = '\"';\nDb2Dialect.prototype.TICK_CHAR_RIGHT = '\"';\nDb2Dialect.prototype.DataTypes = DataTypes;\nmodule.exports = Db2Dialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsbUdBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyx5RUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyw2RkFBbUI7QUFDbEQsa0JBQWtCLHFHQUErQjtBQUNqRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsNkZBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvaW5kZXguanM/MDhiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5kYjI7XG5jb25zdCB7IERiMlF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi9xdWVyeS1pbnRlcmZhY2VcIik7XG5jbGFzcyBEYjJEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgRGIyUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxufVxuRGIyRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIFwiREVGQVVMVFwiOiB0cnVlLFxuICBcIkRFRkFVTFQgVkFMVUVTXCI6IGZhbHNlLFxuICBcIlZBTFVFUyAoKVwiOiBmYWxzZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogZmFsc2UsXG4gIFwiT1JERVIgTlVMTFNcIjogZmFsc2UsXG4gIGxvY2s6IGZhbHNlLFxuICB0cmFuc2FjdGlvbnM6IHRydWUsXG4gIG1pZ3JhdGlvbnM6IGZhbHNlLFxuICByZXR1cm5WYWx1ZXM6IGZhbHNlLFxuICBzY2hlbWFzOiB0cnVlLFxuICBmaW5hbFRhYmxlOiB0cnVlLFxuICBhdXRvSW5jcmVtZW50OiB7XG4gICAgaWRlbnRpdHlJbnNlcnQ6IGZhbHNlLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgdXBkYXRlOiB0cnVlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgcmVzdHJpY3Q6IHRydWUsXG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IGZhbHNlLFxuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgdXNpbmc6IGZhbHNlLFxuICAgIHdoZXJlOiB0cnVlXG4gIH0sXG4gIE5VTUVSSUM6IHRydWUsXG4gIHRtcFRhYmxlVHJpZ2dlcjogdHJ1ZVxufSk7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiMS4wLjBcIjtcbkRiMkRpYWxlY3QucHJvdG90eXBlLlF1ZXJ5ID0gUXVlcnk7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJkYjJcIjtcbkRiMkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9ICdcIic7XG5EYjJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSAnXCInO1xuRGIyRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xubW9kdWxlLmV4cG9ydHMgPSBEYjJEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/query-generator.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/query-generator.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst randomBytes = (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass Db2QueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP_LIKE\",\n      [Op.notRegexp]: \"NOT REGEXP_LIKE\"\n    });\n    this.autoGenValue = 1;\n  }\n  createSchema(schema) {\n    return [\n      \"CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${wrapSingleQuote(schema.trim())}, NULL, ? , ?)`;\n    const sql = { query };\n    sql.bind = [\n      { ParamType: \"INOUT\", Data: \"ERRORSCHEMA\" },\n      { ParamType: \"INOUT\", Data: \"ERRORTABLE\" }\n    ];\n    return sql;\n  }\n  showSchemasQuery() {\n    return `SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')`;\n  }\n  versionQuery() {\n    return \"select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const query = \"CREATE TABLE <%= table %> (<%= attributes %>)\", primaryKeys = [], foreignKeys = {}, attrStr = [], commentTemplate = \" -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;\";\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          if (commentMatch && commentMatch.length > 2) {\n            const commentText = commentMatch[2].replace(/COMMENT/, \"\").trim();\n            commentStr += _.template(commentTemplate, this._templateSettings)({\n              table: this.quoteIdentifier(tableName),\n              comment: this.escape(commentText),\n              column: this.quoteIdentifier(attr)\n            });\n            dataType = commentMatch[1];\n          }\n        }\n        if (_.includes(dataType, \"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (_.includes(dataType, \"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(/PRIMARY KEY/, \"\")}`);\n          }\n        } else if (_.includes(dataType, \"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          if (options && options.uniqueKeys) {\n            for (const ukey in options.uniqueKeys) {\n              if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, \"NOT NULL\")) {\n                dataType += \" NOT NULL\";\n                break;\n              }\n            }\n          }\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const values = {\n      table: this.quoteTable(tableName),\n      attributes: attrStr.join(\", \")\n    }, pkString = primaryKeys.map((pk) => {\n      return this.quoteIdentifier(pk);\n    }).join(\", \");\n    if (options && options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        values.attributes += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return `${_.template(query, this._templateSettings)(values).trim()};${commentStr}`;\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT NAME AS \"Name\", TBNAME AS \"Table\", TBCREATOR AS \"Schema\",',\n      'TRIM(COLTYPE) AS \"Type\", LENGTH AS \"Length\", SCALE AS \"Scale\",',\n      'NULLS AS \"IsNull\", DEFAULT AS \"Default\", COLNO AS \"Colno\",',\n      'IDENTITY AS \"IsIdentity\", KEYSEQ AS \"KeySeq\", REMARKS AS \"Comment\"',\n      \"FROM\",\n      \"SYSIBM.SYSCOLUMNS\",\n      \"WHERE TBNAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;\n    } else {\n      sql += \" AND TBCREATOR = USER\";\n    }\n    return `${sql};`;\n  }\n  renameTableQuery(before, after) {\n    const query = \"RENAME TABLE <%= before %> TO <%= after %>;\";\n    return _.template(query, this._templateSettings)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  }\n  showTablesQuery() {\n    return `SELECT TABNAME AS \"tableName\", TRIM(TABSCHEMA) AS \"tableSchema\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME`;\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || this.sequelize.config.username.toUpperCase();\n    return `SELECT name FROM sysibm.systables WHERE NAME = ${wrapSingleQuote(tableName)} AND CREATOR = ${wrapSingleQuote(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const query = \"DROP TABLE <%= table %>\";\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    return `${_.template(query, this._templateSettings)(values).trim()};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const query = \"ALTER TABLE <%= table %> ADD <%= attribute %>;\", attribute = _.template(\"<%= key %> <%= definition %>\", this._templateSettings)({\n      key: this.quoteIdentifier(key),\n      definition: this.attributeToSQL(dataType, {\n        context: \"addColumn\"\n      })\n    });\n    return _.template(query, this._templateSettings)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const query = \"ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;\";\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> <%= query %>;\";\n    const attrString = [], constraintString = [];\n    for (const attributeName in attributes) {\n      const attrValue = attributes[attributeName];\n      let defs = [attrValue];\n      if (Array.isArray(attrValue)) {\n        defs = attrValue;\n      }\n      for (let i = 0; i < defs.length; i++) {\n        const definition = defs[i];\n        if (definition.match(/REFERENCES/)) {\n          constraintString.push(_.template(\"<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>\", this._templateSettings)({\n            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),\n            attrName: this.quoteIdentifier(attributeName),\n            definition: definition.replace(/.+?(?=REFERENCES)/, \"\")\n          }));\n        } else if (_.startsWith(definition, \"DROP \")) {\n          attrString.push(_.template(\"<%= attrName %> <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        } else {\n          attrString.push(_.template(\"<%= attrName %> SET <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        }\n      }\n    }\n    let finalQuery = \"\";\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(\" ALTER COLUMN \")}`;\n      finalQuery += constraintString.length ? \" \" : \"\";\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(\" ADD CONSTRAINT \")}`;\n    }\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;\", newName = Object.keys(attributes)[0];\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      before: this.quoteIdentifier(attrBefore),\n      after: this.quoteIdentifier(newName)\n    });\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate && options.onUpdate.toUpperCase() === \"CASCADE\") {\n      delete options.onUpdate;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    let query = \"INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;\";\n    if (options.returning) {\n      query = \"SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);\";\n    }\n    const emptyQuery = \"INSERT INTO <%= table %>\", tuples = [], allAttributes = [], allQueries = [];\n    let outputFragment;\n    const valuesForEmptyQuery = [];\n    if (options.returning) {\n      outputFragment = \"\";\n    }\n    _.forEach(attrValueHashes, (attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        valuesForEmptyQuery.push(`(${this.autoGenValue++})`);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (valuesForEmptyQuery.length > 0) {\n      allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(\",\")}`);\n    }\n    if (allAttributes.length > 0) {\n      _.forEach(attrValueHashes, (attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key]), void 0, { context: \"INSERT\" }).join(\",\")})`);\n      });\n      allQueries.push(query);\n    }\n    const replacements = {\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\"),\n      tuples,\n      output: outputFragment\n    };\n    const generatedQuery = _.template(allQueries.join(\";\"), this._templateSettings)(replacements);\n    return generatedQuery;\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    options = options || {};\n    _.defaults(options, this.options);\n    if (!options.limit) {\n      sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;\n      return sql;\n    }\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(\",\")}`;\n    query = `SELECT * FROM FINAL TABLE (${query});`;\n    return { query, bind };\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      }\n      return false;\n    }).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    }).join(\", \");\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const query = \"DELETE FROM <%= table %><%= where %><%= limit %>\";\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = \"\";\n    if (options.offset > 0) {\n      limit = ` OFFSET ${this.escape(options.offset)} ROWS`;\n    }\n    if (options.limit) {\n      limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n    if (replacements.where) {\n      replacements.where = ` WHERE ${replacements.where}`;\n    }\n    return _.template(query, this._templateSettings)(replacements);\n  }\n  showIndexesQuery(tableName) {\n    let sql = 'SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';\n    let schema = void 0;\n    if (_.isObject(tableName)) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    if (schema) {\n      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;\n    }\n    sql = `${sql} ORDER BY NAME;`;\n    return _.template(sql, this._templateSettings)({\n      tableName: wrapSingleQuote(tableName),\n      schemaName: wrapSingleQuote(schema)\n    });\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;\n    if (constraintName) {\n      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;\n    }\n    return `${sql} ORDER BY CONSTNAME;`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = \"DROP INDEX <%= indexName %>\";\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n    return _.template(sql, this._templateSettings)(values);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let template;\n    let changeNull = 1;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n    } else {\n      template = attribute.type.toString();\n    }\n    if (options && options.context === \"changeColumn\" && attribute.type) {\n      template = `DATA TYPE ${template}`;\n    } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {\n      template += \" NOT NULL\";\n      changeNull = 0;\n    }\n    if (attribute.autoIncrement) {\n      let initialValue = 1;\n      if (attribute.initialAutoIncrement) {\n        initialValue = attribute.initialAutoIncrement;\n      }\n      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = `${options.tableName}_${attrName}_fidx`;\n        template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != \"CASCADE\") {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (options && options.context === \"changeColumn\" && changeNull === 1 && attribute.allowNull !== void 0) {\n      template = [template];\n      if (attribute.allowNull) {\n        template.push(\"DROP NOT NULL\");\n      } else {\n        template.push(\"NOT NULL\");\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else if (attribute.unique && attribute.unique === true) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n        }\n      }\n      if (key && !attribute.field && typeof attribute === \"object\")\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQuerySQL(condition) {\n    return `SELECT R.CONSTNAME AS \"constraintName\", TRIM(R.TABSCHEMA) AS \"constraintSchema\", R.TABNAME AS \"tableName\", TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", R.REFTABNAME AS \"referencedTableName\", TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    schemaName = table.schema || schemaName;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    if (columnName) {\n      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT TABNAME AS \"tableName\",',\n      'COLNAME AS \"columnName\",',\n      'CONSTNAME AS \"constraintName\"',\n      \"FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'\",\n      `AND COLNAME = ${wrapSingleQuote(attributeName)}`,\n      `AND TABNAME = ${tableName};`\n    ].join(\" \");\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return _.template(\"ALTER TABLE <%= table %> DROP <%= key %>\", this._templateSettings)({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = \"ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;\";\n    return _.template(sql, this._templateSettings)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  }\n  setAutocommitQuery() {\n    return \"\";\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  addLimitAndOffset(options) {\n    const offset = options.offset || 0;\n    let fragment = \"\";\n    if (offset > 0) {\n      fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n    }\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  addUniqueFields(dataValues, rawAttributes, uniqno) {\n    uniqno = uniqno === void 0 ? 1 : uniqno;\n    for (const key in rawAttributes) {\n      if (rawAttributes[key].unique && dataValues[key] === void 0) {\n        if (rawAttributes[key].type instanceof DataTypes.DATE) {\n          dataValues[key] = Utils.now(\"db2\");\n        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {\n          dataValues[key] = `unique${uniqno++}`;\n        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {\n          dataValues[key] = uniqno++;\n        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {\n          dataValues[key] = new DataTypes.BOOLEAN(false);\n        }\n      }\n    }\n    return uniqno;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  if (identifier) {\n    return `'${identifier}'`;\n  }\n  return \"\";\n}\nmodule.exports = Db2QueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLCtCQUErQixtQkFBTyxDQUFDLDRHQUE2QjtBQUNwRSxvQkFBb0IseURBQTZCO0FBQ2pELFdBQVcsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDcEM7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsK0JBQStCO0FBQ25GLGtCQUFrQjtBQUNsQjtBQUNBLFFBQVEseUNBQXlDO0FBQ2pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyw0R0FBNEc7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzlGO0FBQ0EsWUFBWTtBQUNaLDRCQUE0Qiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDOUY7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUUsU0FBUztBQUNqRTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLFNBQVM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSwrQ0FBK0MsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ2hLO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCLElBQUksa0JBQWtCO0FBQ2hHO0FBQ0E7QUFDQSxjQUFjLDBEQUEwRCxFQUFFLFdBQVc7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDRCQUE0QixnQkFBZ0IsNEJBQTRCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMERBQTBEO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQztBQUN0RTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMENBQTBDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxNQUFNLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHlCQUF5QixZQUFZLFNBQVMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBc0UsbUJBQW1CLFlBQVk7QUFDN0gsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVSxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQixHQUFHLDRFQUE0RSxtQkFBbUIsRUFBRTtBQUNySixRQUFRO0FBQ1IsdUJBQXVCLDBCQUEwQixHQUFHLDRFQUE0RSxtQkFBbUIsYUFBYTtBQUNoSztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRCxxQ0FBcUMsNEJBQTRCLEVBQUUsc0NBQXNDLGFBQWEsNEJBQTRCLGlCQUFpQixpQkFBaUI7QUFDcEwsMENBQTBDLE1BQU0sRUFBRTtBQUNsRCxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUIsR0FBRyxLQUFLLElBQUksaUJBQWlCLEdBQUcsSUFBSTtBQUN2RSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLEdBQUcsS0FBSyxJQUFJLE1BQU07QUFDbkQsS0FBSztBQUNMLDZGQUE2RixzQkFBc0I7QUFDbkgsOEJBQThCLGlCQUFpQixXQUFXLG9CQUFvQjtBQUM5RSw4QkFBOEIsaUJBQWlCLEtBQUssa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCLE9BQU8sY0FBYztBQUNqSyxpQkFBaUIsZUFBZSwrQkFBK0IsZUFBZTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNkJBQTZCO0FBQ3REO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EsYUFBYSxLQUFLLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxSkFBcUosVUFBVTtBQUMvSjtBQUNBLHNDQUFzQyxlQUFlO0FBQ3JEO0FBQ0EsY0FBYyxLQUFLLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDLEtBQUs7QUFDekU7QUFDQSxPQUFPLGFBQWE7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGFBQWE7QUFDL0U7QUFDQTtBQUNBLDhCQUE4QixvQ0FBb0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCLEdBQUcsU0FBUztBQUN4RCxvQ0FBb0MsUUFBUSxlQUFlLFNBQVM7QUFDcEU7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RSxRQUFRO0FBQ1IseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrZkFBa2YsV0FBVztBQUM3ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RCx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xEO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixxQ0FBcUMsU0FBUztBQUM5QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL2RiMi9xdWVyeS1nZW5lcmF0b3IuanM/YjZiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCByYW5kb21CeXRlcyA9IHJlcXVpcmUoXCJjcnlwdG9cIikucmFuZG9tQnl0ZXM7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCB0aHJvd01ldGhvZFVuZGVmaW5lZCA9IGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWV0aG9kIFwiJHttZXRob2ROYW1lfVwiIGlzIG5vdCBkZWZpbmVkISBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgc3FsIGRpYWxlY3QuYCk7XG59O1xuY2xhc3MgRGIyUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuT3BlcmF0b3JNYXAgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLk9wZXJhdG9yTWFwKSwge1xuICAgICAgW09wLnJlZ2V4cF06IFwiUkVHRVhQX0xJS0VcIixcbiAgICAgIFtPcC5ub3RSZWdleHBdOiBcIk5PVCBSRUdFWFBfTElLRVwiXG4gICAgfSk7XG4gICAgdGhpcy5hdXRvR2VuVmFsdWUgPSAxO1xuICB9XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJDUkVBVEUgU0NIRU1BXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLFxuICAgICAgXCI7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgY29uc3QgcXVlcnkgPSBgQ0FMTCBTWVNQUk9DLkFETUlOX0RST1BfU0NIRU1BKCR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYS50cmltKCkpfSwgTlVMTCwgPyAsID8pYDtcbiAgICBjb25zdCBzcWwgPSB7IHF1ZXJ5IH07XG4gICAgc3FsLmJpbmQgPSBbXG4gICAgICB7IFBhcmFtVHlwZTogXCJJTk9VVFwiLCBEYXRhOiBcIkVSUk9SU0NIRU1BXCIgfSxcbiAgICAgIHsgUGFyYW1UeXBlOiBcIklOT1VUXCIsIERhdGE6IFwiRVJST1JUQUJMRVwiIH1cbiAgICBdO1xuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gYFNFTEVDVCBTQ0hFTUFOQU1FIEFTIFwic2NoZW1hX25hbWVcIiBGUk9NIFNZU0NBVC5TQ0hFTUFUQSBXSEVSRSAoU0NIRU1BTkFNRSBOT1QgTElLRSAnU1lTJScpIEFORCBTQ0hFTUFOQU1FIE5PVCBJTiAoJ05VTExJRCcsICdTUUxKJywgJ0VSUk9SU0NIRU1BJylgO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJzZWxlY3Qgc2VydmljZV9sZXZlbCBhcyBWRVJTSU9OIGZyb20gVEFCTEUgKHN5c3Byb2MuZW52X2dldF9pbnN0X2luZm8oKSkgYXMgQVwiO1xuICB9XG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnkgPSBcIkNSRUFURSBUQUJMRSA8JT0gdGFibGUgJT4gKDwlPSBhdHRyaWJ1dGVzICU+KVwiLCBwcmltYXJ5S2V5cyA9IFtdLCBmb3JlaWduS2V5cyA9IHt9LCBhdHRyU3RyID0gW10sIGNvbW1lbnRUZW1wbGF0ZSA9IFwiIC0tIDwlPSBjb21tZW50ICU+LCBUYWJsZU5hbWUgPSA8JT0gdGFibGUgJT4sIENvbHVtbk5hbWUgPSA8JT0gY29sdW1uICU+O1wiO1xuICAgIGxldCBjb21tZW50U3RyID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBsZXQgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIkNPTU1FTlQgXCIpKSB7XG4gICAgICAgICAgY29uc3QgY29tbWVudE1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChDT01NRU5ULiopJC8pO1xuICAgICAgICAgIGlmIChjb21tZW50TWF0Y2ggJiYgY29tbWVudE1hdGNoLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRUZXh0ID0gY29tbWVudE1hdGNoWzJdLnJlcGxhY2UoL0NPTU1FTlQvLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgICBjb21tZW50U3RyICs9IF8udGVtcGxhdGUoY29tbWVudFRlbXBsYXRlLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICAgICAgICAgIHRhYmxlOiB0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZU5hbWUpLFxuICAgICAgICAgICAgICBjb21tZW50OiB0aGlzLmVzY2FwZShjb21tZW50VGV4dCksXG4gICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YVR5cGUgPSBjb21tZW50TWF0Y2hbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfLmluY2x1ZGVzKGRhdGFUeXBlLCBcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgICBpZiAoXy5pbmNsdWRlcyhkYXRhVHlwZSwgXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXS5yZXBsYWNlKC9QUklNQVJZIEtFWS8sIFwiXCIpfWApO1xuICAgICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlLnJlcGxhY2UoL1BSSU1BUlkgS0VZLywgXCJcIil9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXMoZGF0YVR5cGUsIFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB1a2V5IGluIG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzW3VrZXldLmZpZWxkcy5pbmNsdWRlcyhhdHRyKSAmJiAhXy5pbmNsdWRlcyhkYXRhVHlwZSwgXCJOT1QgTlVMTFwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJpYnV0ZXM6IGF0dHJTdHIuam9pbihcIiwgXCIpXG4gICAgfSwgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAoKHBrKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspO1xuICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zLCBpbmRleE5hbWUpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoaW5kZXhOYW1lKSkge1xuICAgICAgICAgICAgaW5kZXhOYW1lID0gYHVuaXFfJHt0YWJsZU5hbWV9XyR7Y29sdW1ucy5maWVsZHMuam9pbihcIl9cIil9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCwgQ09OU1RSQUlOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9IFVOSVFVRSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLCBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBma2V5IGluIGZvcmVpZ25LZXlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSkge1xuICAgICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLCBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke18udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHZhbHVlcykudHJpbSgpfTske2NvbW1lbnRTdHJ9YDtcbiAgfVxuICBkZXNjcmliZVRhYmxlUXVlcnkodGFibGVOYW1lLCBzY2hlbWEpIHtcbiAgICBsZXQgc3FsID0gW1xuICAgICAgJ1NFTEVDVCBOQU1FIEFTIFwiTmFtZVwiLCBUQk5BTUUgQVMgXCJUYWJsZVwiLCBUQkNSRUFUT1IgQVMgXCJTY2hlbWFcIiwnLFxuICAgICAgJ1RSSU0oQ09MVFlQRSkgQVMgXCJUeXBlXCIsIExFTkdUSCBBUyBcIkxlbmd0aFwiLCBTQ0FMRSBBUyBcIlNjYWxlXCIsJyxcbiAgICAgICdOVUxMUyBBUyBcIklzTnVsbFwiLCBERUZBVUxUIEFTIFwiRGVmYXVsdFwiLCBDT0xOTyBBUyBcIkNvbG5vXCIsJyxcbiAgICAgICdJREVOVElUWSBBUyBcIklzSWRlbnRpdHlcIiwgS0VZU0VRIEFTIFwiS2V5U2VxXCIsIFJFTUFSS1MgQVMgXCJDb21tZW50XCInLFxuICAgICAgXCJGUk9NXCIsXG4gICAgICBcIlNZU0lCTS5TWVNDT0xVTU5TXCIsXG4gICAgICBcIldIRVJFIFRCTkFNRSA9XCIsXG4gICAgICB3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKVxuICAgIF0uam9pbihcIiBcIik7XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgc3FsICs9IGAgQU5EIFRCQ1JFQVRPUiA9JHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcWwgKz0gXCIgQU5EIFRCQ1JFQVRPUiA9IFVTRVJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGAke3NxbH07YDtcbiAgfVxuICByZW5hbWVUYWJsZVF1ZXJ5KGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBjb25zdCBxdWVyeSA9IFwiUkVOQU1FIFRBQkxFIDwlPSBiZWZvcmUgJT4gVE8gPCU9IGFmdGVyICU+O1wiO1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICBiZWZvcmU6IHRoaXMucXVvdGVUYWJsZShiZWZvcmUpLFxuICAgICAgYWZ0ZXI6IHRoaXMucXVvdGVUYWJsZShhZnRlcilcbiAgICB9KTtcbiAgfVxuICBzaG93VGFibGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1QgVEFCTkFNRSBBUyBcInRhYmxlTmFtZVwiLCBUUklNKFRBQlNDSEVNQSkgQVMgXCJ0YWJsZVNjaGVtYVwiIEZST00gU1lTQ0FULlRBQkxFUyBXSEVSRSBUQUJTQ0hFTUEgPSBVU0VSIEFORCBUWVBFID0gJ1QnIE9SREVSIEJZIFRBQlNDSEVNQSwgVEFCTkFNRWA7XG4gIH1cbiAgdGFibGVFeGlzdHNRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hIHx8IHRoaXMuc2VxdWVsaXplLmNvbmZpZy51c2VybmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBgU0VMRUNUIG5hbWUgRlJPTSBzeXNpYm0uc3lzdGFibGVzIFdIRVJFIE5BTUUgPSAke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfSBBTkQgQ1JFQVRPUiA9ICR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYU5hbWUpfWA7XG4gIH1cbiAgZHJvcFRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgY29uc3QgcXVlcnkgPSBcIkRST1AgVEFCTEUgPCU9IHRhYmxlICU+XCI7XG4gICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgdGFibGU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpXG4gICAgfTtcbiAgICByZXR1cm4gYCR7Xy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykodmFsdWVzKS50cmltKCl9O2A7XG4gIH1cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgZGF0YVR5cGUpIHtcbiAgICBkYXRhVHlwZS5maWVsZCA9IGtleTtcbiAgICBjb25zdCBxdWVyeSA9IFwiQUxURVIgVEFCTEUgPCU9IHRhYmxlICU+IEFERCA8JT0gYXR0cmlidXRlICU+O1wiLCBhdHRyaWJ1dGUgPSBfLnRlbXBsYXRlKFwiPCU9IGtleSAlPiA8JT0gZGVmaW5pdGlvbiAlPlwiLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh7XG4gICAgICBrZXk6IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksXG4gICAgICBkZWZpbml0aW9uOiB0aGlzLmF0dHJpYnV0ZVRvU1FMKGRhdGFUeXBlLCB7XG4gICAgICAgIGNvbnRleHQ6IFwiYWRkQ29sdW1uXCJcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIF8udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgYXR0cmlidXRlXG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgcXVlcnkgPSBcIkFMVEVSIFRBQkxFIDwlPSB0YWJsZU5hbWUgJT4gRFJPUCBDT0xVTU4gPCU9IGF0dHJpYnV0ZU5hbWUgJT47XCI7XG4gICAgcmV0dXJuIF8udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlTmFtZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBhdHRyaWJ1dGVOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKVxuICAgIH0pO1xuICB9XG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJBTFRFUiBUQUJMRSA8JT0gdGFibGVOYW1lICU+IDwlPSBxdWVyeSAlPjtcIjtcbiAgICBjb25zdCBhdHRyU3RyaW5nID0gW10sIGNvbnN0cmFpbnRTdHJpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgYXR0clZhbHVlID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGxldCBkZWZzID0gW2F0dHJWYWx1ZV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRyVmFsdWUpKSB7XG4gICAgICAgIGRlZnMgPSBhdHRyVmFsdWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGRlZnNbaV07XG4gICAgICAgIGlmIChkZWZpbml0aW9uLm1hdGNoKC9SRUZFUkVOQ0VTLykpIHtcbiAgICAgICAgICBjb25zdHJhaW50U3RyaW5nLnB1c2goXy50ZW1wbGF0ZShcIjwlPSBma05hbWUgJT4gRk9SRUlHTiBLRVkgKDwlPSBhdHRyTmFtZSAlPikgPCU9IGRlZmluaXRpb24gJT5cIiwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgICAgICAgZmtOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcihgJHthdHRyaWJ1dGVOYW1lfV9mb3JlaWduX2lkeGApLFxuICAgICAgICAgICAgYXR0ck5hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sIFwiXCIpXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uc3RhcnRzV2l0aChkZWZpbml0aW9uLCBcIkRST1AgXCIpKSB7XG4gICAgICAgICAgYXR0clN0cmluZy5wdXNoKF8udGVtcGxhdGUoXCI8JT0gYXR0ck5hbWUgJT4gPCU9IGRlZmluaXRpb24gJT5cIiwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgICAgICAgYXR0ck5hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgICAgICAgZGVmaW5pdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyU3RyaW5nLnB1c2goXy50ZW1wbGF0ZShcIjwlPSBhdHRyTmFtZSAlPiBTRVQgPCU9IGRlZmluaXRpb24gJT5cIiwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgICAgICAgYXR0ck5hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgICAgICAgZGVmaW5pdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZmluYWxRdWVyeSA9IFwiXCI7XG4gICAgaWYgKGF0dHJTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBmaW5hbFF1ZXJ5ICs9IGBBTFRFUiBDT0xVTU4gJHthdHRyU3RyaW5nLmpvaW4oXCIgQUxURVIgQ09MVU1OIFwiKX1gO1xuICAgICAgZmluYWxRdWVyeSArPSBjb25zdHJhaW50U3RyaW5nLmxlbmd0aCA/IFwiIFwiIDogXCJcIjtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICBmaW5hbFF1ZXJ5ICs9IGBBREQgQ09OU1RSQUlOVCAke2NvbnN0cmFpbnRTdHJpbmcuam9pbihcIiBBREQgQ09OU1RSQUlOVCBcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIF8udGVtcGxhdGUocXVlcnksIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlTmFtZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBxdWVyeTogZmluYWxRdWVyeVxuICAgIH0pO1xuICB9XG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gXCJBTFRFUiBUQUJMRSA8JT0gdGFibGVOYW1lICU+IFJFTkFNRSBDT0xVTU4gPCU9IGJlZm9yZSAlPiBUTyA8JT0gYWZ0ZXIgJT47XCIsIG5ld05hbWUgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKVswXTtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShxdWVyeSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGVOYW1lOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGJlZm9yZTogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckJlZm9yZSksXG4gICAgICBhZnRlcjogdGhpcy5xdW90ZUlkZW50aWZpZXIobmV3TmFtZSlcbiAgICB9KTtcbiAgfVxuICBhZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMub25VcGRhdGUgJiYgb3B0aW9ucy5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpID09PSBcIkNBU0NBREVcIikge1xuICAgICAgZGVsZXRlIG9wdGlvbnMub25VcGRhdGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbnRTbmlwcGV0ID0gdGhpcy5nZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcnModGFibGVOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0YWJsZU5hbWV9IEFERCAke2NvbnN0cmFpbnRTbmlwcGV0fTtgO1xuICB9XG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2hlcywgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGxldCBxdWVyeSA9IFwiSU5TRVJUIElOVE8gPCU9IHRhYmxlICU+ICg8JT0gYXR0cmlidXRlcyAlPik8JT0gb3V0cHV0ICU+IFZBTFVFUyA8JT0gdHVwbGVzICU+O1wiO1xuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgcXVlcnkgPSBcIlNFTEVDVCAqIEZST00gRklOQUwgVEFCTEUoIElOU0VSVCBJTlRPIDwlPSB0YWJsZSAlPiAoPCU9IGF0dHJpYnV0ZXMgJT4pPCU9IG91dHB1dCAlPiBWQUxVRVMgPCU9IHR1cGxlcyAlPik7XCI7XG4gICAgfVxuICAgIGNvbnN0IGVtcHR5UXVlcnkgPSBcIklOU0VSVCBJTlRPIDwlPSB0YWJsZSAlPlwiLCB0dXBsZXMgPSBbXSwgYWxsQXR0cmlidXRlcyA9IFtdLCBhbGxRdWVyaWVzID0gW107XG4gICAgbGV0IG91dHB1dEZyYWdtZW50O1xuICAgIGNvbnN0IHZhbHVlc0ZvckVtcHR5UXVlcnkgPSBbXTtcbiAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gXCJcIjtcbiAgICB9XG4gICAgXy5mb3JFYWNoKGF0dHJWYWx1ZUhhc2hlcywgKGF0dHJWYWx1ZUhhc2gpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGF0dHJWYWx1ZUhhc2gpO1xuICAgICAgY29uc3QgZmlyc3RBdHRyID0gYXR0cmlidXRlc1tmaWVsZHNbMF1dO1xuICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDEgJiYgZmlyc3RBdHRyICYmIGZpcnN0QXR0ci5hdXRvSW5jcmVtZW50ICYmIGF0dHJWYWx1ZUhhc2hbZmllbGRzWzBdXSA9PT0gbnVsbCkge1xuICAgICAgICB2YWx1ZXNGb3JFbXB0eVF1ZXJ5LnB1c2goYCgke3RoaXMuYXV0b0dlblZhbHVlKyt9KWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfLmZvck93bihhdHRyVmFsdWVIYXNoLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAoYWxsQXR0cmlidXRlcy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsICYmIGF0dHJpYnV0ZXNba2V5XSAmJiBhdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBhbGxBdHRyaWJ1dGVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHZhbHVlc0ZvckVtcHR5UXVlcnkubGVuZ3RoID4gMCkge1xuICAgICAgYWxsUXVlcmllcy5wdXNoKGAke2VtcHR5UXVlcnl9IFZBTFVFUyAke3ZhbHVlc0ZvckVtcHR5UXVlcnkuam9pbihcIixcIil9YCk7XG4gICAgfVxuICAgIGlmIChhbGxBdHRyaWJ1dGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIF8uZm9yRWFjaChhdHRyVmFsdWVIYXNoZXMsIChhdHRyVmFsdWVIYXNoKSA9PiB7XG4gICAgICAgIHR1cGxlcy5wdXNoKGAoJHthbGxBdHRyaWJ1dGVzLm1hcCgoa2V5KSA9PiB0aGlzLmVzY2FwZShhdHRyVmFsdWVIYXNoW2tleV0pLCB2b2lkIDAsIHsgY29udGV4dDogXCJJTlNFUlRcIiB9KS5qb2luKFwiLFwiKX0pYCk7XG4gICAgICB9KTtcbiAgICAgIGFsbFF1ZXJpZXMucHVzaChxdWVyeSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJpYnV0ZXM6IGFsbEF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIixcIiksXG4gICAgICB0dXBsZXMsXG4gICAgICBvdXRwdXQ6IG91dHB1dEZyYWdtZW50XG4gICAgfTtcbiAgICBjb25zdCBnZW5lcmF0ZWRRdWVyeSA9IF8udGVtcGxhdGUoYWxsUXVlcmllcy5qb2luKFwiO1wiKSwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykocmVwbGFjZW1lbnRzKTtcbiAgICByZXR1cm4gZ2VuZXJhdGVkUXVlcnk7XG4gIH1cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHNxbCA9IHN1cGVyLnVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMubGltaXQpIHtcbiAgICAgIHNxbC5xdWVyeSA9IGBTRUxFQ1QgKiBGUk9NIEZJTkFMIFRBQkxFICgke3NxbC5xdWVyeX0pO2A7XG4gICAgICByZXR1cm4gc3FsO1xuICAgIH1cbiAgICBhdHRyVmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMub21pdE51bGwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgYmluZCA9IFtdO1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtIHx8IHRoaXMuYmluZFBhcmFtKGJpbmQpO1xuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2goYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0clZhbHVlSGFzaCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyVmFsdWVIYXNoW2tleV07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiVVBEQVRFXCIgfSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIlVQREFURVwiIH0sIGJpbmRQYXJhbSl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBxdWVyeTtcbiAgICBjb25zdCB3aGVyZU9wdGlvbnMgPSBfLmRlZmF1bHRzKHsgYmluZFBhcmFtIH0sIG9wdGlvbnMpO1xuICAgIHF1ZXJ5ID0gYFVQREFURSAoU0VMRUNUICogRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX0gRkVUQ0ggTkVYVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSBST1dTIE9OTFkpIFNFVCAke3ZhbHVlcy5qb2luKFwiLFwiKX1gO1xuICAgIHF1ZXJ5ID0gYFNFTEVDVCAqIEZST00gRklOQUwgVEFCTEUgKCR7cXVlcnl9KTtgO1xuICAgIHJldHVybiB7IHF1ZXJ5LCBiaW5kIH07XG4gIH1cbiAgdXBzZXJ0UXVlcnkodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG1vZGVsKSB7XG4gICAgY29uc3QgdGFyZ2V0VGFibGVBbGlhcyA9IHRoaXMucXVvdGVUYWJsZShgJHt0YWJsZU5hbWV9X3RhcmdldGApO1xuICAgIGNvbnN0IHNvdXJjZVRhYmxlQWxpYXMgPSB0aGlzLnF1b3RlVGFibGUoYCR7dGFibGVOYW1lfV9zb3VyY2VgKTtcbiAgICBjb25zdCBwcmltYXJ5S2V5c0F0dHJzID0gW107XG4gICAgY29uc3QgaWRlbnRpdHlBdHRycyA9IFtdO1xuICAgIGNvbnN0IHVuaXF1ZUF0dHJzID0gW107XG4gICAgY29uc3QgdGFibGVOYW1lUXVvdGVkID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbW9kZWwucmF3QXR0cmlidXRlcykge1xuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5wcmltYXJ5S2V5KSB7XG4gICAgICAgIHByaW1hcnlLZXlzQXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udW5pcXVlKSB7XG4gICAgICAgIHVuaXF1ZUF0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgaWRlbnRpdHlBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG1vZGVsLl9pbmRleGVzKSB7XG4gICAgICBpZiAoaW5kZXgudW5pcXVlICYmIGluZGV4LmZpZWxkcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4LmZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIiA/IGZpZWxkIDogZmllbGQubmFtZSB8fCBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICAgICAgaWYgKHVuaXF1ZUF0dHJzLmluZGV4T2YoZmllbGROYW1lKSA9PT0gLTEgJiYgbW9kZWwucmF3QXR0cmlidXRlc1tmaWVsZE5hbWVdKSB7XG4gICAgICAgICAgICB1bmlxdWVBdHRycy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZUtleXMgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIGNvbnN0IGluc2VydEtleXMgPSBPYmplY3Qua2V5cyhpbnNlcnRWYWx1ZXMpO1xuICAgIGNvbnN0IGluc2VydEtleXNRdW90ZWQgPSBpbnNlcnRLZXlzLm1hcCgoa2V5KSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzRXNjYXBlZCA9IGluc2VydEtleXMubWFwKChrZXkpID0+IHRoaXMuZXNjYXBlKGluc2VydFZhbHVlc1trZXldKSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHNvdXJjZVRhYmxlUXVlcnkgPSBgVkFMVUVTKCR7aW5zZXJ0VmFsdWVzRXNjYXBlZH0pYDtcbiAgICBsZXQgam9pbkNvbmRpdGlvbjtcbiAgICBjb25zdCBjbGF1c2VzID0gd2hlcmVbT3Aub3JdLmZpbHRlcigoY2xhdXNlKSA9PiB7XG4gICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2xhdXNlKSB7XG4gICAgICAgIGlmICghY2xhdXNlW2tleV0pIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Sm9pblNuaXBwZXQgPSAoYXJyYXkpID0+IHtcbiAgICAgIHJldHVybiBhcnJheS5tYXAoKGtleSkgPT4ge1xuICAgICAgICBrZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgICAgICByZXR1cm4gYCR7dGFyZ2V0VGFibGVBbGlhc30uJHtrZXl9ID0gJHtzb3VyY2VUYWJsZUFsaWFzfS4ke2tleX1gO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoY2xhdXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaW1hcnkgS2V5IG9yIFVuaXF1ZSBrZXkgc2hvdWxkIGJlIHBhc3NlZCB0byB1cHNlcnQgcXVlcnlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsYXVzZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNsYXVzZXNba2V5XSk7XG4gICAgICAgIGlmIChwcmltYXJ5S2V5c0F0dHJzLmluZGV4T2Yoa2V5c1swXSkgIT09IC0xKSB7XG4gICAgICAgICAgam9pbkNvbmRpdGlvbiA9IGdldEpvaW5TbmlwcGV0KHByaW1hcnlLZXlzQXR0cnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFqb2luQ29uZGl0aW9uKSB7XG4gICAgICAgIGpvaW5Db25kaXRpb24gPSBnZXRKb2luU25pcHBldCh1bmlxdWVBdHRycykuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZUNsYXVzZXMgPSB1cGRhdGVLZXlzLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICBpZiAoaWRlbnRpdHlBdHRycy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pLm1hcCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZXNjYXBlKHVwZGF0ZVZhbHVlc1trZXldKTtcbiAgICAgIGtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgICByZXR1cm4gYCR7dGFyZ2V0VGFibGVBbGlhc30uJHtrZXl9ID0gJHt2YWx1ZX1gO1xuICAgIH0pLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCB1cGRhdGVTbmlwcGV0ID0gZmlsdGVyZWRVcGRhdGVDbGF1c2VzLmxlbmd0aCA+IDAgPyBgV0hFTiBNQVRDSEVEIFRIRU4gVVBEQVRFIFNFVCAke2ZpbHRlcmVkVXBkYXRlQ2xhdXNlc31gIDogXCJcIjtcbiAgICBjb25zdCBpbnNlcnRTbmlwcGV0ID0gYCgke2luc2VydEtleXNRdW90ZWR9KSBWQUxVRVMoJHtpbnNlcnRWYWx1ZXNFc2NhcGVkfSlgO1xuICAgIGxldCBxdWVyeSA9IGBNRVJHRSBJTlRPICR7dGFibGVOYW1lUXVvdGVkfSBBUyAke3RhcmdldFRhYmxlQWxpYXN9IFVTSU5HICgke3NvdXJjZVRhYmxlUXVlcnl9KSBBUyAke3NvdXJjZVRhYmxlQWxpYXN9KCR7aW5zZXJ0S2V5c1F1b3RlZH0pIE9OICR7am9pbkNvbmRpdGlvbn1gO1xuICAgIHF1ZXJ5ICs9IGAgJHt1cGRhdGVTbmlwcGV0fSBXSEVOIE5PVCBNQVRDSEVEIFRIRU4gSU5TRVJUICR7aW5zZXJ0U25pcHBldH07YDtcbiAgICByZXR1cm4gcXVlcnk7XG4gIH1cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgVFJVTkNBVEUgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gSU1NRURJQVRFYDtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdWVyeSA9IFwiREVMRVRFIEZST00gPCU9IHRhYmxlICU+PCU9IHdoZXJlICU+PCU9IGxpbWl0ICU+XCI7XG4gICAgd2hlcmUgPSB0aGlzLmdldFdoZXJlQ29uZGl0aW9ucyh3aGVyZSwgbnVsbCwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGxldCBsaW1pdCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ID4gMCkge1xuICAgICAgbGltaXQgPSBgIE9GRlNFVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KX0gUk9XU2A7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBsaW1pdCArPSBgIEZFVENIIE5FWFQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0gUk9XUyBPTkxZYDtcbiAgICB9XG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0ge1xuICAgICAgbGltaXQsXG4gICAgICB0YWJsZSxcbiAgICAgIHdoZXJlXG4gICAgfTtcbiAgICBpZiAocmVwbGFjZW1lbnRzLndoZXJlKSB7XG4gICAgICByZXBsYWNlbWVudHMud2hlcmUgPSBgIFdIRVJFICR7cmVwbGFjZW1lbnRzLndoZXJlfWA7XG4gICAgfVxuICAgIHJldHVybiBfLnRlbXBsYXRlKHF1ZXJ5LCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKShyZXBsYWNlbWVudHMpO1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgbGV0IHNxbCA9ICdTRUxFQ1QgTkFNRSBBUyBcIm5hbWVcIiwgVEJOQU1FIEFTIFwidGFibGVOYW1lXCIsIFVOSVFVRVJVTEUgQVMgXCJrZXlUeXBlXCIsIENPTE5BTUVTLCBJTkRFWFRZUEUgQVMgXCJ0eXBlXCIgRlJPTSBTWVNJQk0uU1lTSU5ERVhFUyBXSEVSRSBUQk5BTUUgPSA8JT0gdGFibGVOYW1lICU+JztcbiAgICBsZXQgc2NoZW1hID0gdm9pZCAwO1xuICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgIHNjaGVtYSA9IHRhYmxlTmFtZS5zY2hlbWE7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hKSB7XG4gICAgICBzcWwgPSBgJHtzcWx9IEFORCBUQkNSRUFUT1IgPSA8JT0gc2NoZW1hTmFtZSAlPmA7XG4gICAgfVxuICAgIHNxbCA9IGAke3NxbH0gT1JERVIgQlkgTkFNRTtgO1xuICAgIHJldHVybiBfLnRlbXBsYXRlKHNxbCwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGVOYW1lOiB3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKSxcbiAgICAgIHNjaGVtYU5hbWU6IHdyYXBTaW5nbGVRdW90ZShzY2hlbWEpXG4gICAgfSk7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGxldCBzcWwgPSBgU0VMRUNUIENPTlNUTkFNRSBBUyBcImNvbnN0cmFpbnROYW1lXCIsIFRSSU0oVEFCU0NIRU1BKSBBUyBcInNjaGVtYU5hbWVcIiwgVEFCTkFNRSBBUyBcInRhYmxlTmFtZVwiIEZST00gU1lTQ0FULlRBQkNPTlNUIFdIRVJFIFRBQk5BTUUgPSAnJHt0YWJsZU5hbWV9J2A7XG4gICAgaWYgKGNvbnN0cmFpbnROYW1lKSB7XG4gICAgICBzcWwgKz0gYCBBTkQgQ09OU1ROQU1FIExJS0UgJyUke2NvbnN0cmFpbnROYW1lfSUnYDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3NxbH0gT1JERVIgQlkgQ09OU1ROQU1FO2A7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGNvbnN0IHNxbCA9IFwiRFJPUCBJTkRFWCA8JT0gaW5kZXhOYW1lICU+XCI7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICB0YWJsZU5hbWU6IHRoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpLFxuICAgICAgaW5kZXhOYW1lOiB0aGlzLnF1b3RlSWRlbnRpZmllcnMoaW5kZXhOYW1lKVxuICAgIH07XG4gICAgcmV0dXJuIF8udGVtcGxhdGUoc3FsLCB0aGlzLl90ZW1wbGF0ZVNldHRpbmdzKSh2YWx1ZXMpO1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgbGV0IGNoYW5nZU51bGwgPSAxO1xuICAgIGlmIChhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUudmFsdWVzICYmICFhdHRyaWJ1dGUudmFsdWVzKVxuICAgICAgICBhdHRyaWJ1dGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUudmFsdWVzO1xuICAgICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1NxbCgpO1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuZmllbGQpfSBJTigke2F0dHJpYnV0ZS52YWx1ZXMubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5lc2NhcGUodmFsdWUpO1xuICAgICAgfSkuam9pbihcIiwgXCIpfSkpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcGxhdGUgPSBhdHRyaWJ1dGUudHlwZS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09IFwiY2hhbmdlQ29sdW1uXCIgJiYgYXR0cmlidXRlLnR5cGUpIHtcbiAgICAgIHRlbXBsYXRlID0gYERBVEEgVFlQRSAke3RlbXBsYXRlfWA7XG4gICAgfSBlbHNlIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSB8fCBhdHRyaWJ1dGUucHJpbWFyeUtleSA9PT0gdHJ1ZSB8fCBhdHRyaWJ1dGUudW5pcXVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBOT1QgTlVMTFwiO1xuICAgICAgY2hhbmdlTnVsbCA9IDA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgbGV0IGluaXRpYWxWYWx1ZSA9IDE7XG4gICAgICBpZiAoYXR0cmlidXRlLmluaXRpYWxBdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGF0dHJpYnV0ZS5pbml0aWFsQXV0b0luY3JlbWVudDtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlICs9IGAgR0VORVJBVEVEIEJZIERFRkFVTFQgQVMgSURFTlRJVFkoU1RBUlQgV0lUSCAke2luaXRpYWxWYWx1ZX0sIElOQ1JFTUVOVCBCWSAxKWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSAhPT0gXCJURVhUXCIgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZSAmJiBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMpICYmIGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPT09IFwiYWRkQ29sdW1uXCIgJiYgb3B0aW9ucy5mb3JlaWduS2V5KSB7XG4gICAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5mb3JlaWduS2V5KTtcbiAgICAgICAgY29uc3QgZmtOYW1lID0gYCR7b3B0aW9ucy50YWJsZU5hbWV9XyR7YXR0ck5hbWV9X2ZpZHhgO1xuICAgICAgICB0ZW1wbGF0ZSArPSBgLCBDT05TVFJBSU5UICR7ZmtOYW1lfSBGT1JFSUdOIEtFWSAoJHthdHRyTmFtZX0pYDtcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlICs9IGAgUkVGRVJFTkNFUyAke3RoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCl9YDtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpfSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlLm9uVXBkYXRlICYmIGF0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpICE9IFwiQ0FTQ0FERVwiKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgT04gVVBEQVRFICR7YXR0cmlidXRlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSBcImNoYW5nZUNvbHVtblwiICYmIGNoYW5nZU51bGwgPT09IDEgJiYgYXR0cmlidXRlLmFsbG93TnVsbCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZW1wbGF0ZSA9IFt0ZW1wbGF0ZV07XG4gICAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCkge1xuICAgICAgICB0ZW1wbGF0ZS5wdXNoKFwiRFJPUCBOT1QgTlVMTFwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlLnB1c2goXCJOT1QgTlVMTFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50ICYmIHR5cGVvZiBhdHRyaWJ1dGUuY29tbWVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDT01NRU5UICR7YXR0cmlidXRlLmNvbW1lbnR9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9XG4gIGF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge30sIGV4aXN0aW5nQ29uc3RyYWludHMgPSBbXTtcbiAgICBsZXQga2V5LCBhdHRyaWJ1dGU7XG4gICAgZm9yIChrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmIChleGlzdGluZ0NvbnN0cmFpbnRzLmluZGV4T2YoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwudG9TdHJpbmcoKSkgIT09IC0xKSB7XG4gICAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gXCJcIjtcbiAgICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZS51bmlxdWUgJiYgYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5vbkRlbGV0ZSA9IFwiXCI7XG4gICAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdGluZ0NvbnN0cmFpbnRzLnB1c2goYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgJiYgIWF0dHJpYnV0ZS5maWVsZCAmJiB0eXBlb2YgYXR0cmlidXRlID09PSBcIm9iamVjdFwiKVxuICAgICAgICBhdHRyaWJ1dGUuZmllbGQgPSBrZXk7XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImNyZWF0ZVRyaWdnZXJcIik7XG4gIH1cbiAgZHJvcFRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wVHJpZ2dlclwiKTtcbiAgfVxuICByZW5hbWVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwicmVuYW1lVHJpZ2dlclwiKTtcbiAgfVxuICBjcmVhdGVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImNyZWF0ZUZ1bmN0aW9uXCIpO1xuICB9XG4gIGRyb3BGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImRyb3BGdW5jdGlvblwiKTtcbiAgfVxuICByZW5hbWVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZUZ1bmN0aW9uXCIpO1xuICB9XG4gIF9nZXRGb3JlaWduS2V5c1F1ZXJ5U1FMKGNvbmRpdGlvbikge1xuICAgIHJldHVybiBgU0VMRUNUIFIuQ09OU1ROQU1FIEFTIFwiY29uc3RyYWludE5hbWVcIiwgVFJJTShSLlRBQlNDSEVNQSkgQVMgXCJjb25zdHJhaW50U2NoZW1hXCIsIFIuVEFCTkFNRSBBUyBcInRhYmxlTmFtZVwiLCBUUklNKFIuVEFCU0NIRU1BKSBBUyBcInRhYmxlU2NoZW1hXCIsIExJU1RBR0coQy5DT0xOQU1FLCcsICcpIFdJVEhJTiBHUk9VUCAoT1JERVIgQlkgQy5DT0xOQU1FKSBBUyBcImNvbHVtbk5hbWVcIiwgVFJJTShSLlJFRlRBQlNDSEVNQSkgQVMgXCJyZWZlcmVuY2VkVGFibGVTY2hlbWFcIiwgUi5SRUZUQUJOQU1FIEFTIFwicmVmZXJlbmNlZFRhYmxlTmFtZVwiLCBUUklNKFIuUEtfQ09MTkFNRVMpIEFTIFwicmVmZXJlbmNlZENvbHVtbk5hbWVcIiBGUk9NIFNZU0NBVC5SRUZFUkVOQ0VTIFIsIFNZU0NBVC5LRVlDT0xVU0UgQyBXSEVSRSBSLkNPTlNUTkFNRSA9IEMuQ09OU1ROQU1FIEFORCBSLlRBQlNDSEVNQSA9IEMuVEFCU0NIRU1BIEFORCBSLlRBQk5BTUUgPSBDLlRBQk5BTUUke2NvbmRpdGlvbn0gR1JPVVAgQlkgUi5SRUZUQUJTQ0hFTUEsIFIuUkVGVEFCTkFNRSwgUi5UQUJTQ0hFTUEsIFIuVEFCTkFNRSwgUi5DT05TVE5BTUUsIFIuUEtfQ09MTkFNRVNgO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUsIHNjaGVtYU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYSB8fCBzY2hlbWFOYW1lO1xuICAgIGxldCBzcWwgPSBcIlwiO1xuICAgIGlmICh0YWJsZU5hbWUpIHtcbiAgICAgIHNxbCA9IGAgQU5EIFIuVEFCTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSl9YDtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUpIHtcbiAgICAgIHNxbCArPSBgIEFORCBSLlRBQlNDSEVNQSA9ICR7d3JhcFNpbmdsZVF1b3RlKHNjaGVtYU5hbWUpfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nZXRGb3JlaWduS2V5c1F1ZXJ5U1FMKHNxbCk7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlLCBjb2x1bW5OYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWE7XG4gICAgbGV0IHNxbCA9IFwiXCI7XG4gICAgaWYgKHRhYmxlTmFtZSkge1xuICAgICAgc3FsID0gYCBBTkQgUi5UQUJOQU1FID0gJHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX1gO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hTmFtZSkge1xuICAgICAgc3FsICs9IGAgQU5EIFIuVEFCU0NIRU1BID0gJHt3cmFwU2luZ2xlUXVvdGUoc2NoZW1hTmFtZSl9YDtcbiAgICB9XG4gICAgaWYgKGNvbHVtbk5hbWUpIHtcbiAgICAgIHNxbCArPSBgIEFORCBDLkNPTE5BTUUgPSAke3dyYXBTaW5nbGVRdW90ZShjb2x1bW5OYW1lKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0Rm9yZWlnbktleXNRdWVyeVNRTChzcWwpO1xuICB9XG4gIGdldFByaW1hcnlLZXlDb25zdHJhaW50UXVlcnkodGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB3cmFwU2luZ2xlUXVvdGUodGFibGUudGFibGVOYW1lIHx8IHRhYmxlKTtcbiAgICByZXR1cm4gW1xuICAgICAgJ1NFTEVDVCBUQUJOQU1FIEFTIFwidGFibGVOYW1lXCIsJyxcbiAgICAgICdDT0xOQU1FIEFTIFwiY29sdW1uTmFtZVwiLCcsXG4gICAgICAnQ09OU1ROQU1FIEFTIFwiY29uc3RyYWludE5hbWVcIicsXG4gICAgICBcIkZST00gU1lTQ0FULktFWUNPTFVTRSBXSEVSRSBDT05TVE5BTUUgTElLRSAnUEtfJSdcIixcbiAgICAgIGBBTkQgQ09MTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKGF0dHJpYnV0ZU5hbWUpfWAsXG4gICAgICBgQU5EIFRBQk5BTUUgPSAke3RhYmxlTmFtZX07YFxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShcIkFMVEVSIFRBQkxFIDwlPSB0YWJsZSAlPiBEUk9QIDwlPSBrZXkgJT5cIiwgdGhpcy5fdGVtcGxhdGVTZXR0aW5ncykoe1xuICAgICAgdGFibGU6IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAga2V5OiB0aGlzLnF1b3RlSWRlbnRpZmllcihmb3JlaWduS2V5KVxuICAgIH0pO1xuICB9XG4gIGRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIGNvbnN0IHNxbCA9IFwiQUxURVIgVEFCTEUgPCU9IHRhYmxlICU+IERST1AgQ09OU1RSQUlOVCA8JT0gY29uc3RyYWludCAlPjtcIjtcbiAgICByZXR1cm4gXy50ZW1wbGF0ZShzcWwsIHRoaXMuX3RlbXBsYXRlU2V0dGluZ3MpKHtcbiAgICAgIHRhYmxlOiB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGNvbnN0cmFpbnQ6IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbnN0cmFpbnROYW1lKVxuICAgIH0pO1xuICB9XG4gIHNldEF1dG9jb21taXRRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBzZXRJc29sYXRpb25MZXZlbFF1ZXJ5KCkge1xuICB9XG4gIGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoMTApLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG4gIHN0YXJ0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgU0FWRSBUUkFOU0FDVElPTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gXCJCRUdJTiBUUkFOU0FDVElPTjtcIjtcbiAgfVxuICBjb21taXRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gXCJDT01NSVQgVFJBTlNBQ1RJT047XCI7XG4gIH1cbiAgcm9sbGJhY2tUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBST0xMQkFDSyBUUkFOU0FDVElPTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gXCJST0xMQkFDSyBUUkFOU0FDVElPTjtcIjtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcbiAgICBsZXQgZnJhZ21lbnQgPSBcIlwiO1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICBmcmFnbWVudCArPSBgIE9GRlNFVCAke3RoaXMuZXNjYXBlKG9mZnNldCl9IFJPV1NgO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgZnJhZ21lbnQgKz0gYCBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWWA7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxuICBhZGRVbmlxdWVGaWVsZHMoZGF0YVZhbHVlcywgcmF3QXR0cmlidXRlcywgdW5pcW5vKSB7XG4gICAgdW5pcW5vID0gdW5pcW5vID09PSB2b2lkIDAgPyAxIDogdW5pcW5vO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChyYXdBdHRyaWJ1dGVzW2tleV0udW5pcXVlICYmIGRhdGFWYWx1ZXNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChyYXdBdHRyaWJ1dGVzW2tleV0udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5EQVRFKSB7XG4gICAgICAgICAgZGF0YVZhbHVlc1trZXldID0gVXRpbHMubm93KFwiZGIyXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHJhd0F0dHJpYnV0ZXNba2V5XS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlNUUklORykge1xuICAgICAgICAgIGRhdGFWYWx1ZXNba2V5XSA9IGB1bmlxdWUke3VuaXFubysrfWA7XG4gICAgICAgIH0gZWxzZSBpZiAocmF3QXR0cmlidXRlc1trZXldLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSU5URUdFUikge1xuICAgICAgICAgIGRhdGFWYWx1ZXNba2V5XSA9IHVuaXFubysrO1xuICAgICAgICB9IGVsc2UgaWYgKHJhd0F0dHJpYnV0ZXNba2V5XS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkJPT0xFQU4pIHtcbiAgICAgICAgICBkYXRhVmFsdWVzW2tleV0gPSBuZXcgRGF0YVR5cGVzLkJPT0xFQU4oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmlxbm87XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsICdcIicpLCAnXCInKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JhcFNpbmdsZVF1b3RlKGlkZW50aWZpZXIpIHtcbiAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gYCcke2lkZW50aWZpZXJ9J2A7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IERiMlF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/query-interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/query-interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    indexes = _.map(model.uniqueKeys, (value) => {\n      return value.fields;\n    });\n    model._indexes.forEach((value) => {\n      if (value.unique) {\n        indexFields = value.fields.map((field) => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, (uniqueKey) => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, (attribute) => this.sequelize.normalizeAttribute(attribute));\n    if (options.indexes) {\n      options.indexes.forEach((fields) => {\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach((field) => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach((fields) => {\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach((field) => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: \"createTable\", withoutForeignKeyConstraints: options.withoutForeignKeyConstraints });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.Db2QueryInterface = Db2QueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMsV0FBVyxtQkFBTyxDQUFDLHdFQUFpQjtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QztBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUVBQW1FLDhHQUE4RztBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvZGIyL3F1ZXJ5LWludGVyZmFjZS5qcz8xYzhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jbGFzcyBEYjJRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgdHlwZTogUXVlcnlUeXBlcy5GT1JFSUdOS0VZU1xuICAgIH0pO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgdGhpcy5zZXF1ZWxpemUuY29uZmlnLnVzZXJuYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgcXVlcnlPcHRpb25zKTtcbiAgfVxuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCB3aGVyZXMgPSBbXTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5zZXJ0VmFsdWVzKTtcbiAgICBsZXQgaW5kZXhlcyA9IFtdO1xuICAgIGxldCBpbmRleEZpZWxkcztcbiAgICBvcHRpb25zID0gXy5jbG9uZShvcHRpb25zKTtcbiAgICBpZiAoIVV0aWxzLmlzV2hlcmVFbXB0eSh3aGVyZSkpIHtcbiAgICAgIHdoZXJlcy5wdXNoKHdoZXJlKTtcbiAgICB9XG4gICAgaW5kZXhlcyA9IF8ubWFwKG1vZGVsLnVuaXF1ZUtleXMsICh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlLmZpZWxkcztcbiAgICB9KTtcbiAgICBtb2RlbC5faW5kZXhlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlLnVuaXF1ZSkge1xuICAgICAgICBpbmRleEZpZWxkcyA9IHZhbHVlLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB7XG4gICAgICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChmaWVsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZC5hdHRyaWJ1dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaWVsZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ZXMucHVzaChpbmRleEZpZWxkcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICBpZiAoXy5pbnRlcnNlY3Rpb24oYXR0cmlidXRlcywgaW5kZXgpLmxlbmd0aCA9PT0gaW5kZXgubGVuZ3RoKSB7XG4gICAgICAgIHdoZXJlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgaW5kZXgpIHtcbiAgICAgICAgICB3aGVyZVtmaWVsZF0gPSBpbnNlcnRWYWx1ZXNbZmllbGRdO1xuICAgICAgICB9XG4gICAgICAgIHdoZXJlcy5wdXNoKHdoZXJlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hlcmUgPSB7IFtPcC5vcl06IHdoZXJlcyB9O1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gW3Jlc3VsdCwgdm9pZCAwXTtcbiAgfVxuICBhc3luYyBjcmVhdGVUYWJsZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIG1vZGVsKSB7XG4gICAgbGV0IHNxbCA9IFwiXCI7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZm9yT3duKG9wdGlvbnMudW5pcXVlS2V5cywgKHVuaXF1ZUtleSkgPT4ge1xuICAgICAgICBpZiAodW5pcXVlS2V5LmN1c3RvbUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB1bmlxdWVLZXkuY3VzdG9tSW5kZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBvcHRpb25zLnVuaXF1ZUtleXMgPSBvcHRpb25zLnVuaXF1ZUtleXMgfHwgbW9kZWwudW5pcXVlS2V5cztcbiAgICB9XG4gICAgYXR0cmlidXRlcyA9IF8ubWFwVmFsdWVzKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUpID0+IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbiAgICBpZiAob3B0aW9ucy5pbmRleGVzKSB7XG4gICAgICBvcHRpb25zLmluZGV4ZXMuZm9yRWFjaCgoZmllbGRzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkQXJyID0gZmllbGRzLmZpZWxkcztcbiAgICAgICAgaWYgKGZpZWxkQXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGZpZWxkQXJyLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSBhdHRyaWJ1dGVzW3Byb3BlcnR5XS5maWVsZCkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbcHJvcGVydHldLnVuaXF1ZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmFsdGVyKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRleGVzKSB7XG4gICAgICAgIG9wdGlvbnMuaW5kZXhlcy5mb3JFYWNoKChmaWVsZHMpID0+IHtcbiAgICAgICAgICBjb25zdCBmaWVsZEFyciA9IGZpZWxkcy5maWVsZHM7XG4gICAgICAgICAgaWYgKGZpZWxkQXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZmllbGRBcnIuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSBhdHRyaWJ1dGVzW3Byb3BlcnR5XS5maWVsZCAmJiBhdHRyaWJ1dGVzW3Byb3BlcnR5XS51bmlxdWUpIHtcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbcHJvcGVydHldLnVuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YWJsZU5hbWUuc2NoZW1hICYmIChvcHRpb25zLnNjaGVtYSB8fCAhIW1vZGVsICYmIG1vZGVsLl9zY2hlbWEpKSB7XG4gICAgICB0YWJsZU5hbWUgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmFkZFNjaGVtYSh7XG4gICAgICAgIHRhYmxlTmFtZSxcbiAgICAgICAgX3NjaGVtYTogISFtb2RlbCAmJiBtb2RlbC5fc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hXG4gICAgICB9KTtcbiAgICB9XG4gICAgYXR0cmlidXRlcyA9IHRoaXMucXVlcnlHZW5lcmF0b3IuYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIHsgdGFibGU6IHRhYmxlTmFtZSwgY29udGV4dDogXCJjcmVhdGVUYWJsZVwiLCB3aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzOiBvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMgfSk7XG4gICAgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgb3B0aW9ucyk7XG4gIH1cbn1cbmV4cG9ydHMuRGIyUXVlcnlJbnRlcmZhY2UgPSBEYjJRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/db2/query.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/db2/query.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst util = __webpack_require__(/*! util */ \"util\");\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"db2\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst debug = logger.debugContext(\"sql:db2\");\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value) {\n    if (Buffer.isBuffer(value)) {\n      return { ParamType: \"INPUT\", DataType: \"BLOB\", Data: value };\n    }\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  }\n  async _run(connection, sql, parameters) {\n    this.sql = sql;\n    const benchmark = this.sequelize.options.benchmark || this.options.benchmark;\n    let queryBegin;\n    if (benchmark) {\n      queryBegin = Date.now();\n    } else {\n      this.sequelize.log(`Executing (${this.connection.uuid || \"default\"}): ${this.sql}`, this.options);\n    }\n    const errStack = new Error().stack;\n    return new Promise((resolve, reject) => {\n      if (_.startsWith(this.sql, \"BEGIN TRANSACTION\")) {\n        connection.beginTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"COMMIT TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"ROLLBACK TRANSACTION\")) {\n        connection.rollbackTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            resolve(this.formatResults());\n          }\n        });\n      } else if (_.startsWith(this.sql, \"SAVE TRANSACTION\")) {\n        connection.commitTransaction((err) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          } else {\n            connection.beginTransaction((err2) => {\n              if (err2) {\n                reject(this.formatError(err2, errStack));\n              } else {\n                resolve(this.formatResults());\n              }\n            });\n          }\n        }, this.options.transaction.name);\n      } else {\n        const params = [];\n        if (parameters) {\n          _.forOwn(parameters, (value, key) => {\n            const param = this.getSQLTypeFromJsType(value, key);\n            params.push(param);\n          });\n        }\n        const SQL = this.sql.toUpperCase();\n        let newSql = this.sql;\n        if ((this.isSelectQuery() || _.startsWith(SQL, \"SELECT \")) && SQL.indexOf(\" FROM \", 8) === -1) {\n          if (this.sql.charAt(this.sql.length - 1) === \";\") {\n            newSql = this.sql.slice(0, this.sql.length - 1);\n          }\n          newSql += \" FROM SYSIBM.SYSDUMMY1;\";\n        }\n        connection.prepare(newSql, (err, stmt) => {\n          if (err) {\n            reject(this.formatError(err, errStack));\n          }\n          stmt.execute(params, (err2, result, outparams) => {\n            debug(`executed(${this.connection.uuid || \"default\"}):${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : \"\"}`);\n            if (benchmark) {\n              this.sequelize.log(`Executed (${this.connection.uuid || \"default\"}): ${newSql} ${parameters ? util.inspect(parameters, { compact: true, breakLength: Infinity }) : \"\"}`, Date.now() - queryBegin, this.options);\n            }\n            if (err2 && err2.message) {\n              err2 = this.filterSQLError(err2, this.sql, connection);\n              if (err2 === null) {\n                stmt.closeSync();\n                resolve(this.formatResults([], 0));\n              }\n            }\n            if (err2) {\n              err2.sql = sql;\n              stmt.closeSync();\n              reject(this.formatError(err2, errStack, connection, parameters));\n            } else {\n              let data = [];\n              let metadata = [];\n              let affectedRows = 0;\n              if (typeof result === \"object\") {\n                if (_.startsWith(this.sql, \"DELETE FROM \")) {\n                  affectedRows = result.getAffectedRowsSync();\n                } else {\n                  data = result.fetchAllSync();\n                  metadata = result.getColumnMetadataSync();\n                }\n                result.closeSync();\n              }\n              stmt.closeSync();\n              const datalen = data.length;\n              if (datalen > 0) {\n                const coltypes = {};\n                for (let i = 0; i < metadata.length; i++) {\n                  coltypes[metadata[i].SQL_DESC_NAME] = metadata[i].SQL_DESC_TYPE_NAME;\n                }\n                for (let i = 0; i < datalen; i++) {\n                  for (const column in data[i]) {\n                    const parse = parserStore.get(coltypes[column]);\n                    const value = data[i][column];\n                    if (value !== null) {\n                      if (parse) {\n                        data[i][column] = parse(value);\n                      } else if (coltypes[column] === \"TIMESTAMP\") {\n                        data[i][column] = new Date(moment.utc(value));\n                      } else if (coltypes[column] === \"BLOB\") {\n                        data[i][column] = new Buffer.from(value);\n                      } else if (coltypes[column].indexOf(\"FOR BIT DATA\") > 0) {\n                        data[i][column] = new Buffer.from(value, \"hex\");\n                      }\n                    }\n                  }\n                }\n                if (outparams && outparams.length) {\n                  data.unshift(outparams);\n                }\n                resolve(this.formatResults(data, datalen, metadata, connection));\n              } else {\n                resolve(this.formatResults(data, affectedRows));\n              }\n            }\n          });\n        });\n      }\n    });\n  }\n  async run(sql, parameters) {\n    return await this._run(this.connection, sql, parameters);\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    if (Array.isArray(values) && typeof values[0] === \"object\") {\n      bindParam = values;\n    }\n    return [sql, bindParam];\n  }\n  filterSQLError(err, sql, connection) {\n    if (err.message.search(\"SQL0204N\") != -1 && _.startsWith(sql, \"DROP \")) {\n      err = null;\n    } else if (err.message.search(\"SQL0443N\") != -1) {\n      if (this.isDropSchemaQuery()) {\n        connection.querySync(\"DROP TABLE ERRORSCHEMA.ERRORTABLE;\");\n        connection.querySync(this.sql);\n      }\n      err = null;\n    } else if (err.message.search(\"SQL0601N\") != -1) {\n      const match = err.message.match(/SQL0601N {2}The name of the object to be created is identical to the existing name \"(.*)\" of type \"(.*)\"./);\n      if (match && match.length > 1 && match[2] === \"TABLE\") {\n        let table;\n        const mtarray = match[1].split(\".\");\n        if (mtarray[1]) {\n          table = `\"${mtarray[0]}\".\"${mtarray[1]}\"`;\n        } else {\n          table = `\"${mtarray[0]}\"`;\n        }\n        if (connection.dropTable !== false) {\n          connection.querySync(`DROP TABLE ${table}`);\n          err = connection.querySync(sql);\n        } else {\n          err = null;\n        }\n      } else {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0911N\") != -1) {\n      if (err.message.search('Reason code \"2\"') != -1) {\n        err = null;\n      }\n    } else if (err.message.search(\"SQL0605W\") != -1) {\n      err = null;\n    } else if (err.message.search(\"SQL0668N\") != -1 && _.startsWith(sql, \"ALTER TABLE \")) {\n      connection.querySync(`CALL SYSPROC.ADMIN_CMD('REORG TABLE ${sql.substring(12).split(\" \")[0]}')`);\n      err = connection.querySync(sql);\n    }\n    if (err && err.length === 0) {\n      err = null;\n    }\n    return err;\n  }\n  formatResults(data, rowCount, metadata, conn) {\n    let result = this.instance;\n    if (this.isInsertQuery(data, metadata)) {\n      this.handleInsertQuery(data, metadata);\n      if (!this.instance) {\n        if (this.options.plain) {\n          const record = data[0];\n          result = record[Object.keys(record)[0]];\n        } else {\n          result = data;\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      result = data;\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"Y\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.KeySeq > 0,\n          autoIncrement: _result.IsIdentity === \"Y\" ? true : false,\n          comment: _result.Comment\n        };\n      }\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data);\n    } else if (this.isSelectQuery()) {\n      result = this.handleSelectQuery(data);\n    } else if (this.isUpsertQuery()) {\n      result = data;\n    } else if (this.isDropSchemaQuery()) {\n      result = data[0];\n      if (conn) {\n        const query = \"DROP TABLE ERRORSCHEMA.ERRORTABLE\";\n        conn.querySync(query);\n      }\n    } else if (this.isCallQuery()) {\n      result = data;\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.length;\n    } else if (this.isBulkDeleteQuery()) {\n      result = rowCount;\n    } else if (this.isVersionQuery()) {\n      result = data[0].VERSION;\n    } else if (this.isForeignKeysQuery()) {\n      result = data;\n    } else if (this.isInsertQuery() || this.isUpdateQuery()) {\n      result = [result, rowCount];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      result = [data, metadata];\n    } else {\n      result = data;\n    }\n    return result;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return _.remove(data, (constraint) => {\n      return !_.startsWith(constraint.constraintName, \"SQL\");\n    });\n  }\n  formatError(err, errStack, conn, parameters) {\n    let match;\n    if (!(err && err.message)) {\n      err[\"message\"] = \"No error message found.\";\n    }\n    match = err.message.match(/SQL0803N {2}One or more values in the INSERT statement, UPDATE statement, or foreign key update caused by a DELETE statement are not valid because the primary key, unique constraint or unique index identified by \"(\\d)+\" constrains table \"(.*)\\.(.*)\" from having duplicate values for the index key./);\n    if (match && match.length > 0) {\n      let uniqueIndexName = \"\";\n      let uniqueKey = \"\";\n      const fields = {};\n      let message = err.message;\n      const query = `SELECT INDNAME FROM SYSCAT.INDEXES  WHERE IID = ${match[1]} AND TABSCHEMA = '${match[2]}' AND TABNAME = '${match[3]}'`;\n      if (!!conn && match.length > 3) {\n        uniqueIndexName = conn.querySync(query);\n        uniqueIndexName = uniqueIndexName[0][\"INDNAME\"];\n      }\n      if (this.model && !!uniqueIndexName) {\n        uniqueKey = this.model.uniqueKeys[uniqueIndexName];\n      }\n      if (!uniqueKey && this.options.fields) {\n        uniqueKey = this.options.fields[match[1] - 1];\n      }\n      if (uniqueKey) {\n        if (this.options.where && this.options.where[uniqueKey.column] !== void 0) {\n          fields[uniqueKey.column] = this.options.where[uniqueKey.column];\n        } else if (this.options.instance && this.options.instance.dataValues && this.options.instance.dataValues[uniqueKey.column]) {\n          fields[uniqueKey.column] = this.options.instance.dataValues[uniqueKey.column];\n        } else if (parameters) {\n          fields[uniqueKey.column] = parameters[\"0\"];\n        }\n      }\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/SQL0532N {2}A parent row cannot be deleted because the relationship \"(.*)\" restricts the deletion/) || err.message.match(/SQL0530N/) || err.message.match(/SQL0531N/);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/SQL0204N {2}\"(.*)\" is an undefined name./);\n    if (match && match.length > 1) {\n      const constraint = match[1];\n      let table = err.sql.match(/table \"(.+?)\"/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[0],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isDropSchemaQuery() {\n    let result = false;\n    if (_.startsWith(this.sql, \"CALL SYSPROC.ADMIN_DROP_SCHEMA\")) {\n      result = true;\n    }\n    return result;\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    result = result || this.sql.startsWith('SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES');\n    return result;\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.keyType === \"P\",\n          fields: [],\n          name: item.name,\n          tableName: item.tableName,\n          unique: item.keyType === \"U\",\n          type: item.type\n        };\n        _.forEach(item.COLNAMES.replace(/\\+|-/g, (x) => {\n          return ` ${x}`;\n        }).split(\" \"), (column) => {\n          let columnName = column.trim();\n          if (columnName) {\n            columnName = columnName.replace(/\\+|-/, \"\");\n            currItem.fields.push({\n              attribute: columnName,\n              length: void 0,\n              order: column.indexOf(\"-\") === -1 ? \"ASC\" : \"DESC\",\n              collate: void 0\n            });\n          }\n        });\n        result.push(currItem);\n      }\n    });\n    return result;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM1QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix1Q0FBdUMsa0NBQWtDLEtBQUssU0FBUztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0MsSUFBSSxRQUFRLEVBQUUsd0NBQXdDLHNDQUFzQyxPQUFPO0FBQ25LO0FBQ0EsOENBQThDLGtDQUFrQyxLQUFLLFFBQVEsRUFBRSx3Q0FBd0Msc0NBQXNDLE9BQU87QUFDcEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVcsS0FBSyxXQUFXO0FBQ2pELFVBQVU7QUFDVixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixrRUFBa0UsZ0NBQWdDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsVUFBVSxtQkFBbUIsU0FBUyxtQkFBbUIsU0FBUztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEVBQUU7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9kYjIvcXVlcnkuanM/Y2UwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJkYjJcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcInNxbDpkYjJcIik7XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiBcImlkXCI7XG4gIH1cbiAgZ2V0U1FMVHlwZUZyb21Kc1R5cGUodmFsdWUpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgUGFyYW1UeXBlOiBcIklOUFVUXCIsIERhdGFUeXBlOiBcIkJMT0JcIiwgRGF0YTogdmFsdWUgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBhc3luYyBfcnVuKGNvbm5lY3Rpb24sIHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IGJlbmNobWFyayA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuYmVuY2htYXJrIHx8IHRoaXMub3B0aW9ucy5iZW5jaG1hcms7XG4gICAgbGV0IHF1ZXJ5QmVnaW47XG4gICAgaWYgKGJlbmNobWFyaykge1xuICAgICAgcXVlcnlCZWdpbiA9IERhdGUubm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLmxvZyhgRXhlY3V0aW5nICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6ICR7dGhpcy5zcWx9YCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZXJyU3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKF8uc3RhcnRzV2l0aCh0aGlzLnNxbCwgXCJCRUdJTiBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICBjb25uZWN0aW9uLmJlZ2luVHJhbnNhY3Rpb24oKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXy5zdGFydHNXaXRoKHRoaXMuc3FsLCBcIkNPTU1JVCBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICBjb25uZWN0aW9uLmNvbW1pdFRyYW5zYWN0aW9uKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKF8uc3RhcnRzV2l0aCh0aGlzLnNxbCwgXCJST0xMQkFDSyBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICBjb25uZWN0aW9uLnJvbGxiYWNrVHJhbnNhY3Rpb24oKGVycikgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdCh0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmZvcm1hdFJlc3VsdHMoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXy5zdGFydHNXaXRoKHRoaXMuc3FsLCBcIlNBVkUgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgY29ubmVjdGlvbi5jb21taXRUcmFuc2FjdGlvbigoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmJlZ2luVHJhbnNhY3Rpb24oKGVycjIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycjIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIyLCBlcnJTdGFjaykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgICAgIF8uZm9yT3duKHBhcmFtZXRlcnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbSA9IHRoaXMuZ2V0U1FMVHlwZUZyb21Kc1R5cGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgU1FMID0gdGhpcy5zcWwudG9VcHBlckNhc2UoKTtcbiAgICAgICAgbGV0IG5ld1NxbCA9IHRoaXMuc3FsO1xuICAgICAgICBpZiAoKHRoaXMuaXNTZWxlY3RRdWVyeSgpIHx8IF8uc3RhcnRzV2l0aChTUUwsIFwiU0VMRUNUIFwiKSkgJiYgU1FMLmluZGV4T2YoXCIgRlJPTSBcIiwgOCkgPT09IC0xKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3FsLmNoYXJBdCh0aGlzLnNxbC5sZW5ndGggLSAxKSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgIG5ld1NxbCA9IHRoaXMuc3FsLnNsaWNlKDAsIHRoaXMuc3FsLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdTcWwgKz0gXCIgRlJPTSBTWVNJQk0uU1lTRFVNTVkxO1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24ucHJlcGFyZShuZXdTcWwsIChlcnIsIHN0bXQpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QodGhpcy5mb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0bXQuZXhlY3V0ZShwYXJhbXMsIChlcnIyLCByZXN1bHQsIG91dHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgZGVidWcoYGV4ZWN1dGVkKCR7dGhpcy5jb25uZWN0aW9uLnV1aWQgfHwgXCJkZWZhdWx0XCJ9KToke25ld1NxbH0gJHtwYXJhbWV0ZXJzID8gdXRpbC5pbnNwZWN0KHBhcmFtZXRlcnMsIHsgY29tcGFjdDogdHJ1ZSwgYnJlYWtMZW5ndGg6IEluZmluaXR5IH0pIDogXCJcIn1gKTtcbiAgICAgICAgICAgIGlmIChiZW5jaG1hcmspIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUubG9nKGBFeGVjdXRlZCAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiAke25ld1NxbH0gJHtwYXJhbWV0ZXJzID8gdXRpbC5pbnNwZWN0KHBhcmFtZXRlcnMsIHsgY29tcGFjdDogdHJ1ZSwgYnJlYWtMZW5ndGg6IEluZmluaXR5IH0pIDogXCJcIn1gLCBEYXRlLm5vdygpIC0gcXVlcnlCZWdpbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIyICYmIGVycjIubWVzc2FnZSkge1xuICAgICAgICAgICAgICBlcnIyID0gdGhpcy5maWx0ZXJTUUxFcnJvcihlcnIyLCB0aGlzLnNxbCwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgIGlmIChlcnIyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RtdC5jbG9zZVN5bmMoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cyhbXSwgMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyMikge1xuICAgICAgICAgICAgICBlcnIyLnNxbCA9IHNxbDtcbiAgICAgICAgICAgICAgc3RtdC5jbG9zZVN5bmMoKTtcbiAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuZm9ybWF0RXJyb3IoZXJyMiwgZXJyU3RhY2ssIGNvbm5lY3Rpb24sIHBhcmFtZXRlcnMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxldCBkYXRhID0gW107XG4gICAgICAgICAgICAgIGxldCBtZXRhZGF0YSA9IFtdO1xuICAgICAgICAgICAgICBsZXQgYWZmZWN0ZWRSb3dzID0gMDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXy5zdGFydHNXaXRoKHRoaXMuc3FsLCBcIkRFTEVURSBGUk9NIFwiKSkge1xuICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRSb3dzID0gcmVzdWx0LmdldEFmZmVjdGVkUm93c1N5bmMoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3VsdC5mZXRjaEFsbFN5bmMoKTtcbiAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcmVzdWx0LmdldENvbHVtbk1ldGFkYXRhU3luYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQuY2xvc2VTeW5jKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RtdC5jbG9zZVN5bmMoKTtcbiAgICAgICAgICAgICAgY29uc3QgZGF0YWxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoZGF0YWxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x0eXBlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIGNvbHR5cGVzW21ldGFkYXRhW2ldLlNRTF9ERVNDX05BTUVdID0gbWV0YWRhdGFbaV0uU1FMX0RFU0NfVFlQRV9OQU1FO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gaW4gZGF0YVtpXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZSA9IHBhcnNlclN0b3JlLmdldChjb2x0eXBlc1tjb2x1bW5dKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkYXRhW2ldW2NvbHVtbl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtjb2x1bW5dID0gcGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdHlwZXNbY29sdW1uXSA9PT0gXCJUSU1FU1RBTVBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXVtjb2x1bW5dID0gbmV3IERhdGUobW9tZW50LnV0Yyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sdHlwZXNbY29sdW1uXSA9PT0gXCJCTE9CXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bY29sdW1uXSA9IG5ldyBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2x0eXBlc1tjb2x1bW5dLmluZGV4T2YoXCJGT1IgQklUIERBVEFcIikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW2NvbHVtbl0gPSBuZXcgQnVmZmVyLmZyb20odmFsdWUsIFwiaGV4XCIpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3V0cGFyYW1zICYmIG91dHBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEudW5zaGlmdChvdXRwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZm9ybWF0UmVzdWx0cyhkYXRhLCBkYXRhbGVuLCBtZXRhZGF0YSwgY29ubmVjdGlvbikpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5mb3JtYXRSZXN1bHRzKGRhdGEsIGFmZmVjdGVkUm93cykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fcnVuKHRoaXMuY29ubmVjdGlvbiwgc3FsLCBwYXJhbWV0ZXJzKTtcbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBsZXQgYmluZFBhcmFtID0ge307XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIpID0+IHtcbiAgICAgIGlmICh2YWx1ZXMyW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBiaW5kUGFyYW1ba2V5XSA9IHZhbHVlczJba2V5XTtcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSAmJiB0eXBlb2YgdmFsdWVzWzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBiaW5kUGFyYW0gPSB2YWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW1dO1xuICB9XG4gIGZpbHRlclNRTEVycm9yKGVyciwgc3FsLCBjb25uZWN0aW9uKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLnNlYXJjaChcIlNRTDAyMDROXCIpICE9IC0xICYmIF8uc3RhcnRzV2l0aChzcWwsIFwiRFJPUCBcIikpIHtcbiAgICAgIGVyciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5zZWFyY2goXCJTUUwwNDQzTlwiKSAhPSAtMSkge1xuICAgICAgaWYgKHRoaXMuaXNEcm9wU2NoZW1hUXVlcnkoKSkge1xuICAgICAgICBjb25uZWN0aW9uLnF1ZXJ5U3luYyhcIkRST1AgVEFCTEUgRVJST1JTQ0hFTUEuRVJST1JUQUJMRTtcIik7XG4gICAgICAgIGNvbm5lY3Rpb24ucXVlcnlTeW5jKHRoaXMuc3FsKTtcbiAgICAgIH1cbiAgICAgIGVyciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5zZWFyY2goXCJTUUwwNjAxTlwiKSAhPSAtMSkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvU1FMMDYwMU4gezJ9VGhlIG5hbWUgb2YgdGhlIG9iamVjdCB0byBiZSBjcmVhdGVkIGlzIGlkZW50aWNhbCB0byB0aGUgZXhpc3RpbmcgbmFtZSBcIiguKilcIiBvZiB0eXBlIFwiKC4qKVwiLi8pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2hbMl0gPT09IFwiVEFCTEVcIikge1xuICAgICAgICBsZXQgdGFibGU7XG4gICAgICAgIGNvbnN0IG10YXJyYXkgPSBtYXRjaFsxXS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChtdGFycmF5WzFdKSB7XG4gICAgICAgICAgdGFibGUgPSBgXCIke210YXJyYXlbMF19XCIuXCIke210YXJyYXlbMV19XCJgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlID0gYFwiJHttdGFycmF5WzBdfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5kcm9wVGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY29ubmVjdGlvbi5xdWVyeVN5bmMoYERST1AgVEFCTEUgJHt0YWJsZX1gKTtcbiAgICAgICAgICBlcnIgPSBjb25uZWN0aW9uLnF1ZXJ5U3luYyhzcWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVyciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5zZWFyY2goXCJTUUwwOTExTlwiKSAhPSAtMSkge1xuICAgICAgaWYgKGVyci5tZXNzYWdlLnNlYXJjaCgnUmVhc29uIGNvZGUgXCIyXCInKSAhPSAtMSkge1xuICAgICAgICBlcnIgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2Uuc2VhcmNoKFwiU1FMMDYwNVdcIikgIT0gLTEpIHtcbiAgICAgIGVyciA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChlcnIubWVzc2FnZS5zZWFyY2goXCJTUUwwNjY4TlwiKSAhPSAtMSAmJiBfLnN0YXJ0c1dpdGgoc3FsLCBcIkFMVEVSIFRBQkxFIFwiKSkge1xuICAgICAgY29ubmVjdGlvbi5xdWVyeVN5bmMoYENBTEwgU1lTUFJPQy5BRE1JTl9DTUQoJ1JFT1JHIFRBQkxFICR7c3FsLnN1YnN0cmluZygxMikuc3BsaXQoXCIgXCIpWzBdfScpYCk7XG4gICAgICBlcnIgPSBjb25uZWN0aW9uLnF1ZXJ5U3luYyhzcWwpO1xuICAgIH1cbiAgICBpZiAoZXJyICYmIGVyci5sZW5ndGggPT09IDApIHtcbiAgICAgIGVyciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlcnI7XG4gIH1cbiAgZm9ybWF0UmVzdWx0cyhkYXRhLCByb3dDb3VudCwgbWV0YWRhdGEsIGNvbm4pIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEsIG1ldGFkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhLCBtZXRhZGF0YSk7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wbGFpbikge1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IGRhdGFbMF07XG4gICAgICAgICAgcmVzdWx0ID0gcmVjb3JkW09iamVjdC5rZXlzKHJlY29yZClbMF1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgaWYgKF9yZXN1bHQuRGVmYXVsdCkge1xuICAgICAgICAgIF9yZXN1bHQuRGVmYXVsdCA9IF9yZXN1bHQuRGVmYXVsdC5yZXBsYWNlKFwiKCdcIiwgXCJcIikucmVwbGFjZShcIicpXCIsIFwiXCIpLnJlcGxhY2UoLycvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0LklzTnVsbCA9PT0gXCJZXCIgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBfcmVzdWx0LkRlZmF1bHQsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5LZXlTZXEgPiAwLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IF9yZXN1bHQuSXNJZGVudGl0eSA9PT0gXCJZXCIgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0Ryb3BTY2hlbWFRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhWzBdO1xuICAgICAgaWYgKGNvbm4pIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBcIkRST1AgVEFCTEUgRVJST1JTQ0hFTUEuRVJST1JUQUJMRVwiO1xuICAgICAgICBjb25uLnF1ZXJ5U3luYyhxdWVyeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2FsbFF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGE7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGEubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSByb3dDb3VudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YVswXS5WRVJTSU9OO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBbcmVzdWx0LCByb3dDb3VudF07XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBbZGF0YSwgbWV0YWRhdGFdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhbmRsZVNob3dUYWJsZXNRdWVyeShyZXN1bHRzKSB7XG4gICAgcmV0dXJuIHJlc3VsdHMubWFwKChyZXN1bHRTZXQpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhYmxlTmFtZTogcmVzdWx0U2V0LlRBQkxFX05BTUUsXG4gICAgICAgIHNjaGVtYTogcmVzdWx0U2V0LlRBQkxFX1NDSEVNQVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVTaG93Q29uc3RyYWludHNRdWVyeShkYXRhKSB7XG4gICAgcmV0dXJuIF8ucmVtb3ZlKGRhdGEsIChjb25zdHJhaW50KSA9PiB7XG4gICAgICByZXR1cm4gIV8uc3RhcnRzV2l0aChjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lLCBcIlNRTFwiKTtcbiAgICB9KTtcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrLCBjb25uLCBwYXJhbWV0ZXJzKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGlmICghKGVyciAmJiBlcnIubWVzc2FnZSkpIHtcbiAgICAgIGVycltcIm1lc3NhZ2VcIl0gPSBcIk5vIGVycm9yIG1lc3NhZ2UgZm91bmQuXCI7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1NRTDA4MDNOIHsyfU9uZSBvciBtb3JlIHZhbHVlcyBpbiB0aGUgSU5TRVJUIHN0YXRlbWVudCwgVVBEQVRFIHN0YXRlbWVudCwgb3IgZm9yZWlnbiBrZXkgdXBkYXRlIGNhdXNlZCBieSBhIERFTEVURSBzdGF0ZW1lbnQgYXJlIG5vdCB2YWxpZCBiZWNhdXNlIHRoZSBwcmltYXJ5IGtleSwgdW5pcXVlIGNvbnN0cmFpbnQgb3IgdW5pcXVlIGluZGV4IGlkZW50aWZpZWQgYnkgXCIoXFxkKStcIiBjb25zdHJhaW5zIHRhYmxlIFwiKC4qKVxcLiguKilcIiBmcm9tIGhhdmluZyBkdXBsaWNhdGUgdmFsdWVzIGZvciB0aGUgaW5kZXgga2V5Li8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgdW5pcXVlSW5kZXhOYW1lID0gXCJcIjtcbiAgICAgIGxldCB1bmlxdWVLZXkgPSBcIlwiO1xuICAgICAgY29uc3QgZmllbGRzID0ge307XG4gICAgICBsZXQgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgICAgY29uc3QgcXVlcnkgPSBgU0VMRUNUIElORE5BTUUgRlJPTSBTWVNDQVQuSU5ERVhFUyAgV0hFUkUgSUlEID0gJHttYXRjaFsxXX0gQU5EIFRBQlNDSEVNQSA9ICcke21hdGNoWzJdfScgQU5EIFRBQk5BTUUgPSAnJHttYXRjaFszXX0nYDtcbiAgICAgIGlmICghIWNvbm4gJiYgbWF0Y2gubGVuZ3RoID4gMykge1xuICAgICAgICB1bmlxdWVJbmRleE5hbWUgPSBjb25uLnF1ZXJ5U3luYyhxdWVyeSk7XG4gICAgICAgIHVuaXF1ZUluZGV4TmFtZSA9IHVuaXF1ZUluZGV4TmFtZVswXVtcIklORE5BTUVcIl07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tb2RlbCAmJiAhIXVuaXF1ZUluZGV4TmFtZSkge1xuICAgICAgICB1bmlxdWVLZXkgPSB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbdW5pcXVlSW5kZXhOYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmICghdW5pcXVlS2V5ICYmIHRoaXMub3B0aW9ucy5maWVsZHMpIHtcbiAgICAgICAgdW5pcXVlS2V5ID0gdGhpcy5vcHRpb25zLmZpZWxkc1ttYXRjaFsxXSAtIDFdO1xuICAgICAgfVxuICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLndoZXJlICYmIHRoaXMub3B0aW9ucy53aGVyZVt1bmlxdWVLZXkuY29sdW1uXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgZmllbGRzW3VuaXF1ZUtleS5jb2x1bW5dID0gdGhpcy5vcHRpb25zLndoZXJlW3VuaXF1ZUtleS5jb2x1bW5dO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5pbnN0YW5jZSAmJiB0aGlzLm9wdGlvbnMuaW5zdGFuY2UuZGF0YVZhbHVlcyAmJiB0aGlzLm9wdGlvbnMuaW5zdGFuY2UuZGF0YVZhbHVlc1t1bmlxdWVLZXkuY29sdW1uXSkge1xuICAgICAgICAgIGZpZWxkc1t1bmlxdWVLZXkuY29sdW1uXSA9IHRoaXMub3B0aW9ucy5pbnN0YW5jZS5kYXRhVmFsdWVzW3VuaXF1ZUtleS5jb2x1bW5dO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBmaWVsZHNbdW5pcXVlS2V5LmNvbHVtbl0gPSBwYXJhbWV0ZXJzW1wiMFwiXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVuaXF1ZUtleSAmJiAhIXVuaXF1ZUtleS5tc2cpIHtcbiAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5pbnN0YW5jZSwgXCJub3RfdW5pcXVlXCIpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzLCBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgfVxuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL1NRTDA1MzJOIHsyfUEgcGFyZW50IHJvdyBjYW5ub3QgYmUgZGVsZXRlZCBiZWNhdXNlIHRoZSByZWxhdGlvbnNoaXAgXCIoLiopXCIgcmVzdHJpY3RzIHRoZSBkZWxldGlvbi8pIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9TUUwwNTMwTi8pIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9TUUwwNTMxTi8pO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgZmllbGRzOiBudWxsLFxuICAgICAgICBpbmRleDogbWF0Y2hbMV0sXG4gICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9TUUwwMjA0TiB7Mn1cIiguKilcIiBpcyBhbiB1bmRlZmluZWQgbmFtZS4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IG1hdGNoWzFdO1xuICAgICAgbGV0IHRhYmxlID0gZXJyLnNxbC5tYXRjaCgvdGFibGUgXCIoLis/KVwiL2kpO1xuICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IG1hdGNoWzBdLFxuICAgICAgICBjb25zdHJhaW50LFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgfVxuICBpc0Ryb3BTY2hlbWFRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgaWYgKF8uc3RhcnRzV2l0aCh0aGlzLnNxbCwgXCJDQUxMIFNZU1BST0MuQURNSU5fRFJPUF9TQ0hFTUFcIikpIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwic2VsZWN0IGMuY29sdW1uX25hbWUgYXMgJ25hbWUnLCBjLmRhdGFfdHlwZSBhcyAndHlwZScsIGMuaXNfbnVsbGFibGUgYXMgJ2lzbnVsbCdcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcInNlbGVjdCB0YWJsZW5hbWUgPSB0Lm5hbWUsIG5hbWUgPSBpbmQubmFtZSxcIik7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImV4ZWMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZVwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzU2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IHRoaXMuc3FsLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChcImV4ZWMgc3lzLnNwX2hlbHBpbmRleCBAb2JqbmFtZVwiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwuc3RhcnRzV2l0aCgnU0VMRUNUIE5BTUUgQVMgXCJuYW1lXCIsIFRCTkFNRSBBUyBcInRhYmxlTmFtZVwiLCBVTklRVUVSVUxFIEFTIFwia2V5VHlwZVwiLCBDT0xOQU1FUywgSU5ERVhUWVBFIEFTIFwidHlwZVwiIEZST00gU1lTSUJNLlNZU0lOREVYRVMnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhbmRsZVNob3dJbmRleGVzUXVlcnkoZGF0YSkge1xuICAgIGxldCBjdXJySXRlbTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBkYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmICghY3Vyckl0ZW0gfHwgY3Vyckl0ZW0ubmFtZSAhPT0gaXRlbS5LZXlfbmFtZSkge1xuICAgICAgICBjdXJySXRlbSA9IHtcbiAgICAgICAgICBwcmltYXJ5OiBpdGVtLmtleVR5cGUgPT09IFwiUFwiLFxuICAgICAgICAgIGZpZWxkczogW10sXG4gICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgIHRhYmxlTmFtZTogaXRlbS50YWJsZU5hbWUsXG4gICAgICAgICAgdW5pcXVlOiBpdGVtLmtleVR5cGUgPT09IFwiVVwiLFxuICAgICAgICAgIHR5cGU6IGl0ZW0udHlwZVxuICAgICAgICB9O1xuICAgICAgICBfLmZvckVhY2goaXRlbS5DT0xOQU1FUy5yZXBsYWNlKC9cXCt8LS9nLCAoeCkgPT4ge1xuICAgICAgICAgIHJldHVybiBgICR7eH1gO1xuICAgICAgICB9KS5zcGxpdChcIiBcIiksIChjb2x1bW4pID0+IHtcbiAgICAgICAgICBsZXQgY29sdW1uTmFtZSA9IGNvbHVtbi50cmltKCk7XG4gICAgICAgICAgaWYgKGNvbHVtbk5hbWUpIHtcbiAgICAgICAgICAgIGNvbHVtbk5hbWUgPSBjb2x1bW5OYW1lLnJlcGxhY2UoL1xcK3wtLywgXCJcIik7XG4gICAgICAgICAgICBjdXJySXRlbS5maWVsZHMucHVzaCh7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZTogY29sdW1uTmFtZSxcbiAgICAgICAgICAgICAgbGVuZ3RoOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG9yZGVyOiBjb2x1bW4uaW5kZXhPZihcIi1cIikgPT09IC0xID8gXCJBU0NcIiA6IFwiREVTQ1wiLFxuICAgICAgICAgICAgICBjb2xsYXRlOiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJJdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhbmRsZUluc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgIGNvbnN0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGU7XG4gICAgICBsZXQgaWQgPSBudWxsO1xuICAgICAgbGV0IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyA9IG51bGw7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWwucmF3QXR0cmlidXRlcywgYXV0b0luY3JlbWVudEF0dHJpYnV0ZSkgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdLmZpZWxkICE9PSB2b2lkIDApXG4gICAgICAgIGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50QXR0cmlidXRlXS5maWVsZDtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgbWV0YURhdGEgJiYgbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgaWQgPSBpZCB8fCByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEF0dHJpYnV0ZV07XG4gICAgICBpZCA9IGlkIHx8IGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhcyAmJiByZXN1bHRzICYmIHJlc3VsdHNbMF1bYXV0b0luY3JlbWVudEF0dHJpYnV0ZUFsaWFzXTtcbiAgICAgIHRoaXMuaW5zdGFuY2VbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0gPSBpZDtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/db2/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mariadb);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst debug = logger.debugContext(\"connection:mariadb\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mariadb\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mariadb\");\n    this.refreshTypeParser(DataTypes);\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false\n    }, config.dialectOptions);\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ER_ACCESS_DENIED_NO_PASSWORD_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n        case \"ENETUNREACH\":\n        case \"EADDRNOTAVAIL\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isValid()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await connection.end();\n  }\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0RBQVE7QUFDL0Isa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLGtCQUFrQix5R0FBbUM7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWlCO0FBQzFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFNBQVM7QUFDbkUsUUFBUTtBQUNSLHVEQUF1RCxTQUFTO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz82N2NjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikubWFyaWFkYjtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246bWFyaWFkYlwiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwibWFyaWFkYlwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAzMzA2O1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcIm1hcmlhZGJcIik7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIHN0YXRpYyBfdHlwZWNhc3QoZmllbGQsIG5leHQpIHtcbiAgICBpZiAocGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VyU3RvcmUuZ2V0KGZpZWxkLnR5cGUpKGZpZWxkLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLCBuZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBsZXQgdHpPZmZzZXQgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lO1xuICAgIHR6T2Zmc2V0ID0gL1xcLy8udGVzdCh0ek9mZnNldCkgPyBtb21lbnRUei50eih0ek9mZnNldCkuZm9ybWF0KFwiWlwiKSA6IHR6T2Zmc2V0O1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBob3N0OiBjb25maWcuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0LFxuICAgICAgdXNlcjogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICB0aW1lem9uZTogdHpPZmZzZXQsXG4gICAgICB0eXBlQ2FzdDogQ29ubmVjdGlvbk1hbmFnZXIuX3R5cGVjYXN0LmJpbmQodGhpcyksXG4gICAgICBiaWdOdW1iZXJTdHJpbmdzOiBmYWxzZSxcbiAgICAgIHN1cHBvcnRCaWdOdW1iZXJzOiB0cnVlLFxuICAgICAgZm91bmRSb3dzOiBmYWxzZVxuICAgIH0sIGNvbmZpZy5kaWFsZWN0T3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLnNlcXVlbGl6ZS5jb25maWcua2VlcERlZmF1bHRUaW1lem9uZSkge1xuICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsKSkge1xuICAgICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbCA9IFtjb25uZWN0aW9uQ29uZmlnLmluaXRTcWxdO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuaW5pdFNxbC5wdXNoKGBTRVQgdGltZV96b25lID0gJyR7dHpPZmZzZXR9J2ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5pbml0U3FsID0gYFNFVCB0aW1lX3pvbmUgPSAnJHt0ek9mZnNldH0nYDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCB0aGlzLmxpYi5jcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGNvbm5lY3Rpb24uc2VydmVyVmVyc2lvbigpKS52ZXJzaW9uO1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgICAgY29ubmVjdGlvbi5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICBjYXNlIFwiRVNPQ0tFVFwiOlxuICAgICAgICAgIGNhc2UgXCJFQ09OTlJFU0VUXCI6XG4gICAgICAgICAgY2FzZSBcIkVQSVBFXCI6XG4gICAgICAgICAgY2FzZSBcIlBST1RPQ09MX0NPTk5FQ1RJT05fTE9TVFwiOlxuICAgICAgICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgIGNhc2UgXCJFQ09OTlJFRlVTRURcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVSX0FDQ0VTU19ERU5JRURfRVJST1JcIjpcbiAgICAgICAgY2FzZSBcIkVSX0FDQ0VTU19ERU5JRURfTk9fUEFTU1dPUkRfRVJST1JcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFTk9URk9VTkRcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFSE9TVFVOUkVBQ0hcIjpcbiAgICAgICAgY2FzZSBcIkVORVRVTlJFQUNIXCI6XG4gICAgICAgIGNhc2UgXCJFQUREUk5PVEFWQUlMXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVJTlZBTFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmICghY29ubmVjdGlvbi5pc1ZhbGlkKCkpIHtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBDTE9TRUQgc3RhdGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLmVuZCgpO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLmlzVmFsaWQoKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/data-types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/data-types.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://mariadb.com/kb/en/library/resultset/#field-types\";\n  BaseTypes.DATE.types.mariadb = [\"DATETIME\"];\n  BaseTypes.STRING.types.mariadb = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mariadb = [\"STRING\"];\n  BaseTypes.TEXT.types.mariadb = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mariadb = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mariadb = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mariadb = [\"INT24\"];\n  BaseTypes.INTEGER.types.mariadb = [\"LONG\"];\n  BaseTypes.BIGINT.types.mariadb = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mariadb = [\"FLOAT\"];\n  BaseTypes.TIME.types.mariadb = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mariadb = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mariadb = [\"TINY\"];\n  BaseTypes.BLOB.types.mariadb = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mariadb = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mariadb = false;\n  BaseTypes.ENUM.types.mariadb = false;\n  BaseTypes.REAL.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mariadb = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mariadb = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mariadb = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n      } else {\n        this.sqlType = this.type;\n      }\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map((value) => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2RhdGEtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZLG1CQUFPLENBQUMsZ0RBQUs7QUFDekIsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRCQUE0QixPQUFPLEVBQUUsaUJBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbWFyaWFkYi9kYXRhLXR5cGVzLmpzP2E5YWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCB3a3ggPSByZXF1aXJlKFwid2t4XCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBtb21lbnRUeiA9IHJlcXVpcmUoXCJtb21lbnQtdGltZXpvbmVcIik7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIEJhc2VUeXBlcy5BQlNUUkFDVC5wcm90b3R5cGUuZGlhbGVjdFR5cGVzID0gXCJodHRwczovL21hcmlhZGIuY29tL2tiL2VuL2xpYnJhcnkvcmVzdWx0c2V0LyNmaWVsZC10eXBlc1wiO1xuICBCYXNlVHlwZXMuREFURS50eXBlcy5tYXJpYWRiID0gW1wiREFURVRJTUVcIl07XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMubWFyaWFkYiA9IFtcIlZBUl9TVFJJTkdcIl07XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm1hcmlhZGIgPSBbXCJTVFJJTkdcIl07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm1hcmlhZGIgPSBbXCJCTE9CXCJdO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5tYXJpYWRiID0gW1wiVElOWVwiXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm1hcmlhZGIgPSBbXCJTSE9SVFwiXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5tYXJpYWRiID0gW1wiSU5UMjRcIl07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm1hcmlhZGIgPSBbXCJMT05HXCJdO1xuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLm1hcmlhZGIgPSBbXCJMT05HTE9OR1wiXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm1hcmlhZGIgPSBbXCJGTE9BVFwiXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMubWFyaWFkYiA9IFtcIlRJTUVcIl07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5tYXJpYWRiID0gW1wiREFURVwiXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMubWFyaWFkYiA9IFtcIlRJTllcIl07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLm1hcmlhZGIgPSBbXCJUSU5ZQkxPQlwiLCBcIkJMT0JcIiwgXCJMT05HQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMubWFyaWFkYiA9IFtcIk5FV0RFQ0lNQUxcIl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm1hcmlhZGIgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMubWFyaWFkYiA9IGZhbHNlO1xuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5tYXJpYWRiID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm1hcmlhZGIgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5tYXJpYWRiID0gW1wiR0VPTUVUUllcIl07XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLm1hcmlhZGIgPSBbXCJKU09OXCJdO1xuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBzdXBlci50b1NxbCgpO1xuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gXCIgVU5TSUdORURcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICBkZWZpbml0aW9uICs9IFwiIFpFUk9GSUxMXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGggPyBgREFURVRJTUUoJHt0aGlzLl9sZW5ndGh9KWAgOiBcIkRBVEVUSU1FXCI7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFtb21lbnQuaXNNb21lbnQoZGF0ZSkpIHtcbiAgICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTU1wiKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN0cmluZygpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb21lbnRUei50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHZhbHVlID0gbW9tZW50VHoudHoodmFsdWUsIG9wdGlvbnMudGltZXpvbmUpLnRvRGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShgJHt2YWx1ZX0gJHtvcHRpb25zLnRpbWV6b25lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDSEFSKDM2KSBCSU5BUllcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPTUVUUlkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICAgIHN1cGVyKHR5cGUsIHNyaWQpO1xuICAgICAgaWYgKF8uaXNFbXB0eSh0aGlzLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMua2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy50eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuYnVmZmVyKCk7XG4gICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoNCk7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKHZhbHVlKS50b0dlb0pTT04oeyBzaG9ydENyczogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zcWxUeXBlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHRvU3FsKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgRU5VTSgke3RoaXMudmFsdWVzLm1hcCgodmFsdWUpID0+IG9wdGlvbnMuZXNjYXBlKHZhbHVlKSkuam9pbihcIiwgXCIpfSlgO1xuICAgIH1cbiAgfVxuICBjbGFzcyBKU09OVFlQRSBleHRlbmRzIEJhc2VUeXBlcy5KU09OIHtcbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5vcGVyYXRpb24gPT09IFwid2hlcmVcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBFTlVNLFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgVVVJRCxcbiAgICBHRU9NRVRSWSxcbiAgICBERUNJTUFMLFxuICAgIEpTT046IEpTT05UWVBFXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query-generator.js\");\nconst { MySQLQueryInterface } = __webpack_require__(/*! ../mysql/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mariadb);\nclass MariadbDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return true;\n  }\n}\nMariadbDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  schemas: true,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: \" ON DUPLICATE KEY UPDATE\"\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\nMariadbDialect.prototype.defaultVersion = \"10.1.44\";\nMariadbDialect.prototype.Query = Query;\nMariadbDialect.prototype.QueryGenerator = QueryGenerator;\nMariadbDialect.prototype.DataTypes = DataTypes;\nMariadbDialect.prototype.name = \"mariadb\";\nMariadbDialect.prototype.TICK_CHAR = \"`\";\nMariadbDialect.prototype.TICK_CHAR_LEFT = MariadbDialect.prototype.TICK_CHAR;\nMariadbDialect.prototype.TICK_CHAR_RIGHT = MariadbDialect.prototype.TICK_CHAR;\nmodule.exports = MariadbDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLHdCQUF3QixtQkFBTyxDQUFDLGtGQUFhO0FBQzdDLDBCQUEwQixtQkFBTyxDQUFDLHVHQUFzQjtBQUN4RCxjQUFjLG1CQUFPLENBQUMsNkVBQVM7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsaUdBQW1CO0FBQ2xELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEUsa0JBQWtCLHlHQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL2luZGV4LmpzP2ExMDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgeyBNeVNRTFF1ZXJ5SW50ZXJmYWNlIH0gPSByZXF1aXJlKFwiLi4vbXlzcWwvcXVlcnktaW50ZXJmYWNlXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikubWFyaWFkYjtcbmNsYXNzIE1hcmlhZGJEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgTXlTUUxRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG4gIGNhbkJhY2tzbGFzaEVzY2FwZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBcIlZBTFVFUyAoKVwiOiB0cnVlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiB0cnVlLFxuICBsb2NrOiB0cnVlLFxuICBmb3JTaGFyZTogXCJMT0NLIElOIFNIQVJFIE1PREVcIixcbiAgc2V0dGluZ0lzb2xhdGlvbkxldmVsRHVyaW5nVHJhbnNhY3Rpb246IGZhbHNlLFxuICBzY2hlbWFzOiB0cnVlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogXCIgSUdOT1JFXCIsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IFwiIE9OIERVUExJQ0FURSBLRVkgVVBEQVRFXCJcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICBjb2xsYXRlOiBmYWxzZSxcbiAgICBsZW5ndGg6IHRydWUsXG4gICAgcGFyc2VyOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgdXNpbmc6IDFcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICBkcm9wQ29uc3RyYWludDogZmFsc2UsXG4gICAgY2hlY2s6IGZhbHNlXG4gIH0sXG4gIGluZGV4VmlhQWx0ZXI6IHRydWUsXG4gIGluZGV4SGludHM6IHRydWUsXG4gIE5VTUVSSUM6IHRydWUsXG4gIEdFT01FVFJZOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICBSRUdFWFA6IHRydWVcbn0pO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCIxMC4xLjQ0XCI7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5RdWVyeUdlbmVyYXRvciA9IFF1ZXJ5R2VuZXJhdG9yO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbk1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJtYXJpYWRiXCI7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gXCJgXCI7XG5NYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBNYXJpYWRiRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuTWFyaWFkYkRpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IE1hcmlhZGJEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVI7XG5tb2R1bGUuZXhwb3J0cyA9IE1hcmlhZGJEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query-generator.js":
/*!************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query-generator.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst MySQLQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst Utils = __webpack_require__(/*! ./../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nclass MariaDBQueryGenerator extends MySQLQueryGenerator {\n  createSchema(schema, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE SCHEMA IF NOT EXISTS\",\n      this.quoteIdentifier(schema),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)};`;\n  }\n  showSchemasQuery(options) {\n    const schemasToSkip = [\n      \"'MYSQL'\",\n      \"'INFORMATION_SCHEMA'\",\n      \"'PERFORMANCE_SCHEMA'\"\n    ];\n    if (options.skip && Array.isArray(options.skip) && options.skip.length > 0) {\n      for (const schemaName of options.skip) {\n        schemasToSkip.push(this.escape(schemaName));\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"SELECT SCHEMA_NAME as schema_name\",\n      \"FROM INFORMATION_SCHEMA.SCHEMATA\",\n      `WHERE SCHEMA_NAME NOT IN (${schemasToSkip.join(\", \")})`,\n      \";\"\n    ]);\n  }\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA')\";\n    }\n    return `${query};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = MariaDBQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLGtFQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LWdlbmVyYXRvci5qcz8wY2Q0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgTXlTUUxRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9teXNxbC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLy4uLy4uL3V0aWxzXCIpO1xuY2xhc3MgTWFyaWFEQlF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgTXlTUUxRdWVyeUdlbmVyYXRvciB7XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBTQ0hFTUEgSUYgTk9UIEVYSVNUU1wiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSxcbiAgICAgIG9wdGlvbnMuY2hhcnNldCAmJiBgREVGQVVMVCBDSEFSQUNURVIgU0VUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jaGFyc2V0KX1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBERUZBVUxUIENPTExBVEUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGBEUk9QIFNDSEVNQSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpfTtgO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkob3B0aW9ucykge1xuICAgIGNvbnN0IHNjaGVtYXNUb1NraXAgPSBbXG4gICAgICBcIidNWVNRTCdcIixcbiAgICAgIFwiJ0lORk9STUFUSU9OX1NDSEVNQSdcIixcbiAgICAgIFwiJ1BFUkZPUk1BTkNFX1NDSEVNQSdcIlxuICAgIF07XG4gICAgaWYgKG9wdGlvbnMuc2tpcCAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMuc2tpcCkgJiYgb3B0aW9ucy5za2lwLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3Qgc2NoZW1hTmFtZSBvZiBvcHRpb25zLnNraXApIHtcbiAgICAgICAgc2NoZW1hc1RvU2tpcC5wdXNoKHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgU0NIRU1BX05BTUUgYXMgc2NoZW1hX25hbWVcIixcbiAgICAgIFwiRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuU0NIRU1BVEFcIixcbiAgICAgIGBXSEVSRSBTQ0hFTUFfTkFNRSBOT1QgSU4gKCR7c2NoZW1hc1RvU2tpcC5qb2luKFwiLCBcIil9KWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeShkYXRhYmFzZSkge1xuICAgIGxldCBxdWVyeSA9IFwiU0VMRUNUIFRBQkxFX05BTUUsIFRBQkxFX1NDSEVNQSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJ1wiO1xuICAgIGlmIChkYXRhYmFzZSkge1xuICAgICAgcXVlcnkgKz0gYCBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZShkYXRhYmFzZSl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgKz0gXCIgQU5EIFRBQkxFX1NDSEVNQSBOT1QgSU4gKCdNWVNRTCcsICdJTkZPUk1BVElPTl9TQ0hFTUEnLCAnUEVSRk9STUFOQ0VfU0NIRU1BJylcIjtcbiAgICB9XG4gICAgcmV0dXJuIGAke3F1ZXJ5fTtgO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCBcImBcIiksIFwiYFwiKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBNYXJpYURCUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mariadb/query.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:mariadb\");\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, __spreadValues({ showWarnings: false }, options));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    const errForStack = new Error();\n    try {\n      results = await connection.query(this.sql, parameters);\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = new Array(data.affectedRows);\n          const pkField = this.model.rawAttributes[this.model.primaryKeyAttribute].field;\n          for (let i = 0; i < data.affectedRows; i++) {\n            result[i] = { [pkField]: startId + i };\n          }\n          return [result, data.affectedRows];\n        }\n        return [data[this.getInsertIdField()], data.affectedRows];\n      }\n    }\n    if (this.isSelectQuery()) {\n      this.handleJsonSelectQuery(data);\n      return this.handleSelectQuery(data);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isRawQuery()) {\n      const meta = data.meta;\n      delete data.meta;\n      return [data, meta];\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isForeignKeysQuery() || this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toLowerCase().startsWith(\"enum\") ? _result.Type.replace(/^enum/i, \"ENUM\") : _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    return result;\n  }\n  handleJsonSelectQuery(rows) {\n    if (!this.model || !this.model.fieldRawAttributesMap) {\n      return;\n    }\n    for (const _field of Object.keys(this.model.fieldRawAttributesMap)) {\n      const modelField = this.model.fieldRawAttributesMap[_field];\n      if (modelField.type instanceof DataTypes.JSON) {\n        rows = rows.map((row) => {\n          if (row[modelField.fieldName] && typeof row[modelField.fieldName] === \"string\" && !this.connection.info.hasMinVersion(10, 5, 2)) {\n            row[modelField.fieldName] = JSON.parse(row[modelField.fieldName]);\n          }\n          if (DataTypes.JSON.parse) {\n            return DataTypes.JSON.parse(modelField, this.sequelize.options, row[modelField.fieldName]);\n          }\n          return row;\n        });\n      }\n    }\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `MariaDB Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err, errStack) {\n    switch (err.errno) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?\\s.*$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: err.errno === ER_ROW_IS_REFERENCED ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err,\n          stack: errStack\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => ({\n      tableName: resultSet.TABLE_NAME,\n      schema: resultSet.TABLE_SCHEMA\n    }));\n  }\n  handleShowIndexesQuery(data) {\n    let currItem;\n    const result = [];\n    data.forEach((item) => {\n      if (!currItem || currItem.name !== item.Key_name) {\n        currItem = {\n          primary: item.Key_name === \"PRIMARY\",\n          fields: [],\n          name: item.Key_name,\n          tableName: item.Table,\n          unique: item.Non_unique !== 1,\n          type: item.Index_type\n        };\n        result.push(currItem);\n      }\n      currItem.fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n    });\n    return result;\n  }\n}\nmodule.exports = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsS0FBSyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tYXJpYWRiL3F1ZXJ5LmpzPzJmYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBBYnN0cmFjdFF1ZXJ5ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5XCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IEVSX0RVUF9FTlRSWSA9IDEwNjI7XG5jb25zdCBFUl9ERUFETE9DSyA9IDEyMTM7XG5jb25zdCBFUl9ST1dfSVNfUkVGRVJFTkNFRCA9IDE0NTE7XG5jb25zdCBFUl9OT19SRUZFUkVOQ0VEX1JPVyA9IDE0NTI7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6bWFyaWFkYlwiKTtcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKGNvbm5lY3Rpb24sIHNlcXVlbGl6ZSwgX19zcHJlYWRWYWx1ZXMoeyBzaG93V2FybmluZ3M6IGZhbHNlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBiaW5kUGFyYW0gPSBbXTtcbiAgICBjb25zdCByZXBsYWNlbWVudEZ1bmMgPSAobWF0Y2gsIGtleSwgdmFsdWVzXykgPT4ge1xuICAgICAgaWYgKHZhbHVlc19ba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGJpbmRQYXJhbS5wdXNoKHZhbHVlc19ba2V5XSk7XG4gICAgICAgIHJldHVybiBcIj9cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfTtcbiAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIHJldHVybiBbc3FsLCBiaW5kUGFyYW0ubGVuZ3RoID4gMCA/IGJpbmRQYXJhbSA6IHZvaWQgMF07XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbiwgb3B0aW9ucyB9ID0gdGhpcztcbiAgICBjb25zdCBzaG93V2FybmluZ3MgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnNob3dXYXJuaW5ncyB8fCBvcHRpb25zLnNob3dXYXJuaW5ncztcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICBkZWJ1ZyhcInBhcmFtZXRlcnMoJWopXCIsIHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cztcbiAgICBjb25zdCBlcnJGb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRzID0gYXdhaXQgY29ubmVjdGlvbi5xdWVyeSh0aGlzLnNxbCwgcGFyYW1ldGVycyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIGVycm9yLmVycm5vID09PSBFUl9ERUFETE9DSykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG9wdGlvbnMudHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCA9IFwicm9sbGJhY2tcIjtcbiAgICAgIH1cbiAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgIGVycm9yLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvciwgZXJyRm9yU3RhY2suc3RhY2spO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgICBpZiAoc2hvd1dhcm5pbmdzICYmIHJlc3VsdHMgJiYgcmVzdWx0cy53YXJuaW5nU3RhdHVzID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5sb2dXYXJuaW5ncyhyZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyZXN1bHRzKTtcbiAgfVxuICBmb3JtYXRSZXN1bHRzKGRhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5pc0J1bGtVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNCdWxrRGVsZXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYWZmZWN0ZWRSb3dzO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93cyA9PT0gMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShkYXRhLmFmZmVjdGVkUm93cyk7XG4gICAgICAgICAgY29uc3QgcGtGaWVsZCA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5hZmZlY3RlZFJvd3M7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0geyBbcGtGaWVsZF06IHN0YXJ0SWQgKyBpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXSwgZGF0YS5hZmZlY3RlZFJvd3NdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSnNvblNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgY29uc3QgbWV0YSA9IGRhdGEubWV0YTtcbiAgICAgIGRlbGV0ZSBkYXRhLm1ldGE7XG4gICAgICByZXR1cm4gW2RhdGEsIG1ldGFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkgfHwgdGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LlR5cGUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZW51bVwiKSA/IF9yZXN1bHQuVHlwZS5yZXBsYWNlKC9eZW51bS9pLCBcIkVOVU1cIikgOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuTnVsbCA9PT0gXCJZRVNcIixcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LktleSA9PT0gXCJQUklcIixcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwgXCJFeHRyYVwiKSAmJiBfcmVzdWx0LkV4dHJhLnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0b19pbmNyZW1lbnRcIixcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnQgPyBfcmVzdWx0LkNvbW1lbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhbmRsZUpzb25TZWxlY3RRdWVyeShyb3dzKSB7XG4gICAgaWYgKCF0aGlzLm1vZGVsIHx8ICF0aGlzLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IF9maWVsZCBvZiBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcCkpIHtcbiAgICAgIGNvbnN0IG1vZGVsRmllbGQgPSB0aGlzLm1vZGVsLmZpZWxkUmF3QXR0cmlidXRlc01hcFtfZmllbGRdO1xuICAgICAgaWYgKG1vZGVsRmllbGQudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5KU09OKSB7XG4gICAgICAgIHJvd3MgPSByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgaWYgKHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0gJiYgdHlwZW9mIHJvd1ttb2RlbEZpZWxkLmZpZWxkTmFtZV0gPT09IFwic3RyaW5nXCIgJiYgIXRoaXMuY29ubmVjdGlvbi5pbmZvLmhhc01pblZlcnNpb24oMTAsIDUsIDIpKSB7XG4gICAgICAgICAgICByb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdID0gSlNPTi5wYXJzZShyb3dbbW9kZWxGaWVsZC5maWVsZE5hbWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKERhdGFUeXBlcy5KU09OLnBhcnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YVR5cGVzLkpTT04ucGFyc2UobW9kZWxGaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgcm93W21vZGVsRmllbGQuZmllbGROYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBsb2dXYXJuaW5ncyhyZXN1bHRzKSB7XG4gICAgY29uc3Qgd2FybmluZ1Jlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bihcIlNIT1cgV0FSTklOR1NcIik7XG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgTWFyaWFEQiBXYXJuaW5ncyAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiBgO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBfd2FybmluZ1JvdyBvZiB3YXJuaW5nUmVzdWx0cykge1xuICAgICAgaWYgKF93YXJuaW5nUm93ID09PSB2b2lkIDAgfHwgdHlwZW9mIF93YXJuaW5nUm93W1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX3dhcm5pbmdSZXN1bHQgb2YgX3dhcm5pbmdSb3cpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfd2FybmluZ1Jlc3VsdCwgXCJNZXNzYWdlXCIpKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChfd2FybmluZ1Jlc3VsdC5NZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IF9vYmplY3RLZXkgb2YgX3dhcm5pbmdSZXN1bHQua2V5cygpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFtfb2JqZWN0S2V5LCBfd2FybmluZ1Jlc3VsdFtfb2JqZWN0S2V5XV0uam9pbihcIjogXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXF1ZWxpemUubG9nKHdhcm5pbmdNZXNzYWdlICsgbWVzc2FnZXMuam9pbihcIjsgXCIpLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spIHtcbiAgICBzd2l0Y2ggKGVyci5lcnJubykge1xuICAgICAgY2FzZSBFUl9EVVBfRU5UUlk6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvRHVwbGljYXRlIGVudHJ5ICcoW1xcc1xcU10qKScgZm9yIGtleSAnPygoLnxcXHMpKj8pJz9cXHMuKiQvKTtcbiAgICAgICAgbGV0IGZpZWxkcyA9IHt9O1xuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KFwiLVwiKSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgZmllbGRLZXkgPSBtYXRjaCA/IG1hdGNoWzJdIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBmaWVsZFZhbCA9IG1hdGNoID8gbWF0Y2hbMV0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW2ZpZWxkS2V5XTtcbiAgICAgICAgaWYgKHVuaXF1ZUtleSkge1xuICAgICAgICAgIGlmICh1bmlxdWVLZXkubXNnKVxuICAgICAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QodW5pcXVlS2V5LmZpZWxkcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHNbZmllbGRLZXldID0gZmllbGRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvcnMuVmFsaWRhdGlvbkVycm9ySXRlbSh0aGlzLmdldFVuaXF1ZUNvbnN0cmFpbnRFcnJvck1lc3NhZ2UoZmllbGQpLCBcInVuaXF1ZSB2aW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzLCBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIEVSX1JPV19JU19SRUZFUkVOQ0VEOlxuICAgICAgY2FzZSBFUl9OT19SRUZFUkVOQ0VEX1JPVzoge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9DT05TVFJBSU5UIChbYFwiXSkoLiopXFwxIEZPUkVJR04gS0VZIFxcKFxcMSguKilcXDFcXCkgUkVGRVJFTkNFUyBcXDEoLiopXFwxIFxcKFxcMSguKilcXDFcXCkvKTtcbiAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiYFwiO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBtYXRjaCA/IG1hdGNoWzNdLnNwbGl0KG5ldyBSZWdFeHAoYCR7cXVvdGVDaGFyfSwgKiR7cXVvdGVDaGFyfWApKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgcmVsdHlwZTogZXJyLmVycm5vID09PSBFUl9ST1dfSVNfUkVGRVJFTkNFRCA/IFwicGFyZW50XCIgOiBcImNoaWxkXCIsXG4gICAgICAgICAgdGFibGU6IG1hdGNoID8gbWF0Y2hbNF0gOiB2b2lkIDAsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIHZhbHVlOiBmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCAmJiB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRzWzBdXSB8fCB2b2lkIDAsXG4gICAgICAgICAgaW5kZXg6IG1hdGNoID8gbWF0Y2hbMl0gOiB2b2lkIDAsXG4gICAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0U2V0KSA9PiAoe1xuICAgICAgdGFibGVOYW1lOiByZXN1bHRTZXQuVEFCTEVfTkFNRSxcbiAgICAgIHNjaGVtYTogcmVzdWx0U2V0LlRBQkxFX1NDSEVNQVxuICAgIH0pKTtcbiAgfVxuICBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICBsZXQgY3Vyckl0ZW07XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZGF0YS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoIWN1cnJJdGVtIHx8IGN1cnJJdGVtLm5hbWUgIT09IGl0ZW0uS2V5X25hbWUpIHtcbiAgICAgICAgY3Vyckl0ZW0gPSB7XG4gICAgICAgICAgcHJpbWFyeTogaXRlbS5LZXlfbmFtZSA9PT0gXCJQUklNQVJZXCIsXG4gICAgICAgICAgZmllbGRzOiBbXSxcbiAgICAgICAgICBuYW1lOiBpdGVtLktleV9uYW1lLFxuICAgICAgICAgIHRhYmxlTmFtZTogaXRlbS5UYWJsZSxcbiAgICAgICAgICB1bmlxdWU6IGl0ZW0uTm9uX3VuaXF1ZSAhPT0gMSxcbiAgICAgICAgICB0eXBlOiBpdGVtLkluZGV4X3R5cGVcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LnB1c2goY3Vyckl0ZW0pO1xuICAgICAgfVxuICAgICAgY3Vyckl0ZW0uZmllbGRzW2l0ZW0uU2VxX2luX2luZGV4IC0gMV0gPSB7XG4gICAgICAgIGF0dHJpYnV0ZTogaXRlbS5Db2x1bW5fbmFtZSxcbiAgICAgICAgbGVuZ3RoOiBpdGVtLlN1Yl9wYXJ0IHx8IHZvaWQgMCxcbiAgICAgICAgb3JkZXI6IGl0ZW0uQ29sbGF0aW9uID09PSBcIkFcIiA/IFwiQVNDXCIgOiB2b2lkIDBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mariadb/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/async-queue.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  AsyncQueueError: () => AsyncQueueError,\n  default: () => async_queue_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ../../errors/base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nvar import_connection_error = __toModule(__webpack_require__(/*! ../../errors/connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass AsyncQueueError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAsyncQueueError\";\n  }\n}\nclass AsyncQueue {\n  constructor() {\n    __publicField(this, \"previous\");\n    __publicField(this, \"closed\");\n    __publicField(this, \"rejectCurrent\");\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {\n    };\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could finish executing\")));\n  }\n  enqueue(asyncFunction) {\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n        if (this.closed) {\n          return reject(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could be executed\")));\n        }\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n}\nvar async_queue_default = AsyncQueue;\n//# sourceMappingURL=async-queue.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLHdGQUF5QjtBQUNwRSx5Q0FBeUMsbUJBQU8sQ0FBQyxvR0FBK0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9hc3luYy1xdWV1ZS5qcz9mY2YwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIEFzeW5jUXVldWVFcnJvcjogKCkgPT4gQXN5bmNRdWV1ZUVycm9yLFxuICBkZWZhdWx0OiAoKSA9PiBhc3luY19xdWV1ZV9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uLy4uL2Vycm9ycy9iYXNlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uLy4uL2Vycm9ycy9jb25uZWN0aW9uLWVycm9yXCIpKTtcbmNsYXNzIEFzeW5jUXVldWVFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVBc3luY1F1ZXVlRXJyb3JcIjtcbiAgfVxufVxuY2xhc3MgQXN5bmNRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcmV2aW91c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2xvc2VkXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZWplY3RDdXJyZW50XCIpO1xuICAgIHRoaXMucHJldmlvdXMgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVqZWN0Q3VycmVudCA9ICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLnJlamVjdEN1cnJlbnQobmV3IGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQobmV3IEFzeW5jUXVldWVFcnJvcihcInRoZSBjb25uZWN0aW9uIHdhcyBjbG9zZWQgYmVmb3JlIHRoaXMgcXVlcnkgY291bGQgZmluaXNoIGV4ZWN1dGluZ1wiKSkpO1xuICB9XG4gIGVucXVldWUoYXN5bmNGdW5jdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnByZXZpb3VzID0gdGhpcy5wcmV2aW91cy50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5yZWplY3RDdXJyZW50ID0gcmVqZWN0O1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0KG5ldyBBc3luY1F1ZXVlRXJyb3IoXCJ0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkIGJlZm9yZSB0aGlzIHF1ZXJ5IGNvdWxkIGJlIGV4ZWN1dGVkXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jRnVuY3Rpb24oKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxudmFyIGFzeW5jX3F1ZXVlX2RlZmF1bHQgPSBBc3luY1F1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMtcXVldWUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst AsyncQueue = (__webpack_require__(/*! ./async-queue */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js\")[\"default\"]);\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mssql);\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mssql\");\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n        const connectHandler = (error) => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error)\n            return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n        const errorHandler = (error) => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", (error) => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EAFNOSUPPORT\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n    connection.queue.close();\n    return new Promise((resolve) => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixrQ0FBa0MsbUJBQU8sQ0FBQyxrSEFBZ0M7QUFDMUUsbUJBQW1CLHlIQUFnQztBQUNuRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFvQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxrQkFBa0IsdUdBQWlDO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL21zc3FsL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz8wNDg2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBBc3luY1F1ZXVlID0gcmVxdWlyZShcIi4vYXN5bmMtcXVldWVcIikuZGVmYXVsdDtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm1zc3FsO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJtc3NxbFwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246bXNzcWxcIik7XG5jb25zdCBkZWJ1Z1RlZGlvdXMgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjptc3NxbDp0ZWRpb3VzXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDE0MzM7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwidGVkaW91c1wiKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKERhdGFUeXBlcyk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHtcbiAgICAgIHNlcnZlcjogY29uZmlnLmhvc3QsXG4gICAgICBhdXRoZW50aWNhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHVzZXJOYW1lOiBjb25maWcudXNlcm5hbWUgfHwgdm9pZCAwLFxuICAgICAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQgfHwgdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KGNvbmZpZy5wb3J0LCAxMCksXG4gICAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICAgIHRydXN0U2VydmVyQ2VydGlmaWNhdGU6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMpIHtcbiAgICAgIGlmIChjb25maWcuZGlhbGVjdE9wdGlvbnMub3B0aW9ucyAmJiBjb25maWcuZGlhbGVjdE9wdGlvbnMub3B0aW9ucy5pbnN0YW5jZU5hbWUpIHtcbiAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25Db25maWcub3B0aW9ucy5wb3J0O1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5hdXRoZW50aWNhdGlvbikge1xuICAgICAgICBPYmplY3QuYXNzaWduKGNvbm5lY3Rpb25Db25maWcuYXV0aGVudGljYXRpb24sIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5hdXRoZW50aWNhdGlvbik7XG4gICAgICB9XG4gICAgICBPYmplY3QuYXNzaWduKGNvbm5lY3Rpb25Db25maWcub3B0aW9ucywgY29uZmlnLmRpYWxlY3RPcHRpb25zLm9wdGlvbnMpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyB0aGlzLmxpYi5Db25uZWN0aW9uKGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0ZSA9PT0gY29ubmVjdGlvbi5TVEFURS5JTklUSUFMSVpFRCkge1xuICAgICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24ucXVldWUgPSBuZXcgQXN5bmNRdWV1ZSgpO1xuICAgICAgICBjb25uZWN0aW9uLmxpYiA9IHRoaXMubGliO1xuICAgICAgICBjb25zdCBjb25uZWN0SGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIiwgZW5kSGFuZGxlcik7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVuZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbi5yZW1vdmVMaXN0ZW5lcihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb25uZWN0aW9uIHdhcyBjbG9zZWQgYnkgcmVtb3RlIHNlcnZlclwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZShcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZShcImVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICAgIGNvbm5lY3Rpb24ub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGVycm9yLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJFU09DS0VUXCI6XG4gICAgICAgICAgICBjYXNlIFwiRUNPTk5SRVNFVFwiOlxuICAgICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zICYmIGNvbmZpZy5kaWFsZWN0T3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgIGNvbm5lY3Rpb24ub24oXCJkZWJ1Z1wiLCBkZWJ1Z1RlZGlvdXMubG9nLmJpbmQoZGVidWdUZWRpb3VzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWVycm9yLmNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgIGNhc2UgXCJFU09DS0VUXCI6XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjb25uZWN0IEVIT1NUVU5SRUFDSFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImNvbm5lY3QgRU5FVFVOUkVBQ0hcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjb25uZWN0IEVBRERSTk9UQVZBSUxcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjb25uZWN0IEVBRk5PU1VQUE9SVFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImdldGFkZHJpbmZvIEVOT1RGT1VORFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90Rm91bmRFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiY29ubmVjdCBFQ09OTlJFRlVTRURcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgY2FzZSBcIkVSX0FDQ0VTU19ERU5JRURfRVJST1JcIjpcbiAgICAgICAgY2FzZSBcIkVMT0dJTlwiOlxuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyb3IpO1xuICAgICAgICBjYXNlIFwiRUlOVkFMXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycm9yKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xuICAgIGlmIChjb25uZWN0aW9uLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25uZWN0aW9uLnF1ZXVlLmNsb3NlKCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25uZWN0aW9uLm9uKFwiZW5kXCIsIHJlc29sdmUpO1xuICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICB9KTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgKGNvbm5lY3Rpb24ubG9nZ2VkSW4gfHwgY29ubmVjdGlvbi5zdGF0ZS5uYW1lID09PSBcIkxvZ2dlZEluXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://msdn.microsoft.com/en-us/library/ms187752%28v=sql.110%29.aspx\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`MSSQL does not support '${dataType.key}' with options. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.mssql = [43];\n  BaseTypes.STRING.types.mssql = [231, 173];\n  BaseTypes.CHAR.types.mssql = [175];\n  BaseTypes.TEXT.types.mssql = false;\n  BaseTypes.TINYINT.types.mssql = [30];\n  BaseTypes.SMALLINT.types.mssql = [34];\n  BaseTypes.MEDIUMINT.types.mssql = false;\n  BaseTypes.INTEGER.types.mssql = [38];\n  BaseTypes.BIGINT.types.mssql = false;\n  BaseTypes.FLOAT.types.mssql = [109];\n  BaseTypes.TIME.types.mssql = [41];\n  BaseTypes.DATEONLY.types.mssql = [40];\n  BaseTypes.BOOLEAN.types.mssql = [104];\n  BaseTypes.BLOB.types.mssql = [165];\n  BaseTypes.DECIMAL.types.mssql = [106];\n  BaseTypes.UUID.types.mssql = false;\n  BaseTypes.ENUM.types.mssql = false;\n  BaseTypes.REAL.types.mssql = [109];\n  BaseTypes.DOUBLE.types.mssql = [109];\n  BaseTypes.GEOMETRY.types.mssql = false;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          warn(\"MSSQL does not support BLOB with the `length` = `tiny` option. `VARBINARY(256)` will be used instead.\");\n          return \"VARBINARY(256)\";\n        }\n        warn(\"MSSQL does not support BLOB with the `length` option. `VARBINARY(MAX)` will be used instead.\");\n      }\n      return \"VARBINARY(MAX)\";\n    }\n    _hexify(hex) {\n      return `0x${hex}`;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (!this._binary) {\n        return `NVARCHAR(${this._length})`;\n      }\n      return `BINARY(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return BLOB.prototype._stringify(value);\n      }\n      return options.escape(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._binary ? Buffer.from(value) : value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        if (this._length.toLowerCase() === \"tiny\") {\n          warn(\"MSSQL does not support TEXT with the `length` = `tiny` option. `NVARCHAR(256)` will be used instead.\");\n          return \"NVARCHAR(256)\";\n        }\n        warn(\"MSSQL does not support TEXT with the `length` option. `NVARCHAR(MAX)` will be used instead.\");\n      }\n      return \"NVARCHAR(MAX)\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BIT\";\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36)\";\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"GETDATE()\";\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"DATETIMEOFFSET\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"MSSQL does not support REAL with options. Plain `REAL` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"MSSQL does not support Float with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"MSSQL does not support Float unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"MSSQL does not support Float zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR(255)\";\n    }\n  }\n  return {\n    BLOB,\n    BOOLEAN,\n    ENUM,\n    STRING,\n    UUID,\n    DATE,\n    DATEONLY,\n    NOW,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    REAL,\n    FLOAT,\n    TEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGFBQWEseUJBQXlCLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9kYXRhLXR5cGVzLmpzPzY3ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHZvaWQgMCwgXCJodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zMTg3NzUyJTI4dj1zcWwuMTEwJTI5LmFzcHhcIik7XG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX2xlbmd0aCB8fCBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCB8fCBkYXRhVHlwZS5fdW5zaWduZWQgfHwgZGF0YVR5cGUuX3plcm9maWxsKSB7XG4gICAgICB3YXJuKGBNU1NRTCBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggb3B0aW9ucy4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLm1zc3FsID0gWzQzXTtcbiAgQmFzZVR5cGVzLlNUUklORy50eXBlcy5tc3NxbCA9IFsyMzEsIDE3M107XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm1zc3FsID0gWzE3NV07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm1zc3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm1zc3FsID0gWzMwXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm1zc3FsID0gWzM0XTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5tc3NxbCA9IGZhbHNlO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5tc3NxbCA9IFszOF07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm1zc3FsID0gWzEwOV07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLm1zc3FsID0gWzQxXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm1zc3FsID0gWzQwXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMubXNzcWwgPSBbMTA0XTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMubXNzcWwgPSBbMTY1XTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMubXNzcWwgPSBbMTA2XTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJFQUwudHlwZXMubXNzcWwgPSBbMTA5XTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5tc3NxbCA9IFsxMDldO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubXNzcWwgPSBmYWxzZTtcbiAgY2xhc3MgQkxPQiBleHRlbmRzIEJhc2VUeXBlcy5CTE9CIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSBcInRpbnlcIikge1xuICAgICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEJMT0Igd2l0aCB0aGUgYGxlbmd0aGAgPSBgdGlueWAgb3B0aW9uLiBgVkFSQklOQVJZKDI1NilgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICByZXR1cm4gXCJWQVJCSU5BUlkoMjU2KVwiO1xuICAgICAgICB9XG4gICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEJMT0Igd2l0aCB0aGUgYGxlbmd0aGAgb3B0aW9uLiBgVkFSQklOQVJZKE1BWClgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlZBUkJJTkFSWShNQVgpXCI7XG4gICAgfVxuICAgIF9oZXhpZnkoaGV4KSB7XG4gICAgICByZXR1cm4gYDB4JHtoZXh9YDtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU1RSSU5HIGV4dGVuZHMgQmFzZVR5cGVzLlNUUklORyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAoIXRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYE5WQVJDSEFSKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBCSU5BUlkoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIEJMT0IucHJvdG90eXBlLl9zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlKTtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX2JpbmFyeSA/IEJ1ZmZlci5mcm9tKHZhbHVlKSA6IHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgU1RSSU5HLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlbmd0aC50b0xvd2VyQ2FzZSgpID09PSBcInRpbnlcIikge1xuICAgICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCB0aGUgYGxlbmd0aGAgPSBgdGlueWAgb3B0aW9uLiBgTlZBUkNIQVIoMjU2KWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICAgIHJldHVybiBcIk5WQVJDSEFSKDI1NilcIjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggdGhlIGBsZW5ndGhgIG9wdGlvbi4gYE5WQVJDSEFSKE1BWClgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIk5WQVJDSEFSKE1BWClcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJJVFwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ0hBUigzNilcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTk9XIGV4dGVuZHMgQmFzZVR5cGVzLk5PVyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJHRVREQVRFKClcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkRBVEVUSU1FT0ZGU0VUXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEVPTkxZIGV4dGVuZHMgQmFzZVR5cGVzLkRBVEVPTkxZIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiBtb21lbnQodmFsdWUpLmZvcm1hdChcIllZWVktTU0tRERcIik7XG4gICAgfVxuICB9XG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVElOWUlOVCBleHRlbmRzIEJhc2VUeXBlcy5USU5ZSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGggfHwgdGhpcy5vcHRpb25zLmxlbmd0aCB8fCB0aGlzLl91bnNpZ25lZCB8fCB0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBSRUFMIHdpdGggb3B0aW9ucy4gUGxhaW4gYFJFQUxgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsYXNzIEZMT0FUIGV4dGVuZHMgQmFzZVR5cGVzLkZMT0FUIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIGRlY2ltYWxzKSB7XG4gICAgICBzdXBlcihsZW5ndGgsIGRlY2ltYWxzKTtcbiAgICAgIGlmICh0aGlzLl9kZWNpbWFscykge1xuICAgICAgICB3YXJuKFwiTVNTUUwgZG9lcyBub3Qgc3VwcG9ydCBGbG9hdCB3aXRoIGRlY2ltYWxzLiBQbGFpbiBgRkxPQVRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9wdGlvbnMubGVuZ3RoID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHdhcm4oXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IEZsb2F0IHVuc2lnbmVkLiBgVU5TSUdORURgIHdhcyByZW1vdmVkLlwiKTtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIk1TU1FMIGRvZXMgbm90IHN1cHBvcnQgRmxvYXQgemVyb2ZpbGwuIGBaRVJPRklMTGAgd2FzIHJlbW92ZWQuXCIpO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlZBUkNIQVIoMjU1KVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIEJMT0IsXG4gICAgQk9PTEVBTixcbiAgICBFTlVNLFxuICAgIFNUUklORyxcbiAgICBVVUlELFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgTk9XLFxuICAgIFRJTllJTlQsXG4gICAgU01BTExJTlQsXG4gICAgSU5URUdFUixcbiAgICBCSUdJTlQsXG4gICAgUkVBTCxcbiAgICBGTE9BVCxcbiAgICBURVhUXG4gIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mssql);\nconst { MSSqlQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-interface.js\");\nclass MssqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MSSqlQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nMssqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  DEFAULT: true,\n  \"DEFAULT VALUES\": true,\n  \"LIMIT ON UPDATE\": true,\n  \"ORDER NULLS\": false,\n  lock: false,\n  transactions: true,\n  migrations: false,\n  returnValues: {\n    output: true\n  },\n  schemas: true,\n  autoIncrement: {\n    identityInsert: true,\n    defaultValue: false,\n    update: false\n  },\n  constraints: {\n    restrict: false,\n    default: true\n  },\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: true,\n    using: false,\n    where: true\n  },\n  NUMERIC: true,\n  tmpTableTrigger: true\n});\nMssqlDialect.prototype.defaultVersion = \"12.0.2000\";\nMssqlDialect.prototype.Query = Query;\nMssqlDialect.prototype.name = \"mssql\";\nMssqlDialect.prototype.TICK_CHAR = '\"';\nMssqlDialect.prototype.TICK_CHAR_LEFT = \"[\";\nMssqlDialect.prototype.TICK_CHAR_RIGHT = \"]\";\nMssqlDialect.prototype.DataTypes = DataTypes;\nmodule.exports = MssqlDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDJFQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFtQjtBQUNsRCxrQkFBa0IsdUdBQWlDO0FBQ25ELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvaW5kZXguanM/NzY2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgQWJzdHJhY3REaWFsZWN0ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0XCIpO1xuY29uc3QgQ29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBRdWVyeSA9IHJlcXVpcmUoXCIuL3F1ZXJ5XCIpO1xuY29uc3QgUXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5tc3NxbDtcbmNvbnN0IHsgTVNTcWxRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgTXNzcWxEaWFsZWN0IGV4dGVuZHMgQWJzdHJhY3REaWFsZWN0IHtcbiAgY29uc3RydWN0b3Ioc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IENvbm5lY3Rpb25NYW5hZ2VyKHRoaXMsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5xdWVyeUdlbmVyYXRvciA9IG5ldyBRdWVyeUdlbmVyYXRvcih7XG4gICAgICBfZGlhbGVjdDogdGhpcyxcbiAgICAgIHNlcXVlbGl6ZVxuICAgIH0pO1xuICAgIHRoaXMucXVlcnlJbnRlcmZhY2UgPSBuZXcgTVNTcWxRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBERUZBVUxUOiB0cnVlLFxuICBcIkRFRkFVTFQgVkFMVUVTXCI6IHRydWUsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IHRydWUsXG4gIFwiT1JERVIgTlVMTFNcIjogZmFsc2UsXG4gIGxvY2s6IGZhbHNlLFxuICB0cmFuc2FjdGlvbnM6IHRydWUsXG4gIG1pZ3JhdGlvbnM6IGZhbHNlLFxuICByZXR1cm5WYWx1ZXM6IHtcbiAgICBvdXRwdXQ6IHRydWVcbiAgfSxcbiAgc2NoZW1hczogdHJ1ZSxcbiAgYXV0b0luY3JlbWVudDoge1xuICAgIGlkZW50aXR5SW5zZXJ0OiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gICAgdXBkYXRlOiBmYWxzZVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIHJlc3RyaWN0OiBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlXG4gIH0sXG4gIGluZGV4OiB7XG4gICAgY29sbGF0ZTogZmFsc2UsXG4gICAgbGVuZ3RoOiBmYWxzZSxcbiAgICBwYXJzZXI6IGZhbHNlLFxuICAgIHR5cGU6IHRydWUsXG4gICAgdXNpbmc6IGZhbHNlLFxuICAgIHdoZXJlOiB0cnVlXG4gIH0sXG4gIE5VTUVSSUM6IHRydWUsXG4gIHRtcFRhYmxlVHJpZ2dlcjogdHJ1ZVxufSk7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCIxMi4wLjIwMDBcIjtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwibXNzcWxcIjtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX0xFRlQgPSBcIltcIjtcbk1zc3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gXCJdXCI7XG5Nc3NxbERpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbm1vZHVsZS5leHBvcnRzID0gTXNzcWxEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst TableHints = __webpack_require__(/*! ../../table-hints */ \"(rsc)/./node_modules/sequelize/lib/table-hints.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst randomBytes = (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({ collate: null }, options);\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : \"\";\n    return [\n      \"IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =\",\n      wrapSingleQuote(databaseName),\n      \")\",\n      \"BEGIN\",\n      \"CREATE DATABASE\",\n      this.quoteIdentifier(databaseName),\n      `${collation};`,\n      \"END;\"\n    ].join(\" \");\n  }\n  dropDatabaseQuery(databaseName) {\n    return [\n      \"IF EXISTS (SELECT * FROM sys.databases WHERE name =\",\n      wrapSingleQuote(databaseName),\n      \")\",\n      \"BEGIN\",\n      \"DROP DATABASE\",\n      this.quoteIdentifier(databaseName),\n      \";\",\n      \"END;\"\n    ].join(\" \");\n  }\n  createSchema(schema) {\n    return [\n      \"IF NOT EXISTS (SELECT schema_name\",\n      \"FROM information_schema.schemata\",\n      \"WHERE schema_name =\",\n      wrapSingleQuote(schema),\n      \")\",\n      \"BEGIN\",\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      \"END;\"\n    ].join(\" \");\n  }\n  dropSchema(schema) {\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      \"IF EXISTS (SELECT schema_name\",\n      \"FROM information_schema.schemata\",\n      \"WHERE schema_name =\",\n      quotedSchema,\n      \")\",\n      \"BEGIN\",\n      \"DECLARE @id INT, @ms_sql NVARCHAR(2000);\",\n      \"DECLARE @cascade TABLE (\",\n      \"id INT NOT NULL IDENTITY PRIMARY KEY,\",\n      \"ms_sql NVARCHAR(2000) NOT NULL );\",\n      \"INSERT INTO @cascade ( ms_sql )\",\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      \"FROM sys.objects o\",\n      \"JOIN sys.schemas s on o.schema_id = s.schema_id\",\n      \"LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id\",\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \",\n      quotedSchema,\n      \"ORDER BY o.type ASC;\",\n      \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\",\n      \"WHILE @id IS NOT NULL\",\n      \"BEGIN\",\n      \"BEGIN TRY EXEC sp_executesql @ms_sql; END TRY\",\n      \"BEGIN CATCH BREAK; THROW; END CATCH;\",\n      \"DELETE FROM @cascade WHERE id = @id;\",\n      \"SELECT @id = NULL, @ms_sql = NULL;\",\n      \"SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;\",\n      \"END\",\n      \"EXEC sp_executesql N'DROP SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      \"END;\"\n    ].join(\" \");\n  }\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      \")\",\n      \"AND\",\n      '\"s\".\"name\" NOT LIKE',\n      \"'db_%'\"\n    ].join(\" \");\n  }\n  versionQuery() {\n    return [\n      \"DECLARE @ms_ver NVARCHAR(20);\",\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(\" \");\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [], foreignKeys = {}, attributesClauseParts = [];\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          dataType = commentMatch[1];\n        }\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (dataType.includes(\"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n          }\n        } else if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`);\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(\", \")})`,\n      \";\",\n      commentStr\n    ]);\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      \"SELECT\",\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID('[' + c.TABLE_SCHEMA + '].[' + c.TABLE_NAME + ']'), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      \"FROM\",\n      \"INFORMATION_SCHEMA.TABLES t\",\n      \"INNER JOIN\",\n      \"INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA\",\n      \"LEFT JOIN (SELECT tc.table_schema, tc.table_name, \",\n      \"cu.column_name, tc.CONSTRAINT_TYPE \",\n      \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc \",\n      \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu \",\n      \"ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name \",\n      \"and tc.constraint_name=cu.constraint_name \",\n      \"and tc.CONSTRAINT_TYPE='PRIMARY KEY') pk \",\n      \"ON pk.table_schema=c.table_schema \",\n      \"AND pk.table_name=c.table_name \",\n      \"AND pk.column_name=c.column_name \",\n      \"INNER JOIN sys.columns AS sc\",\n      \"ON sc.object_id = OBJECT_ID('[' + t.TABLE_SCHEMA + '].[' + t.TABLE_NAME + ']') AND sc.name = c.column_name\",\n      \"LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id\",\n      \"AND prop.minor_id = sc.column_id\",\n      \"AND prop.name = 'MS_Description'\",\n      \"WHERE t.TABLE_NAME =\",\n      wrapSingleQuote(tableName)\n    ].join(\" \");\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n    return sql;\n  }\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || \"dbo\";\n    return `SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${this.escape(tableName)} AND TABLE_SCHEMA = ${this.escape(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      \"DROP TABLE\",\n      quoteTbl,\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    let commentStr = \"\";\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      delete dataType[\"comment\"];\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: \"addColumn\" }),\n      \";\",\n      commentStr\n    ]);\n  }\n  commentTemplate(comment, table, column) {\n    return ` EXEC sp_addextendedproperty @name = N'MS_Description', @value = ${this.escape(comment)}, @level0type = N'Schema', @level0name = 'dbo', @level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, @level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP COLUMN\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [], constraintString = [];\n    let commentString = \"\";\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes(\"COMMENT \")) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace(\"COMMENT\", \"\").trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        definition = commentMatch[1];\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, \"\")}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(\", \")}`,\n      constraintString.length && `ADD ${constraintString.join(\", \")}`,\n      \";\",\n      commentString\n    ]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      \"EXEC sp_rename\",\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      \";\"\n    ]);\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n    let needIdentityInsertWrapper = false, outputFragment = \"\";\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n      outputFragment = returnValues.outputFragment;\n    }\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n    attrValueHashes.forEach((attrValueHash) => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach((attrValueHash) => {\n        tuples.push(`(${allAttributes.map((key) => this.escape(attrValueHash[key])).join(\",\")})`);\n      });\n      const quotedAttributes = allAttributes.map((attr) => this.quoteIdentifier(attr)).join(\",\");\n      allQueries.push((tupleStr) => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map((v) => typeof v === \"string\" ? v : v(tupleStr)).join(\";\");\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(\";\");\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace(\"UPDATE\", updateArgs);\n    }\n    return sql;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map((key) => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map((key) => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    identityAttrs.forEach((key) => {\n      if (insertValues[key] && insertValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n      }\n    });\n    const clauses = where[Op.or].filter((clause) => {\n      let valid = true;\n      for (const key in clause) {\n        if (typeof clause[key] === \"undefined\" || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = (array) => {\n      return array.map((key) => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter((key) => !identityAttrs.includes(key)).map((key) => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    });\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses.join(\", \")}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n    return Utils.joinSQLFragments([\n      \"DELETE\",\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      \"FROM\",\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      \";\",\n      \"SELECT @@ROWCOUNT AS AFFECTEDROWS\",\n      \";\"\n    ]);\n  }\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"MSSQL does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n        attribute.onUpdate = \"\";\n      }\n    }\n    let template;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map((value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    template = attribute.type.toString();\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += \" NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" IDENTITY(1,1)\";\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {}, existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n          attribute.onUpdate = \"\";\n        }\n      }\n      if (key && !attribute.field)\n        attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${\"SELECT constraint_name = OBJ.NAME, constraintName = OBJ.NAME, \"}${catalogName ? `constraintCatalog = '${catalogName}', ` : \"\"}constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), tableName = TB.NAME, tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${catalogName ? `tableCatalog = '${catalogName}', ` : \"\"}columnName = COL.NAME, referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${catalogName ? `referencedCatalog = '${catalogName}', ` : \"\"}referencedTableName = RTB.NAME, referencedColumnName = RCOL.NAME FROM sys.foreign_key_columns FKC INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID`;\n  }\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)} WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      \"WHERE\",\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      \"AND\",\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      \"SELECT K.TABLE_NAME AS tableName,\",\n      \"K.COLUMN_NAME AS columnName,\",\n      \"K.CONSTRAINT_NAME AS constraintName\",\n      \"FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C\",\n      \"JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K\",\n      \"ON C.TABLE_NAME = K.TABLE_NAME\",\n      \"AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG\",\n      \"AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA\",\n      \"AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME\",\n      \"WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'\",\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      \";\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      \"SELECT name FROM sys.default_constraints\",\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      \";\"\n    ]);\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP CONSTRAINT\",\n      this.quoteIdentifier(constraintName),\n      \";\"\n    ]);\n  }\n  setIsolationLevelQuery() {\n  }\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, \"11.0.0\");\n    if (isSQLServer2008 && options.offset) {\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n      const tmpTable = mainTableAs || \"OffsetTable\";\n      if (options.include) {\n        const subQuery = options.subQuery === void 0 ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n        return Utils.joinSQLFragments([\n          \"SELECT TOP 100 PERCENT\",\n          attributes.join(\", \"),\n          \"FROM (\",\n          [\n            \"SELECT\",\n            options.limit && `TOP ${options.limit}`,\n            \"* FROM (\",\n            [\n              \"SELECT ROW_NUMBER() OVER (\",\n              [\n                \"ORDER BY\",\n                orders.mainQueryOrder.join(\", \")\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                \"SELECT DISTINCT\",\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        \"SELECT TOP 100 PERCENT\",\n        attributes.join(\", \"),\n        \"FROM (\",\n        [\n          \"SELECT\",\n          options.limit && `TOP ${options.limit}`,\n          \"* FROM (\",\n          [\n            \"SELECT ROW_NUMBER() OVER (\",\n            [\n              \"ORDER BY\",\n              orders.mainQueryOrder.join(\", \")\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(\", \"),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n  addLimitAndOffset(options, model) {\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, \"11.0.0\")) {\n      return \"\";\n    }\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === void 0 ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation : options.subQuery;\n    let fragment = \"\";\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!options.order || options.order.length === 0 || options.include && orders.subQueryOrder.length === 0) {\n        let primaryKey = model.primaryKeyField;\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(primaryKey)}`;\n        const aliasedAttribute = (options.attributes || []).find((attr) => Array.isArray(attr) && attr[1] && (attr[0] === primaryKey || attr[1] === primaryKey));\n        if (aliasedAttribute) {\n          const modelName = this.quoteIdentifier(options.tableAs || model.name);\n          const alias = this._getAliasForField(modelName, aliasedAttribute[1], options);\n          primaryKey = new Utils.Col(alias || aliasedAttribute[1]);\n        }\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = (options.order || []).map((order) => {\n            const value = Array.isArray(order) ? order[0] : order;\n            if (value instanceof Utils.Col) {\n              return value.col;\n            }\n            if (value instanceof Utils.Literal) {\n              return value.val;\n            }\n            return value;\n          });\n          const primaryKeyFieldAlreadyPresent = orderFieldNames.some((fieldName) => fieldName === (primaryKey.col || primaryKey));\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? \", \" : \" ORDER BY \";\n            fragment += tablePkFragment;\n          }\n        }\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force) {\n    return `[${identifier.replace(/[[\\]']+/g, \"\")}]`;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\nmodule.exports = MSSQLQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDLCtCQUErQixtQkFBTyxDQUFDLDRHQUE2QjtBQUNwRSxvQkFBb0IseURBQTZCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3BDO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGVBQWU7QUFDOUMsbURBQW1ELDZCQUE2QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5RUFBeUU7QUFDekU7QUFDQTtBQUNBLDZDQUE2QztBQUM3QywwQkFBMEIsT0FBTyxVQUFVO0FBQzNDLDJDQUEyQztBQUMzQyx5Q0FBeUM7QUFDekMseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVHO0FBQ0EsWUFBWTtBQUNaLDBDQUEwQyw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDNUc7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx3Q0FBd0MsNEJBQTRCLEVBQUUsU0FBUztBQUMvRTtBQUNBLFVBQVU7QUFDVix3Q0FBd0MsNEJBQTRCLEVBQUUsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSxtREFBbUQsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ3BLO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkJBQTJCLElBQUksa0JBQWtCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QyxzQkFBc0IsaUJBQWlCLEdBQUcsaUNBQWlDO0FBQzNFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCLElBQUksd0JBQXdCO0FBQ2pGO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsd0JBQXdCLHFCQUFxQix3QkFBd0I7QUFDbk07QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxQkFBcUIsd0ZBQXdGLDRCQUE0QiwyQ0FBMkMsOEJBQThCO0FBQ2pTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlLElBQUksNENBQTRDO0FBQzdHLFFBQVE7QUFDUiwyQkFBMkIsZ0JBQWdCLEVBQUUsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCLEdBQUcsV0FBVztBQUNuRCxVQUFVLFFBQVE7QUFDbEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZLEVBQUUsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLHNFQUFzRTtBQUM5RixPQUFPO0FBQ1A7QUFDQSxtREFBbUQsYUFBYSxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixTQUFTLFVBQVU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsZ0RBQWdELGFBQWEsSUFBSSxFQUFFLGlCQUFpQixzQkFBc0IsYUFBYSxJQUFJO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFVBQVU7QUFDMUQsZ0RBQWdELFVBQVU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCLEdBQUcsS0FBSyxJQUFJLGlCQUFpQixHQUFHLElBQUk7QUFDdkUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixHQUFHLEtBQUssSUFBSSxNQUFNO0FBQ25ELEtBQUs7QUFDTCw2RkFBNkYsaUNBQWlDO0FBQzlILDhCQUE4QixpQkFBaUIsV0FBVyxvQkFBb0I7QUFDOUUsOEJBQThCLGlCQUFpQixvQkFBb0Isa0JBQWtCLFNBQVMsaUJBQWlCLE9BQU8saUJBQWlCLEdBQUcsaUJBQWlCLE9BQU8sY0FBYztBQUNoTCxpQkFBaUIsZUFBZSwrQkFBK0IsZUFBZSwyQkFBMkI7QUFDekc7QUFDQSxxQ0FBcUMsaUJBQWlCLElBQUksRUFBRSxPQUFPLHNCQUFzQixpQkFBaUIsSUFBSTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJCQUEyQixFQUFFO0FBQzlFO0FBQ0E7QUFDQSxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUsR0FBRyxnQ0FBZ0M7QUFDbkY7QUFDQSx5QkFBeUIsa0NBQWtDLEtBQUssaUNBQWlDO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QyxLQUFLO0FBQ3pFO0FBQ0EsT0FBTyxhQUFhO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEUsUUFBUTtBQUNSLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUUsRUFBRSxzQ0FBc0MsWUFBWSxVQUFVLCtHQUErRyxpQ0FBaUMsWUFBWSxVQUFVLDZFQUE2RSxzQ0FBc0MsWUFBWSxVQUFVO0FBQzViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBOEMsaUJBQWlCLDJCQUEyQjtBQUMzRztBQUNBLGdEQUFnRCw4QkFBOEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xELHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RCw0QkFBNEIsVUFBVTtBQUN0QyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pELGtGQUFrRixjQUFjO0FBQ2hHLG9DQUFvQyxZQUFZO0FBQ2hELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0NBQXdDO0FBQzdFO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSwrQ0FBK0MsaURBQWlEO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0RBQWtEO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxVQUFVLFFBQVEsS0FBSyxTQUFTO0FBQzVEO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBLG9CQUFvQixVQUFVLGtCQUFrQixPQUFPO0FBQ3ZEO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVEsS0FBSyxTQUFTO0FBQzFELDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0Esa0JBQWtCLFVBQVUsa0JBQWtCLE9BQU87QUFDckQ7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLDJCQUEyQixZQUFZO0FBQ3ZDLHFFQUFxRSw4QkFBOEI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDLEdBQUcsaUNBQWlDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvcXVlcnktZ2VuZXJhdG9yLmpzP2RhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBUYWJsZUhpbnRzID0gcmVxdWlyZShcIi4uLy4uL3RhYmxlLWhpbnRzXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCByYW5kb21CeXRlcyA9IHJlcXVpcmUoXCJjcnlwdG9cIikucmFuZG9tQnl0ZXM7XG5jb25zdCBzZW12ZXIgPSByZXF1aXJlKFwic2VtdmVyXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgdGhyb3dNZXRob2RVbmRlZmluZWQgPSBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gIHRocm93IG5ldyBFcnJvcihgVGhlIG1ldGhvZCBcIiR7bWV0aG9kTmFtZX1cIiBpcyBub3QgZGVmaW5lZCEgUGxlYXNlIGFkZCBpdCB0byB5b3VyIHNxbCBkaWFsZWN0LmApO1xufTtcbmNsYXNzIE1TU1FMUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoeyBjb2xsYXRlOiBudWxsIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbGxhdGlvbiA9IG9wdGlvbnMuY29sbGF0ZSA/IGBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gIDogXCJcIjtcbiAgICByZXR1cm4gW1xuICAgICAgXCJJRiBOT1QgRVhJU1RTIChTRUxFQ1QgKiBGUk9NIHN5cy5kYXRhYmFzZXMgV0hFUkUgbmFtZSA9XCIsXG4gICAgICB3cmFwU2luZ2xlUXVvdGUoZGF0YWJhc2VOYW1lKSxcbiAgICAgIFwiKVwiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJDUkVBVEUgREFUQUJBU0VcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksXG4gICAgICBgJHtjb2xsYXRpb259O2AsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiSUYgRVhJU1RTIChTRUxFQ1QgKiBGUk9NIHN5cy5kYXRhYmFzZXMgV0hFUkUgbmFtZSA9XCIsXG4gICAgICB3cmFwU2luZ2xlUXVvdGUoZGF0YWJhc2VOYW1lKSxcbiAgICAgIFwiKVwiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJEUk9QIERBVEFCQVNFXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLFxuICAgICAgXCI7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBbXG4gICAgICBcIklGIE5PVCBFWElTVFMgKFNFTEVDVCBzY2hlbWFfbmFtZVwiLFxuICAgICAgXCJGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5zY2hlbWF0YVwiLFxuICAgICAgXCJXSEVSRSBzY2hlbWFfbmFtZSA9XCIsXG4gICAgICB3cmFwU2luZ2xlUXVvdGUoc2NoZW1hKSxcbiAgICAgIFwiKVwiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJFWEVDIHNwX2V4ZWN1dGVzcWwgTidDUkVBVEUgU0NIRU1BXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpLFxuICAgICAgXCI7J1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgY29uc3QgcXVvdGVkU2NoZW1hID0gd3JhcFNpbmdsZVF1b3RlKHNjaGVtYSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiSUYgRVhJU1RTIChTRUxFQ1Qgc2NoZW1hX25hbWVcIixcbiAgICAgIFwiRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEuc2NoZW1hdGFcIixcbiAgICAgIFwiV0hFUkUgc2NoZW1hX25hbWUgPVwiLFxuICAgICAgcXVvdGVkU2NoZW1hLFxuICAgICAgXCIpXCIsXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIkRFQ0xBUkUgQGlkIElOVCwgQG1zX3NxbCBOVkFSQ0hBUigyMDAwKTtcIixcbiAgICAgIFwiREVDTEFSRSBAY2FzY2FkZSBUQUJMRSAoXCIsXG4gICAgICBcImlkIElOVCBOT1QgTlVMTCBJREVOVElUWSBQUklNQVJZIEtFWSxcIixcbiAgICAgIFwibXNfc3FsIE5WQVJDSEFSKDIwMDApIE5PVCBOVUxMICk7XCIsXG4gICAgICBcIklOU0VSVCBJTlRPIEBjYXNjYWRlICggbXNfc3FsIClcIixcbiAgICAgIFwiU0VMRUNUIENBU0UgV0hFTiBvLnR5cGUgSU4gKCdGJywnUEsnKVwiLFxuICAgICAgXCJUSEVOIE4nQUxURVIgVEFCTEUgWycrIHMubmFtZSArIE4nXS5bJyArIHAubmFtZSArIE4nXSBEUk9QIENPTlNUUkFJTlQgWycgKyBvLm5hbWUgKyBOJ10nXCIsXG4gICAgICBcIkVMU0UgTidEUk9QIFRBQkxFIFsnKyBzLm5hbWUgKyBOJ10uWycgKyBvLm5hbWUgKyBOJ10nIEVORFwiLFxuICAgICAgXCJGUk9NIHN5cy5vYmplY3RzIG9cIixcbiAgICAgIFwiSk9JTiBzeXMuc2NoZW1hcyBzIG9uIG8uc2NoZW1hX2lkID0gcy5zY2hlbWFfaWRcIixcbiAgICAgIFwiTEVGVCBPVVRFUiBKT0lOIHN5cy5vYmplY3RzIHAgb24gby5wYXJlbnRfb2JqZWN0X2lkID0gcC5vYmplY3RfaWRcIixcbiAgICAgIFwiV0hFUkUgby50eXBlIElOICgnRicsICdQSycsICdVJykgQU5EIHMubmFtZSA9IFwiLFxuICAgICAgcXVvdGVkU2NoZW1hLFxuICAgICAgXCJPUkRFUiBCWSBvLnR5cGUgQVNDO1wiLFxuICAgICAgXCJTRUxFQ1QgVE9QIDEgQGlkID0gaWQsIEBtc19zcWwgPSBtc19zcWwgRlJPTSBAY2FzY2FkZSBPUkRFUiBCWSBpZDtcIixcbiAgICAgIFwiV0hJTEUgQGlkIElTIE5PVCBOVUxMXCIsXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBcIkJFR0lOIFRSWSBFWEVDIHNwX2V4ZWN1dGVzcWwgQG1zX3NxbDsgRU5EIFRSWVwiLFxuICAgICAgXCJCRUdJTiBDQVRDSCBCUkVBSzsgVEhST1c7IEVORCBDQVRDSDtcIixcbiAgICAgIFwiREVMRVRFIEZST00gQGNhc2NhZGUgV0hFUkUgaWQgPSBAaWQ7XCIsXG4gICAgICBcIlNFTEVDVCBAaWQgPSBOVUxMLCBAbXNfc3FsID0gTlVMTDtcIixcbiAgICAgIFwiU0VMRUNUIFRPUCAxIEBpZCA9IGlkLCBAbXNfc3FsID0gbXNfc3FsIEZST00gQGNhc2NhZGUgT1JERVIgQlkgaWQ7XCIsXG4gICAgICBcIkVORFwiLFxuICAgICAgXCJFWEVDIHNwX2V4ZWN1dGVzcWwgTidEUk9QIFNDSEVNQVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKSxcbiAgICAgIFwiOydcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBbXG4gICAgICAnU0VMRUNUIFwibmFtZVwiIGFzIFwic2NoZW1hX25hbWVcIiBGUk9NIHN5cy5zY2hlbWFzIGFzIHMnLFxuICAgICAgJ1dIRVJFIFwic1wiLlwibmFtZVwiIE5PVCBJTiAoJyxcbiAgICAgIFwiJ0lORk9STUFUSU9OX1NDSEVNQScsICdkYm8nLCAnZ3Vlc3QnLCAnc3lzJywgJ2FyY2hpdmUnXCIsXG4gICAgICBcIilcIixcbiAgICAgIFwiQU5EXCIsXG4gICAgICAnXCJzXCIuXCJuYW1lXCIgTk9UIExJS0UnLFxuICAgICAgXCInZGJfJSdcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBbXG4gICAgICBcIkRFQ0xBUkUgQG1zX3ZlciBOVkFSQ0hBUigyMCk7XCIsXG4gICAgICBcIlNFVCBAbXNfdmVyID0gUkVWRVJTRShDT05WRVJUKE5WQVJDSEFSKDIwKSwgU0VSVkVSUFJPUEVSVFkoJ1Byb2R1Y3RWZXJzaW9uJykpKTtcIixcbiAgICAgIFwiU0VMRUNUIFJFVkVSU0UoU1VCU1RSSU5HKEBtc192ZXIsIENIQVJJTkRFWCgnLicsIEBtc192ZXIpKzEsIDIwKSkgQVMgJ3ZlcnNpb24nXCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXSwgZm9yZWlnbktleXMgPSB7fSwgYXR0cmlidXRlc0NsYXVzZVBhcnRzID0gW107XG4gICAgbGV0IGNvbW1lbnRTdHIgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGxldCBkYXRhVHlwZSA9IGF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiQ09NTUVOVCBcIikpIHtcbiAgICAgICAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKENPTU1FTlQuKikkLyk7XG4gICAgICAgICAgY29uc3QgY29tbWVudFRleHQgPSBjb21tZW50TWF0Y2hbMl0ucmVwbGFjZShcIkNPTU1FTlRcIiwgXCJcIikudHJpbSgpO1xuICAgICAgICAgIGNvbW1lbnRTdHIgKz0gdGhpcy5jb21tZW50VGVtcGxhdGUoY29tbWVudFRleHQsIHRhYmxlTmFtZSwgYXR0cik7XG4gICAgICAgICAgZGF0YVR5cGUgPSBjb21tZW50TWF0Y2hbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgICBwcmltYXJ5S2V5cy5wdXNoKGF0dHIpO1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV0ucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpfWApO1xuICAgICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGUucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXX1gKTtcbiAgICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2VQYXJ0cy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKFwiLCBcIik7XG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMsIGluZGV4TmFtZSkgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbmRleE5hbWUgPSBgdW5pcV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5zLmZpZWxkcy5qb2luKFwiX1wiKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgQ09OU1RSQUlOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9IFVOSVFVRSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZVBhcnRzLnB1c2goYFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBma2V5IGluIGZvcmVpZ25LZXlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSkge1xuICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlUGFydHMucHVzaChgRk9SRUlHTiBLRVkgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZmtleSl9KSAke2ZvcmVpZ25LZXlzW2ZrZXldfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBgSUYgT0JKRUNUX0lEKCcke3F1b3RlZFRhYmxlTmFtZX0nLCAnVScpIElTIE5VTExgLFxuICAgICAgYENSRUFURSBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX0gKCR7YXR0cmlidXRlc0NsYXVzZVBhcnRzLmpvaW4oXCIsIFwiKX0pYCxcbiAgICAgIFwiO1wiLFxuICAgICAgY29tbWVudFN0clxuICAgIF0pO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIGxldCBzcWwgPSBbXG4gICAgICBcIlNFTEVDVFwiLFxuICAgICAgXCJjLkNPTFVNTl9OQU1FIEFTICdOYW1lJyxcIixcbiAgICAgIFwiYy5EQVRBX1RZUEUgQVMgJ1R5cGUnLFwiLFxuICAgICAgXCJjLkNIQVJBQ1RFUl9NQVhJTVVNX0xFTkdUSCBBUyAnTGVuZ3RoJyxcIixcbiAgICAgIFwiYy5JU19OVUxMQUJMRSBhcyAnSXNOdWxsJyxcIixcbiAgICAgIFwiQ09MVU1OX0RFRkFVTFQgQVMgJ0RlZmF1bHQnLFwiLFxuICAgICAgXCJway5DT05TVFJBSU5UX1RZUEUgQVMgJ0NvbnN0cmFpbnQnLFwiLFxuICAgICAgXCJDT0xVTU5QUk9QRVJUWShPQkpFQ1RfSUQoJ1snICsgYy5UQUJMRV9TQ0hFTUEgKyAnXS5bJyArIGMuVEFCTEVfTkFNRSArICddJyksIGMuQ09MVU1OX05BTUUsICdJc0lkZW50aXR5JykgYXMgJ0lzSWRlbnRpdHknLFwiLFxuICAgICAgXCJDQVNUKHByb3AudmFsdWUgQVMgTlZBUkNIQVIpIEFTICdDb21tZW50J1wiLFxuICAgICAgXCJGUk9NXCIsXG4gICAgICBcIklORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgdFwiLFxuICAgICAgXCJJTk5FUiBKT0lOXCIsXG4gICAgICBcIklORk9STUFUSU9OX1NDSEVNQS5DT0xVTU5TIGMgT04gdC5UQUJMRV9OQU1FID0gYy5UQUJMRV9OQU1FIEFORCB0LlRBQkxFX1NDSEVNQSA9IGMuVEFCTEVfU0NIRU1BXCIsXG4gICAgICBcIkxFRlQgSk9JTiAoU0VMRUNUIHRjLnRhYmxlX3NjaGVtYSwgdGMudGFibGVfbmFtZSwgXCIsXG4gICAgICBcImN1LmNvbHVtbl9uYW1lLCB0Yy5DT05TVFJBSU5UX1RZUEUgXCIsXG4gICAgICBcIkZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFX0NPTlNUUkFJTlRTIHRjIFwiLFxuICAgICAgXCJKT0lOIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFICBjdSBcIixcbiAgICAgIFwiT04gdGMudGFibGVfc2NoZW1hPWN1LnRhYmxlX3NjaGVtYSBhbmQgdGMudGFibGVfbmFtZT1jdS50YWJsZV9uYW1lIFwiLFxuICAgICAgXCJhbmQgdGMuY29uc3RyYWludF9uYW1lPWN1LmNvbnN0cmFpbnRfbmFtZSBcIixcbiAgICAgIFwiYW5kIHRjLkNPTlNUUkFJTlRfVFlQRT0nUFJJTUFSWSBLRVknKSBwayBcIixcbiAgICAgIFwiT04gcGsudGFibGVfc2NoZW1hPWMudGFibGVfc2NoZW1hIFwiLFxuICAgICAgXCJBTkQgcGsudGFibGVfbmFtZT1jLnRhYmxlX25hbWUgXCIsXG4gICAgICBcIkFORCBway5jb2x1bW5fbmFtZT1jLmNvbHVtbl9uYW1lIFwiLFxuICAgICAgXCJJTk5FUiBKT0lOIHN5cy5jb2x1bW5zIEFTIHNjXCIsXG4gICAgICBcIk9OIHNjLm9iamVjdF9pZCA9IE9CSkVDVF9JRCgnWycgKyB0LlRBQkxFX1NDSEVNQSArICddLlsnICsgdC5UQUJMRV9OQU1FICsgJ10nKSBBTkQgc2MubmFtZSA9IGMuY29sdW1uX25hbWVcIixcbiAgICAgIFwiTEVGVCBKT0lOIHN5cy5leHRlbmRlZF9wcm9wZXJ0aWVzIHByb3AgT04gcHJvcC5tYWpvcl9pZCA9IHNjLm9iamVjdF9pZFwiLFxuICAgICAgXCJBTkQgcHJvcC5taW5vcl9pZCA9IHNjLmNvbHVtbl9pZFwiLFxuICAgICAgXCJBTkQgcHJvcC5uYW1lID0gJ01TX0Rlc2NyaXB0aW9uJ1wiLFxuICAgICAgXCJXSEVSRSB0LlRBQkxFX05BTUUgPVwiLFxuICAgICAgd3JhcFNpbmdsZVF1b3RlKHRhYmxlTmFtZSlcbiAgICBdLmpvaW4oXCIgXCIpO1xuICAgIGlmIChzY2hlbWEpIHtcbiAgICAgIHNxbCArPSBgQU5EIHQuVEFCTEVfU0NIRU1BID0ke3dyYXBTaW5nbGVRdW90ZShzY2hlbWEpfWA7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgcmV0dXJuIGBFWEVDIHNwX3JlbmFtZSAke3RoaXMucXVvdGVUYWJsZShiZWZvcmUpfSwgJHt0aGlzLnF1b3RlVGFibGUoYWZ0ZXIpfTtgO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgVEFCTEVfTkFNRSwgVEFCTEVfU0NIRU1BIEZST00gSU5GT1JNQVRJT05fU0NIRU1BLlRBQkxFUyBXSEVSRSBUQUJMRV9UWVBFID0gJ0JBU0UgVEFCTEUnO1wiO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hTmFtZSA9IHRhYmxlLnNjaGVtYSB8fCBcImRib1wiO1xuICAgIHJldHVybiBgU0VMRUNUIFRBQkxFX05BTUUsIFRBQkxFX1NDSEVNQSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJyBBTkQgVEFCTEVfTkFNRSA9ICR7dGhpcy5lc2NhcGUodGFibGVOYW1lKX0gQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUoc2NoZW1hTmFtZSl9YDtcbiAgfVxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICBjb25zdCBxdW90ZVRibCA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBJRiBPQkpFQ1RfSUQoJyR7cXVvdGVUYmx9JywgJ1UnKSBJUyBOT1QgTlVMTGAsXG4gICAgICBcIkRST1AgVEFCTEVcIixcbiAgICAgIHF1b3RlVGJsLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIGRhdGFUeXBlLmZpZWxkID0ga2V5O1xuICAgIGxldCBjb21tZW50U3RyID0gXCJcIjtcbiAgICBpZiAoZGF0YVR5cGUuY29tbWVudCAmJiBfLmlzU3RyaW5nKGRhdGFUeXBlLmNvbW1lbnQpKSB7XG4gICAgICBjb21tZW50U3RyID0gdGhpcy5jb21tZW50VGVtcGxhdGUoZGF0YVR5cGUuY29tbWVudCwgdGFibGUsIGtleSk7XG4gICAgICBkZWxldGUgZGF0YVR5cGVbXCJjb21tZW50XCJdO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgXCJBRERcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSksXG4gICAgICB0aGlzLmF0dHJpYnV0ZVRvU1FMKGRhdGFUeXBlLCB7IGNvbnRleHQ6IFwiYWRkQ29sdW1uXCIgfSksXG4gICAgICBcIjtcIixcbiAgICAgIGNvbW1lbnRTdHJcbiAgICBdKTtcbiAgfVxuICBjb21tZW50VGVtcGxhdGUoY29tbWVudCwgdGFibGUsIGNvbHVtbikge1xuICAgIHJldHVybiBgIEVYRUMgc3BfYWRkZXh0ZW5kZWRwcm9wZXJ0eSBAbmFtZSA9IE4nTVNfRGVzY3JpcHRpb24nLCBAdmFsdWUgPSAke3RoaXMuZXNjYXBlKGNvbW1lbnQpfSwgQGxldmVsMHR5cGUgPSBOJ1NjaGVtYScsIEBsZXZlbDBuYW1lID0gJ2RibycsIEBsZXZlbDF0eXBlID0gTidUYWJsZScsIEBsZXZlbDFuYW1lID0gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0YWJsZSl9LCBAbGV2ZWwydHlwZSA9IE4nQ29sdW1uJywgQGxldmVsMm5hbWUgPSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbil9O2A7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1AgQ09MVU1OXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdLCBjb25zdHJhaW50U3RyaW5nID0gW107XG4gICAgbGV0IGNvbW1lbnRTdHJpbmcgPSBcIlwiO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBxdW90ZWRBdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJDT01NRU5UIFwiKSkge1xuICAgICAgICBjb25zdCBjb21tZW50TWF0Y2ggPSBkZWZpbml0aW9uLm1hdGNoKC9eKC4rKSAoQ09NTUVOVC4qKSQvKTtcbiAgICAgICAgY29uc3QgY29tbWVudFRleHQgPSBjb21tZW50TWF0Y2hbMl0ucmVwbGFjZShcIkNPTU1FTlRcIiwgXCJcIikudHJpbSgpO1xuICAgICAgICBjb21tZW50U3RyaW5nICs9IHRoaXMuY29tbWVudFRlbXBsYXRlKGNvbW1lbnRUZXh0LCB0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBkZWZpbml0aW9uID0gY29tbWVudE1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGNvbnN0cmFpbnRTdHJpbmcucHVzaChgRk9SRUlHTiBLRVkgKCR7cXVvdGVkQXR0ck5hbWV9KSAke2RlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHJpbmcucHVzaChgJHtxdW90ZWRBdHRyTmFtZX0gJHtkZWZpbml0aW9ufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJTdHJpbmcubGVuZ3RoICYmIGBBTFRFUiBDT0xVTU4gJHthdHRyU3RyaW5nLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgY29uc3RyYWludFN0cmluZy5sZW5ndGggJiYgYEFERCAke2NvbnN0cmFpbnRTdHJpbmcuam9pbihcIiwgXCIpfWAsXG4gICAgICBcIjtcIixcbiAgICAgIGNvbW1lbnRTdHJpbmdcbiAgICBdKTtcbiAgfVxuICByZW5hbWVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJCZWZvcmUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBuZXdOYW1lID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcylbMF07XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJFWEVDIHNwX3JlbmFtZVwiLFxuICAgICAgYCcke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfS4ke2F0dHJCZWZvcmV9JyxgLFxuICAgICAgYCcke25ld05hbWV9JyxgLFxuICAgICAgXCInQ09MVU1OJ1wiLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBidWxrSW5zZXJ0UXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGNvbnN0IHR1cGxlcyA9IFtdO1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBbXTtcbiAgICBjb25zdCBhbGxRdWVyaWVzID0gW107XG4gICAgbGV0IG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIgPSBmYWxzZSwgb3V0cHV0RnJhZ21lbnQgPSBcIlwiO1xuICAgIGlmIChvcHRpb25zLnJldHVybmluZykge1xuICAgICAgY29uc3QgcmV0dXJuVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVJldHVyblZhbHVlcyhhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICAgIG91dHB1dEZyYWdtZW50ID0gcmV0dXJuVmFsdWVzLm91dHB1dEZyYWdtZW50O1xuICAgIH1cbiAgICBjb25zdCBlbXB0eVF1ZXJ5ID0gYElOU0VSVCBJTlRPICR7cXVvdGVkVGFibGV9JHtvdXRwdXRGcmFnbWVudH0gREVGQVVMVCBWQUxVRVNgO1xuICAgIGF0dHJWYWx1ZUhhc2hlcy5mb3JFYWNoKChhdHRyVmFsdWVIYXNoKSA9PiB7XG4gICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhhdHRyVmFsdWVIYXNoKTtcbiAgICAgIGNvbnN0IGZpcnN0QXR0ciA9IGF0dHJpYnV0ZXNbZmllbGRzWzBdXTtcbiAgICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxICYmIGZpcnN0QXR0ciAmJiBmaXJzdEF0dHIuYXV0b0luY3JlbWVudCAmJiBhdHRyVmFsdWVIYXNoW2ZpZWxkc1swXV0gPT09IG51bGwpIHtcbiAgICAgICAgYWxsUXVlcmllcy5wdXNoKGVtcHR5UXVlcnkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfLmZvck93bihhdHRyVmFsdWVIYXNoLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgYXR0cmlidXRlc1trZXldICYmIGF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgICAgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbGxBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgJiYgYXR0cmlidXRlc1trZXldICYmIGF0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGFsbEF0dHJpYnV0ZXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoYWxsQXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICBhdHRyVmFsdWVIYXNoZXMuZm9yRWFjaCgoYXR0clZhbHVlSGFzaCkgPT4ge1xuICAgICAgICB0dXBsZXMucHVzaChgKCR7YWxsQXR0cmlidXRlcy5tYXAoKGtleSkgPT4gdGhpcy5lc2NhcGUoYXR0clZhbHVlSGFzaFtrZXldKSkuam9pbihcIixcIil9KWApO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBxdW90ZWRBdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLFwiKTtcbiAgICAgIGFsbFF1ZXJpZXMucHVzaCgodHVwbGVTdHIpID0+IGBJTlNFUlQgSU5UTyAke3F1b3RlZFRhYmxlfSAoJHtxdW90ZWRBdHRyaWJ1dGVzfSkke291dHB1dEZyYWdtZW50fSBWQUxVRVMgJHt0dXBsZVN0cn07YCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1hbmRzID0gW107XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgYmF0Y2ggPSBNYXRoLmZsb29yKDI1MCAvIChhbGxBdHRyaWJ1dGVzLmxlbmd0aCArIDEpKSArIDE7XG4gICAgd2hpbGUgKG9mZnNldCA8IE1hdGgubWF4KHR1cGxlcy5sZW5ndGgsIDEpKSB7XG4gICAgICBjb25zdCB0dXBsZVN0ciA9IHR1cGxlcy5zbGljZShvZmZzZXQsIE1hdGgubWluKHR1cGxlcy5sZW5ndGgsIG9mZnNldCArIGJhdGNoKSk7XG4gICAgICBsZXQgZ2VuZXJhdGVkUXVlcnkgPSBhbGxRdWVyaWVzLm1hcCgodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyB2IDogdih0dXBsZVN0cikpLmpvaW4oXCI7XCIpO1xuICAgICAgaWYgKG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIpIHtcbiAgICAgICAgZ2VuZXJhdGVkUXVlcnkgPSBgU0VUIElERU5USVRZX0lOU0VSVCAke3F1b3RlZFRhYmxlfSBPTjsgJHtnZW5lcmF0ZWRRdWVyeX07IFNFVCBJREVOVElUWV9JTlNFUlQgJHtxdW90ZWRUYWJsZX0gT0ZGO2A7XG4gICAgICB9XG4gICAgICBjb21tYW5kcy5wdXNoKGdlbmVyYXRlZFF1ZXJ5KTtcbiAgICAgIG9mZnNldCArPSBiYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLmpvaW4oXCI7XCIpO1xuICB9XG4gIHVwZGF0ZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0clZhbHVlSGFzaCwgd2hlcmUsIG9wdGlvbnMsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBzcWwgPSBzdXBlci51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJWYWx1ZUhhc2gsIHdoZXJlLCBvcHRpb25zLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgY29uc3QgdXBkYXRlQXJncyA9IGBVUERBVEUgVE9QKCR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9KWA7XG4gICAgICBzcWwucXVlcnkgPSBzcWwucXVlcnkucmVwbGFjZShcIlVQREFURVwiLCB1cGRhdGVBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICB1cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YXJnZXRUYWJsZUFsaWFzID0gdGhpcy5xdW90ZVRhYmxlKGAke3RhYmxlTmFtZX1fdGFyZ2V0YCk7XG4gICAgY29uc3Qgc291cmNlVGFibGVBbGlhcyA9IHRoaXMucXVvdGVUYWJsZShgJHt0YWJsZU5hbWV9X3NvdXJjZWApO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzQXR0cnMgPSBbXTtcbiAgICBjb25zdCBpZGVudGl0eUF0dHJzID0gW107XG4gICAgY29uc3QgdW5pcXVlQXR0cnMgPSBbXTtcbiAgICBjb25zdCB0YWJsZU5hbWVRdW90ZWQgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vZGVsLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0ucHJpbWFyeUtleSkge1xuICAgICAgICBwcmltYXJ5S2V5c0F0dHJzLnB1c2gobW9kZWwucmF3QXR0cmlidXRlc1trZXldLmZpZWxkIHx8IGtleSk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwucmF3QXR0cmlidXRlc1trZXldLnVuaXF1ZSkge1xuICAgICAgICB1bmlxdWVBdHRycy5wdXNoKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5maWVsZCB8fCBrZXkpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIGlkZW50aXR5QXR0cnMucHVzaChtb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0uZmllbGQgfHwga2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBtb2RlbC5faW5kZXhlcykge1xuICAgICAgaWYgKGluZGV4LnVuaXF1ZSAmJiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSB0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIgPyBmaWVsZCA6IGZpZWxkLm5hbWUgfHwgZmllbGQuYXR0cmlidXRlO1xuICAgICAgICAgIGlmICghdW5pcXVlQXR0cnMuaW5jbHVkZXMoZmllbGROYW1lKSAmJiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2ZpZWxkTmFtZV0pIHtcbiAgICAgICAgICAgIHVuaXF1ZUF0dHJzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlS2V5cyA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgY29uc3QgaW5zZXJ0S2V5cyA9IE9iamVjdC5rZXlzKGluc2VydFZhbHVlcyk7XG4gICAgY29uc3QgaW5zZXJ0S2V5c1F1b3RlZCA9IGluc2VydEtleXMubWFwKChrZXkpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBpbnNlcnRWYWx1ZXNFc2NhcGVkID0gaW5zZXJ0S2V5cy5tYXAoKGtleSkgPT4gdGhpcy5lc2NhcGUoaW5zZXJ0VmFsdWVzW2tleV0pKS5qb2luKFwiLCBcIik7XG4gICAgY29uc3Qgc291cmNlVGFibGVRdWVyeSA9IGBWQUxVRVMoJHtpbnNlcnRWYWx1ZXNFc2NhcGVkfSlgO1xuICAgIGxldCBqb2luQ29uZGl0aW9uO1xuICAgIGlkZW50aXR5QXR0cnMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoaW5zZXJ0VmFsdWVzW2tleV0gJiYgaW5zZXJ0VmFsdWVzW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgbmVlZElkZW50aXR5SW5zZXJ0V3JhcHBlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgY2xhdXNlcyA9IHdoZXJlW09wLm9yXS5maWx0ZXIoKGNsYXVzZSkgPT4ge1xuICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsYXVzZSkge1xuICAgICAgICBpZiAodHlwZW9mIGNsYXVzZVtrZXldID09PSBcInVuZGVmaW5lZFwiIHx8IGNsYXVzZVtrZXldID09IG51bGwpIHtcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSk7XG4gICAgY29uc3QgZ2V0Sm9pblNuaXBwZXQgPSAoYXJyYXkpID0+IHtcbiAgICAgIHJldHVybiBhcnJheS5tYXAoKGtleSkgPT4ge1xuICAgICAgICBrZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgICAgICByZXR1cm4gYCR7dGFyZ2V0VGFibGVBbGlhc30uJHtrZXl9ID0gJHtzb3VyY2VUYWJsZUFsaWFzfS4ke2tleX1gO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoY2xhdXNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByaW1hcnkgS2V5IG9yIFVuaXF1ZSBrZXkgc2hvdWxkIGJlIHBhc3NlZCB0byB1cHNlcnQgcXVlcnlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsYXVzZXMpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGNsYXVzZXNba2V5XSk7XG4gICAgICAgIGlmIChwcmltYXJ5S2V5c0F0dHJzLmluY2x1ZGVzKGtleXNbMF0pKSB7XG4gICAgICAgICAgam9pbkNvbmRpdGlvbiA9IGdldEpvaW5TbmlwcGV0KHByaW1hcnlLZXlzQXR0cnMpLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFqb2luQ29uZGl0aW9uKSB7XG4gICAgICAgIGpvaW5Db25kaXRpb24gPSBnZXRKb2luU25pcHBldCh1bmlxdWVBdHRycykuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJlZFVwZGF0ZUNsYXVzZXMgPSB1cGRhdGVLZXlzLmZpbHRlcigoa2V5KSA9PiAhaWRlbnRpdHlBdHRycy5pbmNsdWRlcyhrZXkpKS5tYXAoKGtleSkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmVzY2FwZSh1cGRhdGVWYWx1ZXNba2V5XSk7XG4gICAgICBrZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpO1xuICAgICAgcmV0dXJuIGAke3RhcmdldFRhYmxlQWxpYXN9LiR7a2V5fSA9ICR7dmFsdWV9YDtcbiAgICB9KTtcbiAgICBjb25zdCB1cGRhdGVTbmlwcGV0ID0gZmlsdGVyZWRVcGRhdGVDbGF1c2VzLmxlbmd0aCA+IDAgPyBgV0hFTiBNQVRDSEVEIFRIRU4gVVBEQVRFIFNFVCAke2ZpbHRlcmVkVXBkYXRlQ2xhdXNlcy5qb2luKFwiLCBcIil9YCA6IFwiXCI7XG4gICAgY29uc3QgaW5zZXJ0U25pcHBldCA9IGAoJHtpbnNlcnRLZXlzUXVvdGVkfSkgVkFMVUVTKCR7aW5zZXJ0VmFsdWVzRXNjYXBlZH0pYDtcbiAgICBsZXQgcXVlcnkgPSBgTUVSR0UgSU5UTyAke3RhYmxlTmFtZVF1b3RlZH0gV0lUSChIT0xETE9DSykgQVMgJHt0YXJnZXRUYWJsZUFsaWFzfSBVU0lORyAoJHtzb3VyY2VUYWJsZVF1ZXJ5fSkgQVMgJHtzb3VyY2VUYWJsZUFsaWFzfSgke2luc2VydEtleXNRdW90ZWR9KSBPTiAke2pvaW5Db25kaXRpb259YDtcbiAgICBxdWVyeSArPSBgICR7dXBkYXRlU25pcHBldH0gV0hFTiBOT1QgTUFUQ0hFRCBUSEVOIElOU0VSVCAke2luc2VydFNuaXBwZXR9IE9VVFBVVCAkYWN0aW9uLCBJTlNFUlRFRC4qO2A7XG4gICAgaWYgKG5lZWRJZGVudGl0eUluc2VydFdyYXBwZXIpIHtcbiAgICAgIHF1ZXJ5ID0gYFNFVCBJREVOVElUWV9JTlNFUlQgJHt0YWJsZU5hbWVRdW90ZWR9IE9OOyAke3F1ZXJ5fSBTRVQgSURFTlRJVFlfSU5TRVJUICR7dGFibGVOYW1lUXVvdGVkfSBPRkY7YDtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG4gIHRydW5jYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFRSVU5DQVRFIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YDtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJERUxFVEVcIixcbiAgICAgIG9wdGlvbnMubGltaXQgJiYgYFRPUCgke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfSlgLFxuICAgICAgXCJGUk9NXCIsXG4gICAgICB0YWJsZSxcbiAgICAgIHdoZXJlQ2xhdXNlICYmIGBXSEVSRSAke3doZXJlQ2xhdXNlfWAsXG4gICAgICBcIjtcIixcbiAgICAgIFwiU0VMRUNUIEBAUk9XQ09VTlQgQVMgQUZGRUNURURST1dTXCIsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBFWEVDIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWUgPSBOJyR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9JztgO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgRVhFQyBzcF9oZWxwY29uc3RyYWludCBAb2JqbmFtZSA9ICR7dGhpcy5lc2NhcGUodGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSkpfTtgO1xuICB9XG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbihcIl9cIil9YCk7XG4gICAgfVxuICAgIHJldHVybiBgRFJPUCBJTkRFWCAke3RoaXMucXVvdGVJZGVudGlmaWVycyhpbmRleE5hbWUpfSBPTiAke3RoaXMucXVvdGVJZGVudGlmaWVycyh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5Nb2RlbCAmJiBhdHRyaWJ1dGUuTW9kZWwudGFibGVOYW1lID09PSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCkge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coXCJNU1NRTCBkb2VzIG5vdCBzdXBwb3J0IHNlbGYgcmVmZXJlbmNpYWwgY29uc3RyYWludHMsIHdlIHdpbGwgcmVtb3ZlIGl0IGJ1dCB3ZSByZWNvbW1lbmQgcmVzdHJ1Y3R1cmluZyB5b3VyIHF1ZXJ5XCIpO1xuICAgICAgICBhdHRyaWJ1dGUub25EZWxldGUgPSBcIlwiO1xuICAgICAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG4gICAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3FsKCk7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5maWVsZCl9IElOKCR7YXR0cmlidXRlLnZhbHVlcy5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KS5qb2luKFwiLCBcIil9KSlgO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKCk7XG4gICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBOT1QgTlVMTFwiO1xuICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZS5wcmltYXJ5S2V5ICYmICFVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIE5VTExcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBJREVOVElUWSgxLDEpXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudHlwZSAhPT0gXCJURVhUXCIgJiYgYXR0cmlidXRlLnR5cGUuX2JpbmFyeSAhPT0gdHJ1ZSAmJiBVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMpICYmIGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCAmJiB0eXBlb2YgYXR0cmlidXRlLmNvbW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQ09NTUVOVCAke2F0dHJpYnV0ZS5jb21tZW50fWA7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9LCBleGlzdGluZ0NvbnN0cmFpbnRzID0gW107XG4gICAgbGV0IGtleSwgYXR0cmlidXRlO1xuICAgIGZvciAoa2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICBpZiAoZXhpc3RpbmdDb25zdHJhaW50cy5pbmNsdWRlcyhhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbC50b1N0cmluZygpKSkge1xuICAgICAgICAgIGF0dHJpYnV0ZS5vbkRlbGV0ZSA9IFwiXCI7XG4gICAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdGluZ0NvbnN0cmFpbnRzLnB1c2goYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgYXR0cmlidXRlLm9uVXBkYXRlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGtleSAmJiAhYXR0cmlidXRlLmZpZWxkKVxuICAgICAgICBhdHRyaWJ1dGUuZmllbGQgPSBrZXk7XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImNyZWF0ZVRyaWdnZXJcIik7XG4gIH1cbiAgZHJvcFRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wVHJpZ2dlclwiKTtcbiAgfVxuICByZW5hbWVUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwicmVuYW1lVHJpZ2dlclwiKTtcbiAgfVxuICBjcmVhdGVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImNyZWF0ZUZ1bmN0aW9uXCIpO1xuICB9XG4gIGRyb3BGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcImRyb3BGdW5jdGlvblwiKTtcbiAgfVxuICByZW5hbWVGdW5jdGlvbigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZUZ1bmN0aW9uXCIpO1xuICB9XG4gIF9nZXRGb3JlaWduS2V5c1F1ZXJ5UHJlZml4KGNhdGFsb2dOYW1lKSB7XG4gICAgcmV0dXJuIGAke1wiU0VMRUNUIGNvbnN0cmFpbnRfbmFtZSA9IE9CSi5OQU1FLCBjb25zdHJhaW50TmFtZSA9IE9CSi5OQU1FLCBcIn0ke2NhdGFsb2dOYW1lID8gYGNvbnN0cmFpbnRDYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9JywgYCA6IFwiXCJ9Y29uc3RyYWludFNjaGVtYSA9IFNDSEVNQV9OQU1FKE9CSi5TQ0hFTUFfSUQpLCB0YWJsZU5hbWUgPSBUQi5OQU1FLCB0YWJsZVNjaGVtYSA9IFNDSEVNQV9OQU1FKFRCLlNDSEVNQV9JRCksICR7Y2F0YWxvZ05hbWUgPyBgdGFibGVDYXRhbG9nID0gJyR7Y2F0YWxvZ05hbWV9JywgYCA6IFwiXCJ9Y29sdW1uTmFtZSA9IENPTC5OQU1FLCByZWZlcmVuY2VkVGFibGVTY2hlbWEgPSBTQ0hFTUFfTkFNRShSVEIuU0NIRU1BX0lEKSwgJHtjYXRhbG9nTmFtZSA/IGByZWZlcmVuY2VkQ2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfScsIGAgOiBcIlwifXJlZmVyZW5jZWRUYWJsZU5hbWUgPSBSVEIuTkFNRSwgcmVmZXJlbmNlZENvbHVtbk5hbWUgPSBSQ09MLk5BTUUgRlJPTSBzeXMuZm9yZWlnbl9rZXlfY29sdW1ucyBGS0MgSU5ORVIgSk9JTiBzeXMub2JqZWN0cyBPQkogT04gT0JKLk9CSkVDVF9JRCA9IEZLQy5DT05TVFJBSU5UX09CSkVDVF9JRCBJTk5FUiBKT0lOIHN5cy50YWJsZXMgVEIgT04gVEIuT0JKRUNUX0lEID0gRktDLlBBUkVOVF9PQkpFQ1RfSUQgSU5ORVIgSk9JTiBzeXMuY29sdW1ucyBDT0wgT04gQ09MLkNPTFVNTl9JRCA9IFBBUkVOVF9DT0xVTU5fSUQgQU5EIENPTC5PQkpFQ1RfSUQgPSBUQi5PQkpFQ1RfSUQgSU5ORVIgSk9JTiBzeXMudGFibGVzIFJUQiBPTiBSVEIuT0JKRUNUX0lEID0gRktDLlJFRkVSRU5DRURfT0JKRUNUX0lEIElOTkVSIEpPSU4gc3lzLmNvbHVtbnMgUkNPTCBPTiBSQ09MLkNPTFVNTl9JRCA9IFJFRkVSRU5DRURfQ09MVU1OX0lEIEFORCBSQ09MLk9CSkVDVF9JRCA9IFJUQi5PQkpFQ1RfSURgO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUsIGNhdGFsb2dOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGxldCBzcWwgPSBgJHt0aGlzLl9nZXRGb3JlaWduS2V5c1F1ZXJ5UHJlZml4KGNhdGFsb2dOYW1lKX0gV0hFUkUgVEIuTkFNRSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGVOYW1lKX1gO1xuICAgIGlmICh0YWJsZS5zY2hlbWEpIHtcbiAgICAgIHNxbCArPSBgIEFORCBTQ0hFTUFfTkFNRShUQi5TQ0hFTUFfSUQpID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZS5zY2hlbWEpfWA7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIHRoaXMuX2dldEZvcmVpZ25LZXlzUXVlcnlQcmVmaXgoKSxcbiAgICAgIFwiV0hFUkVcIixcbiAgICAgIGBUQi5OQU1FID0ke3dyYXBTaW5nbGVRdW90ZSh0YWJsZU5hbWUpfWAsXG4gICAgICBcIkFORFwiLFxuICAgICAgYENPTC5OQU1FID0ke3dyYXBTaW5nbGVRdW90ZShhdHRyaWJ1dGVOYW1lKX1gLFxuICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgU0NIRU1BX05BTUUoVEIuU0NIRU1BX0lEKSA9JHt3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKX1gXG4gICAgXSk7XG4gIH1cbiAgZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIEsuVEFCTEVfTkFNRSBBUyB0YWJsZU5hbWUsXCIsXG4gICAgICBcIksuQ09MVU1OX05BTUUgQVMgY29sdW1uTmFtZSxcIixcbiAgICAgIFwiSy5DT05TVFJBSU5UX05BTUUgQVMgY29uc3RyYWludE5hbWVcIixcbiAgICAgIFwiRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVfQ09OU1RSQUlOVFMgQVMgQ1wiLFxuICAgICAgXCJKT0lOIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFIEFTIEtcIixcbiAgICAgIFwiT04gQy5UQUJMRV9OQU1FID0gSy5UQUJMRV9OQU1FXCIsXG4gICAgICBcIkFORCBDLkNPTlNUUkFJTlRfQ0FUQUxPRyA9IEsuQ09OU1RSQUlOVF9DQVRBTE9HXCIsXG4gICAgICBcIkFORCBDLkNPTlNUUkFJTlRfU0NIRU1BID0gSy5DT05TVFJBSU5UX1NDSEVNQVwiLFxuICAgICAgXCJBTkQgQy5DT05TVFJBSU5UX05BTUUgPSBLLkNPTlNUUkFJTlRfTkFNRVwiLFxuICAgICAgXCJXSEVSRSBDLkNPTlNUUkFJTlRfVFlQRSA9ICdQUklNQVJZIEtFWSdcIixcbiAgICAgIGBBTkQgSy5DT0xVTU5fTkFNRSA9ICR7d3JhcFNpbmdsZVF1b3RlKGF0dHJpYnV0ZU5hbWUpfWAsXG4gICAgICBgQU5EIEsuVEFCTEVfTkFNRSA9ICR7dGFibGVOYW1lfWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1BcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpXG4gICAgXSk7XG4gIH1cbiAgZ2V0RGVmYXVsdENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRUYWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIG5hbWUgRlJPTSBzeXMuZGVmYXVsdF9jb25zdHJhaW50c1wiLFxuICAgICAgYFdIRVJFIFBBUkVOVF9PQkpFQ1RfSUQgPSBPQkpFQ1RfSUQoJyR7cXVvdGVkVGFibGV9JywgJ1UnKWAsXG4gICAgICBgQU5EIFBBUkVOVF9DT0xVTU5fSUQgPSAoU0VMRUNUIGNvbHVtbl9pZCBGUk9NIHN5cy5jb2x1bW5zIFdIRVJFIE5BTUUgPSAoJyR7YXR0cmlidXRlTmFtZX0nKWAsXG4gICAgICBgQU5EIG9iamVjdF9pZCA9IE9CSkVDVF9JRCgnJHtxdW90ZWRUYWJsZX0nLCAnVScpKWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJEUk9QIENPTlNUUkFJTlRcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbnN0cmFpbnROYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgc2V0SXNvbGF0aW9uTGV2ZWxRdWVyeSgpIHtcbiAgfVxuICBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIHJhbmRvbUJ5dGVzKDEwKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkUgVFJBTlNBQ1RJT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiQkVHSU4gVFJBTlNBQ1RJT047XCI7XG4gIH1cbiAgY29tbWl0VHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFwiQ09NTUlUIFRSQU5TQUNUSU9OO1wiO1xuICB9XG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVFJBTlNBQ1RJT04gJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT047XCI7XG4gIH1cbiAgc2VsZWN0RnJvbVRhYmxlRnJhZ21lbnQob3B0aW9ucywgbW9kZWwsIGF0dHJpYnV0ZXMsIHRhYmxlcywgbWFpblRhYmxlQXMsIHdoZXJlKSB7XG4gICAgdGhpcy5fdGhyb3dPbkVtcHR5QXR0cmlidXRlcyhhdHRyaWJ1dGVzLCB7IG1vZGVsTmFtZTogbW9kZWwgJiYgbW9kZWwubmFtZSwgYXM6IG1haW5UYWJsZUFzIH0pO1xuICAgIGNvbnN0IGRiVmVyc2lvbiA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uO1xuICAgIGNvbnN0IGlzU1FMU2VydmVyMjAwOCA9IHNlbXZlci52YWxpZChkYlZlcnNpb24pICYmIHNlbXZlci5sdChkYlZlcnNpb24sIFwiMTEuMC4wXCIpO1xuICAgIGlmIChpc1NRTFNlcnZlcjIwMDggJiYgb3B0aW9ucy5vZmZzZXQpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBpc1N1YlF1ZXJ5ID0gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uO1xuICAgICAgbGV0IG9yZGVycyA9IHsgbWFpblF1ZXJ5T3JkZXI6IFtdIH07XG4gICAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgICBvcmRlcnMgPSB0aGlzLmdldFF1ZXJ5T3JkZXJzKG9wdGlvbnMsIG1vZGVsLCBpc1N1YlF1ZXJ5KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmRlcnMubWFpblF1ZXJ5T3JkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9yZGVycy5tYWluUXVlcnlPcmRlci5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKG1vZGVsLnByaW1hcnlLZXlGaWVsZCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG1wVGFibGUgPSBtYWluVGFibGVBcyB8fCBcIk9mZnNldFRhYmxlXCI7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIGNvbnN0IHN1YlF1ZXJ5ID0gb3B0aW9ucy5zdWJRdWVyeSA9PT0gdm9pZCAwID8gb3B0aW9ucy5saW1pdCAmJiBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gOiBvcHRpb25zLnN1YlF1ZXJ5O1xuICAgICAgICBjb25zdCBtYWluVGFibGUgPSB7XG4gICAgICAgICAgbmFtZTogbWFpblRhYmxlQXMsXG4gICAgICAgICAgcXVvdGVkTmFtZTogbnVsbCxcbiAgICAgICAgICBhczogbnVsbCxcbiAgICAgICAgICBtb2RlbFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b3BMZXZlbEluZm8gPSB7XG4gICAgICAgICAgbmFtZXM6IG1haW5UYWJsZSxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIHN1YlF1ZXJ5XG4gICAgICAgIH07XG4gICAgICAgIGxldCBtYWluSm9pblF1ZXJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbmNsdWRlIG9mIG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICAgIGlmIChpbmNsdWRlLnNlcGFyYXRlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgam9pblF1ZXJpZXMgPSB0aGlzLmdlbmVyYXRlSW5jbHVkZShpbmNsdWRlLCB7IGV4dGVybmFsQXM6IG1haW5UYWJsZUFzLCBpbnRlcm5hbEFzOiBtYWluVGFibGVBcyB9LCB0b3BMZXZlbEluZm8pO1xuICAgICAgICAgIG1haW5Kb2luUXVlcmllcyA9IG1haW5Kb2luUXVlcmllcy5jb25jYXQoam9pblF1ZXJpZXMubWFpblF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICAgICAgXCJTRUxFQ1QgVE9QIDEwMCBQRVJDRU5UXCIsXG4gICAgICAgICAgYXR0cmlidXRlcy5qb2luKFwiLCBcIiksXG4gICAgICAgICAgXCJGUk9NIChcIixcbiAgICAgICAgICBbXG4gICAgICAgICAgICBcIlNFTEVDVFwiLFxuICAgICAgICAgICAgb3B0aW9ucy5saW1pdCAmJiBgVE9QICR7b3B0aW9ucy5saW1pdH1gLFxuICAgICAgICAgICAgXCIqIEZST00gKFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBcIlNFTEVDVCBST1dfTlVNQkVSKCkgT1ZFUiAoXCIsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIk9SREVSIEJZXCIsXG4gICAgICAgICAgICAgICAgb3JkZXJzLm1haW5RdWVyeU9yZGVyLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBgKSBhcyByb3dfbnVtLCAke3RtcFRhYmxlfS4qIEZST00gKGAsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcIlNFTEVDVCBESVNUSU5DVFwiLFxuICAgICAgICAgICAgICAgIGAke3RtcFRhYmxlfS4qIEZST00gJHt0YWJsZXN9IEFTICR7dG1wVGFibGV9YCxcbiAgICAgICAgICAgICAgICBtYWluSm9pblF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgd2hlcmUgJiYgYFdIRVJFICR7d2hlcmV9YFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBgKSBBUyAke3RtcFRhYmxlfWBcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBgKSBBUyAke3RtcFRhYmxlfSBXSEVSRSByb3dfbnVtID4gJHtvZmZzZXR9YFxuICAgICAgICAgIF0sXG4gICAgICAgICAgYCkgQVMgJHt0bXBUYWJsZX1gXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgICBcIlNFTEVDVCBUT1AgMTAwIFBFUkNFTlRcIixcbiAgICAgICAgYXR0cmlidXRlcy5qb2luKFwiLCBcIiksXG4gICAgICAgIFwiRlJPTSAoXCIsXG4gICAgICAgIFtcbiAgICAgICAgICBcIlNFTEVDVFwiLFxuICAgICAgICAgIG9wdGlvbnMubGltaXQgJiYgYFRPUCAke29wdGlvbnMubGltaXR9YCxcbiAgICAgICAgICBcIiogRlJPTSAoXCIsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgXCJTRUxFQ1QgUk9XX05VTUJFUigpIE9WRVIgKFwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBcIk9SREVSIEJZXCIsXG4gICAgICAgICAgICAgIG9yZGVycy5tYWluUXVlcnlPcmRlci5qb2luKFwiLCBcIilcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBgKSBhcyByb3dfbnVtLCAqIEZST00gJHt0YWJsZXN9IEFTICR7dG1wVGFibGV9YCxcbiAgICAgICAgICAgIHdoZXJlICYmIGBXSEVSRSAke3doZXJlfWBcbiAgICAgICAgICBdLFxuICAgICAgICAgIGApIEFTICR7dG1wVGFibGV9IFdIRVJFIHJvd19udW0gPiAke29mZnNldH1gXG4gICAgICAgIF0sXG4gICAgICAgIGApIEFTICR7dG1wVGFibGV9YFxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUXCIsXG4gICAgICBpc1NRTFNlcnZlcjIwMDggJiYgb3B0aW9ucy5saW1pdCAmJiBgVE9QICR7b3B0aW9ucy5saW1pdH1gLFxuICAgICAgYXR0cmlidXRlcy5qb2luKFwiLCBcIiksXG4gICAgICBgRlJPTSAke3RhYmxlc31gLFxuICAgICAgbWFpblRhYmxlQXMgJiYgYEFTICR7bWFpblRhYmxlQXN9YCxcbiAgICAgIG9wdGlvbnMudGFibGVIaW50ICYmIFRhYmxlSGludHNbb3B0aW9ucy50YWJsZUhpbnRdICYmIGBXSVRIICgke1RhYmxlSGludHNbb3B0aW9ucy50YWJsZUhpbnRdfSlgXG4gICAgXSk7XG4gIH1cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucywgbW9kZWwpIHtcbiAgICBpZiAoc2VtdmVyLnZhbGlkKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uKSAmJiBzZW12ZXIubHQodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24sIFwiMTEuMC4wXCIpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMDtcbiAgICBjb25zdCBpc1N1YlF1ZXJ5ID0gb3B0aW9ucy5zdWJRdWVyeSA9PT0gdm9pZCAwID8gb3B0aW9ucy5oYXNJbmNsdWRlV2hlcmUgfHwgb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uIDogb3B0aW9ucy5zdWJRdWVyeTtcbiAgICBsZXQgZnJhZ21lbnQgPSBcIlwiO1xuICAgIGxldCBvcmRlcnMgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5vcmRlcikge1xuICAgICAgb3JkZXJzID0gdGhpcy5nZXRRdWVyeU9yZGVycyhvcHRpb25zLCBtb2RlbCwgaXNTdWJRdWVyeSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0IHx8IG9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMub3JkZXIgfHwgb3B0aW9ucy5vcmRlci5sZW5ndGggPT09IDAgfHwgb3B0aW9ucy5pbmNsdWRlICYmIG9yZGVycy5zdWJRdWVyeU9yZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsZXQgcHJpbWFyeUtleSA9IG1vZGVsLnByaW1hcnlLZXlGaWVsZDtcbiAgICAgICAgY29uc3QgdGFibGVQa0ZyYWdtZW50ID0gYCR7dGhpcy5xdW90ZVRhYmxlKG9wdGlvbnMudGFibGVBcyB8fCBtb2RlbC5uYW1lKX0uJHt0aGlzLnF1b3RlSWRlbnRpZmllcihwcmltYXJ5S2V5KX1gO1xuICAgICAgICBjb25zdCBhbGlhc2VkQXR0cmlidXRlID0gKG9wdGlvbnMuYXR0cmlidXRlcyB8fCBbXSkuZmluZCgoYXR0cikgPT4gQXJyYXkuaXNBcnJheShhdHRyKSAmJiBhdHRyWzFdICYmIChhdHRyWzBdID09PSBwcmltYXJ5S2V5IHx8IGF0dHJbMV0gPT09IHByaW1hcnlLZXkpKTtcbiAgICAgICAgaWYgKGFsaWFzZWRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLnRhYmxlQXMgfHwgbW9kZWwubmFtZSk7XG4gICAgICAgICAgY29uc3QgYWxpYXMgPSB0aGlzLl9nZXRBbGlhc0ZvckZpZWxkKG1vZGVsTmFtZSwgYWxpYXNlZEF0dHJpYnV0ZVsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgcHJpbWFyeUtleSA9IG5ldyBVdGlscy5Db2woYWxpYXMgfHwgYWxpYXNlZEF0dHJpYnV0ZVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zLm9yZGVyIHx8ICFvcHRpb25zLm9yZGVyLmxlbmd0aCkge1xuICAgICAgICAgIGZyYWdtZW50ICs9IGAgT1JERVIgQlkgJHt0YWJsZVBrRnJhZ21lbnR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvcmRlckZpZWxkTmFtZXMgPSAob3B0aW9ucy5vcmRlciB8fCBbXSkubWFwKChvcmRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBBcnJheS5pc0FycmF5KG9yZGVyKSA/IG9yZGVyWzBdIDogb3JkZXI7XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5Db2wpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmNvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcmltYXJ5S2V5RmllbGRBbHJlYWR5UHJlc2VudCA9IG9yZGVyRmllbGROYW1lcy5zb21lKChmaWVsZE5hbWUpID0+IGZpZWxkTmFtZSA9PT0gKHByaW1hcnlLZXkuY29sIHx8IHByaW1hcnlLZXkpKTtcbiAgICAgICAgICBpZiAoIXByaW1hcnlLZXlGaWVsZEFscmVhZHlQcmVzZW50KSB7XG4gICAgICAgICAgICBmcmFnbWVudCArPSBvcHRpb25zLm9yZGVyICYmICFpc1N1YlF1ZXJ5ID8gXCIsIFwiIDogXCIgT1JERVIgQlkgXCI7XG4gICAgICAgICAgICBmcmFnbWVudCArPSB0YWJsZVBrRnJhZ21lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIE9GRlNFVCAke3RoaXMuZXNjYXBlKG9mZnNldCl9IFJPV1NgO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gYCBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UpIHtcbiAgICByZXR1cm4gYFske2lkZW50aWZpZXIucmVwbGFjZSgvW1tcXF0nXSsvZywgXCJcIil9XWA7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBTaW5nbGVRdW90ZShpZGVudGlmaWVyKSB7XG4gIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCBcIidcIiksIFwiJ1wiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTVNTUUxRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nclass MSSqlQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = __spreadValues({ raw: true }, options || {});\n    const findConstraintSql = this.queryGenerator.getDefaultConstraintQuery(tableName, attributeName);\n    const [results0] = await this.sequelize.query(findConstraintSql, options);\n    if (results0.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, results0[0].name);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const findForeignKeySql = this.queryGenerator.getForeignKeyQuery(tableName, attributeName);\n    const [results] = await this.sequelize.query(findForeignKeySql, options);\n    if (results.length) {\n      const dropForeignKeySql = this.queryGenerator.dropForeignKeyQuery(tableName, results[0].constraint_name);\n      await this.sequelize.query(dropForeignKeySql, options);\n    }\n    const primaryKeyConstraintSql = this.queryGenerator.getPrimaryKeyConstraintQuery(tableName, attributeName);\n    const [result] = await this.sequelize.query(primaryKeyConstraintSql, options);\n    if (result.length) {\n      const dropConstraintSql = this.queryGenerator.dropConstraintQuery(tableName, result[0].constraintName);\n      await this.sequelize.query(dropConstraintSql, options);\n    }\n    const removeSql = this.queryGenerator.removeColumnQuery(tableName, attributeName);\n    return this.sequelize.query(removeSql, options);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    const model = options.model;\n    const wheres = [];\n    options = __spreadValues({}, options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    let indexes = Object.values(model.uniqueKeys).map((item) => item.fields);\n    indexes = indexes.concat(Object.values(model._indexes).filter((item) => item.unique).map((item) => item.fields));\n    const attributes = Object.keys(insertValues);\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = { [Op.or]: wheres };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.MSSqlQueryInterface = MSSqlQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUMsV0FBVyxtQkFBTyxDQUFDLHdFQUFpQjtBQUNwQyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS1pbnRlcmZhY2UuanM/MGE3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIE1TU3FsUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIHJlbW92ZUNvbHVtbih0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgY29uc3QgZmluZENvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldERlZmF1bHRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBjb25zdCBbcmVzdWx0czBdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZmluZENvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHRzMC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRyb3BDb25zdHJhaW50U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgcmVzdWx0czBbMF0ubmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShkcm9wQ29uc3RyYWludFNxbCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmRGb3JlaWduS2V5U3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBjb25zdCBbcmVzdWx0c10gPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShmaW5kRm9yZWlnbktleVNxbCwgb3B0aW9ucyk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkcm9wRm9yZWlnbktleVNxbCA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIHJlc3VsdHNbMF0uY29uc3RyYWludF9uYW1lKTtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGRyb3BGb3JlaWduS2V5U3FsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgcHJpbWFyeUtleUNvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmdldFByaW1hcnlLZXlDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKTtcbiAgICBjb25zdCBbcmVzdWx0XSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHByaW1hcnlLZXlDb25zdHJhaW50U3FsLCBvcHRpb25zKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZHJvcENvbnN0cmFpbnRTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRyb3BDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCByZXN1bHRbMF0uY29uc3RyYWludE5hbWUpO1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZHJvcENvbnN0cmFpbnRTcWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCByZW1vdmVTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHJlbW92ZVNxbCwgb3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRpb25zLm1vZGVsO1xuICAgIGNvbnN0IHdoZXJlcyA9IFtdO1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgaWYgKCFVdGlscy5pc1doZXJlRW1wdHkod2hlcmUpKSB7XG4gICAgICB3aGVyZXMucHVzaCh3aGVyZSk7XG4gICAgfVxuICAgIGxldCBpbmRleGVzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC51bmlxdWVLZXlzKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmllbGRzKTtcbiAgICBpbmRleGVzID0gaW5kZXhlcy5jb25jYXQoT2JqZWN0LnZhbHVlcyhtb2RlbC5faW5kZXhlcykuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnVuaXF1ZSkubWFwKChpdGVtKSA9PiBpdGVtLmZpZWxkcykpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbnNlcnRWYWx1ZXMpO1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgaW5kZXhlcykge1xuICAgICAgaWYgKF8uaW50ZXJzZWN0aW9uKGF0dHJpYnV0ZXMsIGluZGV4KS5sZW5ndGggPT09IGluZGV4Lmxlbmd0aCkge1xuICAgICAgICB3aGVyZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGluZGV4KSB7XG4gICAgICAgICAgd2hlcmVbZmllbGRdID0gaW5zZXJ0VmFsdWVzW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgICB3aGVyZXMucHVzaCh3aGVyZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoZXJlID0geyBbT3Aub3JdOiB3aGVyZXMgfTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICB9XG59XG5leHBvcnRzLk1TU3FsUXVlcnlJbnRlcmZhY2UgPSBNU1NxbFF1ZXJ5SW50ZXJmYWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mssql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mssql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mssql\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:mssql\");\nconst minSafeIntegerAsBigInt = BigInt(Number.MIN_SAFE_INTEGER);\nconst maxSafeIntegerAsBigInt = BigInt(Number.MAX_SAFE_INTEGER);\nfunction getScale(aNum) {\n  if (!Number.isFinite(aNum))\n    return 0;\n  let e = 1;\n  while (Math.round(aNum * e) / e !== aNum)\n    e *= 10;\n  return Math.log10(e);\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"id\";\n  }\n  getSQLTypeFromJsType(value, TYPES) {\n    const paramType = { type: TYPES.NVarChar, typeOptions: {}, value };\n    if (typeof value === \"number\") {\n      if (Number.isInteger(value)) {\n        if (value >= -2147483648 && value <= 2147483647) {\n          paramType.type = TYPES.Int;\n        } else {\n          paramType.type = TYPES.BigInt;\n        }\n      } else {\n        paramType.type = TYPES.Numeric;\n        paramType.typeOptions = { precision: 30, scale: getScale(value) };\n      }\n    } else if (typeof value === \"bigint\") {\n      if (value < minSafeIntegerAsBigInt || value > maxSafeIntegerAsBigInt) {\n        paramType.type = TYPES.VarChar;\n        paramType.value = value.toString();\n      } else {\n        return this.getSQLTypeFromJsType(Number(value), TYPES);\n      }\n    } else if (typeof value === \"boolean\") {\n      paramType.type = TYPES.Bit;\n    }\n    if (Buffer.isBuffer(value)) {\n      paramType.type = TYPES.VarBinary;\n    }\n    return paramType;\n  }\n  async _run(connection, sql, parameters, errStack) {\n    this.sql = sql;\n    const { options } = this;\n    const complete = this._logQuery(sql, debug, parameters);\n    const query = new Promise((resolve, reject) => {\n      if (sql.startsWith(\"BEGIN TRANSACTION\")) {\n        return connection.beginTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name, connection.lib.ISOLATION_LEVEL[options.isolationLevel]);\n      }\n      if (sql.startsWith(\"COMMIT TRANSACTION\")) {\n        return connection.commitTransaction((error) => error ? reject(error) : resolve([]));\n      }\n      if (sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n        return connection.rollbackTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      if (sql.startsWith(\"SAVE TRANSACTION\")) {\n        return connection.saveTransaction((error) => error ? reject(error) : resolve([]), options.transaction.name);\n      }\n      const rows2 = [];\n      const request = new connection.lib.Request(sql, (err, rowCount2) => err ? reject(err) : resolve([rows2, rowCount2]));\n      if (parameters) {\n        _.forOwn(parameters, (value, key) => {\n          const paramType = this.getSQLTypeFromJsType(value, connection.lib.TYPES);\n          request.addParameter(key, paramType.type, value, paramType.typeOptions);\n        });\n      }\n      request.on(\"row\", (columns) => {\n        rows2.push(columns);\n      });\n      connection.execSql(request);\n    });\n    let rows, rowCount;\n    try {\n      [rows, rowCount] = await query;\n    } catch (err) {\n      err.sql = sql;\n      err.parameters = parameters;\n      throw this.formatError(err, errStack);\n    }\n    complete();\n    if (Array.isArray(rows)) {\n      rows = rows.map((columns) => {\n        const row = {};\n        for (const column of columns) {\n          const typeid = column.metadata.type.id;\n          const parse = parserStore.get(typeid);\n          let value = column.value;\n          if (value !== null & !!parse) {\n            value = parse(value);\n          }\n          row[column.metadata.colName] = value;\n        }\n        return row;\n      });\n    }\n    return this.formatResults(rows, rowCount);\n  }\n  run(sql, parameters) {\n    const errForStack = new Error();\n    return this.connection.queue.enqueue(() => this._run(this.connection, sql, parameters, errForStack.stack));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = {};\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        bindParam[key] = values2[key];\n        return `@${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam];\n  }\n  formatResults(data, rowCount) {\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      const result = {};\n      for (const _result of data) {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        result[_result.Name] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.IsNull === \"YES\" ? true : false,\n          defaultValue: _result.Default,\n          primaryKey: _result.Constraint === \"PRIMARY KEY\",\n          autoIncrement: _result.IsIdentity === 1,\n          comment: _result.Comment\n        };\n        if (result[_result.Name].type.includes(\"CHAR\") && _result.Length) {\n          if (_result.Length === -1) {\n            result[_result.Name].type += \"(MAX)\";\n          } else {\n            result[_result.Name].type += `(${_result.Length})`;\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery()) {\n      if (this.options.returning) {\n        return this.handleSelectQuery(data);\n      }\n      return rowCount;\n    }\n    if (this.isBulkDeleteQuery()) {\n      return data[0] ? data[0].AFFECTEDROWS : 0;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      if (data && data.length === 0) {\n        return [this.instance || data, false];\n      }\n      this.handleInsertQuery(data);\n      return [this.instance || data, data[0].$action === \"INSERT\"];\n    }\n    if (this.isUpdateQuery()) {\n      return [this.instance || data, rowCount];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return this.handleShowConstraintsQuery(data);\n    }\n    if (this.isRawQuery()) {\n      return [data, rowCount];\n    }\n    return data;\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  handleShowConstraintsQuery(data) {\n    return data.slice(1).map((result) => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key];\n      }\n      return constraint;\n    });\n  }\n  formatError(err, errStack) {\n    let match;\n    match = err.message.match(/Violation of (?:UNIQUE|PRIMARY) KEY constraint '([^']*)'. Cannot insert duplicate key in object '.*'.(:? The duplicate key value is \\((.*)\\).)?/);\n    match = match || err.message.match(/Cannot insert duplicate key row in object .* with unique index '(.*)'/);\n    if (match && match.length > 1) {\n      let fields = {};\n      const uniqueKey = this.model && this.model.uniqueKeys[match[1]];\n      let message = \"Validation error\";\n      if (uniqueKey && !!uniqueKey.msg) {\n        message = uniqueKey.msg;\n      }\n      if (match[3]) {\n        const values = match[3].split(\",\").map((part) => part.trim());\n        if (uniqueKey) {\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[match[1]] = match[3];\n        }\n      }\n      const errors = [];\n      _.forOwn(fields, (value, field) => {\n        errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n      });\n      return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n    }\n    match = err.message.match(/Failed on step '(.*)'.Could not create constraint. See previous errors./) || err.message.match(/The DELETE statement conflicted with the REFERENCE constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./) || err.message.match(/The (?:INSERT|MERGE|UPDATE) statement conflicted with the FOREIGN KEY constraint \"(.*)\". The conflict occurred in database \"(.*)\", table \"(.*)\", column '(.*)'./);\n    if (match && match.length > 0) {\n      return new sequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err,\n        stack: errStack\n      });\n    }\n    match = err.message.match(/Could not drop constraint. See previous errors./);\n    if (match && match.length > 0) {\n      let constraint = err.sql.match(/(?:constraint|index) \\[(.+?)\\]/i);\n      constraint = constraint ? constraint[1] : void 0;\n      let table = err.sql.match(/table \\[(.+?)\\]/i);\n      table = table ? table[1] : void 0;\n      return new sequelizeErrors.UnknownConstraintError({\n        message: match[1],\n        constraint,\n        table,\n        parent: err,\n        stack: errStack\n      });\n    }\n    return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n  }\n  isShowOrDescribeQuery() {\n    let result = false;\n    result = result || this.sql.toLowerCase().startsWith(\"select c.column_name as 'name', c.data_type as 'type', c.is_nullable as 'isnull'\");\n    result = result || this.sql.toLowerCase().startsWith(\"select tablename = t.name, name = ind.name,\");\n    result = result || this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n    return result;\n  }\n  isShowIndexesQuery() {\n    return this.sql.toLowerCase().startsWith(\"exec sys.sp_helpindex @objname\");\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.index_name in acc)) {\n        acc[item.index_name] = item;\n        item.fields = [];\n      }\n      item.index_keys.split(\",\").forEach((column) => {\n        let columnName = column.trim();\n        if (columnName.includes(\"(-)\")) {\n          columnName = columnName.replace(\"(-)\", \"\");\n        }\n        acc[item.index_name].fields.push({\n          attribute: columnName,\n          length: void 0,\n          order: column.includes(\"(-)\") ? \"DESC\" : \"ASC\",\n          collate: void 0\n        });\n      });\n      delete item.index_keys;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.index_name.toLowerCase().startsWith(\"pk\"),\n      fields: item.fields,\n      name: item.index_name,\n      tableName: void 0,\n      unique: item.index_description.toLowerCase().includes(\"unique\"),\n      type: void 0\n    }));\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance) {\n      const autoIncrementAttribute = this.model.autoIncrementAttribute;\n      let id = null;\n      let autoIncrementAttributeAlias = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementAttribute) && this.model.rawAttributes[autoIncrementAttribute].field !== void 0)\n        autoIncrementAttributeAlias = this.model.rawAttributes[autoIncrementAttribute].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementAttribute];\n      id = id || autoIncrementAttributeAlias && results && results[0][autoIncrementAttributeAlias];\n      this.instance[autoIncrementAttribute] = id;\n      if (this.instance.dataValues) {\n        for (const key in results[0]) {\n          if (Object.prototype.hasOwnProperty.call(results[0], key)) {\n            const record = results[0][key];\n            const attr = _.find(this.model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n    }\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9tc3NxbC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDNUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZDQUE2QyxlQUFlO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseURBQXlELHVEQUF1RDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0RBQW9ELGlCQUFpQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXNzcWwvcXVlcnkuanM/YjczYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJtc3NxbFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6bXNzcWxcIik7XG5jb25zdCBtaW5TYWZlSW50ZWdlckFzQmlnSW50ID0gQmlnSW50KE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTtcbmNvbnN0IG1heFNhZmVJbnRlZ2VyQXNCaWdJbnQgPSBCaWdJbnQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuZnVuY3Rpb24gZ2V0U2NhbGUoYU51bSkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZShhTnVtKSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IGUgPSAxO1xuICB3aGlsZSAoTWF0aC5yb3VuZChhTnVtICogZSkgLyBlICE9PSBhTnVtKVxuICAgIGUgKj0gMTA7XG4gIHJldHVybiBNYXRoLmxvZzEwKGUpO1xufVxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gXCJpZFwiO1xuICB9XG4gIGdldFNRTFR5cGVGcm9tSnNUeXBlKHZhbHVlLCBUWVBFUykge1xuICAgIGNvbnN0IHBhcmFtVHlwZSA9IHsgdHlwZTogVFlQRVMuTlZhckNoYXIsIHR5cGVPcHRpb25zOiB7fSwgdmFsdWUgfTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IC0yMTQ3NDgzNjQ4ICYmIHZhbHVlIDw9IDIxNDc0ODM2NDcpIHtcbiAgICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLkludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLkJpZ0ludDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5OdW1lcmljO1xuICAgICAgICBwYXJhbVR5cGUudHlwZU9wdGlvbnMgPSB7IHByZWNpc2lvbjogMzAsIHNjYWxlOiBnZXRTY2FsZSh2YWx1ZSkgfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgaWYgKHZhbHVlIDwgbWluU2FmZUludGVnZXJBc0JpZ0ludCB8fCB2YWx1ZSA+IG1heFNhZmVJbnRlZ2VyQXNCaWdJbnQpIHtcbiAgICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5WYXJDaGFyO1xuICAgICAgICBwYXJhbVR5cGUudmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U1FMVHlwZUZyb21Kc1R5cGUoTnVtYmVyKHZhbHVlKSwgVFlQRVMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcGFyYW1UeXBlLnR5cGUgPSBUWVBFUy5CaXQ7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICBwYXJhbVR5cGUudHlwZSA9IFRZUEVTLlZhckJpbmFyeTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtVHlwZTtcbiAgfVxuICBhc3luYyBfcnVuKGNvbm5lY3Rpb24sIHNxbCwgcGFyYW1ldGVycywgZXJyU3RhY2spIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICBjb25zdCBxdWVyeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzcWwuc3RhcnRzV2l0aChcIkJFR0lOIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLmJlZ2luVHJhbnNhY3Rpb24oKGVycm9yKSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSwgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lLCBjb25uZWN0aW9uLmxpYi5JU09MQVRJT05fTEVWRUxbb3B0aW9ucy5pc29sYXRpb25MZXZlbF0pO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKFwiQ09NTUlUIFRSQU5TQUNUSU9OXCIpKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uLmNvbW1pdFRyYW5zYWN0aW9uKChlcnJvcikgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShbXSkpO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24ucm9sbGJhY2tUcmFuc2FjdGlvbigoZXJyb3IpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUoW10pLCBvcHRpb25zLnRyYW5zYWN0aW9uLm5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKFwiU0FWRSBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zYXZlVHJhbnNhY3Rpb24oKGVycm9yKSA9PiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKFtdKSwgb3B0aW9ucy50cmFuc2FjdGlvbi5uYW1lKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvd3MyID0gW107XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IGNvbm5lY3Rpb24ubGliLlJlcXVlc3Qoc3FsLCAoZXJyLCByb3dDb3VudDIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShbcm93czIsIHJvd0NvdW50Ml0pKTtcbiAgICAgIGlmIChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIF8uZm9yT3duKHBhcmFtZXRlcnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1UeXBlID0gdGhpcy5nZXRTUUxUeXBlRnJvbUpzVHlwZSh2YWx1ZSwgY29ubmVjdGlvbi5saWIuVFlQRVMpO1xuICAgICAgICAgIHJlcXVlc3QuYWRkUGFyYW1ldGVyKGtleSwgcGFyYW1UeXBlLnR5cGUsIHZhbHVlLCBwYXJhbVR5cGUudHlwZU9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3Qub24oXCJyb3dcIiwgKGNvbHVtbnMpID0+IHtcbiAgICAgICAgcm93czIucHVzaChjb2x1bW5zKTtcbiAgICAgIH0pO1xuICAgICAgY29ubmVjdGlvbi5leGVjU3FsKHJlcXVlc3QpO1xuICAgIH0pO1xuICAgIGxldCByb3dzLCByb3dDb3VudDtcbiAgICB0cnkge1xuICAgICAgW3Jvd3MsIHJvd0NvdW50XSA9IGF3YWl0IHF1ZXJ5O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyLnNxbCA9IHNxbDtcbiAgICAgIGVyci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjayk7XG4gICAgfVxuICAgIGNvbXBsZXRlKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm93cykpIHtcbiAgICAgIHJvd3MgPSByb3dzLm1hcCgoY29sdW1ucykgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1ucykge1xuICAgICAgICAgIGNvbnN0IHR5cGVpZCA9IGNvbHVtbi5tZXRhZGF0YS50eXBlLmlkO1xuICAgICAgICAgIGNvbnN0IHBhcnNlID0gcGFyc2VyU3RvcmUuZ2V0KHR5cGVpZCk7XG4gICAgICAgICAgbGV0IHZhbHVlID0gY29sdW1uLnZhbHVlO1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmICEhcGFyc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2UodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb3dbY29sdW1uLm1ldGFkYXRhLmNvbE5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJvd3MsIHJvd0NvdW50KTtcbiAgfVxuICBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgZXJyRm9yU3RhY2sgPSBuZXcgRXJyb3IoKTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnF1ZXVlLmVucXVldWUoKCkgPT4gdGhpcy5fcnVuKHRoaXMuY29ubmVjdGlvbiwgc3FsLCBwYXJhbWV0ZXJzLCBlcnJGb3JTdGFjay5zdGFjaykpO1xuICB9XG4gIHN0YXRpYyBmb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCkge1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IHt9O1xuICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyKSA9PiB7XG4gICAgICBpZiAodmFsdWVzMltrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgYmluZFBhcmFtW2tleV0gPSB2YWx1ZXMyW2tleV07XG4gICAgICAgIHJldHVybiBgQCR7a2V5fWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuICBmb3JtYXRSZXN1bHRzKGRhdGEsIHJvd0NvdW50KSB7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIHJldHVybiBbdGhpcy5pbnN0YW5jZSB8fCBkYXRhLCByb3dDb3VudF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd1RhYmxlc1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBfcmVzdWx0IG9mIGRhdGEpIHtcbiAgICAgICAgaWYgKF9yZXN1bHQuRGVmYXVsdCkge1xuICAgICAgICAgIF9yZXN1bHQuRGVmYXVsdCA9IF9yZXN1bHQuRGVmYXVsdC5yZXBsYWNlKFwiKCdcIiwgXCJcIikucmVwbGFjZShcIicpXCIsIFwiXCIpLnJlcGxhY2UoLycvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W19yZXN1bHQuTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogX3Jlc3VsdC5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBfcmVzdWx0LklzTnVsbCA9PT0gXCJZRVNcIiA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LkNvbnN0cmFpbnQgPT09IFwiUFJJTUFSWSBLRVlcIixcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBfcmVzdWx0LklzSWRlbnRpdHkgPT09IDEsXG4gICAgICAgICAgY29tbWVudDogX3Jlc3VsdC5Db21tZW50XG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN1bHRbX3Jlc3VsdC5OYW1lXS50eXBlLmluY2x1ZGVzKFwiQ0hBUlwiKSAmJiBfcmVzdWx0Lkxlbmd0aCkge1xuICAgICAgICAgIGlmIChfcmVzdWx0Lkxlbmd0aCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdFtfcmVzdWx0Lk5hbWVdLnR5cGUgKz0gXCIoTUFYKVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5OYW1lXS50eXBlICs9IGAoJHtfcmVzdWx0Lkxlbmd0aH0pYDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkoZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93Q291bnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdID8gZGF0YVswXS5BRkZFQ1RFRFJPV1MgOiAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXS52ZXJzaW9uO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmluc3RhbmNlIHx8IGRhdGEsIGZhbHNlXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgZGF0YVswXS4kYWN0aW9uID09PSBcIklOU0VSVFwiXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcGRhdGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3RoaXMuaW5zdGFuY2UgfHwgZGF0YSwgcm93Q291bnRdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbZGF0YSwgcm93Q291bnRdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0U2V0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWJsZU5hbWU6IHJlc3VsdFNldC5UQUJMRV9OQU1FLFxuICAgICAgICBzY2hlbWE6IHJlc3VsdFNldC5UQUJMRV9TQ0hFTUFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlU2hvd0NvbnN0cmFpbnRzUXVlcnkoZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKDEpLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgY29uc3RyYWludFtfLmNhbWVsQ2FzZShrZXkpXSA9IHJlc3VsdFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gICAgfSk7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyLCBlcnJTdGFjaykge1xuICAgIGxldCBtYXRjaDtcbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9WaW9sYXRpb24gb2YgKD86VU5JUVVFfFBSSU1BUlkpIEtFWSBjb25zdHJhaW50ICcoW14nXSopJy4gQ2Fubm90IGluc2VydCBkdXBsaWNhdGUga2V5IGluIG9iamVjdCAnLionLig6PyBUaGUgZHVwbGljYXRlIGtleSB2YWx1ZSBpcyBcXCgoLiopXFwpLik/Lyk7XG4gICAgbWF0Y2ggPSBtYXRjaCB8fCBlcnIubWVzc2FnZS5tYXRjaCgvQ2Fubm90IGluc2VydCBkdXBsaWNhdGUga2V5IHJvdyBpbiBvYmplY3QgLiogd2l0aCB1bmlxdWUgaW5kZXggJyguKiknLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzW21hdGNoWzFdXTtcbiAgICAgIGxldCBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgICBpZiAodW5pcXVlS2V5ICYmICEhdW5pcXVlS2V5Lm1zZykge1xuICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBtYXRjaFszXS5zcGxpdChcIixcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1ttYXRjaFsxXV0gPSBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBfLmZvck93bihmaWVsZHMsICh2YWx1ZSwgZmllbGQpID0+IHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcywgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9GYWlsZWQgb24gc3RlcCAnKC4qKScuQ291bGQgbm90IGNyZWF0ZSBjb25zdHJhaW50LiBTZWUgcHJldmlvdXMgZXJyb3JzLi8pIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9UaGUgREVMRVRFIHN0YXRlbWVudCBjb25mbGljdGVkIHdpdGggdGhlIFJFRkVSRU5DRSBjb25zdHJhaW50IFwiKC4qKVwiLiBUaGUgY29uZmxpY3Qgb2NjdXJyZWQgaW4gZGF0YWJhc2UgXCIoLiopXCIsIHRhYmxlIFwiKC4qKVwiLCBjb2x1bW4gJyguKiknLi8pIHx8IGVyci5tZXNzYWdlLm1hdGNoKC9UaGUgKD86SU5TRVJUfE1FUkdFfFVQREFURSkgc3RhdGVtZW50IGNvbmZsaWN0ZWQgd2l0aCB0aGUgRk9SRUlHTiBLRVkgY29uc3RyYWludCBcIiguKilcIi4gVGhlIGNvbmZsaWN0IG9jY3VycmVkIGluIGRhdGFiYXNlIFwiKC4qKVwiLCB0YWJsZSBcIiguKilcIiwgY29sdW1uICcoLiopJy4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIGZpZWxkczogbnVsbCxcbiAgICAgICAgaW5kZXg6IG1hdGNoWzFdLFxuICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvQ291bGQgbm90IGRyb3AgY29uc3RyYWludC4gU2VlIHByZXZpb3VzIGVycm9ycy4vKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnQgPSBlcnIuc3FsLm1hdGNoKC8oPzpjb25zdHJhaW50fGluZGV4KSBcXFsoLis/KVxcXS9pKTtcbiAgICAgIGNvbnN0cmFpbnQgPSBjb25zdHJhaW50ID8gY29uc3RyYWludFsxXSA6IHZvaWQgMDtcbiAgICAgIGxldCB0YWJsZSA9IGVyci5zcWwubWF0Y2goL3RhYmxlIFxcWyguKz8pXFxdL2kpO1xuICAgICAgdGFibGUgPSB0YWJsZSA/IHRhYmxlWzFdIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IG1hdGNoWzFdLFxuICAgICAgICBjb25zdHJhaW50LFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgcGFyZW50OiBlcnIsXG4gICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgfVxuICBpc1Nob3dPckRlc2NyaWJlUXVlcnkoKSB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIHJlc3VsdCA9IHJlc3VsdCB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJzZWxlY3QgYy5jb2x1bW5fbmFtZSBhcyAnbmFtZScsIGMuZGF0YV90eXBlIGFzICd0eXBlJywgYy5pc19udWxsYWJsZSBhcyAnaXNudWxsJ1wiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwic2VsZWN0IHRhYmxlbmFtZSA9IHQubmFtZSwgbmFtZSA9IGluZC5uYW1lLFwiKTtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgdGhpcy5zcWwudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwiZXhlYyBzeXMuc3BfaGVscGluZGV4IEBvYmpuYW1lXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaXNTaG93SW5kZXhlc1F1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoXCJleGVjIHN5cy5zcF9oZWxwaW5kZXggQG9iam5hbWVcIik7XG4gIH1cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGlmICghKGl0ZW0uaW5kZXhfbmFtZSBpbiBhY2MpKSB7XG4gICAgICAgIGFjY1tpdGVtLmluZGV4X25hbWVdID0gaXRlbTtcbiAgICAgICAgaXRlbS5maWVsZHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGl0ZW0uaW5kZXhfa2V5cy5zcGxpdChcIixcIikuZm9yRWFjaCgoY29sdW1uKSA9PiB7XG4gICAgICAgIGxldCBjb2x1bW5OYW1lID0gY29sdW1uLnRyaW0oKTtcbiAgICAgICAgaWYgKGNvbHVtbk5hbWUuaW5jbHVkZXMoXCIoLSlcIikpIHtcbiAgICAgICAgICBjb2x1bW5OYW1lID0gY29sdW1uTmFtZS5yZXBsYWNlKFwiKC0pXCIsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGFjY1tpdGVtLmluZGV4X25hbWVdLmZpZWxkcy5wdXNoKHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IGNvbHVtbk5hbWUsXG4gICAgICAgICAgbGVuZ3RoOiB2b2lkIDAsXG4gICAgICAgICAgb3JkZXI6IGNvbHVtbi5pbmNsdWRlcyhcIigtKVwiKSA/IFwiREVTQ1wiIDogXCJBU0NcIixcbiAgICAgICAgICBjb2xsYXRlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBpdGVtLmluZGV4X2tleXM7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gXy5tYXAoZGF0YSwgKGl0ZW0pID0+ICh7XG4gICAgICBwcmltYXJ5OiBpdGVtLmluZGV4X25hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKFwicGtcIiksXG4gICAgICBmaWVsZHM6IGl0ZW0uZmllbGRzLFxuICAgICAgbmFtZTogaXRlbS5pbmRleF9uYW1lLFxuICAgICAgdGFibGVOYW1lOiB2b2lkIDAsXG4gICAgICB1bmlxdWU6IGl0ZW0uaW5kZXhfZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInVuaXF1ZVwiKSxcbiAgICAgIHR5cGU6IHZvaWQgMFxuICAgIH0pKTtcbiAgfVxuICBoYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICBjb25zdCBhdXRvSW5jcmVtZW50QXR0cmlidXRlID0gdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlO1xuICAgICAgbGV0IGlkID0gbnVsbDtcbiAgICAgIGxldCBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgPSBudWxsO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIGF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUpICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50QXR0cmlidXRlXS5maWVsZCAhPT0gdm9pZCAwKVxuICAgICAgICBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgPSB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbYXV0b0luY3JlbWVudEF0dHJpYnV0ZV0uZmllbGQ7XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IG1ldGFEYXRhICYmIG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdO1xuICAgICAgaWQgPSBpZCB8fCBhdXRvSW5jcmVtZW50QXR0cmlidXRlQWxpYXMgJiYgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVBbGlhc107XG4gICAgICB0aGlzLmluc3RhbmNlW2F1dG9JbmNyZW1lbnRBdHRyaWJ1dGVdID0gaWQ7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlc3VsdHNbMF0pIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHNbMF0sIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlc3VsdHNbMF1ba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBfLmZpbmQodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUuZmllbGROYW1lID09PSBrZXkgfHwgYXR0cmlidXRlLmZpZWxkID09PSBrZXkpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHIgJiYgYXR0ci5maWVsZE5hbWUgfHwga2V5XSA9IHJlY29yZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mssql/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/connection-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/connection-manager.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mysql);\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst debug = logger.debugContext(\"connection:mysql\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"mysql\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mysql2\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: \"-FOUND_ROWS\",\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        const connection2 = this.lib.createConnection(connectionConfig);\n        const errorHandler = (e) => {\n          connection2.removeListener(\"connect\", connectHandler);\n          connection2.removeListener(\"error\", connectHandler);\n          reject(e);\n        };\n        const connectHandler = () => {\n          connection2.removeListener(\"error\", errorHandler);\n          resolve(connection2);\n        };\n        connection2.on(\"error\", errorHandler);\n        connection2.once(\"connect\", connectHandler);\n      });\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        let tzOffset = this.sequelize.options.timezone;\n        tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n        await promisify((cb) => connection.query(`SET time_zone = '${tzOffset}'`, cb))();\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection._closing) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify((callback) => connection.end(callback))();\n  }\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DLGtCQUFrQix1R0FBaUM7QUFDbkQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQWlCO0FBQzFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFNBQVM7QUFDOUU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz82YjY3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKS5teXNxbDtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246bXlzcWxcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcIm15c3FsXCIpO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY2xhc3MgQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc2VxdWVsaXplLmNvbmZpZy5wb3J0ID0gc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDMzMDY7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLmxpYiA9IHRoaXMuX2xvYWREaWFsZWN0TW9kdWxlKFwibXlzcWwyXCIpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoRGF0YVR5cGVzKTtcbiAgfVxuICBfcmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGUpIHtcbiAgICBwYXJzZXJTdG9yZS5yZWZyZXNoKGRhdGFUeXBlKTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHBhcnNlclN0b3JlLmNsZWFyKCk7XG4gIH1cbiAgc3RhdGljIF90eXBlY2FzdChmaWVsZCwgbmV4dCkge1xuICAgIGlmIChwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZXJTdG9yZS5nZXQoZmllbGQudHlwZSkoZmllbGQsIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMsIG5leHQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dCgpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvc3Q6IGNvbmZpZy5ob3N0LFxuICAgICAgcG9ydDogY29uZmlnLnBvcnQsXG4gICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBmbGFnczogXCItRk9VTkRfUk9XU1wiLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICB0aW1lem9uZTogdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSxcbiAgICAgIHR5cGVDYXN0OiBDb25uZWN0aW9uTWFuYWdlci5fdHlwZWNhc3QuYmluZCh0aGlzKSxcbiAgICAgIGJpZ051bWJlclN0cmluZ3M6IGZhbHNlLFxuICAgICAgc3VwcG9ydEJpZ051bWJlcnM6IHRydWVcbiAgICB9LCBjb25maWcuZGlhbGVjdE9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uMiA9IHRoaXMubGliLmNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlKSA9PiB7XG4gICAgICAgICAgY29ubmVjdGlvbjIucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICBjb25uZWN0aW9uMi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24yLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29ubmVjdGlvbjIub24oXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgICBjb25uZWN0aW9uMi5vbmNlKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgICB9KTtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICAgIGNvbm5lY3Rpb24ub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgc3dpdGNoIChlcnJvci5jb2RlKSB7XG4gICAgICAgICAgY2FzZSBcIkVTT0NLRVRcIjpcbiAgICAgICAgICBjYXNlIFwiRUNPTk5SRVNFVFwiOlxuICAgICAgICAgIGNhc2UgXCJFUElQRVwiOlxuICAgICAgICAgIGNhc2UgXCJQUk9UT0NPTF9DT05ORUNUSU9OX0xPU1RcIjpcbiAgICAgICAgICAgIHRoaXMucG9vbC5kZXN0cm95KGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgICAgbGV0IHR6T2Zmc2V0ID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZTtcbiAgICAgICAgdHpPZmZzZXQgPSAvXFwvLy50ZXN0KHR6T2Zmc2V0KSA/IG1vbWVudFR6LnR6KHR6T2Zmc2V0KS5mb3JtYXQoXCJaXCIpIDogdHpPZmZzZXQ7XG4gICAgICAgIGF3YWl0IHByb21pc2lmeSgoY2IpID0+IGNvbm5lY3Rpb24ucXVlcnkoYFNFVCB0aW1lX3pvbmUgPSAnJHt0ek9mZnNldH0nYCwgY2IpKSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICAgIGNhc2UgXCJFQ09OTlJFRlVTRURcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25SZWZ1c2VkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVSX0FDQ0VTU19ERU5JRURfRVJST1JcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkFjY2Vzc0RlbmllZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFTk9URk9VTkRcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFSE9TVFVOUkVBQ0hcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkhvc3ROb3RSZWFjaGFibGVFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRUlOVkFMXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yKGVycik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uX2Nsb3NpbmcpIHtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBDTE9TRUQgc3RhdGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiBjb25uZWN0aW9uLmVuZChjYWxsYmFjaykpKCk7XG4gIH1cbiAgdmFsaWRhdGUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiBjb25uZWN0aW9uICYmICFjb25uZWN0aW9uLl9mYXRhbEVycm9yICYmICFjb25uZWN0aW9uLl9wcm90b2NvbEVycm9yICYmICFjb25uZWN0aW9uLl9jbG9zaW5nICYmICFjb25uZWN0aW9uLnN0cmVhbS5kZXN0cm95ZWQ7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/data-types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/data-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.mysql.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.mysql = [\"DATETIME\"];\n  BaseTypes.STRING.types.mysql = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mysql = [\"STRING\"];\n  BaseTypes.TEXT.types.mysql = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mysql = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mysql = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mysql = [\"INT24\"];\n  BaseTypes.INTEGER.types.mysql = [\"LONG\"];\n  BaseTypes.BIGINT.types.mysql = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mysql = [\"FLOAT\"];\n  BaseTypes.TIME.types.mysql = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mysql = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mysql = [\"TINY\"];\n  BaseTypes.BLOB.types.mysql = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mysql = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mysql = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mysql = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mysql = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  const SUPPORTED_GEOMETRY_TYPES = [\"POINT\", \"LINESTRING\", \"POLYGON\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n        return;\n      }\n      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {\n        this.sqlType = this.type;\n        return;\n      }\n      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(\", \")}`);\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map((value) => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLGdEQUFLO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIsT0FBTyxFQUFFLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9DQUFvQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkRBQTZEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvZGF0YS10eXBlcy5qcz8zMjJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgd2t4ID0gcmVxdWlyZShcIndreFwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBCYXNlVHlwZXMuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9IFwiaHR0cHM6Ly9kZXYubXlzcWwuY29tL2RvYy9yZWZtYW4vNS43L2VuL2RhdGEtdHlwZXMuaHRtbFwiO1xuICBCYXNlVHlwZXMuREFURS50eXBlcy5teXNxbCA9IFtcIkRBVEVUSU1FXCJdO1xuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLm15c3FsID0gW1wiVkFSX1NUUklOR1wiXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMubXlzcWwgPSBbXCJTVFJJTkdcIl07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm15c3FsID0gW1wiQkxPQlwiXTtcbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMubXlzcWwgPSBbXCJUSU5ZXCJdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMubXlzcWwgPSBbXCJTSE9SVFwiXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5teXNxbCA9IFtcIklOVDI0XCJdO1xuICBCYXNlVHlwZXMuSU5URUdFUi50eXBlcy5teXNxbCA9IFtcIkxPTkdcIl07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMubXlzcWwgPSBbXCJMT05HTE9OR1wiXTtcbiAgQmFzZVR5cGVzLkZMT0FULnR5cGVzLm15c3FsID0gW1wiRkxPQVRcIl07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLm15c3FsID0gW1wiVElNRVwiXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLm15c3FsID0gW1wiREFURVwiXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMubXlzcWwgPSBbXCJUSU5ZXCJdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5teXNxbCA9IFtcIlRJTllCTE9CXCIsIFwiQkxPQlwiLCBcIkxPTkdCTE9CXCJdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5teXNxbCA9IFtcIk5FV0RFQ0lNQUxcIl07XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLm15c3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5FTlVNLnR5cGVzLm15c3FsID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm15c3FsID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuRE9VQkxFLnR5cGVzLm15c3FsID0gW1wiRE9VQkxFXCJdO1xuICBCYXNlVHlwZXMuR0VPTUVUUlkudHlwZXMubXlzcWwgPSBbXCJHRU9NRVRSWVwiXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMubXlzcWwgPSBbXCJKU09OXCJdO1xuICBjbGFzcyBERUNJTUFMIGV4dGVuZHMgQmFzZVR5cGVzLkRFQ0lNQUwge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSBzdXBlci50b1NxbCgpO1xuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIGRlZmluaXRpb24gKz0gXCIgVU5TSUdORURcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICBkZWZpbml0aW9uICs9IFwiIFpFUk9GSUxMXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sZW5ndGggPyBgREFURVRJTUUoJHt0aGlzLl9sZW5ndGh9KWAgOiBcIkRBVEVUSU1FXCI7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFtb21lbnQuaXNNb21lbnQoZGF0ZSkpIHtcbiAgICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3MuU1NTXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGUuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbTpzc1wiKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN0cmluZygpO1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChtb21lbnRUei50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHZhbHVlID0gbW9tZW50VHoudHoodmFsdWUsIG9wdGlvbnMudGltZXpvbmUpLnRvRGF0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZShgJHt2YWx1ZX0gJHtvcHRpb25zLnRpbWV6b25lfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDSEFSKDM2KSBCSU5BUllcIjtcbiAgICB9XG4gIH1cbiAgY29uc3QgU1VQUE9SVEVEX0dFT01FVFJZX1RZUEVTID0gW1wiUE9JTlRcIiwgXCJMSU5FU1RSSU5HXCIsIFwiUE9MWUdPTlwiXTtcbiAgY2xhc3MgR0VPTUVUUlkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPTUVUUlkge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNyaWQpIHtcbiAgICAgIHN1cGVyKHR5cGUsIHNyaWQpO1xuICAgICAgaWYgKF8uaXNFbXB0eSh0aGlzLnR5cGUpKSB7XG4gICAgICAgIHRoaXMuc3FsVHlwZSA9IHRoaXMua2V5O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoU1VQUE9SVEVEX0dFT01FVFJZX1RZUEVTLmluY2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgdGhpcy5zcWxUeXBlID0gdGhpcy50eXBlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlcyBhcmU6ICR7U1VQUE9SVEVEX0dFT01FVFJZX1RZUEVTLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmJ1ZmZlcigpO1xuICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDQpO1xuICAgICAgcmV0dXJuIHdreC5HZW9tZXRyeS5wYXJzZSh2YWx1ZSkudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3FsVHlwZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYEVOVU0oJHt0aGlzLnZhbHVlcy5tYXAoKHZhbHVlKSA9PiBvcHRpb25zLmVzY2FwZSh2YWx1ZSkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3BlcmF0aW9uID09PSBcIndoZXJlXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgRU5VTSxcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFVVSUQsXG4gICAgR0VPTUVUUlksXG4gICAgREVDSU1BTCxcbiAgICBKU09OOiBKU09OVFlQRVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").mysql);\nconst { MySQLQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js\");\nclass MysqlDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new MySQLQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return true;\n  }\n}\nMysqlDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: \" ON DUPLICATE KEY UPDATE\"\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: true,\n  JSON: true,\n  REGEXP: true\n});\nMysqlDialect.prototype.defaultVersion = \"5.7.0\";\nMysqlDialect.prototype.Query = Query;\nMysqlDialect.prototype.QueryGenerator = QueryGenerator;\nMysqlDialect.prototype.DataTypes = DataTypes;\nMysqlDialect.prototype.name = \"mysql\";\nMysqlDialect.prototype.TICK_CHAR = \"`\";\nMysqlDialect.prototype.TICK_CHAR_LEFT = MysqlDialect.prototype.TICK_CHAR;\nMysqlDialect.prototype.TICK_CHAR_RIGHT = MysqlDialect.prototype.TICK_CHAR;\nmodule.exports = MysqlDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDJFQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFtQjtBQUNsRCxrQkFBa0IsdUdBQWlDO0FBQ25ELFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQywrRkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL2luZGV4LmpzPzJlNjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikubXlzcWw7XG5jb25zdCB7IE15U1FMUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIE15c3FsRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE15U1FMUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxuICBjYW5CYWNrc2xhc2hFc2NhcGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbk15c3FsRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIFwiVkFMVUVTICgpXCI6IHRydWUsXG4gIFwiTElNSVQgT04gVVBEQVRFXCI6IHRydWUsXG4gIGxvY2s6IHRydWUsXG4gIGZvclNoYXJlOiBcIkxPQ0sgSU4gU0hBUkUgTU9ERVwiLFxuICBzZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbjogZmFsc2UsXG4gIGluc2VydHM6IHtcbiAgICBpZ25vcmVEdXBsaWNhdGVzOiBcIiBJR05PUkVcIixcbiAgICB1cGRhdGVPbkR1cGxpY2F0ZTogXCIgT04gRFVQTElDQVRFIEtFWSBVUERBVEVcIlxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwYXJzZXI6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICB1c2luZzogMVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZSxcbiAgICBjaGVjazogZmFsc2VcbiAgfSxcbiAgaW5kZXhWaWFBbHRlcjogdHJ1ZSxcbiAgaW5kZXhIaW50czogdHJ1ZSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgR0VPTUVUUlk6IHRydWUsXG4gIEpTT046IHRydWUsXG4gIFJFR0VYUDogdHJ1ZVxufSk7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCI1LjcuMFwiO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5RdWVyeUdlbmVyYXRvciA9IFF1ZXJ5R2VuZXJhdG9yO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcIm15c3FsXCI7XG5NeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9IFwiYFwiO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IE15c3FsRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuTXlzcWxEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBNeXNxbERpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbm1vZHVsZS5leHBvcnRzID0gTXlzcWxEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-generator.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT VERSION() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      engine: \"InnoDB\",\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS', 'mysql', 'information_schema', 'performance_schema', 'sys')\";\n    }\n    return `${query};`;\n  }\n  tableExistsQuery(table) {\n    const tableName = this.escape(this.quoteTable(table).slice(1, -1));\n    return `SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND TABLE_NAME = ${tableName} AND TABLE_SCHEMA = ${this.escape(this.sequelize.config.database)}`;\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes(\"REFERENCES\")) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(\", \")}`,\n      constraintString.length && `ADD ${constraintString.join(\", \")}`,\n      \";\"\n    ]);\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"CHANGE\",\n      attrString.join(\", \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        let str;\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        smth.type = \"char\";\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = \"decimal\";\n      } else if (/text/i.test(smth.type)) {\n        smth.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _toJSONValue(value) {\n    if (typeof value === \"boolean\") {\n      return value.toString();\n    }\n    if (value === null) {\n      return \"null\";\n    }\n    return value;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = \"\";\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n    where = this.getWhereConditions(where, null, model, options);\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n    return query + limit;\n  }\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" auto_increment\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = MySQLQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDcEUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDcEMsOENBQThDLElBQUksa0JBQWtCLElBQUk7QUFDeEUsd0RBQXdELEVBQUU7QUFDMUQsMERBQTBELEVBQUUsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVGO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQiw0QkFBNEIsRUFBRSxvQ0FBb0M7QUFDNUY7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsNEJBQTRCLEVBQUUsU0FBUztBQUMvRDtBQUNBLFFBQVE7QUFDUix3QkFBd0IsNEJBQTRCLEVBQUUsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxHQUFHLHlCQUF5QjtBQUN0RTtBQUNBLDBDQUEwQyxpQ0FBaUMsR0FBRyxzRUFBc0U7QUFDcEo7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsSUFBSSxrQkFBa0I7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCLGdCQUFnQixlQUFlO0FBQy9CLDJFQUEyRSw2QkFBNkI7QUFDeEcsNENBQTRDLGdCQUFnQjtBQUM1RCxvQ0FBb0MsZ0JBQWdCO0FBQ3BELHdEQUF3RCw2QkFBNkI7QUFDckYseUNBQXlDLGtCQUFrQjtBQUMzRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxXQUFXLHFCQUFxQiw0Q0FBNEM7QUFDNUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTLElBQUksV0FBVztBQUN0RSxRQUFRO0FBQ1IsNkJBQTZCLGNBQWMsT0FBTyxjQUFjLEtBQUssV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFzQjtBQUMzRCx3Q0FBd0MsNEJBQTRCO0FBQ3BFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsV0FBVyxPQUFPLFNBQVMsS0FBSyxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBLDRDQUE0QztBQUM1QztBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BELCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkMsV0FBVztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0NBQWdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsK0JBQStCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQixHQUFHLFNBQVM7QUFDN0Usd0NBQXdDLFFBQVEsZUFBZSxTQUFTO0FBQ3hFO0FBQ0EsaUNBQWlDLDRDQUE0QztBQUM3RTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEUsUUFBUTtBQUNSLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBLGtDQUFrQyxpQ0FBaUM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLFVBQVU7QUFDaEYsK0RBQStELFdBQVc7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCx5REFBeUQsaUJBQWlCO0FBQzFFLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4Qyw4Q0FBOEMsaUJBQWlCO0FBQy9ELDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1nZW5lcmF0b3IuanM/NWM1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgT3AgPSByZXF1aXJlKFwiLi4vLi4vb3BlcmF0b3JzXCIpO1xuY29uc3QgSlNPTl9GVU5DVElPTl9SRUdFWCA9IC9eXFxzKigoPzpbYS16XStfKXswLDJ9anNvbmI/KD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuY29uc3QgSlNPTl9PUEVSQVRPUl9SRUdFWCA9IC9eXFxzKigtPj4/fEA+fDxAfFxcP1t8Jl0/fFxcfHsyfXwjLSkvaTtcbmNvbnN0IFRPS0VOX0NBUFRVUkVfUkVHRVggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcbmNvbnN0IEZPUkVJR05fS0VZX0ZJRUxEUyA9IFtcbiAgXCJDT05TVFJBSU5UX05BTUUgYXMgY29uc3RyYWludF9uYW1lXCIsXG4gIFwiQ09OU1RSQUlOVF9OQU1FIGFzIGNvbnN0cmFpbnROYW1lXCIsXG4gIFwiQ09OU1RSQUlOVF9TQ0hFTUEgYXMgY29uc3RyYWludFNjaGVtYVwiLFxuICBcIkNPTlNUUkFJTlRfU0NIRU1BIGFzIGNvbnN0cmFpbnRDYXRhbG9nXCIsXG4gIFwiVEFCTEVfTkFNRSBhcyB0YWJsZU5hbWVcIixcbiAgXCJUQUJMRV9TQ0hFTUEgYXMgdGFibGVTY2hlbWFcIixcbiAgXCJUQUJMRV9TQ0hFTUEgYXMgdGFibGVDYXRhbG9nXCIsXG4gIFwiQ09MVU1OX05BTUUgYXMgY29sdW1uTmFtZVwiLFxuICBcIlJFRkVSRU5DRURfVEFCTEVfU0NIRU1BIGFzIHJlZmVyZW5jZWRUYWJsZVNjaGVtYVwiLFxuICBcIlJFRkVSRU5DRURfVEFCTEVfU0NIRU1BIGFzIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2dcIixcbiAgXCJSRUZFUkVOQ0VEX1RBQkxFX05BTUUgYXMgcmVmZXJlbmNlZFRhYmxlTmFtZVwiLFxuICBcIlJFRkVSRU5DRURfQ09MVU1OX05BTUUgYXMgcmVmZXJlbmNlZENvbHVtbk5hbWVcIlxuXS5qb2luKFwiLFwiKTtcbmNvbnN0IHR5cGVXaXRob3V0RGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIkJMT0JcIiwgXCJURVhUXCIsIFwiR0VPTUVUUllcIiwgXCJKU09OXCJdKTtcbmNsYXNzIE15U1FMUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuT3BlcmF0b3JNYXAgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLk9wZXJhdG9yTWFwKSwge1xuICAgICAgW09wLnJlZ2V4cF06IFwiUkVHRVhQXCIsXG4gICAgICBbT3Aubm90UmVnZXhwXTogXCJOT1QgUkVHRVhQXCJcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEYXRhYmFzZVF1ZXJ5KGRhdGFiYXNlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgY29sbGF0ZTogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQ1JFQVRFIERBVEFCQVNFIElGIE5PVCBFWElTVFNcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSksXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUkFDVEVSIFNFVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY2hhcnNldCl9YCxcbiAgICAgIG9wdGlvbnMuY29sbGF0ZSAmJiBgREVGQVVMVCBDT0xMQVRFICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb2xsYXRlKX1gLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgREFUQUJBU0UgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoZGF0YWJhc2VOYW1lKX07YDtcbiAgfVxuICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIFwiU0hPVyBUQUJMRVNcIjtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNIT1cgVEFCTEVTXCI7XG4gIH1cbiAgdmVyc2lvblF1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBWRVJTSU9OKCkgYXMgYHZlcnNpb25gXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgZW5naW5lOiBcIklubm9EQlwiLFxuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIHJvd0Zvcm1hdDogbnVsbFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IHByaW1hcnlLZXlzID0gW107XG4gICAgY29uc3QgZm9yZWlnbktleXMgPSB7fTtcbiAgICBjb25zdCBhdHRyU3RyID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIGF0dHIpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGRhdGFUeXBlID0gYXR0cmlidXRlc1thdHRyXTtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlBSSU1BUlkgS0VZXCIpKSB7XG4gICAgICAgIHByaW1hcnlLZXlzLnB1c2goYXR0cik7XG4gICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7bWF0Y2hbMV0ucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpfWApO1xuICAgICAgICAgIGZvcmVpZ25LZXlzW2F0dHJdID0gbWF0Y2hbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlLnJlcGxhY2UoXCJQUklNQVJZIEtFWVwiLCBcIlwiKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXX1gKTtcbiAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHtkYXRhVHlwZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBsZXQgYXR0cmlidXRlc0NsYXVzZSA9IGF0dHJTdHIuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IHBrU3RyaW5nID0gcHJpbWFyeUtleXMubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGspKS5qb2luKFwiLCBcIik7XG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMsIGluZGV4TmFtZSkgPT4ge1xuICAgICAgICBpZiAoY29sdW1ucy5jdXN0b21JbmRleCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpbmRleE5hbWUgPSBgdW5pcV8ke3RhYmxlTmFtZX1fJHtjb2x1bW5zLmZpZWxkcy5qb2luKFwiX1wiKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFVOSVFVRSAke3RoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSl9ICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBrU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtTdHJpbmd9KWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmtleSBpbiBmb3JlaWduS2V5cykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb3JlaWduS2V5cywgZmtleSkpIHtcbiAgICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUU1wiLFxuICAgICAgdGFibGUsXG4gICAgICBgKCR7YXR0cmlidXRlc0NsYXVzZX0pYCxcbiAgICAgIGBFTkdJTkU9JHtvcHRpb25zLmVuZ2luZX1gLFxuICAgICAgb3B0aW9ucy5jb21tZW50ICYmIHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09IFwic3RyaW5nXCIgJiYgYENPTU1FTlQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbW1lbnQpfWAsXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUlNFVD0ke29wdGlvbnMuY2hhcnNldH1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBDT0xMQVRFICR7b3B0aW9ucy5jb2xsYXRlfWAsXG4gICAgICBvcHRpb25zLmluaXRpYWxBdXRvSW5jcmVtZW50ICYmIGBBVVRPX0lOQ1JFTUVOVD0ke29wdGlvbnMuaW5pdGlhbEF1dG9JbmNyZW1lbnR9YCxcbiAgICAgIG9wdGlvbnMucm93Rm9ybWF0ICYmIGBST1dfRk9STUFUPSR7b3B0aW9ucy5yb3dGb3JtYXR9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBfc2NoZW1hOiBzY2hlbWEsXG4gICAgICBfc2NoZW1hRGVsaW1pdGVyOiBzY2hlbWFEZWxpbWl0ZXJcbiAgICB9KSk7XG4gICAgcmV0dXJuIGBTSE9XIEZVTEwgQ09MVU1OUyBGUk9NICR7dGFibGV9O2A7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KGRhdGFiYXNlKSB7XG4gICAgbGV0IHF1ZXJ5ID0gXCJTRUxFQ1QgVEFCTEVfTkFNRSBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRVMgV0hFUkUgVEFCTEVfVFlQRSA9ICdCQVNFIFRBQkxFJ1wiO1xuICAgIGlmIChkYXRhYmFzZSkge1xuICAgICAgcXVlcnkgKz0gYCBBTkQgVEFCTEVfU0NIRU1BID0gJHt0aGlzLmVzY2FwZShkYXRhYmFzZSl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgKz0gXCIgQU5EIFRBQkxFX1NDSEVNQSBOT1QgSU4gKCdNWVNRTCcsICdJTkZPUk1BVElPTl9TQ0hFTUEnLCAnUEVSRk9STUFOQ0VfU0NIRU1BJywgJ1NZUycsICdteXNxbCcsICdpbmZvcm1hdGlvbl9zY2hlbWEnLCAncGVyZm9ybWFuY2Vfc2NoZW1hJywgJ3N5cycpXCI7XG4gICAgfVxuICAgIHJldHVybiBgJHtxdWVyeX07YDtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5lc2NhcGUodGhpcy5xdW90ZVRhYmxlKHRhYmxlKS5zbGljZSgxLCAtMSkpO1xuICAgIHJldHVybiBgU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRScgQU5EIFRBQkxFX05BTUUgPSAke3RhYmxlTmFtZX0gQU5EIFRBQkxFX1NDSEVNQSA9ICR7dGhpcy5lc2NhcGUodGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlKX1gO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgIFwiQUREXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwge1xuICAgICAgICBjb250ZXh0OiBcImFkZENvbHVtblwiLFxuICAgICAgICB0YWJsZU5hbWU6IHRhYmxlLFxuICAgICAgICBmb3JlaWduS2V5OiBrZXlcbiAgICAgIH0pLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcbiAgICBjb25zdCBjb25zdHJhaW50U3RyaW5nID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sIFwiXCIpO1xuICAgICAgICBjb25zdHJhaW50U3RyaW5nLnB1c2goYEZPUkVJR04gS0VZICgke2F0dHJOYW1lfSkgJHtkZWZpbml0aW9ufWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0cmluZy5wdXNoKGBcXGAke2F0dHJpYnV0ZU5hbWV9XFxgIFxcYCR7YXR0cmlidXRlTmFtZX1cXGAgJHtkZWZpbml0aW9ufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGF0dHJTdHJpbmcubGVuZ3RoICYmIGBDSEFOR0UgJHthdHRyU3RyaW5nLmpvaW4oXCIsIFwiKX1gLFxuICAgICAgY29uc3RyYWludFN0cmluZy5sZW5ndGggJiYgYEFERCAke2NvbnN0cmFpbnRTdHJpbmcuam9pbihcIiwgXCIpfWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgIGF0dHJTdHJpbmcucHVzaChgXFxgJHthdHRyQmVmb3JlfVxcYCBcXGAke2F0dHJOYW1lfVxcYCAke2RlZmluaXRpb259YCk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpLFxuICAgICAgXCJDSEFOR0VcIixcbiAgICAgIGF0dHJTdHJpbmcuam9pbihcIiwgXCIpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICBpZiAoc210aC5jb25kaXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbnMgPSB0aGlzLnBhcnNlQ29uZGl0aW9uT2JqZWN0KHNtdGguY29uZGl0aW9ucykubWFwKChjb25kaXRpb24pID0+IGAke3RoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29uZGl0aW9uLnBhdGhbMF0sIF8udGFpbChjb25kaXRpb24ucGF0aCkpfSA9ICcke2NvbmRpdGlvbi52YWx1ZX0nYCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb25zLmpvaW4oXCIgQU5EIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzbXRoLnBhdGgpIHtcbiAgICAgICAgbGV0IHN0cjtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrVmFsaWRKc29uU3RhdGVtZW50KHNtdGgucGF0aCkpIHtcbiAgICAgICAgICBzdHIgPSBzbXRoLnBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGF0aHMgPSBfLnRvUGF0aChzbXRoLnBhdGgpO1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBhdGhzLnNoaWZ0KCk7XG4gICAgICAgICAgc3RyID0gdGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb2x1bW4sIHBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc210aC52YWx1ZSkge1xuICAgICAgICAgIHN0ciArPSB1dGlsLmZvcm1hdChcIiA9ICVzXCIsIHRoaXMuZXNjYXBlKHNtdGgudmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkNhc3QpIHtcbiAgICAgIGlmICgvdGltZXN0YW1wL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9IFwiZGF0ZXRpbWVcIjtcbiAgICAgIH0gZWxzZSBpZiAoc210aC5qc29uICYmIC9ib29sZWFuL2kudGVzdChzbXRoLnR5cGUpKSB7XG4gICAgICAgIHNtdGgudHlwZSA9IFwiY2hhclwiO1xuICAgICAgfSBlbHNlIGlmICgvZG91YmxlIHByZWNpc2lvbi9pLnRlc3Qoc210aC50eXBlKSB8fCAvYm9vbGVhbi9pLnRlc3Qoc210aC50eXBlKSB8fCAvaW50ZWdlci9pLnRlc3Qoc210aC50eXBlKSkge1xuICAgICAgICBzbXRoLnR5cGUgPSBcImRlY2ltYWxcIjtcbiAgICAgIH0gZWxzZSBpZiAoL3RleHQvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gXCJjaGFyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5oYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuICBfdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBgVFJVTkNBVEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBsZXQgbGltaXQgPSBcIlwiO1xuICAgIGxldCBxdWVyeSA9IGBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGxpbWl0ID0gYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfWA7XG4gICAgfVxuICAgIHdoZXJlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBpZiAod2hlcmUpIHtcbiAgICAgIHF1ZXJ5ICs9IGAgV0hFUkUgJHt3aGVyZX1gO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnkgKyBsaW1pdDtcbiAgfVxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIGBTSE9XIElOREVYIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX1gLFxuICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLmRhdGFiYXNlICYmIGBGUk9NIFxcYCR7b3B0aW9ucy5kYXRhYmFzZX1cXGBgXG4gICAgXSk7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWE7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgQ09OU1RSQUlOVF9DQVRBTE9HIEFTIGNvbnN0cmFpbnRDYXRhbG9nLFwiLFxuICAgICAgXCJDT05TVFJBSU5UX05BTUUgQVMgY29uc3RyYWludE5hbWUsXCIsXG4gICAgICBcIkNPTlNUUkFJTlRfU0NIRU1BIEFTIGNvbnN0cmFpbnRTY2hlbWEsXCIsXG4gICAgICBcIkNPTlNUUkFJTlRfVFlQRSBBUyBjb25zdHJhaW50VHlwZSxcIixcbiAgICAgIFwiVEFCTEVfTkFNRSBBUyB0YWJsZU5hbWUsXCIsXG4gICAgICBcIlRBQkxFX1NDSEVNQSBBUyB0YWJsZVNjaGVtYVwiLFxuICAgICAgXCJmcm9tIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UU1wiLFxuICAgICAgYFdIRVJFIHRhYmxlX25hbWU9JyR7dGFibGVOYW1lfSdgLFxuICAgICAgY29uc3RyYWludE5hbWUgJiYgYEFORCBjb25zdHJhaW50X25hbWUgPSAnJHtjb25zdHJhaW50TmFtZX0nYCxcbiAgICAgIHNjaGVtYU5hbWUgJiYgYEFORCBUQUJMRV9TQ0hFTUEgPSAnJHtzY2hlbWFOYW1lfSdgLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkRST1AgSU5ERVhcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSksXG4gICAgICBcIk9OXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKVxuICAgIF0pO1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBhdHRyaWJ1dGVTdHJpbmcgPSBhdHRyaWJ1dGUudHlwZS50b1N0cmluZyh7IGVzY2FwZTogdGhpcy5lc2NhcGUuYmluZCh0aGlzKSB9KTtcbiAgICBsZXQgdGVtcGxhdGUgPSBhdHRyaWJ1dGVTdHJpbmc7XG4gICAgaWYgKGF0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBOT1QgTlVMTFwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIGF1dG9faW5jcmVtZW50XCI7XG4gICAgfVxuICAgIGlmICghdHlwZVdpdGhvdXREZWZhdWx0LmhhcyhhdHRyaWJ1dGVTdHJpbmcpICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKX1gO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgVU5JUVVFXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgUFJJTUFSWSBLRVlcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5jb21tZW50KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENPTU1FTlQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuY29tbWVudCl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5maXJzdCkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgRklSU1RcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hZnRlcikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBBRlRFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZS5hZnRlcil9YDtcbiAgICB9XG4gICAgaWYgKCghb3B0aW9ucyB8fCAhb3B0aW9ucy53aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzKSAmJiBhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSBcImFkZENvbHVtblwiICYmIG9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIGNvbnN0IGZrTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGAke29wdGlvbnMudGFibGVOYW1lfV8ke2F0dHJOYW1lfV9mb3JlaWduX2lkeGApO1xuICAgICAgICB0ZW1wbGF0ZSArPSBgLCBBREQgQ09OU1RSQUlOVCAke2ZrTmFtZX0gRk9SRUlHTiBLRVkgKCR7YXR0ck5hbWV9KWA7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IEpTT05fRlVOQ1RJT05fUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoXCIoXCIpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZXJhdG9yTWF0Y2hlcyA9IEpTT05fT1BFUkFUT1JfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG9wZXJhdG9yTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gb3BlcmF0b3JNYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSBUT0tFTl9DQVBUVVJFX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIjtcIikge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgKGhhc0ludmFsaWRUb2tlbiB8fCBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUsIHNjaGVtYU5hbWUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1RcIixcbiAgICAgIEZPUkVJR05fS0VZX0ZJRUxEUyxcbiAgICAgIGBGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFIHdoZXJlIFRBQkxFX05BTUUgPSAnJHt0YWJsZU5hbWV9J2AsXG4gICAgICBgQU5EIENPTlNUUkFJTlRfTkFNRSE9J1BSSU1BUlknIEFORCBDT05TVFJBSU5UX1NDSEVNQT0nJHtzY2hlbWFOYW1lfSdgLFxuICAgICAgXCJBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMXCIsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGdldEZvcmVpZ25LZXlRdWVyeSh0YWJsZSwgY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IHF1b3RlZFNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWEgPyB3cmFwU2luZ2xlUXVvdGUodGFibGUuc2NoZW1hKSA6IFwiXCI7XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZSk7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uTmFtZSA9IHdyYXBTaW5nbGVRdW90ZShjb2x1bW5OYW1lKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIlNFTEVDVFwiLFxuICAgICAgRk9SRUlHTl9LRVlfRklFTERTLFxuICAgICAgXCJGUk9NIElORk9STUFUSU9OX1NDSEVNQS5LRVlfQ09MVU1OX1VTQUdFXCIsXG4gICAgICBcIldIRVJFIChcIixcbiAgICAgIFtcbiAgICAgICAgYFJFRkVSRU5DRURfVEFCTEVfTkFNRSA9ICR7cXVvdGVkVGFibGVOYW1lfWAsXG4gICAgICAgIHRhYmxlLnNjaGVtYSAmJiBgQU5EIFJFRkVSRU5DRURfVEFCTEVfU0NIRU1BID0gJHtxdW90ZWRTY2hlbWFOYW1lfWAsXG4gICAgICAgIGBBTkQgUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSA9ICR7cXVvdGVkQ29sdW1uTmFtZX1gXG4gICAgICBdLFxuICAgICAgXCIpIE9SIChcIixcbiAgICAgIFtcbiAgICAgICAgYFRBQkxFX05BTUUgPSAke3F1b3RlZFRhYmxlTmFtZX1gLFxuICAgICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBUQUJMRV9TQ0hFTUEgPSAke3F1b3RlZFNjaGVtYU5hbWV9YCxcbiAgICAgICAgYEFORCBDT0xVTU5fTkFNRSA9ICR7cXVvdGVkQ29sdW1uTmFtZX1gLFxuICAgICAgICBcIkFORCBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgSVMgTk9UIE5VTExcIlxuICAgICAgXSxcbiAgICAgIFwiKVwiXG4gICAgXSk7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUCBGT1JFSUdOIEtFWVwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoZm9yZWlnbktleSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIHJldHVybiBVdGlscy5hZGRUaWNrcyhVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCBcImBcIiksIFwiYFwiKTtcbiAgfVxufVxuZnVuY3Rpb24gd3JhcFNpbmdsZVF1b3RlKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKGlkZW50aWZpZXIsIFwiJ1wiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gTXlTUUxRdWVyeUdlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWdlbmVyYXRvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass MySQLQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = Object.values(options.model.primaryKeys).map((item) => item.field);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.MySQLQueryInterface = MySQLQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLDRHQUE2QjtBQUNoRSxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnQ0FBZ0MsV0FBVztBQUNoRDtBQUNBLDBLQUEwSyxXQUFXO0FBQ3JMO0FBQ0EscUhBQXFILFdBQVc7QUFDaEk7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVGQUF1RjtBQUN2RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsV0FBVyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL215c3FsL3F1ZXJ5LWludGVyZmFjZS5qcz9mYTgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jbGFzcyBNeVNRTFF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBjb2x1bW5OYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgW3Jlc3VsdHNdID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLnRhYmxlTmFtZSA/IHRhYmxlTmFtZSA6IHtcbiAgICAgIHRhYmxlTmFtZSxcbiAgICAgIHNjaGVtYTogdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlXG4gICAgfSwgY29sdW1uTmFtZSksIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgICBpZiAocmVzdWx0cy5sZW5ndGggJiYgcmVzdWx0c1swXS5jb25zdHJhaW50X25hbWUgIT09IFwiUFJJTUFSWVwiKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChyZXN1bHRzLm1hcCgoY29uc3RyYWludCkgPT4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludC5jb25zdHJhaW50X25hbWUpLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBjb2x1bW5OYW1lKSwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIHVwc2VydCh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5VUFNFUlQ7XG4gICAgb3B0aW9ucy51cGRhdGVPbkR1cGxpY2F0ZSA9IE9iamVjdC5rZXlzKHVwZGF0ZVZhbHVlcyk7XG4gICAgb3B0aW9ucy51cHNlcnRLZXlzID0gT2JqZWN0LnZhbHVlcyhvcHRpb25zLm1vZGVsLnByaW1hcnlLZXlzKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmllbGQpO1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCBtb2RlbC5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZS50YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiB7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBzY2hlbWE6IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZVxuICAgIH0sIGNvbnN0cmFpbnROYW1lKTtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHR5cGU6IHRoaXMuc2VxdWVsaXplLlF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTXG4gICAgfSkpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1swXTtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKCFjb25zdHJhaW50IHx8ICFjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ29uc3RyYWludCAke2NvbnN0cmFpbnROYW1lfSBvbiB0YWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgLFxuICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50TmFtZSxcbiAgICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlID09PSBcIkZPUkVJR04gS0VZXCIpIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlSW5kZXhRdWVyeShjb25zdHJhaW50LnRhYmxlTmFtZSwgY29uc3RyYWludC5jb25zdHJhaW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cbn1cbmV4cG9ydHMuTXlTUUxRdWVyeUludGVyZmFjZSA9IE15U1FMUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/mysql/query.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/mysql/query.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:mysql\");\nclass Query extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, __spreadValues({ showWarnings: false }, options));\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    const errForStack = new Error();\n    try {\n      if (parameters && parameters.length) {\n        results = await new Promise((resolve, reject) => {\n          connection.execute(sql, parameters, (error, result) => error ? reject(error) : resolve(result)).setMaxListeners(100);\n        });\n      } else {\n        results = await new Promise((resolve, reject) => {\n          connection.query({ sql }, (error, result) => error ? reject(error) : resolve(result)).setMaxListeners(100);\n        });\n      }\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        const enumRegex = /^enum/i;\n        result[_result.Field] = {\n          type: enumRegex.test(_result.Type) ? _result.Type.replace(enumRegex, \"ENUM\") : _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data.affectedRows;\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `MySQL Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err, errStack) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2].split(\".\").pop() : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err,\n          stack: errStack\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9teXNxbC9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakUsMEJBQTBCLHFFQUFxRTtBQUMvRjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkRBQTJELHVEQUF1RDtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsS0FBSyxVQUFVO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvbXlzcWwvcXVlcnkuanM/NTM5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IEVSX0RVUF9FTlRSWSA9IDEwNjI7XG5jb25zdCBFUl9ERUFETE9DSyA9IDEyMTM7XG5jb25zdCBFUl9ST1dfSVNfUkVGRVJFTkNFRCA9IDE0NTE7XG5jb25zdCBFUl9OT19SRUZFUkVOQ0VEX1JPVyA9IDE0NTI7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6bXlzcWxcIik7XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIG9wdGlvbnMpIHtcbiAgICBzdXBlcihjb25uZWN0aW9uLCBzZXF1ZWxpemUsIF9fc3ByZWFkVmFsdWVzKHsgc2hvd1dhcm5pbmdzOiBmYWxzZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0gW107XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlc18pID0+IHtcbiAgICAgIGlmICh2YWx1ZXNfW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICBiaW5kUGFyYW0ucHVzaCh2YWx1ZXNfW2tleV0pO1xuICAgICAgICByZXR1cm4gXCI/XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH07XG4gICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgcmVwbGFjZW1lbnRGdW5jKVswXTtcbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtLmxlbmd0aCA+IDAgPyBiaW5kUGFyYW0gOiB2b2lkIDBdO1xuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb24sIG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2hvd1dhcm5pbmdzID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zaG93V2FybmluZ3MgfHwgb3B0aW9ucy5zaG93V2FybmluZ3M7XG4gICAgY29uc3QgY29tcGxldGUgPSB0aGlzLl9sb2dRdWVyeShzcWwsIGRlYnVnLCBwYXJhbWV0ZXJzKTtcbiAgICBpZiAocGFyYW1ldGVycykge1xuICAgICAgZGVidWcoXCJwYXJhbWV0ZXJzKCVqKVwiLCBwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHM7XG4gICAgY29uc3QgZXJyRm9yU3RhY2sgPSBuZXcgRXJyb3IoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25uZWN0aW9uLmV4ZWN1dGUoc3FsLCBwYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKS5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbm5lY3Rpb24ucXVlcnkoeyBzcWwgfSwgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSkuc2V0TWF4TGlzdGVuZXJzKDEwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiAmJiBlcnJvci5lcnJubyA9PT0gRVJfREVBRExPQ0spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBvcHRpb25zLnRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yXykge1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24uZmluaXNoZWQgPSBcInJvbGxiYWNrXCI7XG4gICAgICB9XG4gICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICBlcnJvci5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IsIGVyckZvclN0YWNrLnN0YWNrKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gICAgaWYgKHNob3dXYXJuaW5ncyAmJiByZXN1bHRzICYmIHJlc3VsdHMud2FybmluZ1N0YXR1cyA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMubG9nV2FybmluZ3MocmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcm1hdFJlc3VsdHMocmVzdWx0cyk7XG4gIH1cbiAgZm9ybWF0UmVzdWx0cyhkYXRhKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuaW5zdGFuY2U7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeShkYXRhKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShkYXRhKTtcbiAgICAgIGlmICghdGhpcy5pbnN0YW5jZSkge1xuICAgICAgICBpZiAoZGF0YS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlJlc3VsdFNldEhlYWRlclwiICYmIHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9PT0gdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgY29uc3Qgc3RhcnRJZCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydElkOyBpIDwgc3RhcnRJZCArIGRhdGEuYWZmZWN0ZWRSb3dzOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgW3RoaXMubW9kZWwucmF3QXR0cmlidXRlc1t0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkXTogaSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gZGF0YVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93VGFibGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd1RhYmxlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IF9yZXN1bHQgb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBlbnVtUmVnZXggPSAvXmVudW0vaTtcbiAgICAgICAgcmVzdWx0W19yZXN1bHQuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IGVudW1SZWdleC50ZXN0KF9yZXN1bHQuVHlwZSkgPyBfcmVzdWx0LlR5cGUucmVwbGFjZShlbnVtUmVnZXgsIFwiRU5VTVwiKSA6IF9yZXN1bHQuVHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgIGFsbG93TnVsbDogX3Jlc3VsdC5OdWxsID09PSBcIllFU1wiLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogX3Jlc3VsdC5EZWZhdWx0LFxuICAgICAgICAgIHByaW1hcnlLZXk6IF9yZXN1bHQuS2V5ID09PSBcIlBSSVwiLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfcmVzdWx0LCBcIkV4dHJhXCIpICYmIF9yZXN1bHQuRXh0cmEudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRvX2luY3JlbWVudFwiLFxuICAgICAgICAgIGNvbW1lbnQ6IF9yZXN1bHQuQ29tbWVudCA/IF9yZXN1bHQuQ29tbWVudCA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0luZGV4ZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NhbGxRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhLmFmZmVjdGVkUm93cztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNWZXJzaW9uUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF0udmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb3JlaWduS2V5c1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93cyA9PT0gMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoKSB8fCB0aGlzLmlzVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtyZXN1bHQsIGRhdGEuYWZmZWN0ZWRSb3dzXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW2RhdGEsIGRhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGxvZ1dhcm5pbmdzKHJlc3VsdHMpIHtcbiAgICBjb25zdCB3YXJuaW5nUmVzdWx0cyA9IGF3YWl0IHRoaXMucnVuKFwiU0hPVyBXQVJOSU5HU1wiKTtcbiAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBNeVNRTCBXYXJuaW5ncyAoJHt0aGlzLmNvbm5lY3Rpb24udXVpZCB8fCBcImRlZmF1bHRcIn0pOiBgO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBfd2FybmluZ1JvdyBvZiB3YXJuaW5nUmVzdWx0cykge1xuICAgICAgaWYgKF93YXJuaW5nUm93ID09PSB2b2lkIDAgfHwgdHlwZW9mIF93YXJuaW5nUm93W1N5bWJvbC5pdGVyYXRvcl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgX3dhcm5pbmdSZXN1bHQgb2YgX3dhcm5pbmdSb3cpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfd2FybmluZ1Jlc3VsdCwgXCJNZXNzYWdlXCIpKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChfd2FybmluZ1Jlc3VsdC5NZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IF9vYmplY3RLZXkgb2YgX3dhcm5pbmdSZXN1bHQua2V5cygpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKFtfb2JqZWN0S2V5LCBfd2FybmluZ1Jlc3VsdFtfb2JqZWN0S2V5XV0uam9pbihcIjogXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXF1ZWxpemUubG9nKHdhcm5pbmdNZXNzYWdlICsgbWVzc2FnZXMuam9pbihcIjsgXCIpLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spIHtcbiAgICBjb25zdCBlcnJDb2RlID0gZXJyLmVycm5vIHx8IGVyci5jb2RlO1xuICAgIHN3aXRjaCAoZXJyQ29kZSkge1xuICAgICAgY2FzZSBFUl9EVVBfRU5UUlk6IHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvRHVwbGljYXRlIGVudHJ5ICcoW1xcc1xcU10qKScgZm9yIGtleSAnPygoLnxcXHMpKj8pJz8kLyk7XG4gICAgICAgIGxldCBmaWVsZHMgPSB7fTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0Y2ggPyBtYXRjaFsxXS5zcGxpdChcIi1cIikgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGZpZWxkS2V5ID0gbWF0Y2ggPyBtYXRjaFsyXS5zcGxpdChcIi5cIikucG9wKCkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGZpZWxkVmFsID0gbWF0Y2ggPyBtYXRjaFsxXSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbZmllbGRLZXldO1xuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgaWYgKHVuaXF1ZUtleS5tc2cpXG4gICAgICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tmaWVsZEtleV0gPSBmaWVsZFZhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMsIHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgRVJfUk9XX0lTX1JFRkVSRU5DRUQ6XG4gICAgICBjYXNlIEVSX05PX1JFRkVSRU5DRURfUk9XOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0NPTlNUUkFJTlQgKFtgXCJdKSguKilcXDEgRk9SRUlHTiBLRVkgXFwoXFwxKC4qKVxcMVxcKSBSRUZFUkVOQ0VTIFxcMSguKilcXDEgXFwoXFwxKC4qKVxcMVxcKS8pO1xuICAgICAgICBjb25zdCBxdW90ZUNoYXIgPSBtYXRjaCA/IG1hdGNoWzFdIDogXCJgXCI7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IG1hdGNoID8gbWF0Y2hbM10uc3BsaXQobmV3IFJlZ0V4cChgJHtxdW90ZUNoYXJ9LCAqJHtxdW90ZUNoYXJ9YCkpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICByZWx0eXBlOiBTdHJpbmcoZXJyQ29kZSkgPT09IFN0cmluZyhFUl9ST1dfSVNfUkVGRVJFTkNFRCkgPyBcInBhcmVudFwiIDogXCJjaGlsZFwiLFxuICAgICAgICAgIHRhYmxlOiBtYXRjaCA/IG1hdGNoWzRdIDogdm9pZCAwLFxuICAgICAgICAgIGZpZWxkcyxcbiAgICAgICAgICB2YWx1ZTogZmllbGRzICYmIGZpZWxkcy5sZW5ndGggJiYgdGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlW2ZpZWxkc1swXV0gfHwgdm9pZCAwLFxuICAgICAgICAgIGluZGV4OiBtYXRjaCA/IG1hdGNoWzJdIDogdm9pZCAwLFxuICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyLCB7IHN0YWNrOiBlcnJTdGFjayB9KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGlmICghKGl0ZW0uS2V5X25hbWUgaW4gYWNjKSkge1xuICAgICAgICBhY2NbaXRlbS5LZXlfbmFtZV0gPSBpdGVtO1xuICAgICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgfVxuICAgICAgYWNjW2l0ZW0uS2V5X25hbWVdLmZpZWxkc1tpdGVtLlNlcV9pbl9pbmRleCAtIDFdID0ge1xuICAgICAgICBhdHRyaWJ1dGU6IGl0ZW0uQ29sdW1uX25hbWUsXG4gICAgICAgIGxlbmd0aDogaXRlbS5TdWJfcGFydCB8fCB2b2lkIDAsXG4gICAgICAgIG9yZGVyOiBpdGVtLkNvbGxhdGlvbiA9PT0gXCJBXCIgPyBcIkFTQ1wiIDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgZGVsZXRlIGl0ZW0uY29sdW1uX25hbWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gXy5tYXAoZGF0YSwgKGl0ZW0pID0+ICh7XG4gICAgICBwcmltYXJ5OiBpdGVtLktleV9uYW1lID09PSBcIlBSSU1BUllcIixcbiAgICAgIGZpZWxkczogaXRlbS5maWVsZHMsXG4gICAgICBuYW1lOiBpdGVtLktleV9uYW1lLFxuICAgICAgdGFibGVOYW1lOiBpdGVtLlRhYmxlLFxuICAgICAgdW5pcXVlOiBpdGVtLk5vbl91bmlxdWUgIT09IDEsXG4gICAgICB0eXBlOiBpdGVtLkluZGV4X3R5cGVcbiAgICB9KSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/mysql/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/connection-manager.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleConnectionManager: () => OracleConnectionManager\n});\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"oracle\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst debug = logger.debugContext(\"connection:oracle\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").oracle);\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass OracleConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    this.sequelize = sequelize;\n    this.sequelize.config.port = this.sequelize.config.port || 1521;\n    this.lib = this._loadDialectModule(\"oracledb\");\n    this.extendLib();\n    this.refreshTypeParser(DataTypes);\n  }\n  extendLib() {\n    if (this.sequelize.config && \"dialectOptions\" in this.sequelize.config) {\n      const dialectOptions = this.sequelize.config.dialectOptions;\n      if (dialectOptions && \"maxRows\" in dialectOptions) {\n        this.lib.maxRows = this.sequelize.config.dialectOptions.maxRows;\n      }\n      if (dialectOptions && \"fetchAsString\" in dialectOptions) {\n        this.lib.fetchAsString = this.sequelize.config.dialectOptions.fetchAsString;\n      } else {\n        this.lib.fetchAsString = [this.lib.CLOB];\n      }\n    }\n    this.lib.fetchAsBuffer = [this.lib.BLOB];\n  }\n  buildConnectString(config) {\n    if (!config.host || config.host.length === 0)\n      return config.database;\n    let connectString = config.host;\n    if (config.port && config.port > 0) {\n      connectString += `:${config.port}`;\n    } else {\n      connectString += \":1521\";\n    }\n    if (config.database && config.database.length > 0) {\n      connectString += `/${config.database}`;\n    }\n    return connectString;\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      user: config.username,\n      password: config.password,\n      externalAuth: config.externalAuth,\n      stmtCacheSize: 0,\n      connectString: this.buildConnectString(config)\n    }, config.dialectOptions);\n    try {\n      const connection = await this.lib.getConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.oracleServerVersionString).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", (error) => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      let errorCode = err.message.split(\":\");\n      errorCode = errorCode[0];\n      switch (errorCode) {\n        case \"ORA-12560\":\n        case \"ORA-12154\":\n        case \"ORA-12505\":\n        case \"ORA-12514\":\n        case \"NJS-511\":\n        case \"NJS-516\":\n        case \"NJS-517\":\n        case \"NJS-520\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ORA-28000\":\n        case \"ORA-28040\":\n        case \"ORA-01017\":\n        case \"NJS-506\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ORA-12541\":\n        case \"NJS-503\":\n        case \"NJS-508\":\n        case \"NJS-507\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"NJS-512\":\n        case \"NJS-515\":\n        case \"NJS-518\":\n        case \"NJS-519\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        case \"ORA-12170\":\n        case \"NJS-510\":\n          throw new SequelizeErrors.ConnectionTimedOutError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isHealthy()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return await promisify((callback) => connection.close(callback))();\n  }\n  validate(connection) {\n    return connection && connection.isHealthy();\n  }\n}\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtDQUFrQyxtQkFBTyxDQUFDLGtIQUFnQztBQUMxRSx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDNUMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CO0FBQ0Esa0JBQWtCLHdHQUFrQztBQUNwRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvb3JhY2xlL2Nvbm5lY3Rpb24tbWFuYWdlci5qcz9iYWZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIE9yYWNsZUNvbm5lY3Rpb25NYW5hZ2VyOiAoKSA9PiBPcmFjbGVDb25uZWN0aW9uTWFuYWdlclxufSk7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcIm9yYWNsZVwiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IGRlYnVnID0gbG9nZ2VyLmRlYnVnQ29udGV4dChcImNvbm5lY3Rpb246b3JhY2xlXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikub3JhY2xlO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY2xhc3MgT3JhY2xlQ29ubmVjdGlvbk1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZGlhbGVjdCwgc2VxdWVsaXplKSB7XG4gICAgc3VwZXIoZGlhbGVjdCwgc2VxdWVsaXplKTtcbiAgICB0aGlzLnNlcXVlbGl6ZSA9IHNlcXVlbGl6ZTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5wb3J0IHx8IDE1MjE7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcIm9yYWNsZWRiXCIpO1xuICAgIHRoaXMuZXh0ZW5kTGliKCk7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIGV4dGVuZExpYigpIHtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUuY29uZmlnICYmIFwiZGlhbGVjdE9wdGlvbnNcIiBpbiB0aGlzLnNlcXVlbGl6ZS5jb25maWcpIHtcbiAgICAgIGNvbnN0IGRpYWxlY3RPcHRpb25zID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RPcHRpb25zO1xuICAgICAgaWYgKGRpYWxlY3RPcHRpb25zICYmIFwibWF4Um93c1wiIGluIGRpYWxlY3RPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGliLm1heFJvd3MgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGlhbGVjdE9wdGlvbnMubWF4Um93cztcbiAgICAgIH1cbiAgICAgIGlmIChkaWFsZWN0T3B0aW9ucyAmJiBcImZldGNoQXNTdHJpbmdcIiBpbiBkaWFsZWN0T3B0aW9ucykge1xuICAgICAgICB0aGlzLmxpYi5mZXRjaEFzU3RyaW5nID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRpYWxlY3RPcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxpYi5mZXRjaEFzU3RyaW5nID0gW3RoaXMubGliLkNMT0JdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxpYi5mZXRjaEFzQnVmZmVyID0gW3RoaXMubGliLkJMT0JdO1xuICB9XG4gIGJ1aWxkQ29ubmVjdFN0cmluZyhjb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZy5ob3N0IHx8IGNvbmZpZy5ob3N0Lmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBjb25maWcuZGF0YWJhc2U7XG4gICAgbGV0IGNvbm5lY3RTdHJpbmcgPSBjb25maWcuaG9zdDtcbiAgICBpZiAoY29uZmlnLnBvcnQgJiYgY29uZmlnLnBvcnQgPiAwKSB7XG4gICAgICBjb25uZWN0U3RyaW5nICs9IGA6JHtjb25maWcucG9ydH1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25uZWN0U3RyaW5nICs9IFwiOjE1MjFcIjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5kYXRhYmFzZSAmJiBjb25maWcuZGF0YWJhc2UubGVuZ3RoID4gMCkge1xuICAgICAgY29ubmVjdFN0cmluZyArPSBgLyR7Y29uZmlnLmRhdGFiYXNlfWA7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0U3RyaW5nO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGNvbmZpZykge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB1c2VyOiBjb25maWcudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogY29uZmlnLnBhc3N3b3JkLFxuICAgICAgZXh0ZXJuYWxBdXRoOiBjb25maWcuZXh0ZXJuYWxBdXRoLFxuICAgICAgc3RtdENhY2hlU2l6ZTogMCxcbiAgICAgIGNvbm5lY3RTdHJpbmc6IHRoaXMuYnVpbGRDb25uZWN0U3RyaW5nKGNvbmZpZylcbiAgICB9LCBjb25maWcuZGlhbGVjdE9wdGlvbnMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgdGhpcy5saWIuZ2V0Q29ubmVjdGlvbihjb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uID0gc2VtdmVyLmNvZXJjZShjb25uZWN0aW9uLm9yYWNsZVNlcnZlclZlcnNpb25TdHJpbmcpLnZlcnNpb247XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gYWNxdWlyZWRcIik7XG4gICAgICBjb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoZXJyb3IuY29kZSkge1xuICAgICAgICAgIGNhc2UgXCJFU09DS0VUXCI6XG4gICAgICAgICAgY2FzZSBcIkVDT05OUkVTRVRcIjpcbiAgICAgICAgICBjYXNlIFwiRVBJUEVcIjpcbiAgICAgICAgICBjYXNlIFwiUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUXCI6XG4gICAgICAgICAgICB0aGlzLnBvb2wuZGVzdHJveShjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxldCBlcnJvckNvZGUgPSBlcnIubWVzc2FnZS5zcGxpdChcIjpcIik7XG4gICAgICBlcnJvckNvZGUgPSBlcnJvckNvZGVbMF07XG4gICAgICBzd2l0Y2ggKGVycm9yQ29kZSkge1xuICAgICAgICBjYXNlIFwiT1JBLTEyNTYwXCI6XG4gICAgICAgIGNhc2UgXCJPUkEtMTIxNTRcIjpcbiAgICAgICAgY2FzZSBcIk9SQS0xMjUwNVwiOlxuICAgICAgICBjYXNlIFwiT1JBLTEyNTE0XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTExXCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTE2XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTE3XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTIwXCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uUmVmdXNlZEVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJPUkEtMjgwMDBcIjpcbiAgICAgICAgY2FzZSBcIk9SQS0yODA0MFwiOlxuICAgICAgICBjYXNlIFwiT1JBLTAxMDE3XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTA2XCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5BY2Nlc3NEZW5pZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiT1JBLTEyNTQxXCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTAzXCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTA4XCI6XG4gICAgICAgIGNhc2UgXCJOSlMtNTA3XCI6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcXVlbGl6ZUVycm9ycy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIk5KUy01MTJcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MTVcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MThcIjpcbiAgICAgICAgY2FzZSBcIk5KUy01MTlcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIk9SQS0xMjE3MFwiOlxuICAgICAgICBjYXNlIFwiTkpTLTUxMFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IoZXJyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIWNvbm5lY3Rpb24uaXNIZWFsdGh5KCkpIHtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiB0cmllZCB0byBkaXNjb25uZWN0IGJ1dCB3YXMgYWxyZWFkeSBhdCBDTE9TRUQgc3RhdGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm9taXNpZnkoKGNhbGxiYWNrKSA9PiBjb25uZWN0aW9uLmNsb3NlKGNhbGxiYWNrKSkoKTtcbiAgfVxuICB2YWxpZGF0ZShjb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5pc0hlYWx0aHkoKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/data-types.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C\");\n  BaseTypes.DATE.types.oracle = [\"TIMESTAMP\", \"TIMESTAMP WITH LOCAL TIME ZONE\"];\n  BaseTypes.STRING.types.oracle = [\"VARCHAR2\", \"NVARCHAR2\"];\n  BaseTypes.CHAR.types.oracle = [\"CHAR\", \"RAW\"];\n  BaseTypes.TEXT.types.oracle = [\"CLOB\"];\n  BaseTypes.TINYINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.SMALLINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.MEDIUMINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.INTEGER.types.oracle = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.FLOAT.types.oracle = [\"BINARY_FLOAT\"];\n  BaseTypes.DATEONLY.types.oracle = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.oracle = [\"CHAR(1)\"];\n  BaseTypes.BLOB.types.oracle = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.oracle = [\"NUMBER\"];\n  BaseTypes.UUID.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.ENUM.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.REAL.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.DOUBLE.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.JSON.types.oracle = [\"BLOB\"];\n  BaseTypes.GEOMETRY.types.oracle = false;\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4e3 || this._binary && this._length > 2e3) {\n        warn(\"Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\");\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return options.escape(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: this._length };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"CHAR(1)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: 1 };\n    }\n    _stringify(value) {\n      return value === true ? \"1\" : value === false ? \"0\" : value;\n    }\n    _sanitize(value) {\n      if (typeof value === \"string\") {\n        return value === \"1\" || value === \"true\" ? true : value === \"0\" || value === \"false\" ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR2(36)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 36 };\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"SYSDATE\";\n    }\n    _stringify() {\n      return \"SYSDATE\";\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR2(512)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 512 };\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"CLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CLOB };\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn(\"Oracle CHAR.BINARY datatype is not of Fixed Length.\");\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: this._length };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH LOCAL TIME ZONE\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_TIMESTAMP_LTZ };\n    }\n    _stringify(date, options) {\n      const format = \"YYYY-MM-DD HH24:MI:SS.FFTZH:TZM\";\n      date = this._applyTimezone(date, options);\n      const formatedDate = date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  DATE.prototype.escape = false;\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let result = \"\";\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === \"number\") {\n          result += `,${this._scale}`;\n        }\n        result += \")\";\n      }\n      return `NUMBER${result}`;\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return \"NUMBER(3)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"SMALLINT\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return \"NUMBER(8)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT))\n        return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support BIGINT with options\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"NUMBER(19)\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n    _sanitize(value) {\n      if (typeof value === \"bigint\" || typeof value === \"number\") {\n        return value.toString();\n      }\n      return value;\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    toSql() {\n      if (this._length) {\n        return `NUMBER(${this._length},0)`;\n      }\n      return \"INTEGER\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return \"BINARY_FLOAT\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_FLOAT };\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return \"inf\";\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return \"-inf\";\n      }\n      return value;\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n  }\n  class BLOB extends BaseTypes.BLOB {\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE))\n        return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n      if (this._length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support DOUBLE with options.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n      this.key = \"DOUBLE PRECISION\";\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format(\"YYYY-MM-DD\");\n      }\n      return value;\n    }\n    _stringify(date, options) {\n      if (date) {\n        const format = \"YYYY/MM/DD\";\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_DATE };\n    }\n    _bindParam(value, options) {\n      if (typeof value === \"string\") {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n    }\n  }\n  DATEONLY.prototype.escape = false;\n  return {\n    BOOLEAN,\n    \"DOUBLE PRECISION\": DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhLEtBQUssT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssS0FBSyxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL29yYWNsZS9kYXRhLXR5cGVzLmpzPzNlZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xubW9kdWxlLmV4cG9ydHMgPSAoQmFzZVR5cGVzKSA9PiB7XG4gIGNvbnN0IHdhcm4gPSBCYXNlVHlwZXMuQUJTVFJBQ1Qud2Fybi5iaW5kKHZvaWQgMCwgXCJodHRwczovL3d3dy5vcmFjbGUuY29tL3Bscy90b3BpYy9sb29rdXA/Y3R4PWRibGF0ZXN0JmlkPUdVSUQtRDQyNEQyM0ItMDkzMy00MjVGLUJDNjktOUMwRTY3MjQ2OTNDXCIpO1xuICBCYXNlVHlwZXMuREFURS50eXBlcy5vcmFjbGUgPSBbXCJUSU1FU1RBTVBcIiwgXCJUSU1FU1RBTVAgV0lUSCBMT0NBTCBUSU1FIFpPTkVcIl07XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMub3JhY2xlID0gW1wiVkFSQ0hBUjJcIiwgXCJOVkFSQ0hBUjJcIl07XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLm9yYWNsZSA9IFtcIkNIQVJcIiwgXCJSQVdcIl07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLm9yYWNsZSA9IFtcIkNMT0JcIl07XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLm9yYWNsZSA9IFtcIk5VTUJFUlwiXTtcbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLm9yYWNsZSA9IFtcIk5VTUJFUlwiXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5vcmFjbGUgPSBbXCJOVU1CRVJcIl07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLm9yYWNsZSA9IFtcIklOVEVHRVJcIl07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMub3JhY2xlID0gW1wiTlVNQkVSXCJdO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMub3JhY2xlID0gW1wiQklOQVJZX0ZMT0FUXCJdO1xuICBCYXNlVHlwZXMuREFURU9OTFkudHlwZXMub3JhY2xlID0gW1wiREFURVwiXTtcbiAgQmFzZVR5cGVzLkJPT0xFQU4udHlwZXMub3JhY2xlID0gW1wiQ0hBUigxKVwiXTtcbiAgQmFzZVR5cGVzLkJMT0IudHlwZXMub3JhY2xlID0gW1wiQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMub3JhY2xlID0gW1wiTlVNQkVSXCJdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5vcmFjbGUgPSBbXCJWQVJDSEFSMlwiXTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMub3JhY2xlID0gW1wiVkFSQ0hBUjJcIl07XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLm9yYWNsZSA9IFtcIkJJTkFSWV9ET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMub3JhY2xlID0gW1wiQklOQVJZX0RPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMub3JhY2xlID0gW1wiQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLm9yYWNsZSA9IGZhbHNlO1xuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDRlMyB8fCB0aGlzLl9iaW5hcnkgJiYgdGhpcy5fbGVuZ3RoID4gMmUzKSB7XG4gICAgICAgIHdhcm4oXCJPcmFjbGUgc3VwcG9ydHMgbGVuZ3RoIHVwIHRvIDMyNzY0IGJ5dGVzIG9yIGNoYXJhY3RlcnM7IEJlIHN1cmUgdGhhdCB5b3VyIGFkbWluaXN0cmF0b3IgaGFzIGV4dGVuZGVkIHRoZSBNQVhfU1RSSU5HX1NJWkUgcGFyYW1ldGVyLiBDaGVjayBodHRwczovL2RvY3Mub3JhY2xlLmNvbS9wbHMvdG9waWMvbG9va3VwP2N0eD1kYmxhdGVzdCZpZD1HVUlELTdCNzJFMTU0LTY3N0EtNDM0Mi1BMUVBLUM3NEMxRUE5MjhFNlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBgTlZBUkNIQVIyKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGBSQVcoJHt0aGlzLl9sZW5ndGh9KWA7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKHZhbHVlLnRvU3RyaW5nKFwiaGV4XCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfUkFXLCBtYXhTaXplOiB0aGlzLl9sZW5ndGggfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfVkFSQ0hBUiwgbWF4U2l6ZTogdGhpcy5fbGVuZ3RoIH07XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIFNUUklORy5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIGNsYXNzIEJPT0xFQU4gZXh0ZW5kcyBCYXNlVHlwZXMuQk9PTEVBTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJDSEFSKDEpXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0NIQVIsIG1heFNpemU6IDEgfTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gXCIxXCIgOiB2YWx1ZSA9PT0gZmFsc2UgPyBcIjBcIiA6IHZhbHVlO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBcIjFcIiB8fCB2YWx1ZSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogdmFsdWUgPT09IFwiMFwiIHx8IHZhbHVlID09PSBcImZhbHNlXCIgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLl9zYW5pdGl6ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGNsYXNzIFVVSUQgZXh0ZW5kcyBCYXNlVHlwZXMuVVVJRCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJWQVJDSEFSMigzNilcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfVkFSQ0hBUiwgbWF4U2l6ZTogMzYgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgTk9XIGV4dGVuZHMgQmFzZVR5cGVzLk5PVyB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJTWVNEQVRFXCI7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkoKSB7XG4gICAgICByZXR1cm4gXCJTWVNEQVRFXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIEVOVU0gZXh0ZW5kcyBCYXNlVHlwZXMuRU5VTSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJWQVJDSEFSMig1MTIpXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX1ZBUkNIQVIsIG1heFNpemU6IDUxMiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBURVhUIGV4dGVuZHMgQmFzZVR5cGVzLlRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQ0xPQlwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9DTE9CIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIENIQVIgZXh0ZW5kcyBCYXNlVHlwZXMuQ0hBUiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHdhcm4oXCJPcmFjbGUgQ0hBUi5CSU5BUlkgZGF0YXR5cGUgaXMgbm90IG9mIEZpeGVkIExlbmd0aC5cIik7XG4gICAgICAgIHJldHVybiBgUkFXKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICBpZiAodGhpcy5fYmluYXJ5KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfUkFXLCBtYXhTaXplOiB0aGlzLl9sZW5ndGggfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQ0hBUiwgbWF4U2l6ZTogdGhpcy5fbGVuZ3RoIH07XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGNsYXNzIERBVEUgZXh0ZW5kcyBCYXNlVHlwZXMuREFURSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJUSU1FU1RBTVAgV0lUSCBMT0NBTCBUSU1FIFpPTkVcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfVElNRVNUQU1QX0xUWiB9O1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IFwiWVlZWS1NTS1ERCBISDI0Ok1JOlNTLkZGVFpIOlRaTVwiO1xuICAgICAgZGF0ZSA9IHRoaXMuX2FwcGx5VGltZXpvbmUoZGF0ZSwgb3B0aW9ucyk7XG4gICAgICBjb25zdCBmb3JtYXRlZERhdGUgPSBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3MuU1NTIFpcIik7XG4gICAgICByZXR1cm4gYFRPX1RJTUVTVEFNUF9UWignJHtmb3JtYXRlZERhdGV9JywnJHtmb3JtYXR9JylgO1xuICAgIH1cbiAgICBfYXBwbHlUaW1lem9uZShkYXRlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucy50aW1lem9uZSkge1xuICAgICAgICBpZiAobW9tZW50VHoudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICAgIGRhdGUgPSBtb21lbnRUeihkYXRlKS50eihvcHRpb25zLnRpbWV6b25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRlID0gbW9tZW50KGRhdGUpLnV0Y09mZnNldChvcHRpb25zLnRpbWV6b25lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IG1vbWVudFR6KGRhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zICYmIG1vbWVudC50ei56b25lKG9wdGlvbnMudGltZXpvbmUpKSB7XG4gICAgICAgIHZhbHVlID0gbW9tZW50LnR6KHZhbHVlLnRvU3RyaW5nKCksIG9wdGlvbnMudGltZXpvbmUpLnRvRGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICAgIH1cbiAgfVxuICBEQVRFLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMuX2xlbmd0aH1gO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RlY2ltYWxzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLl9kZWNpbWFsc31gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fbGVuZ3RoICYmIHRoaXMuX3ByZWNpc2lvbikge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMuX3ByZWNpc2lvbn1gO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3NjYWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLl9zY2FsZX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgTlVNQkVSJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJOVU1CRVIoMylcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICB9XG4gIGNsYXNzIFNNQUxMSU5UIGV4dGVuZHMgQmFzZVR5cGVzLlNNQUxMSU5UIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGBOVU1CRVIoJHt0aGlzLl9sZW5ndGh9LDApYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlNNQUxMSU5UXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBNRURJVU1JTlQgZXh0ZW5kcyBCYXNlVHlwZXMuTUVESVVNSU5UIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIk5VTUJFUig4KVwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJJR0lOVCkpXG4gICAgICAgIHJldHVybiBuZXcgQklHSU5UKGxlbmd0aCk7XG4gICAgICBCYXNlVHlwZXMuQklHSU5ULmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodGhpcy5fbGVuZ3RoIHx8IHRoaXMub3B0aW9ucy5sZW5ndGggfHwgdGhpcy5fdW5zaWduZWQgfHwgdGhpcy5femVyb2ZpbGwpIHtcbiAgICAgICAgd2FybihcIk9yYWNsZSBkb2VzIG5vdCBzdXBwb3J0IEJJR0lOVCB3aXRoIG9wdGlvbnNcIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIk5VTUJFUigxOSlcIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfTlVNQkVSIH07XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGNsYXNzIE5VTUJFUiBleHRlbmRzIEJhc2VUeXBlcy5OVU1CRVIge1xuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX05VTUJFUiB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBJTlRFR0VSIGV4dGVuZHMgQmFzZVR5cGVzLklOVEVHRVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXR1cm4gYE5VTUJFUigke3RoaXMuX2xlbmd0aH0sMClgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiSU5URUdFUlwiO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9OVU1CRVIgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQklOQVJZX0ZMT0FUXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0JJTkFSWV9GTE9BVCB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBSRUFMIGV4dGVuZHMgQmFzZVR5cGVzLlJFQUwge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiQklOQVJZX0RPVUJMRVwiO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICByZXR1cm4gXCJpbmZcIjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgIHJldHVybiBcIi1pbmZcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQklOQVJZX0RPVUJMRSB9O1xuICAgIH1cbiAgfVxuICBjbGFzcyBCTE9CIGV4dGVuZHMgQmFzZVR5cGVzLkJMT0Ige1xuICAgIF9oZXhpZnkoaGV4KSB7XG4gICAgICByZXR1cm4gYCcke2hleH0nYDtcbiAgICB9XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCTE9CXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0JMT0IgfTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgdG9TcWwoKSB7XG4gICAgICByZXR1cm4gXCJCTE9CXCI7XG4gICAgfVxuICAgIF9nZXRCaW5kRGVmKG9yYWNsZWRiKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBvcmFjbGVkYi5EQl9UWVBFX0JMT0IgfTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3BlcmF0aW9uID09PSBcIndoZXJlXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmJpbmRQYXJhbShCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRE9VQkxFIGV4dGVuZHMgQmFzZVR5cGVzLkRPVUJMRSB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBkZWNpbWFscykge1xuICAgICAgc3VwZXIobGVuZ3RoLCBkZWNpbWFscyk7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRE9VQkxFKSlcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlVHlwZXMuRE9VQkxFKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgQmFzZVR5cGVzLkRPVUJMRS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCB8fCB0aGlzLl91bnNpZ25lZCB8fCB0aGlzLl96ZXJvZmlsbCkge1xuICAgICAgICB3YXJuKFwiT3JhY2xlIGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFIHdpdGggb3B0aW9ucy5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMuX3plcm9maWxsID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXkgPSBcIkRPVUJMRSBQUkVDSVNJT05cIjtcbiAgICB9XG4gICAgX2dldEJpbmREZWYob3JhY2xlZGIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IG9yYWNsZWRiLkRCX1RZUEVfQklOQVJZX0RPVUJMRSB9O1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJJTkFSWV9ET1VCTEVcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbW9tZW50KHZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbW9tZW50KHZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IFwiWVlZWS9NTS9ERFwiO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5lc2NhcGUoYFRPX0RBVEUoJyR7ZGF0ZX0nLCcke2Zvcm1hdH0nKWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnMuZXNjYXBlKGRhdGUpO1xuICAgIH1cbiAgICBfZ2V0QmluZERlZihvcmFjbGVkYikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogb3JhY2xlZGIuREJfVFlQRV9EQVRFIH07XG4gICAgfVxuICAgIF9iaW5kUGFyYW0odmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKG5ldyBEYXRlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICAgIH1cbiAgfVxuICBEQVRFT05MWS5wcm90b3R5cGUuZXNjYXBlID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgQk9PTEVBTixcbiAgICBcIkRPVUJMRSBQUkVDSVNJT05cIjogRE9VQkxFLFxuICAgIERPVUJMRSxcbiAgICBTVFJJTkcsXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBNRURJVU1JTlQsXG4gICAgQklHSU5ULFxuICAgIE5VTUJFUixcbiAgICBJTlRFR0VSLFxuICAgIEZMT0FULFxuICAgIFVVSUQsXG4gICAgREFURU9OTFksXG4gICAgREFURSxcbiAgICBOT1csXG4gICAgQkxPQixcbiAgICBFTlVNLFxuICAgIFRFWFQsXG4gICAgQ0hBUixcbiAgICBKU09OOiBKU09OVFlQRSxcbiAgICBSRUFMLFxuICAgIERFQ0lNQUxcbiAgfTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhLXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { AbstractDialect } = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst { OracleConnectionManager } = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/connection-manager.js\");\nconst { OracleQuery } = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/query.js\");\nconst { OracleQueryGenerator } = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").oracle);\nconst { OracleQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-interface.js\");\nclass OracleDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new OracleConnectionManager(this, sequelize);\n    this.connectionManager.initPools();\n    this.queryGenerator = new OracleQueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new OracleQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nOracleDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  IGNORE: \" IGNORE\",\n  lock: true,\n  lockOuterJoinFailure: true,\n  forShare: \"FOR UPDATE\",\n  skipLocked: true,\n  index: {\n    collate: false,\n    length: false,\n    parser: false,\n    type: false,\n    using: false\n  },\n  constraints: {\n    restrict: false\n  },\n  returnValues: false,\n  returnIntoValues: true,\n  \"ORDER NULLS\": true,\n  schemas: true,\n  updateOnDuplicate: false,\n  indexViaAlter: false,\n  NUMERIC: true,\n  JSON: true,\n  upserts: true,\n  bulkDefault: true,\n  topLevelOrderByRequired: true,\n  GEOMETRY: false\n});\nOracleDialect.prototype.defaultVersion = \"18.0.0\";\nOracleDialect.prototype.Query = OracleQuery;\nOracleDialect.prototype.queryGenerator = OracleQueryGenerator;\nOracleDialect.prototype.DataTypes = DataTypes;\nOracleDialect.prototype.name = \"oracle\";\nOracleDialect.prototype.TICK_CHAR = '\"';\nOracleDialect.prototype.TICK_CHAR_LEFT = OracleDialect.prototype.TICK_CHAR;\nOracleDialect.prototype.TICK_CHAR_RIGHT = OracleDialect.prototype.TICK_CHAR;\nmodule.exports = OracleDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGtGQUFhO0FBQ2pELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyxzR0FBc0I7QUFDbEUsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyw0RUFBUztBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0dBQW1CO0FBQzVELGtCQUFrQix3R0FBa0M7QUFDcEQsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLGdHQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvb3JhY2xlL2luZGV4LmpzPzE2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHsgQWJzdHJhY3REaWFsZWN0IH0gPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCB7IE9yYWNsZUNvbm5lY3Rpb25NYW5hZ2VyIH0gPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uLW1hbmFnZXJcIik7XG5jb25zdCB7IE9yYWNsZVF1ZXJ5IH0gPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IHsgT3JhY2xlUXVlcnlHZW5lcmF0b3IgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLm9yYWNsZTtcbmNvbnN0IHsgT3JhY2xlUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIE9yYWNsZURpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgT3JhY2xlQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmluaXRQb29scygpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgT3JhY2xlUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IE9yYWNsZVF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBcIlZBTFVFUyAoKVwiOiB0cnVlLFxuICBcIkxJTUlUIE9OIFVQREFURVwiOiB0cnVlLFxuICBJR05PUkU6IFwiIElHTk9SRVwiLFxuICBsb2NrOiB0cnVlLFxuICBsb2NrT3V0ZXJKb2luRmFpbHVyZTogdHJ1ZSxcbiAgZm9yU2hhcmU6IFwiRk9SIFVQREFURVwiLFxuICBza2lwTG9ja2VkOiB0cnVlLFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogZmFsc2UsXG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICB1c2luZzogZmFsc2VcbiAgfSxcbiAgY29uc3RyYWludHM6IHtcbiAgICByZXN0cmljdDogZmFsc2VcbiAgfSxcbiAgcmV0dXJuVmFsdWVzOiBmYWxzZSxcbiAgcmV0dXJuSW50b1ZhbHVlczogdHJ1ZSxcbiAgXCJPUkRFUiBOVUxMU1wiOiB0cnVlLFxuICBzY2hlbWFzOiB0cnVlLFxuICB1cGRhdGVPbkR1cGxpY2F0ZTogZmFsc2UsXG4gIGluZGV4VmlhQWx0ZXI6IGZhbHNlLFxuICBOVU1FUklDOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICB1cHNlcnRzOiB0cnVlLFxuICBidWxrRGVmYXVsdDogdHJ1ZSxcbiAgdG9wTGV2ZWxPcmRlckJ5UmVxdWlyZWQ6IHRydWUsXG4gIEdFT01FVFJZOiBmYWxzZVxufSk7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiMTguMC4wXCI7XG5PcmFjbGVEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IE9yYWNsZVF1ZXJ5O1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUucXVlcnlHZW5lcmF0b3IgPSBPcmFjbGVRdWVyeUdlbmVyYXRvcjtcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLm5hbWUgPSBcIm9yYWNsZVwiO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSID0gJ1wiJztcbk9yYWNsZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gT3JhY2xlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xubW9kdWxlLmV4cG9ydHMgPSBPcmFjbGVEaWFsZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/query-generator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQueryGenerator: () => OracleQueryGenerator\n});\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nclass OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      \"DECLARE\",\n      \"USER_FOUND BOOLEAN := FALSE;\",\n      \"BEGIN\",\n      \" BEGIN\",\n      \"   EXECUTE IMMEDIATE \",\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      \";\",\n      \"   EXCEPTION WHEN OTHERS THEN\",\n      \"     IF SQLCODE != -1920 THEN\",\n      \"       RAISE;\",\n      \"     ELSE\",\n      \"       USER_FOUND := TRUE;\",\n      \"     END IF;\",\n      \" END;\",\n      \" IF NOT USER_FOUND THEN\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      \";\",\n      \"    EXECUTE IMMEDIATE \",\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      \";\",\n      \" END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  showSchemasQuery() {\n    return `SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;\n  }\n  dropSchema(schema) {\n    return [\n      \"BEGIN\",\n      \"EXECUTE IMMEDIATE \",\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      \";\",\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \"  IF SQLCODE != -1918 THEN\",\n      \"    RAISE;\",\n      \"  END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [], foreignKeys = Object.create(null), attrStr = [], checkStr = [];\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, \"\").trim()}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n    values[\"attributes\"] = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey))\n        continue;\n      if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(\", \")}`;\n    }\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          const fields = index.fields.map((field) => {\n            if (typeof field === \"string\") {\n              return field;\n            }\n            return field.attribute;\n          });\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n              if (currUnique.fields.length === fields.length) {\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n            if (canContinue) {\n              const indexName = \"name\" in index ? index.name : \"\";\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!(\"uniqueKeys\" in options)) {\n                options.uniqueKeys = {};\n              }\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach((idx) => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n        primaryKeys.forEach((primaryKey) => {\n          primaryKey = primaryKey.replace(/\"/g, \"\");\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n        columns.fields.forEach((field) => {\n          let currField = \"\";\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, \"\");\n          }\n          if (currField in attributes) {\n            if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n              const attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, \"\");\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n          } else {\n            values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n          }\n        }\n      });\n    }\n    const query = Utils.joinSQLFragments([\n      \"CREATE TABLE\",\n      values.table,\n      `(${values.attributes})`\n    ]);\n    return Utils.joinSQLFragments([\n      \"BEGIN\",\n      \"EXECUTE IMMEDIATE\",\n      `${this.escape(query)};`,\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \"IF SQLCODE != -955 THEN\",\n      \"RAISE;\",\n      \"END IF;\",\n      \"END;\"\n    ]);\n  }\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : \"USER\"}`;\n  }\n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    return [\n      \"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \",\n      \"FROM all_tab_columns atc \",\n      \"LEFT OUTER JOIN \",\n      \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \",\n      \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \",\n      schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : \"WHERE atc.OWNER = USER \",\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"\n    ].join(\"\");\n  }\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(before),\n      \"RENAME TO\",\n      this.quoteTable(after)\n    ]);\n  }\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n  showTablesQuery() {\n    return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;\n  }\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"BEGIN \",\n      \"EXECUTE IMMEDIATE 'DROP TABLE\",\n      this.quoteTable(tableName),\n      \"CASCADE CONSTRAINTS PURGE';\",\n      \"EXCEPTION WHEN OTHERS THEN\",\n      \" IF SQLCODE != -942 THEN\",\n      \"   RAISE;\",\n      \" END IF;\",\n      \"END;\"\n    ]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== \"string\" && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate) {\n      delete options.onUpdate;\n    }\n    if (options.onDelete && options.onDelete.toUpperCase() === \"NO ACTION\") {\n      delete options.onDelete;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: \"addColumn\"\n      })\n    ]);\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      attribute\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP COLUMN\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      \"SELECT constraint_name INTO cons_name\",\n      \"FROM (\",\n      \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\",\n      \"  FROM all_cons_columns cc, all_constraints c\",\n      \"  WHERE cc.owner = c.owner\",\n      \"  AND cc.table_name = c.table_name\",\n      \"  AND cc.constraint_name = c.constraint_name\",\n      \"  AND c.constraint_type = 'R'\",\n      \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\",\n      \")\",\n      \"WHERE owner =\",\n      schemaNameConstant,\n      \"AND table_name =\",\n      tableNameConstant,\n      \"AND cons_columns =\",\n      attributeNameConstant,\n      \";\"\n    ].join(\" \");\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      \"ADD FOREIGN KEY\",\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, \"\")\n    ]);\n    return [\n      \"BEGIN\",\n      getConsNameQuery,\n      \"EXCEPTION\",\n      \"WHEN NO_DATA_FOUND THEN\",\n      \" CONS_NAME := NULL;\",\n      \"END;\",\n      \"IF CONS_NAME IS NOT NULL THEN\",\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      \"END IF;\",\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(\" \");\n  }\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"MODIFY\",\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n    return [\n      \"BEGIN\",\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      \"EXCEPTION\",\n      \"WHEN OTHERS THEN\",\n      \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\",\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      \" ELSE\",\n      \"   RAISE;\",\n      \" END IF;\",\n      \"END;\"\n    ].join(\" \");\n  }\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      \"DECLARE\",\n      \"CONS_NAME VARCHAR2(200);\",\n      \"BEGIN\"\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName))\n        continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push(\"END;\");\n    return sql.join(\" \");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(void 0, void 0, { context: \"INSERT\" }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n    const sql = [\n      \"DECLARE \",\n      \"BEGIN \",\n      updateQuery.query ? [\n        updateQuery.query,\n        \"; \",\n        \" IF ( SQL%ROWCOUNT = 0 ) THEN \",\n        insertQuery.query,\n        \" :isUpdate := 0; \",\n        \"ELSE \",\n        \" :isUpdate := 1; \",\n        \" END IF; \"\n      ].join(\"\") : [\n        insertQuery.query,\n        \" :isUpdate := 0; \",\n        \"EXCEPTION WHEN OTHERS THEN\",\n        \" IF SQLCODE != -1 THEN\",\n        \"   RAISE;\",\n        \" END IF;\"\n      ].join(\"\"),\n      \"END;\"\n    ];\n    const query = sql.join(\"\");\n    const result = { query };\n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n    let inBindPosition;\n    for (const fieldValueHash of fieldValueHashes) {\n      const tuple = [];\n      const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;\n      const tempBindPositions = Object.keys(allColumns).map((key) => {\n        if (allColumns[key] === true) {\n          if (fieldValueHash[key] !== null) {\n            throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n          }\n          return \"DEFAULT\";\n        }\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: \"INSERT\" }, inbindParam);\n      });\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      tuples.push(tuple);\n    }\n    const returnColumn = [];\n    const returnColumnBindPositions = [];\n    const insertColumns = [];\n    for (const key of Object.keys(allColumns)) {\n      if (fieldMappedAttributes[key]) {\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n          returnColumn.push(this.quoteIdentifier(key));\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n    let query = Utils.joinSQLFragments([\n      \"INSERT\",\n      \"INTO\",\n      this.quoteTable(tableName),\n      `(${insertColumns.join(\",\")})`,\n      \"VALUES\",\n      `(${inBindPosition})`\n    ]);\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        \"RETURNING\",\n        `${returnColumn.join(\",\")}`,\n        \"INTO\",\n        `${returnColumnBindPositions}`\n      ]);\n    }\n    const result = { query };\n    result.bind = tuples;\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = tableName;\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      \"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \",\n      \"FROM all_ind_columns i \",\n      \"INNER JOIN all_indexes u \",\n      \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \",\n      \"LEFT OUTER JOIN all_constraints c \",\n      \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \",\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      \" AND u.table_owner = \",\n      owner ? this.escape(owner) : \"USER\",\n      \" ORDER BY index_name, column_position\"\n    ];\n    return sql.join(\"\");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    attribute.onUpdate = \"\";\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n      }\n    }\n    let template;\n    template = attribute.type.toSql ? attribute.type.toSql() : \"\";\n    if (attribute.type instanceof DataTypes.JSON) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values)\n        attribute.values = attribute.type.values;\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, (value) => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    }\n    if (attribute.autoIncrement) {\n      template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      let unsignedTemplate = \"\";\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(options.attributeName)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n      }\n      if (!attribute.autoIncrement) {\n        if (attribute.allowNull === false) {\n          template += \" NOT NULL\";\n        } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n          template += \" NULL\";\n        }\n      }\n      template += unsignedTemplate;\n    } else {\n      template = \"\";\n    }\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, __spreadValues({ attributeName }, options));\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      \"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \",\n      this.escape(tableName),\n      \" and OWNER = \",\n      table.schema ? this.escape(schemaName) : \"USER\",\n      \" and COLUMN_NAME = \",\n      this.escape(column),\n      \" AND POSITION IS NOT NULL ORDER BY POSITION\"\n    ].join(\"\");\n    return sql;\n  }\n  getForeignKeysQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",',\n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      \" FROM all_cons_columns a\",\n      \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\",\n      \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\",\n      \" WHERE c.constraint_type  = 'R'\",\n      \" AND a.table_name = \",\n      this.escape(tableName),\n      \" AND a.owner = \",\n      table.schema ? this.escape(schemaName) : \"USER\",\n      \" ORDER BY a.table_name, a.constraint_name\"\n    ].join(\"\");\n    return sql;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      \"SELECT cols.column_name, atc.identity_column \",\n      \"FROM all_constraints cons, all_cons_columns cols \",\n      \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\",\n      \"WHERE cols.table_name = \",\n      this.escape(tableName),\n      \"AND cols.owner = \",\n      table.schema ? this.escape(schemaName) : \"USER \",\n      \"AND cons.constraint_type = 'P' \",\n      \"AND cons.constraint_name = cols.constraint_name \",\n      \"AND cons.owner = cols.owner \",\n      \"ORDER BY cols.table_name, cols.position\"\n    ].join(\"\");\n    return sql;\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n  getAliasToken() {\n    return \"\";\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"BEGIN TRANSACTION\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"ROLLBACK TRANSACTION\";\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === \"boolean\") {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        }\n        if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    paths = paths.map((subPath) => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n    const pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n  addLimitAndOffset(options, model) {\n    let fragment = \"\";\n    const offset = options.offset || 0, isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n    if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n  bindParam(bind, posOffset = 0) {\n    return (value) => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result FROM DUAL\";\n  }\n}\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3BFLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQW1CO0FBQy9DO0FBQ0EsOENBQThDLElBQUksa0JBQWtCLElBQUk7QUFDeEUsd0RBQXdELEVBQUU7QUFDMUQsMERBQTBELEVBQUUsc0JBQXNCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQyxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGlDQUFpQztBQUNqQyxtQkFBbUI7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRCxRQUFRO0FBQ1I7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RCxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RCxRQUFRO0FBQ1I7QUFDQSxpREFBaUQsYUFBYTtBQUM5RCxRQUFRO0FBQ1I7QUFDQSxtREFBbUQsYUFBYTtBQUNoRSxRQUFRO0FBQ1I7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRCxRQUFRO0FBQ1I7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRCxRQUFRO0FBQ1I7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QyxRQUFRO0FBQ1IsZUFBZTtBQUNmLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCO0FBQ3hELFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLG9DQUFvQztBQUN0RTtBQUNBLFVBQVU7QUFDViwwQkFBMEIsTUFBTSxFQUFFLDJDQUEyQztBQUM3RTtBQUNBLFFBQVE7QUFDUjtBQUNBLHdCQUF3QixNQUFNLEVBQUUsU0FBUztBQUN6QztBQUNBLFFBQVE7QUFDUix3QkFBd0IsTUFBTSxFQUFFLFNBQVM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixJQUFJLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0VBQXNFO0FBQ25ILFlBQVk7QUFDWixpREFBaUQsaUNBQWlDLFVBQVUsc0VBQXNFO0FBQ2xLO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsY0FBYztBQUNkLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSx3QkFBd0IsY0FBYyxnREFBZ0Q7QUFDeko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0JBQW9CO0FBQ3pELCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsdUJBQXVCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLEdBQUcsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVcsTUFBTSxtQkFBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLFdBQVc7QUFDWDtBQUNBLHlDQUF5Qyx3QkFBd0IsbUNBQW1DO0FBQ3BHLGNBQWM7QUFDZCwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsZ0JBQWdCLGtDQUFrQyxLQUFLLDhCQUE4QjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2Rix3QkFBd0I7QUFDckgsaUNBQWlDLDhCQUE4QixtQkFBbUIsZ0JBQWdCO0FBQ2xHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsMEJBQTBCO0FBQzFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsbUJBQW1CO0FBQ2pHLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUNBQXVDO0FBQ3BGLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDO0FBQ0EsV0FBVywwQkFBMEI7QUFDckM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDLGlDQUFpQyx3QkFBd0Isb0NBQW9DLHdCQUF3QixrQkFBa0IsMkJBQTJCLEVBQUUsVUFBVTtBQUM5SyxNQUFNO0FBQ04sMENBQTBDLE1BQU07QUFDaEQsaUNBQWlDLHVCQUF1QixFQUFFLFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxHQUFHLGdDQUFnQztBQUNuRjtBQUNBLHlCQUF5QixnQ0FBZ0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkM7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkMsS0FBSztBQUMvRTtBQUNBLE9BQU8sYUFBYTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQTZDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBNkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RSxRQUFRO0FBQ1IseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0Esa0NBQWtDLGlDQUFpQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsZUFBZTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEIsa0JBQWtCLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLDRDQUE0QyxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVDQUF1QztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Rix5RUFBeUUsS0FBSyxnQkFBZ0I7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLElBQUk7QUFDbEMseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpSEFBaUgsTUFBTTtBQUN2SCx5QkFBeUIsYUFBYSxHQUFHLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDLEdBQUcsNENBQTRDO0FBQ2pJLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktZ2VuZXJhdG9yLmpzPzRkNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgT3JhY2xlUXVlcnlHZW5lcmF0b3I6ICgpID0+IE9yYWNsZVF1ZXJ5R2VuZXJhdG9yXG59KTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgVHJhbnNhY3Rpb24gPSByZXF1aXJlKFwiLi4vLi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBPUkFDTEVfUkVTRVJWRURfV09SRFMgPSBbXCJBQ0NFU1NcIiwgXCJBRERcIiwgXCJBTExcIiwgXCJBTFRFUlwiLCBcIkFORFwiLCBcIkFOWVwiLCBcIkFSUkFZTEVOXCIsIFwiQVNcIiwgXCJBU0NcIiwgXCJBVURJVFwiLCBcIkJFVFdFRU5cIiwgXCJCWVwiLCBcIkNIQVJcIiwgXCJDSEVDS1wiLCBcIkNMVVNURVJcIiwgXCJDT0xVTU5cIiwgXCJDT01NRU5UXCIsIFwiQ09NUFJFU1NcIiwgXCJDT05ORUNUXCIsIFwiQ1JFQVRFXCIsIFwiQ1VSUkVOVFwiLCBcIkRBVEVcIiwgXCJERUNJTUFMXCIsIFwiREVGQVVMVFwiLCBcIkRFTEVURVwiLCBcIkRFU0NcIiwgXCJESVNUSU5DVFwiLCBcIkRST1BcIiwgXCJFTFNFXCIsIFwiRVhDTFVTSVZFXCIsIFwiRVhJU1RTXCIsIFwiRklMRVwiLCBcIkZMT0FUXCIsIFwiRk9SXCIsIFwiRlJPTVwiLCBcIkdSQU5UXCIsIFwiR1JPVVBcIiwgXCJIQVZJTkdcIiwgXCJJREVOVElGSUVEXCIsIFwiSU1NRURJQVRFXCIsIFwiSU5cIiwgXCJJTkNSRU1FTlRcIiwgXCJJTkRFWFwiLCBcIklOSVRJQUxcIiwgXCJJTlNFUlRcIiwgXCJJTlRFR0VSXCIsIFwiSU5URVJTRUNUXCIsIFwiSU5UT1wiLCBcIklTXCIsIFwiTEVWRUxcIiwgXCJMSUtFXCIsIFwiTE9DS1wiLCBcIkxPTkdcIiwgXCJNQVhFWFRFTlRTXCIsIFwiTUlOVVNcIiwgXCJNT0RFXCIsIFwiTU9ESUZZXCIsIFwiTk9BVURJVFwiLCBcIk5PQ09NUFJFU1NcIiwgXCJOT1RcIiwgXCJOT1RGT1VORFwiLCBcIk5PV0FJVFwiLCBcIk5VTExcIiwgXCJOVU1CRVJcIiwgXCJPRlwiLCBcIk9GRkxJTkVcIiwgXCJPTlwiLCBcIk9OTElORVwiLCBcIk9QVElPTlwiLCBcIk9SXCIsIFwiT1JERVJcIiwgXCJQQ1RGUkVFXCIsIFwiUFJJT1JcIiwgXCJQUklWSUxFR0VTXCIsIFwiUFVCTElDXCIsIFwiUkFXXCIsIFwiUkVOQU1FXCIsIFwiUkVTT1VSQ0VcIiwgXCJSRVZPS0VcIiwgXCJST1dcIiwgXCJST1dJRFwiLCBcIlJPV0xBQkVMXCIsIFwiUk9XTlVNXCIsIFwiUk9XU1wiLCBcIlNFTEVDVFwiLCBcIlNFU1NJT05cIiwgXCJTRVRcIiwgXCJTSEFSRVwiLCBcIlNJWkVcIiwgXCJTTUFMTElOVFwiLCBcIlNRTEJVRlwiLCBcIlNUQVJUXCIsIFwiU1VDQ0VTU0ZVTFwiLCBcIlNZTk9OWU1cIiwgXCJTWVNEQVRFXCIsIFwiVEFCTEVcIiwgXCJUSEVOXCIsIFwiVE9cIiwgXCJUUklHR0VSXCIsIFwiVUlEXCIsIFwiVU5JT05cIiwgXCJVTklRVUVcIiwgXCJVUERBVEVcIiwgXCJVU0VSXCIsIFwiVkFMSURBVEVcIiwgXCJWQUxVRVNcIiwgXCJWQVJDSEFSXCIsIFwiVkFSQ0hBUjJcIiwgXCJWSUVXXCIsIFwiV0hFTkVWRVJcIiwgXCJXSEVSRVwiLCBcIldJVEhcIl07XG5jb25zdCBKU09OX0ZVTkNUSU9OX1JFR0VYID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG5jb25zdCBKU09OX09QRVJBVE9SX1JFR0VYID0gL15cXHMqKC0+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuY29uc3QgVE9LRU5fQ0FQVFVSRV9SRUdFWCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuY2xhc3MgT3JhY2xlUXVlcnlHZW5lcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIGdldENhdGFsb2dOYW1lKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlZFZhbHVlID0gdGhpcy5xdW90ZUlkZW50aWZpZXIodmFsdWUpO1xuICAgICAgICBpZiAocXVvdGVkVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRDYXRhbG9nTmFtZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0aGlzLmdldENhdGFsb2dOYW1lKHRhYmxlLnNjaGVtYSk7XG4gICAgcmV0dXJuIFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdO1xuICB9XG4gIGNyZWF0ZVNjaGVtYShzY2hlbWEpIHtcbiAgICBjb25zdCBxdW90ZWRTY2hlbWEgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihzY2hlbWEpO1xuICAgIHJldHVybiBbXG4gICAgICBcIkRFQ0xBUkVcIixcbiAgICAgIFwiVVNFUl9GT1VORCBCT09MRUFOIDo9IEZBTFNFO1wiLFxuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCIgQkVHSU5cIixcbiAgICAgIFwiICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgQ1JFQVRFIFVTRVIgJHtxdW90ZWRTY2hlbWF9IElERU5USUZJRUQgQlkgMTIzNDUgREVGQVVMVCBUQUJMRVNQQUNFIFVTRVJTYCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiICAgRVhDRVBUSU9OIFdIRU4gT1RIRVJTIFRIRU5cIixcbiAgICAgIFwiICAgICBJRiBTUUxDT0RFICE9IC0xOTIwIFRIRU5cIixcbiAgICAgIFwiICAgICAgIFJBSVNFO1wiLFxuICAgICAgXCIgICAgIEVMU0VcIixcbiAgICAgIFwiICAgICAgIFVTRVJfRk9VTkQgOj0gVFJVRTtcIixcbiAgICAgIFwiICAgICBFTkQgSUY7XCIsXG4gICAgICBcIiBFTkQ7XCIsXG4gICAgICBcIiBJRiBOT1QgVVNFUl9GT1VORCBUSEVOXCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBcIkNPTk5FQ1RcIiBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgR1JBTlQgQ1JFQVRFIFRBQkxFIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgVklFVyBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgR1JBTlQgQ1JFQVRFIEFOWSBUUklHR0VSIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgQU5ZIFBST0NFRFVSRSBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgR1JBTlQgQ1JFQVRFIFNFUVVFTkNFIFRPICR7cXVvdGVkU2NoZW1hfWApLFxuICAgICAgXCI7XCIsXG4gICAgICBcIiAgICBFWEVDVVRFIElNTUVESUFURSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGBHUkFOVCBDUkVBVEUgU1lOT05ZTSBUTyAke3F1b3RlZFNjaGVtYX1gKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCIgICAgRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgQUxURVIgVVNFUiAke3F1b3RlZFNjaGVtYX0gUVVPVEEgVU5MSU1JVEVEIE9OIFVTRVJTYCksXG4gICAgICBcIjtcIixcbiAgICAgIFwiIEVORCBJRjtcIixcbiAgICAgIFwiRU5EO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgfVxuICBzaG93U2NoZW1hc1F1ZXJ5KCkge1xuICAgIHJldHVybiBgU0VMRUNUIFVTRVJOQU1FIEFTIFwic2NoZW1hX25hbWVcIiBGUk9NIEFMTF9VU0VSUyBXSEVSRSBDT01NT04gPSAoJ05PJykgQU5EIFVTRVJOQU1FICE9IHVzZXJgO1xuICB9XG4gIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiQkVHSU5cIixcbiAgICAgIFwiRVhFQ1VURSBJTU1FRElBVEUgXCIsXG4gICAgICB0aGlzLmVzY2FwZShgRFJPUCBVU0VSICR7dGhpcy5xdW90ZVRhYmxlKHNjaGVtYSl9IENBU0NBREVgKSxcbiAgICAgIFwiO1wiLFxuICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCIgIElGIFNRTENPREUgIT0gLTE5MTggVEhFTlwiLFxuICAgICAgXCIgICAgUkFJU0U7XCIsXG4gICAgICBcIiAgRU5EIElGO1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgVkVSU0lPTl9GVUxMIEZST00gUFJPRFVDVF9DT01QT05FTlRfVkVSU0lPTiBXSEVSRSBQUk9EVUNUIExJS0UgJ09yYWNsZSUnXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdLCBmb3JlaWduS2V5cyA9IE9iamVjdC5jcmVhdGUobnVsbCksIGF0dHJTdHIgPSBbXSwgY2hlY2tTdHIgPSBbXTtcbiAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICB0YWJsZTogdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSlcbiAgICB9O1xuICAgIGZvciAobGV0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgYXR0ciA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpO1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHthdHRyfSAke21hdGNoWzFdLnJlcGxhY2UoL1BSSU1BUlkgS0VZLywgXCJcIil9YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7YXR0cn0gJHtkYXRhVHlwZS5yZXBsYWNlKC9QUklNQVJZIEtFWS8sIFwiXCIpLnRyaW0oKX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBkYXRhVHlwZS5tYXRjaCgvXiguKykgKFJFRkVSRU5DRVMuKikkLyk7XG4gICAgICAgIGF0dHJTdHIucHVzaChgJHthdHRyfSAke21hdGNoWzFdfWApO1xuICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke2F0dHJ9ICR7ZGF0YVR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlc1tcImF0dHJpYnV0ZXNcIl0gPSBhdHRyU3RyLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChwa1N0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLFBSSU1BUlkgS0VZICgke3BrU3RyaW5nfSlgO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZrZXkgaW4gZm9yZWlnbktleXMpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoZm9yZWlnbktleXNbZmtleV0uaW5kZXhPZihcIk9OIERFTEVURSBOTyBBQ1RJT05cIikgPiAtMSkge1xuICAgICAgICBmb3JlaWduS2V5c1tma2V5XSA9IGZvcmVpZ25LZXlzW2ZrZXldLnJlcGxhY2UoXCJPTiBERUxFVEUgTk8gQUNUSU9OXCIsIFwiXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWVzLmF0dHJpYnV0ZXMgKz0gYCxGT1JFSUdOIEtFWSAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihma2V5KX0pICR7Zm9yZWlnbktleXNbZmtleV19YDtcbiAgICB9XG4gICAgaWYgKGNoZWNrU3RyLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsICR7Y2hlY2tTdHIuam9pbihcIiwgXCIpfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaW5kZXhlcyAmJiBvcHRpb25zLmluZGV4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaWR4VG9EZWxldGUgPSBbXTtcbiAgICAgIG9wdGlvbnMuaW5kZXhlcy5mb3JFYWNoKChpbmRleCwgaWR4KSA9PiB7XG4gICAgICAgIGlmIChcInVuaXF1ZVwiIGluIGluZGV4ICYmIChpbmRleC51bmlxdWUgPT09IHRydWUgfHwgaW5kZXgudW5pcXVlLmxlbmd0aCA+IDAgJiYgaW5kZXgudW5pcXVlICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICBjb25zdCBmaWVsZHMgPSBpbmRleC5maWVsZHMubWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmllbGQuYXR0cmlidXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxldCBjYW5Db250aW51ZSA9IHRydWU7XG4gICAgICAgICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMudW5pcXVlS2V5cyk7XG4gICAgICAgICAgICBmb3IgKGxldCBmaWVsZElkeCA9IDA7IGZpZWxkSWR4IDwga2V5cy5sZW5ndGg7IGZpZWxkSWR4KyspIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyclVuaXF1ZSA9IG9wdGlvbnMudW5pcXVlS2V5c1trZXlzW2ZpZWxkSWR4XV07XG4gICAgICAgICAgICAgIGlmIChjdXJyVW5pcXVlLmZpZWxkcy5sZW5ndGggPT09IGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJVbmlxdWUuZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGN1cnJVbmlxdWUuZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXMoZmllbGRzLCBmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuQ29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbkNvbnRpbnVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXhOYW1lID0gXCJuYW1lXCIgaW4gaW5kZXggPyBpbmRleC5uYW1lIDogXCJcIjtcbiAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludFRvQWRkID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGluZGV4TmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZHNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKCEoXCJ1bmlxdWVLZXlzXCIgaW4gb3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVuaXF1ZUtleXMgPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHRpb25zLnVuaXF1ZUtleXNbaW5kZXhOYW1lXSA9IGNvbnN0cmFpbnRUb0FkZDtcbiAgICAgICAgICAgICAgaWR4VG9EZWxldGUucHVzaChpZHgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWR4VG9EZWxldGUucHVzaChpZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZHhUb0RlbGV0ZS5mb3JFYWNoKChpZHgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5pbmRleGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zICYmICEhb3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGxldCBjYW5CZVVuaXEgPSBmYWxzZTtcbiAgICAgICAgcHJpbWFyeUtleXMuZm9yRWFjaCgocHJpbWFyeUtleSkgPT4ge1xuICAgICAgICAgIHByaW1hcnlLZXkgPSBwcmltYXJ5S2V5LnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICAgICAgICAgIGlmICghXy5pbmNsdWRlcyhjb2x1bW5zLmZpZWxkcywgcHJpbWFyeUtleSkpIHtcbiAgICAgICAgICAgIGNhbkJlVW5pcSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29sdW1ucy5maWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICBsZXQgY3VyckZpZWxkID0gXCJcIjtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcoZmllbGQpKSB7XG4gICAgICAgICAgICBjdXJyRmllbGQgPSBmaWVsZC5hdHRyaWJ1dGUucmVwbGFjZSgvWy4sXCJcXHNdL2csIFwiXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyRmllbGQgPSBmaWVsZC5yZXBsYWNlKC9bLixcIlxcc10vZywgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyRmllbGQgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbY3VyckZpZWxkXS50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXCJVTklRVUVcIikgPiAtMSAmJiBjYW5CZVVuaXEpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0clRvUmVwbGFjZSA9IGF0dHJpYnV0ZXNbY3VyckZpZWxkXS5yZXBsYWNlKFwiVU5JUVVFXCIsIFwiXCIpO1xuICAgICAgICAgICAgICB2YWx1ZXMuYXR0cmlidXRlcyA9IHZhbHVlcy5hdHRyaWJ1dGVzLnJlcGxhY2UoYXR0cmlidXRlc1tjdXJyRmllbGRdLCBhdHRyVG9SZXBsYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuQmVVbmlxKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBvcHRpb25zLnVuaXF1ZUtleXNbY29sdW1ucy5uYW1lXTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy51bmlxdWVLZXlzW2NvbHVtbnMubmFtZV07XG4gICAgICAgICAgaW5kZXhOYW1lID0gaW5kZXhOYW1lLnJlcGxhY2UoL1suLFxcc10vZywgXCJcIik7XG4gICAgICAgICAgY29sdW1ucy5uYW1lID0gaW5kZXhOYW1lO1xuICAgICAgICAgIG9wdGlvbnMudW5pcXVlS2V5c1tpbmRleE5hbWVdID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGluZGV4TmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5hdHRyaWJ1dGVzICs9IGAsVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZXMuYXR0cmlidXRlcyArPSBgLCBDT05TVFJBSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gVU5JUVVFICgke2NvbHVtbnMuZmllbGRzLm1hcCgoZmllbGQpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGZpZWxkKSkuam9pbihcIiwgXCIpfSlgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBUQUJMRVwiLFxuICAgICAgdmFsdWVzLnRhYmxlLFxuICAgICAgYCgke3ZhbHVlcy5hdHRyaWJ1dGVzfSlgXG4gICAgXSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJCRUdJTlwiLFxuICAgICAgXCJFWEVDVVRFIElNTUVESUFURVwiLFxuICAgICAgYCR7dGhpcy5lc2NhcGUocXVlcnkpfTtgLFxuICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCJJRiBTUUxDT0RFICE9IC05NTUgVEhFTlwiLFxuICAgICAgXCJSQUlTRTtcIixcbiAgICAgIFwiRU5EIElGO1wiLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdKTtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgW3RhYmxlTmFtZSwgc2NoZW1hTmFtZV0gPSB0aGlzLmdldFNjaGVtYU5hbWVBbmRUYWJsZU5hbWUodGFibGUpO1xuICAgIHJldHVybiBgU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBBTExfVEFCTEVTIFdIRVJFIFRBQkxFX05BTUUgPSAke3RoaXMuZXNjYXBlKHRhYmxlTmFtZSl9IEFORCBPV05FUiA9ICR7dGFibGUuc2NoZW1hID8gdGhpcy5lc2NhcGUoc2NoZW1hTmFtZSkgOiBcIlVTRVJcIn1gO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIGNvbnN0IGN1cnJUYWJsZU5hbWUgPSB0aGlzLmdldENhdGFsb2dOYW1lKHRhYmxlTmFtZS50YWJsZU5hbWUgfHwgdGFibGVOYW1lKTtcbiAgICBzY2hlbWEgPSB0aGlzLmdldENhdGFsb2dOYW1lKHNjaGVtYSk7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiU0VMRUNUIGF0Yy5DT0xVTU5fTkFNRSwgYXRjLkRBVEFfVFlQRSwgYXRjLkRBVEFfTEVOR1RILCBhdGMuQ0hBUl9MRU5HVEgsIGF0Yy5ERUZBVUxUX0xFTkdUSCwgYXRjLk5VTExBQkxFLCB1Y2MuY29uc3RyYWludF90eXBlIFwiLFxuICAgICAgXCJGUk9NIGFsbF90YWJfY29sdW1ucyBhdGMgXCIsXG4gICAgICBcIkxFRlQgT1VURVIgSk9JTiBcIixcbiAgICAgIFwiKFNFTEVDVCBhY2MuY29sdW1uX25hbWUsIGFjYy50YWJsZV9uYW1lLCBhYy5jb25zdHJhaW50X3R5cGUgRlJPTSBhbGxfY29uc19jb2x1bW5zIGFjYyBJTk5FUiBKT0lOIGFsbF9jb25zdHJhaW50cyBhYyBPTiBhY2MuY29uc3RyYWludF9uYW1lID0gYWMuY29uc3RyYWludF9uYW1lKSB1Y2MgXCIsXG4gICAgICBcIk9OIChhdGMudGFibGVfbmFtZSA9IHVjYy50YWJsZV9uYW1lIEFORCBhdGMuQ09MVU1OX05BTUUgPSB1Y2MuQ09MVU1OX05BTUUpIFwiLFxuICAgICAgc2NoZW1hID8gYFdIRVJFIChhdGMuT1dORVIgPSAke3RoaXMuZXNjYXBlKHNjaGVtYSl9KSBgIDogXCJXSEVSRSBhdGMuT1dORVIgPSBVU0VSIFwiLFxuICAgICAgYEFORCAoYXRjLlRBQkxFX05BTUUgPSAke3RoaXMuZXNjYXBlKGN1cnJUYWJsZU5hbWUpfSlgLFxuICAgICAgXCJPUkRFUiBCWSBhdGMuQ09MVU1OX05BTUUsIENPTlNUUkFJTlRfVFlQRSBERVNDXCJcbiAgICBdLmpvaW4oXCJcIik7XG4gIH1cbiAgcmVuYW1lVGFibGVRdWVyeShiZWZvcmUsIGFmdGVyKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKGJlZm9yZSksXG4gICAgICBcIlJFTkFNRSBUT1wiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKGFmdGVyKVxuICAgIF0pO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRDYXRhbG9nTmFtZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIHJldHVybiBgU0VMRUNUIENPTlNUUkFJTlRfTkFNRSBjb25zdHJhaW50X25hbWUgRlJPTSB1c2VyX2NvbnNfY29sdW1ucyBXSEVSRSB0YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBgU0VMRUNUIG93bmVyIGFzIHRhYmxlX3NjaGVtYSwgdGFibGVfbmFtZSwgMCBhcyBsdmwgRlJPTSBhbGxfdGFibGVzIHdoZXJlIE9XTkVSIElOKFNFTEVDVCBVU0VSTkFNRSBBUyBcInNjaGVtYV9uYW1lXCIgRlJPTSBBTExfVVNFUlMgV0hFUkUgT1JBQ0xFX01BSU5UQUlORUQgPSAnTicpYDtcbiAgfVxuICBkcm9wVGFibGVRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkJFR0lOIFwiLFxuICAgICAgXCJFWEVDVVRFIElNTUVESUFURSAnRFJPUCBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkNBU0NBREUgQ09OU1RSQUlOVFMgUFVSR0UnO1wiLFxuICAgICAgXCJFWENFUFRJT04gV0hFTiBPVEhFUlMgVEhFTlwiLFxuICAgICAgXCIgSUYgU1FMQ09ERSAhPSAtOTQyIFRIRU5cIixcbiAgICAgIFwiICAgUkFJU0U7XCIsXG4gICAgICBcIiBFTkQgSUY7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0pO1xuICB9XG4gIGFkZEluZGV4UXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCByYXdUYWJsZW5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSAhPT0gXCJzdHJpbmdcIiAmJiBhdHRyaWJ1dGVzLm5hbWUpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke3RhYmxlTmFtZS5zY2hlbWF9LiR7YXR0cmlidXRlcy5uYW1lfWA7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5hZGRJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgcmF3VGFibGVuYW1lKTtcbiAgfVxuICBhZGRDb25zdHJhaW50UXVlcnkodGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKG9wdGlvbnMub25VcGRhdGUpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9uVXBkYXRlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5vbkRlbGV0ZSAmJiBvcHRpb25zLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCkgPT09IFwiTk8gQUNUSU9OXCIpIHtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLm9uRGVsZXRlO1xuICAgIH1cbiAgICBjb25zdCBjb25zdHJhaW50U25pcHBldCA9IHRoaXMuZ2V0Q29uc3RyYWludFNuaXBwZXQodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICB0YWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGFibGVOYW1lfSBBREQgJHtjb25zdHJhaW50U25pcHBldH07YDtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIGRhdGFUeXBlLmZpZWxkID0ga2V5O1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSxcbiAgICAgIHRoaXMuYXR0cmlidXRlVG9TUUwoZGF0YVR5cGUsIHtcbiAgICAgICAgYXR0cmlidXRlTmFtZToga2V5LFxuICAgICAgICBjb250ZXh0OiBcImFkZENvbHVtblwiXG4gICAgICB9KVxuICAgIF0pO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiQUxURVIgVEFCTEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZSksXG4gICAgICBcIkFERFwiLFxuICAgICAgYXR0cmlidXRlXG4gICAgXSk7XG4gIH1cbiAgcmVtb3ZlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1AgQ09MVU1OXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgX2FsdGVyRm9yZWlnbktleUNvbnN0cmFpbnQoZGVmaW5pdGlvbiwgdGFibGUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZUNvbnN0YW50ID0gdGhpcy5lc2NhcGUodGhpcy5nZXRDYXRhbG9nTmFtZShhdHRyaWJ1dGVOYW1lKSk7XG4gICAgY29uc3Qgc2NoZW1hTmFtZUNvbnN0YW50ID0gdGFibGUuc2NoZW1hID8gdGhpcy5lc2NhcGUodGhpcy5nZXRDYXRhbG9nTmFtZShzY2hlbWFOYW1lKSkgOiBcIlVTRVJcIjtcbiAgICBjb25zdCB0YWJsZU5hbWVDb25zdGFudCA9IHRoaXMuZXNjYXBlKHRoaXMuZ2V0Q2F0YWxvZ05hbWUodGFibGVOYW1lKSk7XG4gICAgY29uc3QgZ2V0Q29uc05hbWVRdWVyeSA9IFtcbiAgICAgIFwiU0VMRUNUIGNvbnN0cmFpbnRfbmFtZSBJTlRPIGNvbnNfbmFtZVwiLFxuICAgICAgXCJGUk9NIChcIixcbiAgICAgIFwiICBTRUxFQ1QgRElTVElOQ1QgY2Mub3duZXIsIGNjLnRhYmxlX25hbWUsIGNjLmNvbnN0cmFpbnRfbmFtZSwgY2MuY29sdW1uX25hbWUgQVMgY29uc19jb2x1bW5zXCIsXG4gICAgICBcIiAgRlJPTSBhbGxfY29uc19jb2x1bW5zIGNjLCBhbGxfY29uc3RyYWludHMgY1wiLFxuICAgICAgXCIgIFdIRVJFIGNjLm93bmVyID0gYy5vd25lclwiLFxuICAgICAgXCIgIEFORCBjYy50YWJsZV9uYW1lID0gYy50YWJsZV9uYW1lXCIsXG4gICAgICBcIiAgQU5EIGNjLmNvbnN0cmFpbnRfbmFtZSA9IGMuY29uc3RyYWludF9uYW1lXCIsXG4gICAgICBcIiAgQU5EIGMuY29uc3RyYWludF90eXBlID0gJ1InXCIsXG4gICAgICBcIiAgR1JPVVAgQlkgY2Mub3duZXIsIGNjLnRhYmxlX25hbWUsIGNjLmNvbnN0cmFpbnRfbmFtZSwgY2MuY29sdW1uX25hbWVcIixcbiAgICAgIFwiKVwiLFxuICAgICAgXCJXSEVSRSBvd25lciA9XCIsXG4gICAgICBzY2hlbWFOYW1lQ29uc3RhbnQsXG4gICAgICBcIkFORCB0YWJsZV9uYW1lID1cIixcbiAgICAgIHRhYmxlTmFtZUNvbnN0YW50LFxuICAgICAgXCJBTkQgY29uc19jb2x1bW5zID1cIixcbiAgICAgIGF0dHJpYnV0ZU5hbWVDb25zdGFudCxcbiAgICAgIFwiO1wiXG4gICAgXS5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBzZWNvbmRRdWVyeSA9IFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodGFibGVOYW1lKX1gLFxuICAgICAgXCJBREQgRk9SRUlHTiBLRVlcIixcbiAgICAgIGAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX0pYCxcbiAgICAgIGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKVxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBnZXRDb25zTmFtZVF1ZXJ5LFxuICAgICAgXCJFWENFUFRJT05cIixcbiAgICAgIFwiV0hFTiBOT19EQVRBX0ZPVU5EIFRIRU5cIixcbiAgICAgIFwiIENPTlNfTkFNRSA6PSBOVUxMO1wiLFxuICAgICAgXCJFTkQ7XCIsXG4gICAgICBcIklGIENPTlNfTkFNRSBJUyBOT1QgTlVMTCBUSEVOXCIsXG4gICAgICBgIEVYRUNVVEUgSU1NRURJQVRFICdBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZSl9IERST1AgQ09OU1RSQUlOVCBcIid8fENPTlNfTkFNRXx8J1wiJztgLFxuICAgICAgXCJFTkQgSUY7XCIsXG4gICAgICBgRVhFQ1VURSBJTU1FRElBVEUgJHt0aGlzLmVzY2FwZShzZWNvbmRRdWVyeSl9O2BcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIF9tb2RpZnlRdWVyeShkZWZpbml0aW9uLCB0YWJsZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGUpLFxuICAgICAgXCJNT0RJRllcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLFxuICAgICAgZGVmaW5pdGlvblxuICAgIF0pO1xuICAgIGNvbnN0IHNlY29uZFF1ZXJ5ID0gcXVlcnkucmVwbGFjZShcIk5PVCBOVUxMXCIsIFwiXCIpLnJlcGxhY2UoXCJOVUxMXCIsIFwiXCIpO1xuICAgIHJldHVybiBbXG4gICAgICBcIkJFR0lOXCIsXG4gICAgICBgRVhFQ1VURSBJTU1FRElBVEUgJHt0aGlzLmVzY2FwZShxdWVyeSl9O2AsXG4gICAgICBcIkVYQ0VQVElPTlwiLFxuICAgICAgXCJXSEVOIE9USEVSUyBUSEVOXCIsXG4gICAgICBcIiBJRiBTUUxDT0RFID0gLTE0NDIgT1IgU1FMQ09ERSA9IC0xNDUxIFRIRU5cIixcbiAgICAgIGAgICBFWEVDVVRFIElNTUVESUFURSAke3RoaXMuZXNjYXBlKHNlY29uZFF1ZXJ5KX07YCxcbiAgICAgIFwiIEVMU0VcIixcbiAgICAgIFwiICAgUkFJU0U7XCIsXG4gICAgICBcIiBFTkQgSUY7XCIsXG4gICAgICBcIkVORDtcIlxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGUsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICBcIkRFQ0xBUkVcIixcbiAgICAgIFwiQ09OU19OQU1FIFZBUkNIQVIyKDIwMCk7XCIsXG4gICAgICBcIkJFR0lOXCJcbiAgICBdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgIGlmIChkZWZpbml0aW9uLm1hdGNoKC9SRUZFUkVOQ0VTLykpIHtcbiAgICAgICAgc3FsLnB1c2godGhpcy5fYWx0ZXJGb3JlaWduS2V5Q29uc3RyYWludChkZWZpbml0aW9uLCB0YWJsZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsLnB1c2godGhpcy5fbW9kaWZ5UXVlcnkoZGVmaW5pdGlvbiwgdGFibGUsIGF0dHJpYnV0ZU5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3FsLnB1c2goXCJFTkQ7XCIpO1xuICAgIHJldHVybiBzcWwuam9pbihcIiBcIik7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgbmV3TmFtZSA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpWzBdO1xuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVOQU1FIENPTFVNTiAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJCZWZvcmUpfSBUTyAke3RoaXMucXVvdGVJZGVudGlmaWVyKG5ld05hbWUpfWA7XG4gIH1cbiAgcG9wdWxhdGVJbnNlcnRRdWVyeVJldHVybkludG9CaW5kcyhyZXR1cm5pbmdNb2RlbEF0dHJpYnV0ZXMsIHJldHVyblR5cGVzLCBpbmJpbmRMZW5ndGgsIHJldHVybkF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcmFjbGVkYiA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmxpYjtcbiAgICBjb25zdCBvdXRCaW5kQXR0cmlidXRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qgb3V0YmluZCA9IFtdO1xuICAgIGNvbnN0IG91dGJpbmRQYXJhbSA9IHRoaXMuYmluZFBhcmFtKG91dGJpbmQsIGluYmluZExlbmd0aCk7XG4gICAgcmV0dXJuaW5nTW9kZWxBdHRyaWJ1dGVzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnN1YnN0cmluZygxLCBlbGVtZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgb3V0QmluZEF0dHJpYnV0ZXNbZWxlbWVudF0gPSBPYmplY3QuYXNzaWduKHJldHVyblR5cGVzW2luZGV4XS5fZ2V0QmluZERlZihvcmFjbGVkYiksIHsgZGlyOiBvcmFjbGVkYi5CSU5EX09VVCB9KTtcbiAgICAgIGNvbnN0IHJldHVybkF0dHJpYnV0ZSA9IGAke3RoaXMuZm9ybWF0KHZvaWQgMCwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSwgb3V0YmluZFBhcmFtKX1gO1xuICAgICAgcmV0dXJuQXR0cmlidXRlcy5wdXNoKHJldHVybkF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyA9IG91dEJpbmRBdHRyaWJ1dGVzO1xuICB9XG4gIHVwc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBtb2RlbCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJhd0F0dHJpYnV0ZXMgPSBtb2RlbC5yYXdBdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHVwZGF0ZVF1ZXJ5ID0gdGhpcy51cGRhdGVRdWVyeSh0YWJsZU5hbWUsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMsIHJhd0F0dHJpYnV0ZXMpO1xuICAgIG9wdGlvbnMuYmluZCA9IHVwZGF0ZVF1ZXJ5LmJpbmQ7XG4gICAgY29uc3QgaW5zZXJ0UXVlcnkgPSB0aGlzLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCByYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICBcIkRFQ0xBUkUgXCIsXG4gICAgICBcIkJFR0lOIFwiLFxuICAgICAgdXBkYXRlUXVlcnkucXVlcnkgPyBbXG4gICAgICAgIHVwZGF0ZVF1ZXJ5LnF1ZXJ5LFxuICAgICAgICBcIjsgXCIsXG4gICAgICAgIFwiIElGICggU1FMJVJPV0NPVU5UID0gMCApIFRIRU4gXCIsXG4gICAgICAgIGluc2VydFF1ZXJ5LnF1ZXJ5LFxuICAgICAgICBcIiA6aXNVcGRhdGUgOj0gMDsgXCIsXG4gICAgICAgIFwiRUxTRSBcIixcbiAgICAgICAgXCIgOmlzVXBkYXRlIDo9IDE7IFwiLFxuICAgICAgICBcIiBFTkQgSUY7IFwiXG4gICAgICBdLmpvaW4oXCJcIikgOiBbXG4gICAgICAgIGluc2VydFF1ZXJ5LnF1ZXJ5LFxuICAgICAgICBcIiA6aXNVcGRhdGUgOj0gMDsgXCIsXG4gICAgICAgIFwiRVhDRVBUSU9OIFdIRU4gT1RIRVJTIFRIRU5cIixcbiAgICAgICAgXCIgSUYgU1FMQ09ERSAhPSAtMSBUSEVOXCIsXG4gICAgICAgIFwiICAgUkFJU0U7XCIsXG4gICAgICAgIFwiIEVORCBJRjtcIlxuICAgICAgXS5qb2luKFwiXCIpLFxuICAgICAgXCJFTkQ7XCJcbiAgICBdO1xuICAgIGNvbnN0IHF1ZXJ5ID0gc3FsLmpvaW4oXCJcIik7XG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIGlmIChvcHRpb25zLmJpbmRQYXJhbSAhPT0gZmFsc2UpIHtcbiAgICAgIHJlc3VsdC5iaW5kID0gdXBkYXRlUXVlcnkuYmluZCB8fCBpbnNlcnRRdWVyeS5iaW5kO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGJ1bGtJbnNlcnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkVmFsdWVIYXNoZXMsIG9wdGlvbnMsIGZpZWxkTWFwcGVkQXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuZXhlY3V0ZU1hbnkgPSB0cnVlO1xuICAgIGZpZWxkTWFwcGVkQXR0cmlidXRlcyA9IGZpZWxkTWFwcGVkQXR0cmlidXRlcyB8fCB7fTtcbiAgICBjb25zdCB0dXBsZXMgPSBbXTtcbiAgICBjb25zdCBhbGxDb2x1bW5zID0ge307XG4gICAgY29uc3QgaW5CaW5kQmluZERlZk1hcCA9IHt9O1xuICAgIGNvbnN0IG91dEJpbmRCaW5kRGVmTWFwID0ge307XG4gICAgY29uc3Qgb3JhY2xlZGIgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5saWI7XG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBfLmZvck93bihmaWVsZFZhbHVlSGFzaCwgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgYWxsQ29sdW1uc1trZXldID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0gJiYgZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0uYXV0b0luY3JlbWVudCA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaW5CaW5kUG9zaXRpb247XG4gICAgZm9yIChjb25zdCBmaWVsZFZhbHVlSGFzaCBvZiBmaWVsZFZhbHVlSGFzaGVzKSB7XG4gICAgICBjb25zdCB0dXBsZSA9IFtdO1xuICAgICAgY29uc3QgaW5iaW5kUGFyYW0gPSBvcHRpb25zLmJpbmRQYXJhbSA9PT0gdm9pZCAwID8gdGhpcy5iaW5kUGFyYW0odHVwbGUpIDogb3B0aW9ucy5iaW5kUGFyYW07XG4gICAgICBjb25zdCB0ZW1wQmluZFBvc2l0aW9ucyA9IE9iamVjdC5rZXlzKGFsbENvbHVtbnMpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIGlmIChhbGxDb2x1bW5zW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAoZmllbGRWYWx1ZUhhc2hba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJGb3IgYW4gYXV0by1pbmNyZW1lbnQgY29sdW1uIGVpdGhlciBhbGwgcm93IG11c3QgYmUgbnVsbCBvciBub24tbnVsbCwgYSBtaXggb2YgbnVsbCBhbmQgbm9uLW51bGwgaXMgbm90IGFsbG93ZWQhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJERUZBVUxUXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KGZpZWxkVmFsdWVIYXNoW2tleV0sIGZpZWxkTWFwcGVkQXR0cmlidXRlc1trZXldLCB7IGNvbnRleHQ6IFwiSU5TRVJUXCIgfSwgaW5iaW5kUGFyYW0pO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWluQmluZFBvc2l0aW9uKSB7XG4gICAgICAgIGluQmluZFBvc2l0aW9uID0gdGVtcEJpbmRQb3NpdGlvbnM7XG4gICAgICB9XG4gICAgICB0dXBsZXMucHVzaCh0dXBsZSk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVybkNvbHVtbiA9IFtdO1xuICAgIGNvbnN0IHJldHVybkNvbHVtbkJpbmRQb3NpdGlvbnMgPSBbXTtcbiAgICBjb25zdCBpbnNlcnRDb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoYWxsQ29sdW1ucykpIHtcbiAgICAgIGlmIChmaWVsZE1hcHBlZEF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICBjb25zdCBiaW5kRGVmID0gZmllbGRNYXBwZWRBdHRyaWJ1dGVzW2tleV0udHlwZS5fZ2V0QmluZERlZihvcmFjbGVkYik7XG4gICAgICAgIGlmIChhbGxDb2x1bW5zW2tleV0pIHtcbiAgICAgICAgICBiaW5kRGVmLmRpciA9IG9yYWNsZWRiLkJJTkRfT1VUO1xuICAgICAgICAgIG91dEJpbmRCaW5kRGVmTWFwW2tleV0gPSBiaW5kRGVmO1xuICAgICAgICAgIHJldHVybkNvbHVtbi5wdXNoKHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSkpO1xuICAgICAgICAgIHJldHVybkNvbHVtbkJpbmRQb3NpdGlvbnMucHVzaChgOiR7dHVwbGVzWzBdLmxlbmd0aCArIHJldHVybkNvbHVtbi5sZW5ndGh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmluZERlZi5kaXIgPSBvcmFjbGVkYi5CSU5EX0lOO1xuICAgICAgICAgIGluQmluZEJpbmREZWZNYXBba2V5XSA9IGJpbmREZWY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydENvbHVtbnMucHVzaCh0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpKTtcbiAgICB9XG4gICAgbGV0IHF1ZXJ5ID0gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIklOU0VSVFwiLFxuICAgICAgXCJJTlRPXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIGAoJHtpbnNlcnRDb2x1bW5zLmpvaW4oXCIsXCIpfSlgLFxuICAgICAgXCJWQUxVRVNcIixcbiAgICAgIGAoJHtpbkJpbmRQb3NpdGlvbn0pYFxuICAgIF0pO1xuICAgIGlmIChyZXR1cm5Db2x1bW4ubGVuZ3RoID4gMCkge1xuICAgICAgb3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyA9IG91dEJpbmRCaW5kRGVmTWFwO1xuICAgICAgcXVlcnkgPSBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIFwiUkVUVVJOSU5HXCIsXG4gICAgICAgIGAke3JldHVybkNvbHVtbi5qb2luKFwiLFwiKX1gLFxuICAgICAgICBcIklOVE9cIixcbiAgICAgICAgYCR7cmV0dXJuQ29sdW1uQmluZFBvc2l0aW9uc31gXG4gICAgICBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0geyBxdWVyeSB9O1xuICAgIHJlc3VsdC5iaW5kID0gdHVwbGVzO1xuICAgIG9wdGlvbnMuaW5iaW5kQXR0cmlidXRlcyA9IGluQmluZEJpbmREZWZNYXA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBUUlVOQ0FURSBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWA7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCB0YWJsZSA9IHRhYmxlTmFtZTtcbiAgICB3aGVyZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgbGV0IHF1ZXJ5VG1wbDtcbiAgICBpZiAob3B0aW9ucy5saW1pdCkge1xuICAgICAgY29uc3Qgd2hlcmVUbXBsID0gd2hlcmUgPyBgIEFORCAke3doZXJlfWAgOiBcIlwiO1xuICAgICAgcXVlcnlUbXBsID0gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gV0hFUkUgcm93aWQgSU4gKFNFTEVDVCByb3dpZCBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0gV0hFUkUgcm93bnVtIDw9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9JHt3aGVyZVRtcGx9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdoZXJlVG1wbCA9IHdoZXJlID8gYCBXSEVSRSAke3doZXJlfWAgOiBcIlwiO1xuICAgICAgcXVlcnlUbXBsID0gYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlKX0ke3doZXJlVG1wbH1gO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlUbXBsO1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBvd25lcl0gPSB0aGlzLmdldFNjaGVtYU5hbWVBbmRUYWJsZU5hbWUodGFibGUpO1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiU0VMRUNUIGkuaW5kZXhfbmFtZSxpLnRhYmxlX25hbWUsIGkuY29sdW1uX25hbWUsIHUudW5pcXVlbmVzcywgaS5kZXNjZW5kLCBjLmNvbnN0cmFpbnRfdHlwZSBcIixcbiAgICAgIFwiRlJPTSBhbGxfaW5kX2NvbHVtbnMgaSBcIixcbiAgICAgIFwiSU5ORVIgSk9JTiBhbGxfaW5kZXhlcyB1IFwiLFxuICAgICAgXCJPTiAodS50YWJsZV9uYW1lID0gaS50YWJsZV9uYW1lIEFORCB1LmluZGV4X25hbWUgPSBpLmluZGV4X25hbWUpIFwiLFxuICAgICAgXCJMRUZUIE9VVEVSIEpPSU4gYWxsX2NvbnN0cmFpbnRzIGMgXCIsXG4gICAgICBcIk9OIChjLnRhYmxlX25hbWUgPSBpLnRhYmxlX25hbWUgQU5EIGMuaW5kZXhfbmFtZSA9IGkuaW5kZXhfbmFtZSkgXCIsXG4gICAgICBgV0hFUkUgaS50YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfWAsXG4gICAgICBcIiBBTkQgdS50YWJsZV9vd25lciA9IFwiLFxuICAgICAgb3duZXIgPyB0aGlzLmVzY2FwZShvd25lcikgOiBcIlVTRVJcIixcbiAgICAgIFwiIE9SREVSIEJZIGluZGV4X25hbWUsIGNvbHVtbl9wb3NpdGlvblwiXG4gICAgXTtcbiAgICByZXR1cm4gc3FsLmpvaW4oXCJcIik7XG4gIH1cbiAgcmVtb3ZlSW5kZXhRdWVyeSh0YWJsZU5hbWUsIGluZGV4TmFtZU9yQXR0cmlidXRlcykge1xuICAgIGxldCBpbmRleE5hbWUgPSBpbmRleE5hbWVPckF0dHJpYnV0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGluZGV4TmFtZSA9IFV0aWxzLnVuZGVyc2NvcmUoYCR7dGFibGVOYW1lfV8ke2luZGV4TmFtZU9yQXR0cmlidXRlcy5qb2luKFwiX1wiKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGBEUk9QIElOREVYICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX1gO1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBhdHRyaWJ1dGUub25VcGRhdGUgPSBcIlwiO1xuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5Nb2RlbCAmJiBhdHRyaWJ1dGUuTW9kZWwudGFibGVOYW1lID09PSBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCkge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coXCJPcmFjbGUgZG9lcyBub3Qgc3VwcG9ydCBzZWxmIHJlZmVyZW5jaWFsIGNvbnN0cmFpbnRzLCB3ZSB3aWxsIHJlbW92ZSBpdCBidXQgd2UgcmVjb21tZW5kIHJlc3RydWN0dXJpbmcgeW91ciBxdWVyeVwiKTtcbiAgICAgICAgYXR0cmlidXRlLm9uRGVsZXRlID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRlbXBsYXRlO1xuICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwgPyBhdHRyaWJ1dGUudHlwZS50b1NxbCgpIDogXCJcIjtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSlNPTikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmF0dHJpYnV0ZU5hbWUpfSBJUyBKU09OKWA7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuICAgIGlmIChVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgTk9UIE5VTExcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGlmIChhdHRyaWJ1dGUudHlwZS52YWx1ZXMgJiYgIWF0dHJpYnV0ZS52YWx1ZXMpXG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZXMgPSBhdHRyaWJ1dGUudHlwZS52YWx1ZXM7XG4gICAgICB0ZW1wbGF0ZSArPSBgIENIRUNLICgke3RoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuYXR0cmlidXRlTmFtZSl9IElOKCR7Xy5tYXAoYXR0cmlidXRlLnZhbHVlcywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KS5qb2luKFwiLCBcIil9KSlgO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuQk9PTEVBTikge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDSEVDSyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmF0dHJpYnV0ZU5hbWUpfSBJTignMScsICcwJykpYDtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZSA9IFwiIE5VTUJFUigqLDApIEdFTkVSQVRFRCBCWSBERUZBVUxUIE9OIE5VTEwgQVMgSURFTlRJVFlcIjtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlICYmIGF0dHJpYnV0ZS50eXBlLmtleSA9PT0gRGF0YVR5cGVzLkRPVUJMRS5rZXkpIHtcbiAgICAgIHRlbXBsYXRlID0gYXR0cmlidXRlLnR5cGUudG9TcWwoKTtcbiAgICB9IGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlKSB7XG4gICAgICBsZXQgdW5zaWduZWRUZW1wbGF0ZSA9IFwiXCI7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUuX3Vuc2lnbmVkKSB7XG4gICAgICAgIGF0dHJpYnV0ZS50eXBlLl91bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICB1bnNpZ25lZFRlbXBsYXRlICs9IGAgY2hlY2soJHt0aGlzLnF1b3RlSWRlbnRpZmllcihvcHRpb25zLmF0dHJpYnV0ZU5hbWUpfSA+PSAwKWA7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoYXR0cmlidXRlLnR5cGUgJiYgYXR0cmlidXRlLnR5cGUgIT09IFwiVEVYVFwiICYmIGF0dHJpYnV0ZS50eXBlLl9iaW5hcnkgIT09IHRydWUgJiYgVXRpbHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpfWA7XG4gICAgICB9XG4gICAgICBpZiAoIWF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsID09PSBmYWxzZSkge1xuICAgICAgICAgIHRlbXBsYXRlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIWF0dHJpYnV0ZS5wcmltYXJ5S2V5ICYmICFVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSArPSBcIiBOVUxMXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlICs9IHVuc2lnbmVkVGVtcGxhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUgJiYgIWF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBVTklRVUVcIjtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS5wcmltYXJ5S2V5KSB7XG4gICAgICB0ZW1wbGF0ZSArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgIH1cbiAgICBpZiAoKCFvcHRpb25zIHx8ICFvcHRpb25zLndpdGhvdXRGb3JlaWduS2V5Q29uc3RyYWludHMpICYmIGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUgJiYgYXR0cmlidXRlLm9uRGVsZXRlLnRvVXBwZXJDYXNlKCkgIT09IFwiTk8gQUNUSU9OXCIpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLmZpZWxkIHx8IGtleTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGVOYW1lXSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBfX3NwcmVhZFZhbHVlcyh7IGF0dHJpYnV0ZU5hbWUgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVRyaWdnZXIoKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVUcmlnZ2VyXCIpO1xuICB9XG4gIGRyb3BUcmlnZ2VyKCkge1xuICAgIHRocm93TWV0aG9kVW5kZWZpbmVkKFwiZHJvcFRyaWdnZXJcIik7XG4gIH1cbiAgcmVuYW1lVHJpZ2dlcigpIHtcbiAgICB0aHJvd01ldGhvZFVuZGVmaW5lZChcInJlbmFtZVRyaWdnZXJcIik7XG4gIH1cbiAgY3JlYXRlRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJjcmVhdGVGdW5jdGlvblwiKTtcbiAgfVxuICBkcm9wRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJkcm9wRnVuY3Rpb25cIik7XG4gIH1cbiAgcmVuYW1lRnVuY3Rpb24oKSB7XG4gICAgdGhyb3dNZXRob2RVbmRlZmluZWQoXCJyZW5hbWVGdW5jdGlvblwiKTtcbiAgfVxuICBnZXRDb25zdHJhaW50c09uQ29sdW1uKHRhYmxlLCBjb2x1bW4pIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29sdW1uID0gdGhpcy5nZXRDYXRhbG9nTmFtZShjb2x1bW4pO1xuICAgIGNvbnN0IHNxbCA9IFtcbiAgICAgIFwiU0VMRUNUIENPTlNUUkFJTlRfTkFNRSBGUk9NIHVzZXJfY29uc19jb2x1bW5zIFdIRVJFIFRBQkxFX05BTUUgPSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKHRhYmxlTmFtZSksXG4gICAgICBcIiBhbmQgT1dORVIgPSBcIixcbiAgICAgIHRhYmxlLnNjaGVtYSA/IHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpIDogXCJVU0VSXCIsXG4gICAgICBcIiBhbmQgQ09MVU1OX05BTUUgPSBcIixcbiAgICAgIHRoaXMuZXNjYXBlKGNvbHVtbiksXG4gICAgICBcIiBBTkQgUE9TSVRJT04gSVMgTk9UIE5VTEwgT1JERVIgQlkgUE9TSVRJT05cIlxuICAgIF0uam9pbihcIlwiKTtcbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCBbdGFibGVOYW1lLCBzY2hlbWFOYW1lXSA9IHRoaXMuZ2V0U2NoZW1hTmFtZUFuZFRhYmxlTmFtZSh0YWJsZSk7XG4gICAgY29uc3Qgc3FsID0gW1xuICAgICAgJ1NFTEVDVCBESVNUSU5DVCAgYS50YWJsZV9uYW1lIFwidGFibGVOYW1lXCIsIGEuY29uc3RyYWludF9uYW1lIFwiY29uc3RyYWludE5hbWVcIiwgYS5vd25lciBcIm93bmVyXCIsICBhLmNvbHVtbl9uYW1lIFwiY29sdW1uTmFtZVwiLCcsXG4gICAgICAnIGIudGFibGVfbmFtZSBcInJlZmVyZW5jZWRUYWJsZU5hbWVcIiwgYi5jb2x1bW5fbmFtZSBcInJlZmVyZW5jZWRDb2x1bW5OYW1lXCInLFxuICAgICAgXCIgRlJPTSBhbGxfY29uc19jb2x1bW5zIGFcIixcbiAgICAgIFwiIEpPSU4gYWxsX2NvbnN0cmFpbnRzIGMgT04gYS5vd25lciA9IGMub3duZXIgQU5EIGEuY29uc3RyYWludF9uYW1lID0gYy5jb25zdHJhaW50X25hbWVcIixcbiAgICAgIFwiIEpPSU4gYWxsX2NvbnNfY29sdW1ucyBiIE9OIGMub3duZXIgPSBiLm93bmVyIEFORCBjLnJfY29uc3RyYWludF9uYW1lID0gYi5jb25zdHJhaW50X25hbWVcIixcbiAgICAgIFwiIFdIRVJFIGMuY29uc3RyYWludF90eXBlICA9ICdSJ1wiLFxuICAgICAgXCIgQU5EIGEudGFibGVfbmFtZSA9IFwiLFxuICAgICAgdGhpcy5lc2NhcGUodGFibGVOYW1lKSxcbiAgICAgIFwiIEFORCBhLm93bmVyID0gXCIsXG4gICAgICB0YWJsZS5zY2hlbWEgPyB0aGlzLmVzY2FwZShzY2hlbWFOYW1lKSA6IFwiVVNFUlwiLFxuICAgICAgXCIgT1JERVIgQlkgYS50YWJsZV9uYW1lLCBhLmNvbnN0cmFpbnRfbmFtZVwiXG4gICAgXS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kcm9wQ29uc3RyYWludFF1ZXJ5KHRhYmxlTmFtZSwgZm9yZWlnbktleSk7XG4gIH1cbiAgZ2V0UHJpbWFyeUtleUNvbnN0cmFpbnRRdWVyeSh0YWJsZSkge1xuICAgIGNvbnN0IFt0YWJsZU5hbWUsIHNjaGVtYU5hbWVdID0gdGhpcy5nZXRTY2hlbWFOYW1lQW5kVGFibGVOYW1lKHRhYmxlKTtcbiAgICBjb25zdCBzcWwgPSBbXG4gICAgICBcIlNFTEVDVCBjb2xzLmNvbHVtbl9uYW1lLCBhdGMuaWRlbnRpdHlfY29sdW1uIFwiLFxuICAgICAgXCJGUk9NIGFsbF9jb25zdHJhaW50cyBjb25zLCBhbGxfY29uc19jb2x1bW5zIGNvbHMgXCIsXG4gICAgICBcIklOTkVSIEpPSU4gYWxsX3RhYl9jb2x1bW5zIGF0YyBPTihhdGMudGFibGVfbmFtZSA9IGNvbHMudGFibGVfbmFtZSBBTkQgYXRjLkNPTFVNTl9OQU1FID0gY29scy5DT0xVTU5fTkFNRSApXCIsXG4gICAgICBcIldIRVJFIGNvbHMudGFibGVfbmFtZSA9IFwiLFxuICAgICAgdGhpcy5lc2NhcGUodGFibGVOYW1lKSxcbiAgICAgIFwiQU5EIGNvbHMub3duZXIgPSBcIixcbiAgICAgIHRhYmxlLnNjaGVtYSA/IHRoaXMuZXNjYXBlKHNjaGVtYU5hbWUpIDogXCJVU0VSIFwiLFxuICAgICAgXCJBTkQgY29ucy5jb25zdHJhaW50X3R5cGUgPSAnUCcgXCIsXG4gICAgICBcIkFORCBjb25zLmNvbnN0cmFpbnRfbmFtZSA9IGNvbHMuY29uc3RyYWludF9uYW1lIFwiLFxuICAgICAgXCJBTkQgY29ucy5vd25lciA9IGNvbHMub3duZXIgXCIsXG4gICAgICBcIk9SREVSIEJZIGNvbHMudGFibGVfbmFtZSwgY29scy5wb3NpdGlvblwiXG4gICAgXS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZHJvcENvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBEUk9QIENPTlNUUkFJTlQgJHtjb25zdHJhaW50TmFtZX1gO1xuICB9XG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFQURfVU5DT01NSVRURUQ6XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9DT01NSVRURUQ6XG4gICAgICAgIHJldHVybiBcIlNFVCBUUkFOU0FDVElPTiBJU09MQVRJT04gTEVWRUwgUkVBRCBDT01NSVRURUQ7XCI7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVQRUFUQUJMRV9SRUFEOlxuICAgICAgICByZXR1cm4gXCJTRVQgVFJBTlNBQ1RJT04gSVNPTEFUSU9OIExFVkVMIFNFUklBTElaQUJMRTtcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaXNvbGF0aW9uIGxldmVsIFwiJHt2YWx1ZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICB9XG4gIGdldEFsaWFzVG9rZW4oKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgc3RhcnRUcmFuc2FjdGlvblF1ZXJ5KHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnBhcmVudCkge1xuICAgICAgcmV0dXJuIGBTQVZFUE9JTlQgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmFuc2FjdGlvbi5uYW1lKX1gO1xuICAgIH1cbiAgICByZXR1cm4gXCJCRUdJTiBUUkFOU0FDVElPTlwiO1xuICB9XG4gIGNvbW1pdFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBcIkNPTU1JVCBUUkFOU0FDVElPTlwiO1xuICB9XG4gIHJvbGxiYWNrVHJhbnNhY3Rpb25RdWVyeSh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5wYXJlbnQpIHtcbiAgICAgIHJldHVybiBgUk9MTEJBQ0sgVE8gU0FWRVBPSU5UICR7dGhpcy5xdW90ZUlkZW50aWZpZXIodHJhbnNhY3Rpb24ubmFtZSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIFwiUk9MTEJBQ0sgVFJBTlNBQ1RJT05cIjtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgbGV0IHN0cjtcbiAgICBpZiAoc210aCBpbnN0YW5jZW9mIFV0aWxzLkpzb24pIHtcbiAgICAgIGlmIChzbXRoLmNvbmRpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29uZGl0aW9ucyA9IHRoaXMucGFyc2VDb25kaXRpb25PYmplY3Qoc210aC5jb25kaXRpb25zKS5tYXAoKGNvbmRpdGlvbikgPT4gYCR7dGhpcy5qc29uUGF0aEV4dHJhY3Rpb25RdWVyeShjb25kaXRpb24ucGF0aFswXSwgXy50YWlsKGNvbmRpdGlvbi5wYXRoKSl9ID0gJyR7Y29uZGl0aW9uLnZhbHVlfSdgKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbnMuam9pbihcIiBBTkQgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNtdGgucGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc210aC5wYXRoKSkge1xuICAgICAgICAgIHN0ciA9IHNtdGgucGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYXRocyA9IF8udG9QYXRoKHNtdGgucGF0aCk7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gcGF0aHMuc2hpZnQoKTtcbiAgICAgICAgICBzdHIgPSB0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbHVtbiwgcGF0aHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLnZhbHVlKSB7XG4gICAgICAgICAgc3RyICs9IHV0aWwuZm9ybWF0KFwiID0gJXNcIiwgdGhpcy5lc2NhcGUoc210aC52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKHNtdGgudmFsIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHN0ciA9IHRoaXMuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgudmFsLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICAgICAgICBpZiAoc210aC50eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHN0ciA9IGAoQ0FTRSBXSEVOICR7c3RyfT0ndHJ1ZScgVEhFTiAxIEVMU0UgMCBFTkQpYDtcbiAgICAgICAgICByZXR1cm4gYENBU1QoJHtzdHJ9IEFTIE5VTUJFUilgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzbXRoLnR5cGUgPT09IFwidGltZXN0YW1wdHpcIiAmJiAvanNvbl92YWx1ZVxcKC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICByZXR1cm4gYCR7c3RyfSBSRVRVUk5JTkcgVElNRVNUQU1QIFdJVEggVElNRSBaT05FKWA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZChzbXRoLCB0YWJsZU5hbWUsIGZhY3RvcnksIG9wdGlvbnMsIHByZXBlbmQpO1xuICB9XG4gIF9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzdG10KSB7XG4gICAgaWYgKHR5cGVvZiBzdG10ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5kZXggPSAwO1xuICAgIGxldCBvcGVuaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBjbG9zaW5nQnJhY2tldHMgPSAwO1xuICAgIGxldCBoYXNKc29uRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgaGFzSW52YWxpZFRva2VuID0gZmFsc2U7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRleCA8IHN0bXQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdHJpbmcgPSBzdG10LnN1YnN0cihjdXJyZW50SW5kZXgpO1xuICAgICAgY29uc3QgZnVuY3Rpb25NYXRjaGVzID0gSlNPTl9GVU5DVElPTl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZihcIihcIik7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3BlcmF0b3JNYXRjaGVzID0gSlNPTl9PUEVSQVRPUl9SRUdFWC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IFRPS0VOX0NBUFRVUkVfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIilcIikge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGhhc0pzb25GdW5jdGlvbiAmJiAoaGFzSW52YWxpZFRva2VuIHx8IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cbiAganNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRoKSB7XG4gICAgbGV0IHBhdGhzID0gXy50b1BhdGgocGF0aCk7XG4gICAgY29uc3QgcXVvdGVkQ29sdW1uID0gdGhpcy5pc0lkZW50aWZpZXJRdW90ZWQoY29sdW1uKSA/IGNvbHVtbiA6IHRoaXMucXVvdGVJZGVudGlmaWVyKGNvbHVtbik7XG4gICAgcGF0aHMgPSBwYXRocy5tYXAoKHN1YlBhdGgpID0+IHtcbiAgICAgIHJldHVybiAvXFxELy50ZXN0KHN1YlBhdGgpID8gVXRpbHMuYWRkVGlja3Moc3ViUGF0aCwgJ1wiJykgOiBzdWJQYXRoO1xuICAgIH0pO1xuICAgIGNvbnN0IHBhdGhTdHIgPSB0aGlzLmVzY2FwZShbXCIkXCJdLmNvbmNhdChwYXRocykuam9pbihcIi5cIikucmVwbGFjZSgvXFwuKFxcZCspKD86KD89XFwuKXwkKS9nLCAoX18sIGRpZ2l0KSA9PiBgWyR7ZGlnaXR9XWApKTtcbiAgICByZXR1cm4gYGpzb25fdmFsdWUoJHtxdW90ZWRDb2x1bW59LCR7cGF0aFN0cn0pYDtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zLCBtb2RlbCkge1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgY29uc3Qgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQgfHwgMCwgaXNTdWJRdWVyeSA9IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbjtcbiAgICBsZXQgb3JkZXJzID0ge307XG4gICAgaWYgKG9wdGlvbnMub3JkZXIpIHtcbiAgICAgIG9yZGVycyA9IHRoaXMuZ2V0UXVlcnlPcmRlcnMob3B0aW9ucywgbW9kZWwsIGlzU3ViUXVlcnkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5saW1pdCB8fCBvcHRpb25zLm9mZnNldCkge1xuICAgICAgaWYgKCFvcmRlcnMubWFpblF1ZXJ5T3JkZXIgfHwgIW9yZGVycy5tYWluUXVlcnlPcmRlci5sZW5ndGggfHwgaXNTdWJRdWVyeSAmJiAoIW9yZGVycy5zdWJRdWVyeU9yZGVyIHx8ICFvcmRlcnMuc3ViUXVlcnlPcmRlci5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlUGtGcmFnbWVudCA9IGAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnRhYmxlQXMgfHwgbW9kZWwubmFtZSl9LiR7dGhpcy5xdW90ZUlkZW50aWZpZXIobW9kZWwucHJpbWFyeUtleUZpZWxkKX1gO1xuICAgICAgICBmcmFnbWVudCArPSBgIE9SREVSIEJZICR7dGFibGVQa0ZyYWdtZW50fWA7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5vZmZzZXQgfHwgb3B0aW9ucy5saW1pdCkge1xuICAgICAgICBmcmFnbWVudCArPSBgIE9GRlNFVCAke3RoaXMuZXNjYXBlKG9mZnNldCl9IFJPV1NgO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgZnJhZ21lbnQgKz0gYCBGRVRDSCBORVhUICR7dGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCl9IFJPV1MgT05MWWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfVxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxuICBxdW90ZUlkZW50aWZpZXIoaWRlbnRpZmllciwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IG9wdEZvcmNlUXVvdGUgPSBmb3JjZTtcbiAgICBjb25zdCBvcHRRdW90ZUlkZW50aWZpZXJzID0gdGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IHJhd0lkZW50aWZpZXIgPSBVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnXCInKTtcbiAgICBjb25zdCByZWdFeHAgPSAvXigoW1xcd11bXFx3XFxkX10qKSkkL2c7XG4gICAgaWYgKG9wdEZvcmNlUXVvdGUgIT09IHRydWUgJiYgb3B0UXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UgJiYgcmVnRXhwLnRlc3QocmF3SWRlbnRpZmllcikgJiYgIU9SQUNMRV9SRVNFUlZFRF9XT1JEUy5pbmNsdWRlcyhyYXdJZGVudGlmaWVyLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICByZXR1cm4gcmF3SWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKHJhd0lkZW50aWZpZXIsICdcIicpO1xuICB9XG4gIGJpbmRQYXJhbShiaW5kLCBwb3NPZmZzZXQgPSAwKSB7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgYmluZC5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiBgOiR7YmluZC5sZW5ndGggKyBwb3NPZmZzZXR9YDtcbiAgICB9O1xuICB9XG4gIGF1dGhUZXN0UXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIDErMSBBUyByZXN1bHQgRlJPTSBEVUFMXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIHRocm93TWV0aG9kVW5kZWZpbmVkKG1ldGhvZE5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKGBUaGUgbWV0aG9kIFwiJHttZXRob2ROYW1lfVwiIGlzIG5vdCBkZWZpbmVkISBQbGVhc2UgYWRkIGl0IHRvIHlvdXIgc3FsIGRpYWxlY3QuYCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQueryInterface: () => OracleQueryInterface\n});\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nclass OracleQueryInterface extends QueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map((item) => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter((c) => c.fields.length > 0).map((c) => c.fields);\n    const indexKeys = Object.values(model._indexes).filter((c) => c.unique && c.fields.length > 0).map((c) => c.fields);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find((fields) => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n      const indexKey = indexKeys.find((fields) => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n    if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n      options.upsertKeys = primaryKeys;\n    }\n    options.upsertKeys = _.uniq(options.upsertKeys);\n    let whereHasNull = false;\n    primaryKeys.forEach((element) => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {});\n    }\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    if (sql.bind) {\n      options.bind = void 0;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnktaW50ZXJmYWNlLmpzPzE5NjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgT3JhY2xlUXVlcnlJbnRlcmZhY2U6ICgpID0+IE9yYWNsZVF1ZXJ5SW50ZXJmYWNlXG59KTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jbGFzcyBPcmFjbGVRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgdXBzZXJ0KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCB1cGRhdGVWYWx1ZXMsIHdoZXJlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmllbGQpO1xuICAgIGNvbnN0IHVuaXF1ZUtleXMgPSBPYmplY3QudmFsdWVzKG1vZGVsLnVuaXF1ZUtleXMpLmZpbHRlcigoYykgPT4gYy5maWVsZHMubGVuZ3RoID4gMCkubWFwKChjKSA9PiBjLmZpZWxkcyk7XG4gICAgY29uc3QgaW5kZXhLZXlzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5faW5kZXhlcykuZmlsdGVyKChjKSA9PiBjLnVuaXF1ZSAmJiBjLmZpZWxkcy5sZW5ndGggPiAwKS5tYXAoKGMpID0+IGMuZmllbGRzKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLlVQU0VSVDtcbiAgICBvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlID0gT2JqZWN0LmtleXModXBkYXRlVmFsdWVzKTtcbiAgICBvcHRpb25zLnVwc2VydEtleXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUtleSA9IHVuaXF1ZUtleXMuZmluZCgoZmllbGRzKSA9PiBmaWVsZHMuaW5jbHVkZXMoZmllbGQpKTtcbiAgICAgIGlmICh1bmlxdWVLZXkpIHtcbiAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gdW5pcXVlS2V5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4S2V5ID0gaW5kZXhLZXlzLmZpbmQoKGZpZWxkcykgPT4gZmllbGRzLmluY2x1ZGVzKGZpZWxkKSk7XG4gICAgICBpZiAoaW5kZXhLZXkpIHtcbiAgICAgICAgb3B0aW9ucy51cHNlcnRLZXlzID0gaW5kZXhLZXk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy51cHNlcnRLZXlzLmxlbmd0aCA9PT0gMCB8fCBfLmludGVyc2VjdGlvbihvcHRpb25zLnVwZGF0ZU9uRHVwbGljYXRlLCBwcmltYXJ5S2V5cykubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zLnVwc2VydEtleXMgPSBwcmltYXJ5S2V5cztcbiAgICB9XG4gICAgb3B0aW9ucy51cHNlcnRLZXlzID0gXy51bmlxKG9wdGlvbnMudXBzZXJ0S2V5cyk7XG4gICAgbGV0IHdoZXJlSGFzTnVsbCA9IGZhbHNlO1xuICAgIHByaW1hcnlLZXlzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmICh3aGVyZVtlbGVtZW50XSA9PT0gbnVsbCkge1xuICAgICAgICB3aGVyZUhhc051bGwgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh3aGVyZUhhc051bGwgPT09IHRydWUpIHtcbiAgICAgIHdoZXJlID0gb3B0aW9ucy51cHNlcnRLZXlzLnJlZHVjZSgocmVzdWx0LCBhdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgcmVzdWx0W2F0dHJpYnV0ZV0gPSBpbnNlcnRWYWx1ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci51cHNlcnRRdWVyeSh0YWJsZU5hbWUsIGluc2VydFZhbHVlcywgdXBkYXRlVmFsdWVzLCB3aGVyZSwgbW9kZWwsIG9wdGlvbnMpO1xuICAgIGlmIChzcWwuYmluZCkge1xuICAgICAgb3B0aW9ucy5iaW5kID0gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktaW50ZXJmYWNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/oracle/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/oracle/query.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  OracleQuery: () => OracleQuery\n});\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"oracle\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:oracle\");\nclass OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n  getExecOptions() {\n    const execOpts = { outFormat: this.outFormat, autoCommit: this.autoCommit };\n    const oracledb = this.sequelize.connectionManager.lib;\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"DECIMAL\") {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n        if (keyValue.type.key === \"BIGINT\") {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n      }\n      if (fInfo) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"BIGINT\") {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {\n              type: oracledb.STRING,\n              maxSize: 1e7\n            });\n          }\n        }\n      }\n    }\n  }\n  async run(sql, parameters) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, \"\");\n    } else {\n      this.sql = sql;\n    }\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes(\"outBindAttributes\", oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      if (this.isUpsertQuery()) {\n        outParameters.push({ dir: oracledb.BIND_OUT });\n      }\n    }\n    this.bindParameters = outParameters;\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        this._convertBindAttributes(\"inbindAttributes\", oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else if (this.isRawQuery()) {\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach((value) => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN TRANSACTION\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT ON\")) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT OFF\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"DECLARE x NUMBER\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, { autoCommit: this.autoCommit });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"COMMIT TRANSACTION\")) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"SET TRANSACTION\")) {\n      try {\n        await this.connection.execute(this.sql, [], { autoCommit: false });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.autoCommit === void 0) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n    if (\"inputParameters\" in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        return `:${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, values];\n  }\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        if (typeof v === \"object\") {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows.map((row) => _.toPairs(row).reduce((acc, [key, value]) => {\n          const mapping = Object.values(obj).find((element) => {\n            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n            return catalogElement === key;\n          });\n          if (mapping)\n            acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n      result = rows.map((row) => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === \"string\" && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n    if (this.model) {\n      result = result.map((row) => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === \"JSON\") {\n              value = JSON.parse(value);\n            }\n            if (typeid.indexOf(\"(\") > -1 && this.model.rawAttributes[key].type.key !== \"BOOLEAN\") {\n              typeid = typeid.substr(0, typeid.indexOf(\"(\"));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n    return result;\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        const res = insertData.map((row) => {\n          const obj = {};\n          row.forEach((element, index) => {\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach((_result) => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === \"N\" ? false : true,\n            defaultValue: void 0,\n            primaryKey: _result.CONSTRAINT_TYPE === \"P\"\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result2 = this._processRows(rows);\n      return this.handleSelectQuery(result2);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split(\".\");\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = \"0.0.0\";\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{ isNewRecord: data.isUpdate, value: data }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n    return result;\n  }\n  handleShowConstraintsQuery(data) {\n    return data.rows.map((result) => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n  handleShowTablesQuery(results) {\n    return results.map((resultSet) => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  formatError(err) {\n    let match;\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace(\"(\", \"\").replace(\")\", \"\").split(\".\")[1];\n      const errors = [];\n      let fields = [], message = \"Validation error\", uniqueKey = null;\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n        const currKey = uniqueKeys.find((key) => {\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n        fields.forEach((field) => {\n          errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, null));\n        });\n      }\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n    return new SequelizeErrors.DatabaseError(err);\n  }\n  isShowIndexesQuery() {\n    return this.sql.indexOf(\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness\") > -1;\n  }\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf(\"SELECT COUNT(\") > -1;\n  }\n  handleShowIndexesQuery(data) {\n    const acc = [];\n    data.forEach((indexRecord) => {\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === \"UNIQUE\" ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === \"P\",\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: void 0\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: void 0,\n        order: indexRecord.DESCEND,\n        collate: void 0\n      });\n    });\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if (\"pkReturnVal\" in results[0]) {\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null, id = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0)\n        autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9vcmFjbGUvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCLG1CQUFPLENBQUMsd0ZBQW1CO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFnQjtBQUM1QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCO0FBQ3BHO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CO0FBQ3pFO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksR0FBRyxZQUFZLEdBQUcsWUFBWTtBQUM5RCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlDQUF5QztBQUMzRCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHVCQUF1QjtBQUNsSCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL29yYWNsZS9xdWVyeS5qcz9lMzU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgT3JhY2xlUXVlcnk6ICgpID0+IE9yYWNsZVF1ZXJ5XG59KTtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBTZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgcGFyc2VyU3RvcmUgPSByZXF1aXJlKFwiLi4vcGFyc2VyU3RvcmVcIikoXCJvcmFjbGVcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6b3JhY2xlXCIpO1xuY2xhc3MgT3JhY2xlUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbiwgc2VxdWVsaXplLCBvcHRpb25zKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICBsb2dnaW5nOiBjb25zb2xlLmxvZyxcbiAgICAgIHBsYWluOiBmYWxzZSxcbiAgICAgIHJhdzogZmFsc2VcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLmNoZWNrTG9nZ2luZ09wdGlvbigpO1xuICAgIHRoaXMub3V0Rm9ybWF0ID0gb3B0aW9ucy5vdXRGb3JtYXQgfHwgdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIubGliLk9CSkVDVDtcbiAgfVxuICBnZXRJbnNlcnRJZEZpZWxkKCkge1xuICAgIHJldHVybiBcImlkXCI7XG4gIH1cbiAgZ2V0RXhlY09wdGlvbnMoKSB7XG4gICAgY29uc3QgZXhlY09wdHMgPSB7IG91dEZvcm1hdDogdGhpcy5vdXRGb3JtYXQsIGF1dG9Db21taXQ6IHRoaXMuYXV0b0NvbW1pdCB9O1xuICAgIGNvbnN0IG9yYWNsZWRiID0gdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIubGliO1xuICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBjb25zdCBmSW5mbyA9IHt9O1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubW9kZWwudGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5VmFsdWUgPSB0aGlzLm1vZGVsLnRhYmxlQXR0cmlidXRlc1trZXldO1xuICAgICAgICBpZiAoa2V5VmFsdWUudHlwZS5rZXkgPT09IFwiREVDSU1BTFwiKSB7XG4gICAgICAgICAgZkluZm9ba2V5XSA9IHsgdHlwZTogb3JhY2xlZGIuU1RSSU5HIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleVZhbHVlLnR5cGUua2V5ID09PSBcIkJJR0lOVFwiKSB7XG4gICAgICAgICAgZkluZm9ba2V5XSA9IHsgdHlwZTogb3JhY2xlZGIuU1RSSU5HIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmSW5mbykge1xuICAgICAgICBleGVjT3B0cy5mZXRjaEluZm8gPSBmSW5mbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4ZWNPcHRzO1xuICB9XG4gIF9jb252ZXJ0QmluZEF0dHJpYnV0ZXMoYmluZGluZ0RpY3Rpb25hcnksIG9yYWNsZWRiKSB7XG4gICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5vcHRpb25zW2JpbmRpbmdEaWN0aW9uYXJ5XSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubW9kZWwudGFibGVBdHRyaWJ1dGVzKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3Qga2V5VmFsdWUgPSB0aGlzLm1vZGVsLnRhYmxlQXR0cmlidXRlc1trZXldO1xuICAgICAgICBpZiAoa2V5VmFsdWUudHlwZS5rZXkgPT09IFwiQklHSU5UXCIpIHtcbiAgICAgICAgICBjb25zdCBvbGRCaW5kaW5nID0gdGhpcy5vcHRpb25zW2JpbmRpbmdEaWN0aW9uYXJ5XVtrZXldO1xuICAgICAgICAgIGlmIChvbGRCaW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNbYmluZGluZ0RpY3Rpb25hcnldW2tleV0gPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvbGRCaW5kaW5nKSwge1xuICAgICAgICAgICAgICB0eXBlOiBvcmFjbGVkYi5TVFJJTkcsXG4gICAgICAgICAgICAgIG1heFNpemU6IDFlN1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIHJ1bihzcWwsIHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBvcmFjbGVkYiA9IHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLmxpYjtcbiAgICBjb25zdCBjb21wbGV0ZSA9IHRoaXMuX2xvZ1F1ZXJ5KHNxbCwgZGVidWcsIHBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IG91dFBhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBiaW5kUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGJpbmREZWYgPSBbXTtcbiAgICBpZiAoIXNxbC5tYXRjaCgvRU5EOyQvKSkge1xuICAgICAgdGhpcy5zcWwgPSBzcWwucmVwbGFjZSgvOyAqJC8sIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNxbCA9IHNxbDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vdXRCaW5kQXR0cmlidXRlcyAmJiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSB8fCBfLmlzUGxhaW5PYmplY3QocGFyYW1ldGVycykpKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0QmluZEF0dHJpYnV0ZXMoXCJvdXRCaW5kQXR0cmlidXRlc1wiLCBvcmFjbGVkYik7XG4gICAgICBvdXRQYXJhbWV0ZXJzLnB1c2goLi4uT2JqZWN0LnZhbHVlcyh0aGlzLm9wdGlvbnMub3V0QmluZEF0dHJpYnV0ZXMpKTtcbiAgICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgICBvdXRQYXJhbWV0ZXJzLnB1c2goeyBkaXI6IG9yYWNsZWRiLkJJTkRfT1VUIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJpbmRQYXJhbWV0ZXJzID0gb3V0UGFyYW1ldGVycztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSB8fCBfLmlzUGxhaW5PYmplY3QocGFyYW1ldGVycykpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhlY3V0ZU1hbnkpIHtcbiAgICAgICAgdGhpcy5fY29udmVydEJpbmRBdHRyaWJ1dGVzKFwiaW5iaW5kQXR0cmlidXRlc1wiLCBvcmFjbGVkYik7XG4gICAgICAgIGJpbmREZWYucHVzaCguLi5PYmplY3QudmFsdWVzKHRoaXMub3B0aW9ucy5pbmJpbmRBdHRyaWJ1dGVzKSk7XG4gICAgICAgIGJpbmREZWYucHVzaCguLi5vdXRQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5iaW5kUGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNSYXdRdWVyeSgpKSB7XG4gICAgICAgIHRoaXMuYmluZFBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhwYXJhbWV0ZXJzKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIGJpbmRQYXJhbWV0ZXJzLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYmluZFBhcmFtZXRlcnMucHVzaCguLi5vdXRQYXJhbWV0ZXJzKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJpbmRQYXJhbWV0ZXJzLCBiaW5kUGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiQkVHSU4gVFJBTlNBQ1RJT05cIikpIHtcbiAgICAgIHRoaXMuYXV0b2NvbW1pdCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIlNFVCBBVVRPQ09NTUlUIE9OXCIpKSB7XG4gICAgICB0aGlzLmF1dG9jb21taXQgPSB0cnVlO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIlNFVCBBVVRPQ09NTUlUIE9GRlwiKSkge1xuICAgICAgdGhpcy5hdXRvY29tbWl0ID0gZmFsc2U7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiREVDTEFSRSB4IE5VTUJFUlwiKSkge1xuICAgICAgaWYgKHRoaXMuYXV0b0NvbW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24udXVpZCkge1xuICAgICAgICAgIHRoaXMuYXV0b0NvbW1pdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXV0b0NvbW1pdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdGlvbi5leGVjdXRlKHRoaXMuc3FsLCB0aGlzLmJpbmRQYXJhbWV0ZXJzLCB7IGF1dG9Db21taXQ6IHRoaXMuYXV0b0NvbW1pdCB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5zdGFydHNXaXRoKFwiQkVHSU5cIikpIHtcbiAgICAgIGlmICh0aGlzLmF1dG9Db21taXQgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnV1aWQpIHtcbiAgICAgICAgICB0aGlzLmF1dG9Db21taXQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmF1dG9Db21taXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZXhlY3V0ZSh0aGlzLnNxbCwgdGhpcy5iaW5kUGFyYW1ldGVycywge1xuICAgICAgICAgIG91dEZvcm1hdDogdGhpcy5vdXRGb3JtYXQsXG4gICAgICAgICAgYXV0b0NvbW1pdDogdGhpcy5hdXRvQ29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0Lm91dEJpbmRzKSkge1xuICAgICAgICAgIHJldHVybiBbcmVzdWx0Lm91dEJpbmRzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0Lm91dEJpbmRzO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIkNPTU1JVCBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmNvbW1pdCgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLnN0YXJ0c1dpdGgoXCJST0xMQkFDSyBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zcWwuc3RhcnRzV2l0aChcIlNFVCBUUkFOU0FDVElPTlwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0aW9uLmV4ZWN1dGUodGhpcy5zcWwsIFtdLCB7IGF1dG9Db21taXQ6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZm9ybWF0RXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYXV0b0NvbW1pdCA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0aW9uLnV1aWQpIHtcbiAgICAgICAgdGhpcy5hdXRvQ29tbWl0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF1dG9Db21taXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJpbnB1dFBhcmFtZXRlcnNcIiBpbiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmlucHV0UGFyYW1ldGVycyAhPT0gbnVsbCkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmJpbmRQYXJhbWV0ZXJzLCB0aGlzLm9wdGlvbnMuaW5wdXRQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZXhlY09wdHMgPSB0aGlzLmdldEV4ZWNPcHRpb25zKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5leGVjdXRlTWFueSAmJiBiaW5kRGVmLmxlbmd0aCA+IDApIHtcbiAgICAgIGV4ZWNPcHRzLmJpbmREZWZzID0gYmluZERlZjtcbiAgICB9XG4gICAgY29uc3QgZXhlY3V0ZVByb21pc2UgPSB0aGlzLm9wdGlvbnMuZXhlY3V0ZU1hbnkgPyB0aGlzLmNvbm5lY3Rpb24uZXhlY3V0ZU1hbnkodGhpcy5zcWwsIHRoaXMuYmluZFBhcmFtZXRlcnMsIGV4ZWNPcHRzKSA6IHRoaXMuY29ubmVjdGlvbi5leGVjdXRlKHRoaXMuc3FsLCB0aGlzLmJpbmRQYXJhbWV0ZXJzLCBleGVjT3B0cyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVQcm9taXNlO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UmVzdWx0cyhyZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKG1hdGNoLCBrZXksIHZhbHVlczIpID0+IHtcbiAgICAgIGlmICh2YWx1ZXMyW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gYDoke2tleX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIHZhbHVlc107XG4gIH1cbiAgX2dldEF0dHJpYnV0ZU1hcChhdHRyc01hcCwgcmF3QXR0cmlidXRlcykge1xuICAgIGF0dHJzTWFwID0gT2JqZWN0LmFzc2lnbihhdHRyc01hcCwgXy5yZWR1Y2UocmF3QXR0cmlidXRlcywgKG1wLCBfMiwga2V5KSA9PiB7XG4gICAgICBjb25zdCBjYXRhbG9nS2V5ID0gdGhpcy5zZXF1ZWxpemUucXVlcnlJbnRlcmZhY2UucXVlcnlHZW5lcmF0b3IuZ2V0Q2F0YWxvZ05hbWUoa2V5KTtcbiAgICAgIG1wW2NhdGFsb2dLZXldID0ga2V5O1xuICAgICAgcmV0dXJuIG1wO1xuICAgIH0sIHt9KSk7XG4gIH1cbiAgX3Byb2Nlc3NSb3dzKHJvd3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gcm93cztcbiAgICBsZXQgYXR0cnNNYXAgPSB7fTtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5xdW90ZUlkZW50aWZpZXJzID09PSBmYWxzZSkge1xuICAgICAgYXR0cnNNYXAgPSBfLnJlZHVjZSh0aGlzLm9wdGlvbnMuYXR0cmlidXRlcywgKG1wLCB2KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHYgPSB2WzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhdGFsb2d2ID0gdGhpcy5zZXF1ZWxpemUucXVlcnlJbnRlcmZhY2UucXVlcnlHZW5lcmF0b3IuZ2V0Q2F0YWxvZ05hbWUodik7XG4gICAgICAgIG1wW2NhdGFsb2d2XSA9IHY7XG4gICAgICAgIHJldHVybiBtcDtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgIHRoaXMuX2dldEF0dHJpYnV0ZU1hcChhdHRyc01hcCwgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxpYXNlc01hcHBpbmcpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMub3B0aW9ucy5hbGlhc2VzTWFwcGluZyk7XG4gICAgICAgIHJvd3MgPSByb3dzLm1hcCgocm93KSA9PiBfLnRvUGFpcnMocm93KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWFwcGluZyA9IE9iamVjdC52YWx1ZXMob2JqKS5maW5kKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYXRhbG9nRWxlbWVudCA9IHRoaXMuc2VxdWVsaXplLnF1ZXJ5SW50ZXJmYWNlLnF1ZXJ5R2VuZXJhdG9yLmdldENhdGFsb2dOYW1lKGVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGNhdGFsb2dFbGVtZW50ID09PSBrZXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG1hcHBpbmcpXG4gICAgICAgICAgICBhY2NbbWFwcGluZyB8fCBrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJvd3MubWFwKChyb3cpID0+IHtcbiAgICAgICAgcmV0dXJuIF8ubWFwS2V5cyhyb3csICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0QXR0ciA9IGF0dHJzTWFwW2tleV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRBdHRyID09PSBcInN0cmluZ1wiICYmIHRhcmdldEF0dHIgIT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldEF0dHI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQubWFwKChyb3cpID0+IHtcbiAgICAgICAgcmV0dXJuIF8ubWFwVmFsdWVzKHJvdywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0gJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2tleV0udHlwZSkge1xuICAgICAgICAgICAgbGV0IHR5cGVpZCA9IHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1trZXldLnR5cGUudG9Mb2NhbGVTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS50eXBlLmtleSA9PT0gXCJKU09OXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlaWQuaW5kZXhPZihcIihcIikgPiAtMSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNba2V5XS50eXBlLmtleSAhPT0gXCJCT09MRUFOXCIpIHtcbiAgICAgICAgICAgICAgdHlwZWlkID0gdHlwZWlkLnN1YnN0cigwLCB0eXBlaWQuaW5kZXhPZihcIihcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2UgPSBwYXJzZXJTdG9yZS5nZXQodHlwZWlkKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmICEhcGFyc2UpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmb3JtYXRSZXN1bHRzKGRhdGEpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KGRhdGEpKSB7XG4gICAgICBsZXQgaW5zZXJ0RGF0YTtcbiAgICAgIGlmIChkYXRhLm91dEJpbmRzKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMub3V0QmluZEF0dHJpYnV0ZXMpO1xuICAgICAgICBpbnNlcnREYXRhID0gZGF0YS5vdXRCaW5kcztcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnNlcnREYXRhID0gW2luc2VydERhdGFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGluc2VydERhdGEubWFwKChyb3cpID0+IHtcbiAgICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgICByb3cuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIG9ialtrZXlzW2luZGV4XV0gPSBlbGVtZW50WzBdO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnNlcnREYXRhID0gcmVzO1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoaW5zZXJ0RGF0YSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5yb3dzQWZmZWN0ZWRdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNob3dUYWJsZXNRdWVyeShkYXRhLnJvd3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0Rlc2NyaWJlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0ge307XG4gICAgICBjb25zdCB0YWJsZSA9IE9iamVjdC5rZXlzKHRoaXMuc2VxdWVsaXplLm1vZGVscyk7XG4gICAgICBjb25zdCBtb2RlbEF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5tb2RlbHMgJiYgdGFibGUubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLl9nZXRBdHRyaWJ1dGVNYXAobW9kZWxBdHRyaWJ1dGVzLCB0aGlzLnNlcXVlbGl6ZS5tb2RlbHNbdGFibGVbMF1dLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgICAgZGF0YS5yb3dzLmZvckVhY2goKF9yZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKF9yZXN1bHQuRGVmYXVsdCkge1xuICAgICAgICAgIF9yZXN1bHQuRGVmYXVsdCA9IF9yZXN1bHQuRGVmYXVsdC5yZXBsYWNlKFwiKCdcIiwgXCJcIikucmVwbGFjZShcIicpXCIsIFwiXCIpLnJlcGxhY2UoLycvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEobW9kZWxBdHRyaWJ1dGVzW19yZXN1bHQuQ09MVU1OX05BTUVdIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICBsZXQga2V5ID0gbW9kZWxBdHRyaWJ1dGVzW19yZXN1bHQuQ09MVU1OX05BTUVdO1xuICAgICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICBrZXkgPSBfcmVzdWx0LkNPTFVNTl9OQU1FO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHRba2V5XSA9IHtcbiAgICAgICAgICAgIHR5cGU6IF9yZXN1bHQuREFUQV9UWVBFLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuTlVMTEFCTEUgPT09IFwiTlwiID8gZmFsc2UgOiB0cnVlLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiB2b2lkIDAsXG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LkNPTlNUUkFJTlRfVFlQRSA9PT0gXCJQXCJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTaG93SW5kZXhlc1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhLnJvd3MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGNvbnN0IHJvd3MgPSBkYXRhLnJvd3M7XG4gICAgICBjb25zdCByZXN1bHQyID0gdGhpcy5fcHJvY2Vzc1Jvd3Mocm93cyk7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHQyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YS5yb3dzWzBdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IFtyZXN1bHQsIGRhdGEucm93c0FmZmVjdGVkXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSkge1xuICAgICAgcmVzdWx0ID0gZGF0YS5yb3dzQWZmZWN0ZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQnVsa0RlbGV0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGEucm93c0FmZmVjdGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gZGF0YS5yb3dzWzBdLlZFUlNJT05fRlVMTDtcbiAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25zID0gdmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgICAgIHJlc3VsdCA9IGAke3ZlcnNpb25zWzBdfS4ke3ZlcnNpb25zWzFdfS4ke3ZlcnNpb25zWzJdfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBcIjAuMC4wXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSBkYXRhLnJvd3M7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgZGF0YSA9IGRhdGEub3V0QmluZHM7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm91dEJpbmRBdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrIGluIGtleXMpIHtcbiAgICAgICAgb2JqW2tleXNba11dID0gZGF0YVtrXTtcbiAgICAgIH1cbiAgICAgIG9iai5pc1VwZGF0ZSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgIGRhdGEgPSBvYmo7XG4gICAgICByZXN1bHQgPSBbeyBpc05ld1JlY29yZDogZGF0YS5pc1VwZGF0ZSwgdmFsdWU6IGRhdGEgfSwgZGF0YS5pc1VwZGF0ZSA9PSAwXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTaG93Q29uc3RyYWludHNRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIGlmIChkYXRhICYmIGRhdGEucm93cykge1xuICAgICAgICByZXR1cm4gW2RhdGEucm93cywgZGF0YS5tZXRhRGF0YV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW2RhdGEsIGRhdGFdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhbmRsZVNob3dDb25zdHJhaW50c1F1ZXJ5KGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5yb3dzLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0ge307XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgY29uc3RyYWludFtfLmNhbWVsQ2FzZShrZXkpXSA9IHJlc3VsdFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVTaG93VGFibGVzUXVlcnkocmVzdWx0cykge1xuICAgIHJldHVybiByZXN1bHRzLm1hcCgocmVzdWx0U2V0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWJsZU5hbWU6IHJlc3VsdFNldC5UQUJMRV9OQU1FLFxuICAgICAgICBzY2hlbWE6IHJlc3VsdFNldC5UQUJMRV9TQ0hFTUFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL3VuaXF1ZSBjb25zdHJhaW50IChbXFxzXFxTXSopIHZpb2xhdGVkLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZShcIihcIiwgXCJcIikucmVwbGFjZShcIilcIiwgXCJcIikuc3BsaXQoXCIuXCIpWzFdO1xuICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICBsZXQgZmllbGRzID0gW10sIG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIiwgdW5pcXVlS2V5ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm1vZGVsLnVuaXF1ZUtleXMpO1xuICAgICAgICBjb25zdCBjdXJyS2V5ID0gdW5pcXVlS2V5cy5maW5kKChrZXkpID0+IHtcbiAgICAgICAgICByZXR1cm4ga2V5LnRvVXBwZXJDYXNlKCkgPT09IG1hdGNoWzFdLnRvVXBwZXJDYXNlKCkgfHwga2V5LnRvVXBwZXJDYXNlKCkgPT09IGBcIiR7bWF0Y2hbMV0udG9VcHBlckNhc2UoKX1cImA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3VycktleSkge1xuICAgICAgICAgIHVuaXF1ZUtleSA9IHRoaXMubW9kZWwudW5pcXVlS2V5c1tjdXJyS2V5XTtcbiAgICAgICAgICBmaWVsZHMgPSB1bmlxdWVLZXkuZmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmlxdWVLZXkgJiYgISF1bmlxdWVLZXkubXNnKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IHVuaXF1ZUtleS5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGVycm9ycyxcbiAgICAgICAgZXJyLFxuICAgICAgICBmaWVsZHNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9PUkEtMDIyOTEvKSB8fCBlcnIubWVzc2FnZS5tYXRjaCgvT1JBLTAyMjkyLyk7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBuZXcgU2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBmaWVsZHM6IG51bGwsXG4gICAgICAgIGluZGV4OiBtYXRjaFsxXSxcbiAgICAgICAgcGFyZW50OiBlcnJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9PUkEtMDI0NDMvKTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXF1ZWxpemVFcnJvcnMuVW5rbm93bkNvbnN0cmFpbnRFcnJvcihtYXRjaFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgU2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgfVxuICBpc1Nob3dJbmRleGVzUXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3FsLmluZGV4T2YoXCJTRUxFQ1QgaS5pbmRleF9uYW1lLGkudGFibGVfbmFtZSwgaS5jb2x1bW5fbmFtZSwgdS51bmlxdWVuZXNzXCIpID4gLTE7XG4gIH1cbiAgaXNTZWxlY3RDb3VudFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnNxbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoXCJTRUxFQ1QgQ09VTlQoXCIpID4gLTE7XG4gIH1cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgY29uc3QgYWNjID0gW107XG4gICAgZGF0YS5mb3JFYWNoKChpbmRleFJlY29yZCkgPT4ge1xuICAgICAgaWYgKCFhY2NbaW5kZXhSZWNvcmQuSU5ERVhfTkFNRV0pIHtcbiAgICAgICAgYWNjW2luZGV4UmVjb3JkLklOREVYX05BTUVdID0ge1xuICAgICAgICAgIHVuaXF1ZTogaW5kZXhSZWNvcmQuVU5JUVVFTkVTUyA9PT0gXCJVTklRVUVcIiA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICBwcmltYXJ5OiBpbmRleFJlY29yZC5DT05TVFJBSU5UX1RZUEUgPT09IFwiUFwiLFxuICAgICAgICAgIG5hbWU6IGluZGV4UmVjb3JkLklOREVYX05BTUUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICB0YWJsZU5hbWU6IGluZGV4UmVjb3JkLlRBQkxFX05BTUUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICB0eXBlOiB2b2lkIDBcbiAgICAgICAgfTtcbiAgICAgICAgYWNjW2luZGV4UmVjb3JkLklOREVYX05BTUVdLmZpZWxkcyA9IFtdO1xuICAgICAgfVxuICAgICAgYWNjW2luZGV4UmVjb3JkLklOREVYX05BTUVdLmZpZWxkcy5wdXNoKHtcbiAgICAgICAgYXR0cmlidXRlOiBpbmRleFJlY29yZC5DT0xVTU5fTkFNRSxcbiAgICAgICAgbGVuZ3RoOiB2b2lkIDAsXG4gICAgICAgIG9yZGVyOiBpbmRleFJlY29yZC5ERVNDRU5ELFxuICAgICAgICBjb2xsYXRlOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHJldHVybkluZGV4ZXMgPSBbXTtcbiAgICBjb25zdCBhY2NLZXlzID0gT2JqZWN0LmtleXMoYWNjKTtcbiAgICBmb3IgKGNvbnN0IGFjY0tleSBvZiBhY2NLZXlzKSB7XG4gICAgICBjb25zdCBjb2x1bW5zID0ge307XG4gICAgICBjb2x1bW5zLmZpZWxkcyA9IGFjY1thY2NLZXldLmZpZWxkcztcbiAgICAgIGlmIChhY2NbYWNjS2V5XS5uYW1lLm1hdGNoKC9zeXNfY1swLTldKi8pKSB7XG4gICAgICAgIGFjY1thY2NLZXldLm5hbWUgPSBVdGlscy5uYW1lSW5kZXgoY29sdW1ucywgYWNjW2FjY0tleV0udGFibGVOYW1lKS5uYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuSW5kZXhlcy5wdXNoKGFjY1thY2NLZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkluZGV4ZXM7XG4gIH1cbiAgaGFuZGxlSW5zZXJ0UXVlcnkocmVzdWx0cywgbWV0YURhdGEpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiByZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChcInBrUmV0dXJuVmFsXCIgaW4gcmVzdWx0c1swXSkge1xuICAgICAgICByZXN1bHRzWzBdW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0gPSByZXN1bHRzWzBdLnBrUmV0dXJuVmFsO1xuICAgICAgICBkZWxldGUgcmVzdWx0c1swXS5wa1JldHVyblZhbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF1dG9JbmNyZW1lbnRGaWVsZCA9IHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdXRvSW5jcmVtZW50RmllbGRBbGlhcyA9IG51bGwsIGlkID0gbnVsbDtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCBhdXRvSW5jcmVtZW50RmllbGQpICYmIHRoaXMubW9kZWwucmF3QXR0cmlidXRlc1thdXRvSW5jcmVtZW50RmllbGRdLmZpZWxkICE9PSB2b2lkIDApXG4gICAgICAgIGF1dG9JbmNyZW1lbnRGaWVsZEFsaWFzID0gdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F1dG9JbmNyZW1lbnRGaWVsZF0uZmllbGQ7XG4gICAgICBpZCA9IGlkIHx8IHJlc3VsdHMgJiYgcmVzdWx0c1swXVt0aGlzLmdldEluc2VydElkRmllbGQoKV07XG4gICAgICBpZCA9IGlkIHx8IG1ldGFEYXRhICYmIG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgIGlkID0gaWQgfHwgcmVzdWx0cyAmJiByZXN1bHRzWzBdW2F1dG9JbmNyZW1lbnRGaWVsZF07XG4gICAgICBpZCA9IGlkIHx8IGF1dG9JbmNyZW1lbnRGaWVsZEFsaWFzICYmIHJlc3VsdHMgJiYgcmVzdWx0c1swXVthdXRvSW5jcmVtZW50RmllbGRBbGlhc107XG4gICAgICB0aGlzLmluc3RhbmNlW2F1dG9JbmNyZW1lbnRGaWVsZF0gPSBpZDtcbiAgICB9XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/oracle/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js":
/*!************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/parserStore.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst stores = /* @__PURE__ */ new Map();\nmodule.exports = (dialect) => {\n  if (!stores.has(dialect)) {\n    stores.set(dialect, /* @__PURE__ */ new Map());\n  }\n  return {\n    clear() {\n      stores.get(dialect).clear();\n    },\n    refresh(dataType) {\n      for (const type of dataType.types[dialect]) {\n        stores.get(dialect).set(type, dataType.parse);\n      }\n    },\n    get(type) {\n      return stores.get(dialect).get(type);\n    }\n  };\n};\n//# sourceMappingURL=parserStore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wYXJzZXJTdG9yZS5qcz80NmIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3Qgc3RvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbm1vZHVsZS5leHBvcnRzID0gKGRpYWxlY3QpID0+IHtcbiAgaWYgKCFzdG9yZXMuaGFzKGRpYWxlY3QpKSB7XG4gICAgc3RvcmVzLnNldChkaWFsZWN0LCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNsZWFyKCkge1xuICAgICAgc3RvcmVzLmdldChkaWFsZWN0KS5jbGVhcigpO1xuICAgIH0sXG4gICAgcmVmcmVzaChkYXRhVHlwZSkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGRhdGFUeXBlLnR5cGVzW2RpYWxlY3RdKSB7XG4gICAgICAgIHN0b3Jlcy5nZXQoZGlhbGVjdCkuc2V0KHR5cGUsIGRhdGFUeXBlLnBhcnNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCh0eXBlKSB7XG4gICAgICByZXR1cm4gc3RvcmVzLmdldChkaWFsZWN0KS5nZXQodHlwZSk7XG4gICAgfVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlclN0b3JlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/connection-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/connection-manager.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"connection:pg\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst dataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 5432;\n    super(dialect, sequelize);\n    const pgLib = this._loadDialectModule(\"pg\");\n    this.lib = this.sequelize.config.native ? pgLib.native : pgLib;\n    this._clearDynamicOIDs();\n    this._clearTypeParser();\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _refreshTypeParser(dataType) {\n    const arrayParserBuilder = (parser2) => {\n      return (value) => this.lib.types.arrayParser.create(value, parser2).parse();\n    };\n    const rangeParserBuilder = (parser2) => {\n      return (value) => dataType.parse(value, { parser: parser2 });\n    };\n    if (dataType.key.toLowerCase() === \"range\") {\n      for (const name in this.nameOidMap) {\n        const entry = this.nameOidMap[name];\n        if (!entry.rangeOid)\n          continue;\n        const rangeParser = rangeParserBuilder(this.getTypeParser(entry.oid));\n        const arrayRangeParser = arrayParserBuilder(rangeParser);\n        this.oidParserMap.set(entry.rangeOid, rangeParser);\n        if (!entry.arrayRangeOid)\n          continue;\n        this.oidParserMap.set(entry.arrayRangeOid, arrayRangeParser);\n      }\n      return;\n    }\n    const parser = (value) => dataType.parse(value);\n    const arrayParser = arrayParserBuilder(parser);\n    if (dataType.key.toLowerCase() === \"enum\") {\n      this.enumOids.oids.forEach((oid) => {\n        this.oidParserMap.set(oid, parser);\n      });\n      this.enumOids.arrayOids.forEach((arrayOid) => {\n        this.oidParserMap.set(arrayOid, arrayParser);\n      });\n      return;\n    }\n    dataType.types.postgres.forEach((name) => {\n      if (!this.nameOidMap[name])\n        return;\n      this.oidParserMap.set(this.nameOidMap[name].oid, parser);\n      if (!this.nameOidMap[name].arrayOid)\n        return;\n      this.oidParserMap.set(this.nameOidMap[name].arrayOid, arrayParser);\n    });\n  }\n  _clearTypeParser() {\n    this.oidParserMap = /* @__PURE__ */ new Map();\n  }\n  getTypeParser(oid, ...args) {\n    if (this.oidParserMap.get(oid))\n      return this.oidParserMap.get(oid);\n    return this.lib.types.getTypeParser(oid, ...args);\n  }\n  async connect(config) {\n    config.user = config.username;\n    const connectionConfig = _.pick(config, [\n      \"user\",\n      \"password\",\n      \"host\",\n      \"database\",\n      \"port\"\n    ]);\n    connectionConfig.types = {\n      getTypeParser: ConnectionManager.prototype.getTypeParser.bind(this)\n    };\n    if (config.dialectOptions) {\n      _.merge(connectionConfig, _.pick(config.dialectOptions, [\n        \"application_name\",\n        \"ssl\",\n        \"client_encoding\",\n        \"binary\",\n        \"keepAlive\",\n        \"statement_timeout\",\n        \"query_timeout\",\n        \"connectionTimeoutMillis\",\n        \"idle_in_transaction_session_timeout\",\n        \"lock_timeout\",\n        \"options\",\n        \"stream\"\n      ]));\n    }\n    const connection = await new Promise((resolve, reject) => {\n      let responded = false;\n      const connection2 = new this.lib.Client(connectionConfig);\n      const parameterHandler = (message) => {\n        switch (message.parameterName) {\n          case \"server_version\":\n            if (this.sequelize.options.databaseVersion === 0) {\n              const version = semver.coerce(message.parameterValue).version;\n              this.sequelize.options.databaseVersion = semver.valid(version) ? version : this.dialect.defaultVersion;\n            }\n            break;\n          case \"standard_conforming_strings\":\n            connection2[\"standard_conforming_strings\"] = message.parameterValue;\n            break;\n        }\n      };\n      const endHandler = () => {\n        debug(\"connection timeout\");\n        if (!responded) {\n          reject(new sequelizeErrors.ConnectionTimedOutError(new Error(\"Connection timed out\")));\n        }\n      };\n      connection2.once(\"end\", endHandler);\n      if (!this.sequelize.config.native) {\n        connection2.connection.on(\"parameterStatus\", parameterHandler);\n      }\n      connection2.connect((err) => {\n        responded = true;\n        if (!this.sequelize.config.native) {\n          connection2.connection.removeListener(\"parameterStatus\", parameterHandler);\n        }\n        if (err) {\n          if (err.code) {\n            switch (err.code) {\n              case \"ECONNREFUSED\":\n                reject(new sequelizeErrors.ConnectionRefusedError(err));\n                break;\n              case \"ENOTFOUND\":\n                reject(new sequelizeErrors.HostNotFoundError(err));\n                break;\n              case \"EHOSTUNREACH\":\n                reject(new sequelizeErrors.HostNotReachableError(err));\n                break;\n              case \"EINVAL\":\n                reject(new sequelizeErrors.InvalidConnectionError(err));\n                break;\n              default:\n                reject(new sequelizeErrors.ConnectionError(err));\n                break;\n            }\n          } else {\n            reject(new sequelizeErrors.ConnectionError(err));\n          }\n        } else {\n          debug(\"connection acquired\");\n          connection2.removeListener(\"end\", endHandler);\n          resolve(connection2);\n        }\n      });\n    });\n    connection.on(\"error\", (error) => {\n      connection._invalid = true;\n      debug(`connection error ${error.code || error.message}`);\n      this.pool.destroy(connection);\n    });\n    let query = \"\";\n    if (this.sequelize.options.standardConformingStrings !== false && connection[\"standard_conforming_strings\"] !== \"on\") {\n      query += \"SET standard_conforming_strings=on;\";\n    }\n    if (this.sequelize.options.clientMinMessages !== void 0) {\n      console.warn('Usage of \"options.clientMinMessages\" is deprecated and will be removed in v7.');\n      console.warn('Please use the sequelize option \"dialectOptions.clientMinMessages\" instead.');\n    }\n    if (!(config.dialectOptions && config.dialectOptions.clientMinMessages && config.dialectOptions.clientMinMessages.toLowerCase() === \"ignore\" || this.sequelize.options.clientMinMessages === false)) {\n      const clientMinMessages = config.dialectOptions && config.dialectOptions.clientMinMessages || this.sequelize.options.clientMinMessages || \"warning\";\n      query += `SET client_min_messages TO ${clientMinMessages};`;\n    }\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      const isZone = !!momentTz.tz.zone(this.sequelize.options.timezone);\n      if (isZone) {\n        query += `SET TIME ZONE '${this.sequelize.options.timezone}';`;\n      } else {\n        query += `SET TIME ZONE INTERVAL '${this.sequelize.options.timezone}' HOUR TO MINUTE;`;\n      }\n    }\n    if (query) {\n      await connection.query(query);\n    }\n    if (Object.keys(this.nameOidMap).length === 0 && this.enumOids.oids.length === 0 && this.enumOids.arrayOids.length === 0) {\n      await this._refreshDynamicOIDs(connection);\n    }\n    return connection;\n  }\n  async disconnect(connection) {\n    if (connection._ending) {\n      debug(\"connection tried to disconnect but was already at ENDING state\");\n      return;\n    }\n    return await promisify((callback) => connection.end(callback))();\n  }\n  validate(connection) {\n    return !connection._invalid && !connection._ending;\n  }\n  async _refreshDynamicOIDs(connection) {\n    const databaseVersion = this.sequelize.options.databaseVersion;\n    const supportedVersion = \"8.3.0\";\n    if ((databaseVersion && semver.gte(databaseVersion, supportedVersion)) === false) {\n      return;\n    }\n    const results = await (connection || this.sequelize).query(\"WITH ranges AS (  SELECT pg_range.rngtypid, pg_type.typname AS rngtypname,         pg_type.typarray AS rngtyparray, pg_range.rngsubtype    FROM pg_range LEFT OUTER JOIN pg_type ON pg_type.oid = pg_range.rngtypid)SELECT pg_type.typname, pg_type.typtype, pg_type.oid, pg_type.typarray,       ranges.rngtypname, ranges.rngtypid, ranges.rngtyparray  FROM pg_type LEFT OUTER JOIN ranges ON pg_type.oid = ranges.rngsubtype WHERE (pg_type.typtype IN('b', 'e'));\");\n    let result = Array.isArray(results) ? results.pop() : results;\n    if (Array.isArray(result)) {\n      if (result[0].command === \"SET\") {\n        result = result.pop();\n      }\n    }\n    const newNameOidMap = {};\n    const newEnumOids = { oids: [], arrayOids: [] };\n    for (const row of result.rows) {\n      if (row.typtype === \"e\") {\n        newEnumOids.oids.push(row.oid);\n        if (row.typarray)\n          newEnumOids.arrayOids.push(row.typarray);\n        continue;\n      }\n      newNameOidMap[row.typname] = { oid: row.oid };\n      if (row.typarray)\n        newNameOidMap[row.typname].arrayOid = row.typarray;\n      if (row.rngtypid) {\n        newNameOidMap[row.typname].rangeOid = row.rngtypid;\n        if (row.rngtyparray)\n          newNameOidMap[row.typname].arrayRangeOid = row.rngtyparray;\n      }\n    }\n    this.nameOidMap = newNameOidMap;\n    this.enumOids = newEnumOids;\n    this.refreshTypeParser(dataTypes.postgres);\n  }\n  _clearDynamicOIDs() {\n    this.nameOidMap = {};\n    this.enumOids = { oids: [], arrayOids: [] };\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9jb25uZWN0aW9uLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsa0NBQWtDLG1CQUFPLENBQUMsa0hBQWdDO0FBQzFFLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFrQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDMUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsaUJBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdDQUFnQyxFQUFFO0FBQ3JFLFFBQVE7QUFDUiw0Q0FBNEMsZ0NBQWdDLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2dCQUFzZ0I7QUFDdGdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvY29ubmVjdGlvbi1tYW5hZ2VyLmpzPzgyNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOnBnXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5jb25zdCBkYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IG1vbWVudFR6ID0gcmVxdWlyZShcIm1vbWVudC10aW1lem9uZVwiKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCA1NDMyO1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgY29uc3QgcGdMaWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcInBnXCIpO1xuICAgIHRoaXMubGliID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLm5hdGl2ZSA/IHBnTGliLm5hdGl2ZSA6IHBnTGliO1xuICAgIHRoaXMuX2NsZWFyRHluYW1pY09JRHMoKTtcbiAgICB0aGlzLl9jbGVhclR5cGVQYXJzZXIoKTtcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcy5wb3N0Z3Jlcyk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgY29uc3QgYXJyYXlQYXJzZXJCdWlsZGVyID0gKHBhcnNlcjIpID0+IHtcbiAgICAgIHJldHVybiAodmFsdWUpID0+IHRoaXMubGliLnR5cGVzLmFycmF5UGFyc2VyLmNyZWF0ZSh2YWx1ZSwgcGFyc2VyMikucGFyc2UoKTtcbiAgICB9O1xuICAgIGNvbnN0IHJhbmdlUGFyc2VyQnVpbGRlciA9IChwYXJzZXIyKSA9PiB7XG4gICAgICByZXR1cm4gKHZhbHVlKSA9PiBkYXRhVHlwZS5wYXJzZSh2YWx1ZSwgeyBwYXJzZXI6IHBhcnNlcjIgfSk7XG4gICAgfTtcbiAgICBpZiAoZGF0YVR5cGUua2V5LnRvTG93ZXJDYXNlKCkgPT09IFwicmFuZ2VcIikge1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMubmFtZU9pZE1hcCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMubmFtZU9pZE1hcFtuYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeS5yYW5nZU9pZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcmFuZ2VQYXJzZXIgPSByYW5nZVBhcnNlckJ1aWxkZXIodGhpcy5nZXRUeXBlUGFyc2VyKGVudHJ5Lm9pZCkpO1xuICAgICAgICBjb25zdCBhcnJheVJhbmdlUGFyc2VyID0gYXJyYXlQYXJzZXJCdWlsZGVyKHJhbmdlUGFyc2VyKTtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KGVudHJ5LnJhbmdlT2lkLCByYW5nZVBhcnNlcik7XG4gICAgICAgIGlmICghZW50cnkuYXJyYXlSYW5nZU9pZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KGVudHJ5LmFycmF5UmFuZ2VPaWQsIGFycmF5UmFuZ2VQYXJzZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZXIgPSAodmFsdWUpID0+IGRhdGFUeXBlLnBhcnNlKHZhbHVlKTtcbiAgICBjb25zdCBhcnJheVBhcnNlciA9IGFycmF5UGFyc2VyQnVpbGRlcihwYXJzZXIpO1xuICAgIGlmIChkYXRhVHlwZS5rZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgIHRoaXMuZW51bU9pZHMub2lkcy5mb3JFYWNoKChvaWQpID0+IHtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KG9pZCwgcGFyc2VyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbnVtT2lkcy5hcnJheU9pZHMuZm9yRWFjaCgoYXJyYXlPaWQpID0+IHtcbiAgICAgICAgdGhpcy5vaWRQYXJzZXJNYXAuc2V0KGFycmF5T2lkLCBhcnJheVBhcnNlcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YVR5cGUudHlwZXMucG9zdGdyZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm5hbWVPaWRNYXBbbmFtZV0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldCh0aGlzLm5hbWVPaWRNYXBbbmFtZV0ub2lkLCBwYXJzZXIpO1xuICAgICAgaWYgKCF0aGlzLm5hbWVPaWRNYXBbbmFtZV0uYXJyYXlPaWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMub2lkUGFyc2VyTWFwLnNldCh0aGlzLm5hbWVPaWRNYXBbbmFtZV0uYXJyYXlPaWQsIGFycmF5UGFyc2VyKTtcbiAgICB9KTtcbiAgfVxuICBfY2xlYXJUeXBlUGFyc2VyKCkge1xuICAgIHRoaXMub2lkUGFyc2VyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBnZXRUeXBlUGFyc2VyKG9pZCwgLi4uYXJncykge1xuICAgIGlmICh0aGlzLm9pZFBhcnNlck1hcC5nZXQob2lkKSlcbiAgICAgIHJldHVybiB0aGlzLm9pZFBhcnNlck1hcC5nZXQob2lkKTtcbiAgICByZXR1cm4gdGhpcy5saWIudHlwZXMuZ2V0VHlwZVBhcnNlcihvaWQsIC4uLmFyZ3MpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoY29uZmlnKSB7XG4gICAgY29uZmlnLnVzZXIgPSBjb25maWcudXNlcm5hbWU7XG4gICAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IF8ucGljayhjb25maWcsIFtcbiAgICAgIFwidXNlclwiLFxuICAgICAgXCJwYXNzd29yZFwiLFxuICAgICAgXCJob3N0XCIsXG4gICAgICBcImRhdGFiYXNlXCIsXG4gICAgICBcInBvcnRcIlxuICAgIF0pO1xuICAgIGNvbm5lY3Rpb25Db25maWcudHlwZXMgPSB7XG4gICAgICBnZXRUeXBlUGFyc2VyOiBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHlwZVBhcnNlci5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICBpZiAoY29uZmlnLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICBfLm1lcmdlKGNvbm5lY3Rpb25Db25maWcsIF8ucGljayhjb25maWcuZGlhbGVjdE9wdGlvbnMsIFtcbiAgICAgICAgXCJhcHBsaWNhdGlvbl9uYW1lXCIsXG4gICAgICAgIFwic3NsXCIsXG4gICAgICAgIFwiY2xpZW50X2VuY29kaW5nXCIsXG4gICAgICAgIFwiYmluYXJ5XCIsXG4gICAgICAgIFwia2VlcEFsaXZlXCIsXG4gICAgICAgIFwic3RhdGVtZW50X3RpbWVvdXRcIixcbiAgICAgICAgXCJxdWVyeV90aW1lb3V0XCIsXG4gICAgICAgIFwiY29ubmVjdGlvblRpbWVvdXRNaWxsaXNcIixcbiAgICAgICAgXCJpZGxlX2luX3RyYW5zYWN0aW9uX3Nlc3Npb25fdGltZW91dFwiLFxuICAgICAgICBcImxvY2tfdGltZW91dFwiLFxuICAgICAgICBcIm9wdGlvbnNcIixcbiAgICAgICAgXCJzdHJlYW1cIlxuICAgICAgXSkpO1xuICAgIH1cbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHJlc3BvbmRlZCA9IGZhbHNlO1xuICAgICAgY29uc3QgY29ubmVjdGlvbjIgPSBuZXcgdGhpcy5saWIuQ2xpZW50KGNvbm5lY3Rpb25Db25maWcpO1xuICAgICAgY29uc3QgcGFyYW1ldGVySGFuZGxlciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5wYXJhbWV0ZXJOYW1lKSB7XG4gICAgICAgICAgY2FzZSBcInNlcnZlcl92ZXJzaW9uXCI6XG4gICAgICAgICAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IHNlbXZlci5jb2VyY2UobWVzc2FnZS5wYXJhbWV0ZXJWYWx1ZSkudmVyc2lvbjtcbiAgICAgICAgICAgICAgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24gPSBzZW12ZXIudmFsaWQodmVyc2lvbikgPyB2ZXJzaW9uIDogdGhpcy5kaWFsZWN0LmRlZmF1bHRWZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5nc1wiOlxuICAgICAgICAgICAgY29ubmVjdGlvbjJbXCJzdGFuZGFyZF9jb25mb3JtaW5nX3N0cmluZ3NcIl0gPSBtZXNzYWdlLnBhcmFtZXRlclZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBlbmRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gdGltZW91dFwiKTtcbiAgICAgICAgaWYgKCFyZXNwb25kZWQpIHtcbiAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uVGltZWRPdXRFcnJvcihuZXcgRXJyb3IoXCJDb25uZWN0aW9uIHRpbWVkIG91dFwiKSkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29ubmVjdGlvbjIub25jZShcImVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLm5hdGl2ZSkge1xuICAgICAgICBjb25uZWN0aW9uMi5jb25uZWN0aW9uLm9uKFwicGFyYW1ldGVyU3RhdHVzXCIsIHBhcmFtZXRlckhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgY29ubmVjdGlvbjIuY29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLm5hdGl2ZSkge1xuICAgICAgICAgIGNvbm5lY3Rpb24yLmNvbm5lY3Rpb24ucmVtb3ZlTGlzdGVuZXIoXCJwYXJhbWV0ZXJTdGF0dXNcIiwgcGFyYW1ldGVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGlmIChlcnIuY29kZSkge1xuICAgICAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiRUNPTk5SRUZVU0VEXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIkVOT1RGT1VORFwiOlxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkhvc3ROb3RGb3VuZEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiRUhPU1RVTlJFQUNIXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiRUlOVkFMXCI6XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBzZXF1ZWxpemVFcnJvcnMuSW52YWxpZENvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IHNlcXVlbGl6ZUVycm9ycy5Db25uZWN0aW9uRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoXCJjb25uZWN0aW9uIGFjcXVpcmVkXCIpO1xuICAgICAgICAgIGNvbm5lY3Rpb24yLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIGVuZEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoY29ubmVjdGlvbjIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25uZWN0aW9uLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICBjb25uZWN0aW9uLl9pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIGRlYnVnKGBjb25uZWN0aW9uIGVycm9yICR7ZXJyb3IuY29kZSB8fCBlcnJvci5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5wb29sLmRlc3Ryb3koY29ubmVjdGlvbik7XG4gICAgfSk7XG4gICAgbGV0IHF1ZXJ5ID0gXCJcIjtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdGFuZGFyZENvbmZvcm1pbmdTdHJpbmdzICE9PSBmYWxzZSAmJiBjb25uZWN0aW9uW1wic3RhbmRhcmRfY29uZm9ybWluZ19zdHJpbmdzXCJdICE9PSBcIm9uXCIpIHtcbiAgICAgIHF1ZXJ5ICs9IFwiU0VUIHN0YW5kYXJkX2NvbmZvcm1pbmdfc3RyaW5ncz1vbjtcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc29sZS53YXJuKCdVc2FnZSBvZiBcIm9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXNcIiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjcuJyk7XG4gICAgICBjb25zb2xlLndhcm4oJ1BsZWFzZSB1c2UgdGhlIHNlcXVlbGl6ZSBvcHRpb24gXCJkaWFsZWN0T3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlc1wiIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGlmICghKGNvbmZpZy5kaWFsZWN0T3B0aW9ucyAmJiBjb25maWcuZGlhbGVjdE9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMgJiYgY29uZmlnLmRpYWxlY3RPcHRpb25zLmNsaWVudE1pbk1lc3NhZ2VzLnRvTG93ZXJDYXNlKCkgPT09IFwiaWdub3JlXCIgfHwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcyA9PT0gZmFsc2UpKSB7XG4gICAgICBjb25zdCBjbGllbnRNaW5NZXNzYWdlcyA9IGNvbmZpZy5kaWFsZWN0T3B0aW9ucyAmJiBjb25maWcuZGlhbGVjdE9wdGlvbnMuY2xpZW50TWluTWVzc2FnZXMgfHwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5jbGllbnRNaW5NZXNzYWdlcyB8fCBcIndhcm5pbmdcIjtcbiAgICAgIHF1ZXJ5ICs9IGBTRVQgY2xpZW50X21pbl9tZXNzYWdlcyBUTyAke2NsaWVudE1pbk1lc3NhZ2VzfTtgO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuc2VxdWVsaXplLmNvbmZpZy5rZWVwRGVmYXVsdFRpbWV6b25lKSB7XG4gICAgICBjb25zdCBpc1pvbmUgPSAhIW1vbWVudFR6LnR6LnpvbmUodGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZSk7XG4gICAgICBpZiAoaXNab25lKSB7XG4gICAgICAgIHF1ZXJ5ICs9IGBTRVQgVElNRSBaT05FICcke3RoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmV9JztgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkgKz0gYFNFVCBUSU1FIFpPTkUgSU5URVJWQUwgJyR7dGhpcy5zZXF1ZWxpemUub3B0aW9ucy50aW1lem9uZX0nIEhPVVIgVE8gTUlOVVRFO2A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSkge1xuICAgICAgYXdhaXQgY29ubmVjdGlvbi5xdWVyeShxdWVyeSk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLm5hbWVPaWRNYXApLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmVudW1PaWRzLm9pZHMubGVuZ3RoID09PSAwICYmIHRoaXMuZW51bU9pZHMuYXJyYXlPaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXdhaXQgdGhpcy5fcmVmcmVzaER5bmFtaWNPSURzKGNvbm5lY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoY29ubmVjdGlvbi5fZW5kaW5nKSB7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgRU5ESU5HIHN0YXRlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KChjYWxsYmFjaykgPT4gY29ubmVjdGlvbi5lbmQoY2FsbGJhY2spKSgpO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gIWNvbm5lY3Rpb24uX2ludmFsaWQgJiYgIWNvbm5lY3Rpb24uX2VuZGluZztcbiAgfVxuICBhc3luYyBfcmVmcmVzaER5bmFtaWNPSURzKGNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBkYXRhYmFzZVZlcnNpb24gPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvbjtcbiAgICBjb25zdCBzdXBwb3J0ZWRWZXJzaW9uID0gXCI4LjMuMFwiO1xuICAgIGlmICgoZGF0YWJhc2VWZXJzaW9uICYmIHNlbXZlci5ndGUoZGF0YWJhc2VWZXJzaW9uLCBzdXBwb3J0ZWRWZXJzaW9uKSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCAoY29ubmVjdGlvbiB8fCB0aGlzLnNlcXVlbGl6ZSkucXVlcnkoXCJXSVRIIHJhbmdlcyBBUyAoICBTRUxFQ1QgcGdfcmFuZ2Uucm5ndHlwaWQsIHBnX3R5cGUudHlwbmFtZSBBUyBybmd0eXBuYW1lLCAgICAgICAgIHBnX3R5cGUudHlwYXJyYXkgQVMgcm5ndHlwYXJyYXksIHBnX3JhbmdlLnJuZ3N1YnR5cGUgICAgRlJPTSBwZ19yYW5nZSBMRUZUIE9VVEVSIEpPSU4gcGdfdHlwZSBPTiBwZ190eXBlLm9pZCA9IHBnX3JhbmdlLnJuZ3R5cGlkKVNFTEVDVCBwZ190eXBlLnR5cG5hbWUsIHBnX3R5cGUudHlwdHlwZSwgcGdfdHlwZS5vaWQsIHBnX3R5cGUudHlwYXJyYXksICAgICAgIHJhbmdlcy5ybmd0eXBuYW1lLCByYW5nZXMucm5ndHlwaWQsIHJhbmdlcy5ybmd0eXBhcnJheSAgRlJPTSBwZ190eXBlIExFRlQgT1VURVIgSk9JTiByYW5nZXMgT04gcGdfdHlwZS5vaWQgPSByYW5nZXMucm5nc3VidHlwZSBXSEVSRSAocGdfdHlwZS50eXB0eXBlIElOKCdiJywgJ2UnKSk7XCIpO1xuICAgIGxldCByZXN1bHQgPSBBcnJheS5pc0FycmF5KHJlc3VsdHMpID8gcmVzdWx0cy5wb3AoKSA6IHJlc3VsdHM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgaWYgKHJlc3VsdFswXS5jb21tYW5kID09PSBcIlNFVFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmV3TmFtZU9pZE1hcCA9IHt9O1xuICAgIGNvbnN0IG5ld0VudW1PaWRzID0geyBvaWRzOiBbXSwgYXJyYXlPaWRzOiBbXSB9O1xuICAgIGZvciAoY29uc3Qgcm93IG9mIHJlc3VsdC5yb3dzKSB7XG4gICAgICBpZiAocm93LnR5cHR5cGUgPT09IFwiZVwiKSB7XG4gICAgICAgIG5ld0VudW1PaWRzLm9pZHMucHVzaChyb3cub2lkKTtcbiAgICAgICAgaWYgKHJvdy50eXBhcnJheSlcbiAgICAgICAgICBuZXdFbnVtT2lkcy5hcnJheU9pZHMucHVzaChyb3cudHlwYXJyYXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdID0geyBvaWQ6IHJvdy5vaWQgfTtcbiAgICAgIGlmIChyb3cudHlwYXJyYXkpXG4gICAgICAgIG5ld05hbWVPaWRNYXBbcm93LnR5cG5hbWVdLmFycmF5T2lkID0gcm93LnR5cGFycmF5O1xuICAgICAgaWYgKHJvdy5ybmd0eXBpZCkge1xuICAgICAgICBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXS5yYW5nZU9pZCA9IHJvdy5ybmd0eXBpZDtcbiAgICAgICAgaWYgKHJvdy5ybmd0eXBhcnJheSlcbiAgICAgICAgICBuZXdOYW1lT2lkTWFwW3Jvdy50eXBuYW1lXS5hcnJheVJhbmdlT2lkID0gcm93LnJuZ3R5cGFycmF5O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5hbWVPaWRNYXAgPSBuZXdOYW1lT2lkTWFwO1xuICAgIHRoaXMuZW51bU9pZHMgPSBuZXdFbnVtT2lkcztcbiAgICB0aGlzLnJlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlcy5wb3N0Z3Jlcyk7XG4gIH1cbiAgX2NsZWFyRHluYW1pY09JRHMoKSB7XG4gICAgdGhpcy5uYW1lT2lkTWFwID0ge307XG4gICAgdGhpcy5lbnVtT2lkcyA9IHsgb2lkczogW10sIGFycmF5T2lkczogW10gfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25NYW5hZ2VyID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLW1hbmFnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/data-types.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/data-types.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst wkx = __webpack_require__(/*! wkx */ \"(rsc)/./node_modules/wkx/lib/wkx.js\");\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"http://www.postgresql.org/docs/9.4/static/datatype.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = void 0;\n      dataType.options.length = void 0;\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.UUID.types.postgres = [\"uuid\"];\n  BaseTypes.CIDR.types.postgres = [\"cidr\"];\n  BaseTypes.INET.types.postgres = [\"inet\"];\n  BaseTypes.MACADDR.types.postgres = [\"macaddr\"];\n  BaseTypes.TSVECTOR.types.postgres = [\"tsvector\"];\n  BaseTypes.JSON.types.postgres = [\"json\"];\n  BaseTypes.JSONB.types.postgres = [\"jsonb\"];\n  BaseTypes.TIME.types.postgres = [\"time\"];\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === \"infinity\") {\n        return Infinity;\n      }\n      if (value === \"-infinity\") {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n  BaseTypes.DATEONLY.types.postgres = [\"date\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.DECIMAL.types.postgres = [\"numeric\"];\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n      return super.toSql();\n    }\n  }\n  BaseTypes.STRING.types.postgres = [\"varchar\"];\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"TEXT\";\n    }\n  }\n  BaseTypes.TEXT.types.postgres = [\"text\"];\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.CITEXT.types.postgres = [\"citext\"];\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return \"BYTEA\";\n      }\n      return super.toSql();\n    }\n  }\n  BaseTypes.CHAR.types.postgres = [\"char\", \"bpchar\"];\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n    _sanitize(value) {\n      if (value !== null && value !== void 0) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          value = value[0];\n        }\n        if (typeof value === \"string\") {\n          return [\"true\", \"t\"].includes(value) ? true : [\"false\", \"f\"].includes(value) ? false : value;\n        }\n        if (typeof value === \"number\") {\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = [\"bool\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH TIME ZONE\";\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return \"Infinity\";\n      }\n      if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === \"string\") {\n          const lower = value.toLowerCase();\n          if (lower === \"infinity\") {\n            return Infinity;\n          }\n          if (lower === \"-infinity\") {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n  BaseTypes.DATE.types.postgres = [\"timestamptz\"];\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.TINYINT.types.postgres = [\"int2\"];\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.SMALLINT.types.postgres = [\"int2\"];\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n  BaseTypes.INTEGER.types.postgres = [\"int4\"];\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.BIGINT.types.postgres = [\"int8\"];\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.REAL.types.postgres = [\"float4\"];\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  BaseTypes.DOUBLE.types.postgres = [\"float8\"];\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (this._decimals) {\n        warn(\"PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._decimals = void 0;\n      }\n      if (this._unsigned) {\n        warn(\"PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.\");\n        this._unsigned = void 0;\n      }\n      if (this._zerofill) {\n        warn(\"PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.\");\n        this._zerofill = void 0;\n      }\n    }\n  }\n  delete FLOAT.parse;\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn(\"PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"BYTEA\";\n    }\n    _hexify(hex) {\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n  BaseTypes.BLOB.types.postgres = [\"bytea\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n  BaseTypes.GEOMETRY.types.postgres = [\"geometry\"];\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = \"GEOGRAPHY\";\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, \"hex\");\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n  BaseTypes.GEOGRAPHY.types.postgres = [\"geography\"];\n  let hstore;\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        hstore = __webpack_require__(/*! ./hstore */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\");\n      }\n      return hstore.parse(value);\n    }\n  }\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = [\"hstore\"];\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, \"value\")) {\n          if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: (val) => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = __webpack_require__(/*! ./range */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/range.js\");\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: \"int4range\",\n      decimal: \"numrange\",\n      date: \"tstzrange\",\n      dateonly: \"daterange\",\n      bigint: \"int8range\"\n    },\n    castTypes: {\n      integer: \"int4\",\n      decimal: \"numeric\",\n      date: \"timestamptz\",\n      dateonly: \"date\",\n      bigint: \"int8\"\n    }\n  };\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map((value) => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(\",\")}]`;\n    if (this.type) {\n      const Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\n      let castKey = this.toSql();\n      if (this.type instanceof BaseTypes.ENUM) {\n        const table = options.field.Model.getTableName();\n        const useSchema = table.schema !== void 0;\n        const schemaWithDelimiter = useSchema ? `${Utils.addTicks(table.schema, '\"')}${table.delimiter}` : \"\";\n        castKey = `${Utils.addTicks(Utils.generateEnumName(useSchema ? table.tableName : table, options.field.field), '\"')}[]`;\n        str += `::${schemaWithDelimiter}${castKey}`;\n      } else {\n        str += `::${castKey}`;\n      }\n    }\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9kYXRhLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFlBQVksbUJBQU8sQ0FBQyxnREFBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhLDhDQUE4QyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQSxtQ0FBbUMsc0NBQXNDO0FBQ3pFO0FBQ0E7QUFDQSxtQ0FBbUMseUJBQXlCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sS0FBSyxrQkFBa0I7QUFDaEQ7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUIsSUFBSSxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHNCQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLHVDQUF1QztBQUM5RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQyxFQUFFLGdCQUFnQjtBQUN2RyxxQkFBcUIsc0dBQXNHO0FBQzNILG9CQUFvQixvQkFBb0IsRUFBRSxRQUFRO0FBQ2xELFFBQVE7QUFDUixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9kYXRhLXR5cGVzLmpzPzZmNzMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IHdreCA9IHJlcXVpcmUoXCJ3a3hcIik7XG5tb2R1bGUuZXhwb3J0cyA9IChCYXNlVHlwZXMpID0+IHtcbiAgY29uc3Qgd2FybiA9IEJhc2VUeXBlcy5BQlNUUkFDVC53YXJuLmJpbmQodm9pZCAwLCBcImh0dHA6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy85LjQvc3RhdGljL2RhdGF0eXBlLmh0bWxcIik7XG4gIGZ1bmN0aW9uIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnMoZGF0YVR5cGUpIHtcbiAgICBpZiAoZGF0YVR5cGUuX2xlbmd0aCB8fCBkYXRhVHlwZS5vcHRpb25zLmxlbmd0aCB8fCBkYXRhVHlwZS5fdW5zaWduZWQgfHwgZGF0YVR5cGUuX3plcm9maWxsKSB7XG4gICAgICB3YXJuKGBQb3N0Z3Jlc1NRTCBkb2VzIG5vdCBzdXBwb3J0ICcke2RhdGFUeXBlLmtleX0nIHdpdGggTEVOR1RILCBVTlNJR05FRCBvciBaRVJPRklMTC4gUGxhaW4gJyR7ZGF0YVR5cGUua2V5fScgd2lsbCBiZSB1c2VkIGluc3RlYWQuYCk7XG4gICAgICBkYXRhVHlwZS5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgZGF0YVR5cGUub3B0aW9ucy5sZW5ndGggPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5fdW5zaWduZWQgPSB2b2lkIDA7XG4gICAgICBkYXRhVHlwZS5femVyb2ZpbGwgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5VVUlELnR5cGVzLnBvc3RncmVzID0gW1widXVpZFwiXTtcbiAgQmFzZVR5cGVzLkNJRFIudHlwZXMucG9zdGdyZXMgPSBbXCJjaWRyXCJdO1xuICBCYXNlVHlwZXMuSU5FVC50eXBlcy5wb3N0Z3JlcyA9IFtcImluZXRcIl07XG4gIEJhc2VUeXBlcy5NQUNBRERSLnR5cGVzLnBvc3RncmVzID0gW1wibWFjYWRkclwiXTtcbiAgQmFzZVR5cGVzLlRTVkVDVE9SLnR5cGVzLnBvc3RncmVzID0gW1widHN2ZWN0b3JcIl07XG4gIEJhc2VUeXBlcy5KU09OLnR5cGVzLnBvc3RncmVzID0gW1wianNvblwiXTtcbiAgQmFzZVR5cGVzLkpTT05CLnR5cGVzLnBvc3RncmVzID0gW1wianNvbmJcIl07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLnBvc3RncmVzID0gW1widGltZVwiXTtcbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiSW5maW5pdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLl9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBfc2FuaXRpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucyAmJiAhb3B0aW9ucy5yYXcpICYmIHZhbHVlICE9PSBJbmZpbml0eSAmJiB2YWx1ZSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBsb3dlciA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgaWYgKGxvd2VyID09PSBcImluZmluaXR5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID09PSBcIi1pbmZpbml0eVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuX3Nhbml0aXplKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IFwiaW5maW5pdHlcIikge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IFwiLWluZmluaXR5XCIpIHtcbiAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLnBvc3RncmVzID0gW1wiZGF0ZVwiXTtcbiAgY2xhc3MgREVDSU1BTCBleHRlbmRzIEJhc2VUeXBlcy5ERUNJTUFMIHtcbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMucG9zdGdyZXMgPSBbXCJudW1lcmljXCJdO1xuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQllURUFcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCgpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuU1RSSU5HLnR5cGVzLnBvc3RncmVzID0gW1widmFyY2hhclwiXTtcbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgd2FybihcIlBvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBURVhUIHdpdGggb3B0aW9ucy4gUGxhaW4gYFRFWFRgIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiVEVYVFwiO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5wb3N0Z3JlcyA9IFtcInRleHRcIl07XG4gIGNsYXNzIENJVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5DSVRFWFQge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuQ0lURVhULnR5cGVzLnBvc3RncmVzID0gW1wiY2l0ZXh0XCJdO1xuICBjbGFzcyBDSEFSIGV4dGVuZHMgQmFzZVR5cGVzLkNIQVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gXCJCWVRFQVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5DSEFSLnR5cGVzLnBvc3RncmVzID0gW1wiY2hhclwiLCBcImJwY2hhclwiXTtcbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJPT0xFQU5cIjtcbiAgICB9XG4gICAgX3Nhbml0aXplKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gW1widHJ1ZVwiLCBcInRcIl0uaW5jbHVkZXModmFsdWUpID8gdHJ1ZSA6IFtcImZhbHNlXCIsIFwiZlwiXS5pbmNsdWRlcyh2YWx1ZSkgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgPyB0cnVlIDogdmFsdWUgPT09IDAgPyBmYWxzZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJPT0xFQU4ucGFyc2UgPSBCT09MRUFOLnByb3RvdHlwZS5fc2FuaXRpemU7XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLnBvc3RncmVzID0gW1wiYm9vbFwiXTtcbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlRJTUVTVEFNUCBXSVRIIFRJTUUgWk9ORVwiO1xuICAgIH1cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlICE9PSBJbmZpbml0eSAmJiB2YWx1ZSAhPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VwZXIuX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9zYW5pdGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zICYmICFvcHRpb25zLnJhdykgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEhdmFsdWUgJiYgdmFsdWUgIT09IEluZmluaXR5ICYmIHZhbHVlICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGNvbnN0IGxvd2VyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAobG93ZXIgPT09IFwiaW5maW5pdHlcIikge1xuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgPT09IFwiLWluZmluaXR5XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5EQVRFLnR5cGVzLnBvc3RncmVzID0gW1widGltZXN0YW1wdHpcIl07XG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLlRJTllJTlQudHlwZXMucG9zdGdyZXMgPSBbXCJpbnQyXCJdO1xuICBjbGFzcyBTTUFMTElOVCBleHRlbmRzIEJhc2VUeXBlcy5TTUFMTElOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLlNNQUxMSU5ULnR5cGVzLnBvc3RncmVzID0gW1wiaW50MlwiXTtcbiAgY2xhc3MgSU5URUdFUiBleHRlbmRzIEJhc2VUeXBlcy5JTlRFR0VSIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBJTlRFR0VSLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfTtcbiAgQmFzZVR5cGVzLklOVEVHRVIudHlwZXMucG9zdGdyZXMgPSBbXCJpbnQ0XCJdO1xuICBjbGFzcyBCSUdJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuQklHSU5UIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuQklHSU5ULnR5cGVzLnBvc3RncmVzID0gW1wiaW50OFwiXTtcbiAgY2xhc3MgUkVBTCBleHRlbmRzIEJhc2VUeXBlcy5SRUFMIHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCk7XG4gICAgICByZW1vdmVVbnN1cHBvcnRlZEludGVnZXJPcHRpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuUkVBTC50eXBlcy5wb3N0Z3JlcyA9IFtcImZsb2F0NFwiXTtcbiAgY2xhc3MgRE9VQkxFIGV4dGVuZHMgQmFzZVR5cGVzLkRPVUJMRSB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5wb3N0Z3JlcyA9IFtcImZsb2F0OFwiXTtcbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgZGVjaW1hbHMpIHtcbiAgICAgIHN1cGVyKGxlbmd0aCwgZGVjaW1hbHMpO1xuICAgICAgaWYgKHRoaXMuX2RlY2ltYWxzKSB7XG4gICAgICAgIHdhcm4oXCJQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgd2l0aCBkZWNpbWFscy4gUGxhaW4gYEZMT0FUYCB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cIik7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5fZGVjaW1hbHMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fdW5zaWduZWQpIHtcbiAgICAgICAgd2FybihcIlBvc3RncmVTUUwgZG9lcyBub3Qgc3VwcG9ydCBGTE9BVCB1bnNpZ25lZC4gYFVOU0lHTkVEYCB3YXMgcmVtb3ZlZC5cIik7XG4gICAgICAgIHRoaXMuX3Vuc2lnbmVkID0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHdhcm4oXCJQb3N0Z3JlU1FMIGRvZXMgbm90IHN1cHBvcnQgRkxPQVQgemVyb2ZpbGwuIGBaRVJPRklMTGAgd2FzIHJlbW92ZWQuXCIpO1xuICAgICAgICB0aGlzLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGVsZXRlIEZMT0FULnBhcnNlO1xuICBjbGFzcyBCTE9CIGV4dGVuZHMgQmFzZVR5cGVzLkJMT0Ige1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICB3YXJuKFwiUG9zdGdyZVNRTCBkb2VzIG5vdCBzdXBwb3J0IEJMT0IgKEJZVEVBKSB3aXRoIG9wdGlvbnMuIFBsYWluIGBCWVRFQWAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJCWVRFQVwiO1xuICAgIH1cbiAgICBfaGV4aWZ5KGhleCkge1xuICAgICAgcmV0dXJuIGBFJ1xcXFxcXFxceCR7aGV4fSdgO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5wb3N0Z3JlcyA9IFtcImJ5dGVhXCJdO1xuICBjbGFzcyBHRU9NRVRSWSBleHRlbmRzIEJhc2VUeXBlcy5HRU9NRVRSWSB7XG4gICAgdG9TcWwoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5rZXk7XG4gICAgICBpZiAodGhpcy50eXBlKSB7XG4gICAgICAgIHJlc3VsdCArPSBgKCR7dGhpcy50eXBlfWA7XG4gICAgICAgIGlmICh0aGlzLnNyaWQpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYCwke3RoaXMuc3JpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBcImhleFwiKTtcbiAgICAgIHJldHVybiB3a3guR2VvbWV0cnkucGFyc2UoYikudG9HZW9KU09OKHsgc2hvcnRDcnM6IHRydWUgfSk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBgU1RfR2VvbUZyb21HZW9KU09OKCR7b3B0aW9ucy5lc2NhcGUoSlNPTi5zdHJpbmdpZnkodmFsdWUpKX0pYDtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSl9KWA7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5wb3N0Z3JlcyA9IFtcImdlb21ldHJ5XCJdO1xuICBjbGFzcyBHRU9HUkFQSFkgZXh0ZW5kcyBCYXNlVHlwZXMuR0VPR1JBUEhZIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGxldCByZXN1bHQgPSBcIkdFT0dSQVBIWVwiO1xuICAgICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMudHlwZX1gO1xuICAgICAgICBpZiAodGhpcy5zcmlkKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLnNyaWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gXCIpXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UodmFsdWUpIHtcbiAgICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJoZXhcIik7XG4gICAgICByZXR1cm4gd2t4Lkdlb21ldHJ5LnBhcnNlKGIpLnRvR2VvSlNPTih7IHNob3J0Q3JzOiB0cnVlIH0pO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gYFNUX0dlb21Gcm9tR2VvSlNPTigke29wdGlvbnMuZXNjYXBlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSl9KWA7XG4gICAgfVxuICAgIGJpbmRQYXJhbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGBTVF9HZW9tRnJvbUdlb0pTT04oJHtvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSl9KWA7XG4gICAgfVxuICB9XG4gIEJhc2VUeXBlcy5HRU9HUkFQSFkudHlwZXMucG9zdGdyZXMgPSBbXCJnZW9ncmFwaHlcIl07XG4gIGxldCBoc3RvcmU7XG4gIGNsYXNzIEhTVE9SRSBleHRlbmRzIEJhc2VUeXBlcy5IU1RPUkUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGlmICghaHN0b3JlKSB7XG4gICAgICAgIGhzdG9yZSA9IHJlcXVpcmUoXCIuL2hzdG9yZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3ZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAoIWhzdG9yZSkge1xuICAgICAgICBoc3RvcmUgPSByZXF1aXJlKFwiLi9oc3RvcmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHN0b3JlLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICAgIF9zdHJpbmdpZnkodmFsdWUpIHtcbiAgICAgIHJldHVybiBgJyR7dGhpcy5fdmFsdWUodmFsdWUpfSdgO1xuICAgIH1cbiAgICBfYmluZFBhcmFtKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odGhpcy5fdmFsdWUodmFsdWUpKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAoIWhzdG9yZSkge1xuICAgICAgICBoc3RvcmUgPSByZXF1aXJlKFwiLi9oc3RvcmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHN0b3JlLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgSFNUT1JFLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkhTVE9SRS50eXBlcy5wb3N0Z3JlcyA9IFtcImhzdG9yZVwiXTtcbiAgY2xhc3MgUkFOR0UgZXh0ZW5kcyBCYXNlVHlwZXMuUkFOR0Uge1xuICAgIF92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3VidHlwZS5zdHJpbmdpZnkodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlSW5jbHVzaXZpdHkgPSBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgY29uc3QgdmFsdWVzU3RyaW5naWZpZWQgPSB2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwiaW5jbHVzaXZlXCIpKSB7XG4gICAgICAgICAgICB2YWx1ZUluY2x1c2l2aXR5W2luZGV4XSA9IHZhbHVlLmluY2x1c2l2ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IC1JbmZpbml0eSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdWJ0eXBlLnN0cmluZ2lmeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3VidHlwZS5zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHZhbHVlc1N0cmluZ2lmaWVkLmluY2x1c2l2ZSA9IHZhbHVlSW5jbHVzaXZpdHk7XG4gICAgICByZXR1cm4gcmFuZ2Uuc3RyaW5naWZ5KHZhbHVlc1N0cmluZ2lmaWVkKTtcbiAgICB9XG4gICAgX3N0cmluZ2lmeSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiBgJyR7dmFsdWV9Jzo6JHt0aGlzLnRvQ2FzdFR5cGUoKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGAnJHt2YWx1ZX0nYDtcbiAgICB9XG4gICAgX2JpbmRQYXJhbSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fdmFsdWUodmFsdWVzLCBvcHRpb25zKTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgIHJldHVybiBgJHtvcHRpb25zLmJpbmRQYXJhbSh2YWx1ZSl9Ojoke3RoaXMudG9DYXN0VHlwZSgpfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucy5iaW5kUGFyYW0odmFsdWUpO1xuICAgIH1cbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBCYXNlVHlwZXMuUkFOR0UudHlwZXMucG9zdGdyZXMuc3VidHlwZXNbdGhpcy5fc3VidHlwZS50b0xvd2VyQ2FzZSgpXTtcbiAgICB9XG4gICAgdG9DYXN0VHlwZSgpIHtcbiAgICAgIHJldHVybiBCYXNlVHlwZXMuUkFOR0UudHlwZXMucG9zdGdyZXMuY2FzdFR5cGVzW3RoaXMuX3N1YnR5cGUudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucyA9IHsgcGFyc2VyOiAodmFsKSA9PiB2YWwgfSkge1xuICAgICAgcmV0dXJuIHJhbmdlLnBhcnNlKHZhbHVlLCBvcHRpb25zLnBhcnNlcik7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJhbmdlID0gcmVxdWlyZShcIi4vcmFuZ2VcIik7XG4gIFJBTkdFLnByb3RvdHlwZS5lc2NhcGUgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLlJBTkdFLnR5cGVzLnBvc3RncmVzID0ge1xuICAgIHN1YnR5cGVzOiB7XG4gICAgICBpbnRlZ2VyOiBcImludDRyYW5nZVwiLFxuICAgICAgZGVjaW1hbDogXCJudW1yYW5nZVwiLFxuICAgICAgZGF0ZTogXCJ0c3R6cmFuZ2VcIixcbiAgICAgIGRhdGVvbmx5OiBcImRhdGVyYW5nZVwiLFxuICAgICAgYmlnaW50OiBcImludDhyYW5nZVwiXG4gICAgfSxcbiAgICBjYXN0VHlwZXM6IHtcbiAgICAgIGludGVnZXI6IFwiaW50NFwiLFxuICAgICAgZGVjaW1hbDogXCJudW1lcmljXCIsXG4gICAgICBkYXRlOiBcInRpbWVzdGFtcHR6XCIsXG4gICAgICBkYXRlb25seTogXCJkYXRlXCIsXG4gICAgICBiaWdpbnQ6IFwiaW50OFwiXG4gICAgfVxuICB9O1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLmVzY2FwZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuQVJSQVkucHJvdG90eXBlLl92YWx1ZSA9IGZ1bmN0aW9uIF92YWx1ZSh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgodmFsdWUpID0+IHtcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYmluZFBhcmFtICYmIHRoaXMudHlwZSAmJiB0aGlzLnR5cGUuX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuX3ZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlLnN0cmluZ2lmeSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMudHlwZS5zdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy50eXBlLmVzY2FwZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHRpb25zLmVzY2FwZSh2YWx1ZSk7XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuX3N0cmluZ2lmeSA9IGZ1bmN0aW9uIF9zdHJpbmdpZnkodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgbGV0IHN0ciA9IGBBUlJBWVske3RoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykuam9pbihcIixcIil9XWA7XG4gICAgaWYgKHRoaXMudHlwZSkge1xuICAgICAgY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG4gICAgICBsZXQgY2FzdEtleSA9IHRoaXMudG9TcWwoKTtcbiAgICAgIGlmICh0aGlzLnR5cGUgaW5zdGFuY2VvZiBCYXNlVHlwZXMuRU5VTSkge1xuICAgICAgICBjb25zdCB0YWJsZSA9IG9wdGlvbnMuZmllbGQuTW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgICAgIGNvbnN0IHVzZVNjaGVtYSA9IHRhYmxlLnNjaGVtYSAhPT0gdm9pZCAwO1xuICAgICAgICBjb25zdCBzY2hlbWFXaXRoRGVsaW1pdGVyID0gdXNlU2NoZW1hID8gYCR7VXRpbHMuYWRkVGlja3ModGFibGUuc2NoZW1hLCAnXCInKX0ke3RhYmxlLmRlbGltaXRlcn1gIDogXCJcIjtcbiAgICAgICAgY2FzdEtleSA9IGAke1V0aWxzLmFkZFRpY2tzKFV0aWxzLmdlbmVyYXRlRW51bU5hbWUodXNlU2NoZW1hID8gdGFibGUudGFibGVOYW1lIDogdGFibGUsIG9wdGlvbnMuZmllbGQuZmllbGQpLCAnXCInKX1bXWA7XG4gICAgICAgIHN0ciArPSBgOjoke3NjaGVtYVdpdGhEZWxpbWl0ZXJ9JHtjYXN0S2V5fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gYDo6JHtjYXN0S2V5fWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIEJhc2VUeXBlcy5BUlJBWS5wcm90b3R5cGUuX2JpbmRQYXJhbSA9IGZ1bmN0aW9uIF9iaW5kUGFyYW0odmFsdWVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuYmluZFBhcmFtKHRoaXMuX3ZhbHVlKHZhbHVlcywgb3B0aW9ucykpO1xuICB9O1xuICBjbGFzcyBFTlVNIGV4dGVuZHMgQmFzZVR5cGVzLkVOVU0ge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICBCYXNlVHlwZXMuRU5VTS50eXBlcy5wb3N0Z3JlcyA9IFtudWxsXTtcbiAgcmV0dXJuIHtcbiAgICBERUNJTUFMLFxuICAgIEJMT0IsXG4gICAgU1RSSU5HLFxuICAgIENIQVIsXG4gICAgVEVYVCxcbiAgICBDSVRFWFQsXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBJTlRFR0VSLFxuICAgIEJJR0lOVCxcbiAgICBCT09MRUFOLFxuICAgIERBVEUsXG4gICAgREFURU9OTFksXG4gICAgUkVBTCxcbiAgICBcIkRPVUJMRSBQUkVDSVNJT05cIjogRE9VQkxFLFxuICAgIEZMT0FULFxuICAgIEdFT01FVFJZLFxuICAgIEdFT0dSQVBIWSxcbiAgICBIU1RPUkUsXG4gICAgUkFOR0UsXG4gICAgRU5VTVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/hstore.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst hstore = __webpack_require__(/*! pg-hstore */ \"?9973\")({ sanitize: true });\nfunction stringify(data) {\n  if (data === null)\n    return null;\n  return hstore.stringify(data);\n}\nexports.stringify = stringify;\nfunction parse(value) {\n  if (value === null)\n    return null;\n  return hstore.parse(value);\n}\nexports.parse = parse;\n//# sourceMappingURL=hstore.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsd0JBQVcsSUFBSSxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9oc3RvcmUuanM/M2YxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGhzdG9yZSA9IHJlcXVpcmUoXCJwZy1oc3RvcmVcIikoeyBzYW5pdGl6ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhKSB7XG4gIGlmIChkYXRhID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gaHN0b3JlLnN0cmluZ2lmeShkYXRhKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuZnVuY3Rpb24gcGFyc2UodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgIHJldHVybiBudWxsO1xuICByZXR1cm4gaHN0b3JlLnBhcnNlKHZhbHVlKTtcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhzdG9yZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/hstore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").postgres);\nconst { PostgresQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-interface.js\");\nclass PostgresDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new PostgresQueryInterface(sequelize, this.queryGenerator);\n  }\n  canBackslashEscape() {\n    return !this.sequelize.options.standardConformingStrings;\n  }\n}\nPostgresDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"DEFAULT VALUES\": true,\n  EXCEPTION: true,\n  \"ON DUPLICATE KEY\": false,\n  \"ORDER NULLS\": true,\n  returnValues: {\n    returning: true\n  },\n  bulkDefault: true,\n  schemas: true,\n  lock: true,\n  lockOf: true,\n  lockKey: true,\n  lockOuterJoinFailure: true,\n  skipLocked: true,\n  forShare: \"FOR SHARE\",\n  index: {\n    concurrently: true,\n    using: 2,\n    where: true,\n    functionBased: true,\n    operator: true\n  },\n  inserts: {\n    onConflictDoNothing: \" ON CONFLICT DO NOTHING\",\n    updateOnDuplicate: \" ON CONFLICT DO UPDATE SET\",\n    conflictFields: true,\n    onConflictWhere: true\n  },\n  NUMERIC: true,\n  ARRAY: true,\n  RANGE: true,\n  GEOMETRY: true,\n  REGEXP: true,\n  GEOGRAPHY: true,\n  JSON: true,\n  JSONB: true,\n  HSTORE: true,\n  TSVECTOR: true,\n  deferrableConstraints: true,\n  searchPath: true,\n  escapeStringConstants: true\n});\nPostgresDialect.prototype.defaultVersion = \"9.5.0\";\nPostgresDialect.prototype.Query = Query;\nPostgresDialect.prototype.DataTypes = DataTypes;\nPostgresDialect.prototype.name = \"postgres\";\nPostgresDialect.prototype.TICK_CHAR = '\"';\nPostgresDialect.prototype.TICK_CHAR_LEFT = PostgresDialect.prototype.TICK_CHAR;\nPostgresDialect.prototype.TICK_CHAR_RIGHT = PostgresDialect.prototype.TICK_CHAR;\nmodule.exports = PostgresDialect;\nmodule.exports[\"default\"] = PostgresDialect;\nmodule.exports.PostgresDialect = PostgresDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQix3QkFBd0IsbUJBQU8sQ0FBQyxrRkFBYTtBQUM3QywwQkFBMEIsbUJBQU8sQ0FBQyx3R0FBc0I7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLDhFQUFTO0FBQy9CLHVCQUF1QixtQkFBTyxDQUFDLGtHQUFtQjtBQUNsRCxrQkFBa0IsMEdBQW9DO0FBQ3RELFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxrR0FBbUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL2luZGV4LmpzP2U2NTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikucG9zdGdyZXM7XG5jb25zdCB7IFBvc3RncmVzUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIFBvc3RncmVzRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IFBvc3RncmVzUXVlcnlJbnRlcmZhY2Uoc2VxdWVsaXplLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yKTtcbiAgfVxuICBjYW5CYWNrc2xhc2hFc2NhcGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0YW5kYXJkQ29uZm9ybWluZ1N0cmluZ3M7XG4gIH1cbn1cblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMgPSBfLm1lcmdlKF8uY2xvbmVEZWVwKEFic3RyYWN0RGlhbGVjdC5wcm90b3R5cGUuc3VwcG9ydHMpLCB7XG4gIFwiREVGQVVMVCBWQUxVRVNcIjogdHJ1ZSxcbiAgRVhDRVBUSU9OOiB0cnVlLFxuICBcIk9OIERVUExJQ0FURSBLRVlcIjogZmFsc2UsXG4gIFwiT1JERVIgTlVMTFNcIjogdHJ1ZSxcbiAgcmV0dXJuVmFsdWVzOiB7XG4gICAgcmV0dXJuaW5nOiB0cnVlXG4gIH0sXG4gIGJ1bGtEZWZhdWx0OiB0cnVlLFxuICBzY2hlbWFzOiB0cnVlLFxuICBsb2NrOiB0cnVlLFxuICBsb2NrT2Y6IHRydWUsXG4gIGxvY2tLZXk6IHRydWUsXG4gIGxvY2tPdXRlckpvaW5GYWlsdXJlOiB0cnVlLFxuICBza2lwTG9ja2VkOiB0cnVlLFxuICBmb3JTaGFyZTogXCJGT1IgU0hBUkVcIixcbiAgaW5kZXg6IHtcbiAgICBjb25jdXJyZW50bHk6IHRydWUsXG4gICAgdXNpbmc6IDIsXG4gICAgd2hlcmU6IHRydWUsXG4gICAgZnVuY3Rpb25CYXNlZDogdHJ1ZSxcbiAgICBvcGVyYXRvcjogdHJ1ZVxuICB9LFxuICBpbnNlcnRzOiB7XG4gICAgb25Db25mbGljdERvTm90aGluZzogXCIgT04gQ09ORkxJQ1QgRE8gTk9USElOR1wiLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBcIiBPTiBDT05GTElDVCBETyBVUERBVEUgU0VUXCIsXG4gICAgY29uZmxpY3RGaWVsZHM6IHRydWUsXG4gICAgb25Db25mbGljdFdoZXJlOiB0cnVlXG4gIH0sXG4gIE5VTUVSSUM6IHRydWUsXG4gIEFSUkFZOiB0cnVlLFxuICBSQU5HRTogdHJ1ZSxcbiAgR0VPTUVUUlk6IHRydWUsXG4gIFJFR0VYUDogdHJ1ZSxcbiAgR0VPR1JBUEhZOiB0cnVlLFxuICBKU09OOiB0cnVlLFxuICBKU09OQjogdHJ1ZSxcbiAgSFNUT1JFOiB0cnVlLFxuICBUU1ZFQ1RPUjogdHJ1ZSxcbiAgZGVmZXJyYWJsZUNvbnN0cmFpbnRzOiB0cnVlLFxuICBzZWFyY2hQYXRoOiB0cnVlLFxuICBlc2NhcGVTdHJpbmdDb25zdGFudHM6IHRydWVcbn0pO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5kZWZhdWx0VmVyc2lvbiA9IFwiOS41LjBcIjtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcblBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJwb3N0Z3Jlc1wiO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSAnXCInO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IFBvc3RncmVzRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuUG9zdGdyZXNEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfUklHSFQgPSBQb3N0Z3Jlc0RpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbm1vZHVsZS5leHBvcnRzID0gUG9zdGdyZXNEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzRGlhbGVjdDtcbm1vZHVsZS5leHBvcnRzLlBvc3RncmVzRGlhbGVjdCA9IFBvc3RncmVzRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-generator.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-generator.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst semver = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst POSTGRES_RESERVED_WORDS = \"all,analyse,analyze,and,any,array,as,asc,asymmetric,authorization,binary,both,case,cast,check,collate,collation,column,concurrently,constraint,create,cross,current_catalog,current_date,current_role,current_schema,current_time,current_timestamp,current_user,default,deferrable,desc,distinct,do,else,end,except,false,fetch,for,foreign,freeze,from,full,grant,group,having,ilike,in,initially,inner,intersect,into,is,isnull,join,lateral,leading,left,like,limit,localtime,localtimestamp,natural,not,notnull,null,offset,on,only,or,order,outer,overlaps,placing,primary,references,returning,right,select,session_user,similar,some,symmetric,table,tablesample,then,to,trailing,true,union,unique,user,using,variadic,verbose,when,where,window,with\".split(\",\");\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      encoding: null,\n      collate: null\n    }, options);\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : \"\",\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : \"\",\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : \"\",\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : \"\"\n    };\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n  createSchema(schema) {\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n    if (databaseVersion && semver.gte(databaseVersion, \"9.2.0\")) {\n      return `CREATE SCHEMA IF NOT EXISTS ${this.quoteIdentifier(schema)};`;\n    }\n    return `CREATE SCHEMA ${this.quoteIdentifier(schema)};`;\n  }\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${this.quoteIdentifier(schema)} CASCADE;`;\n  }\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n  versionQuery() {\n    return \"SHOW SERVER_VERSION\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({}, options);\n    const databaseVersion = _.get(this, \"sequelize.options.databaseVersion\", 0);\n    const attrStr = [];\n    let comments = \"\";\n    let columnComments = \"\";\n    const quotedTable = this.quoteTable(tableName);\n    if (options.comment && typeof options.comment === \"string\") {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf(\"COMMENT \");\n      if (i !== -1) {\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n    let attributesClause = attrStr.join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns) => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes(\"PRIMARY KEY\")) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(\",\");\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, \"9.1.0\") ? \"IF NOT EXISTS \" : \"\"}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? \" CASCADE\" : \"\"};`;\n  }\n  showTablesQuery() {\n    const schema = this.options.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';`;\n  }\n  tableExistsQuery(tableName) {\n    const table = tableName.tableName || tableName;\n    const schema = tableName.schema || \"public\";\n    return `SELECT table_name FROM information_schema.tables WHERE table_schema = ${this.escape(schema)} AND table_name = ${this.escape(table)}`;\n  }\n  describeTableQuery(tableName, schema) {\n    schema = schema || this.options.schema || \"public\";\n    return `SELECT pk.constraint_type as \"Constraint\",c.column_name as \"Field\", c.column_default as \"Default\",c.is_nullable as \"Null\", (CASE WHEN c.udt_name = 'hstore' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN '(' || c.character_maximum_length || ')' ELSE '' END) as \"Type\", (SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", (SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" FROM information_schema.columns c LEFT JOIN (SELECT tc.table_schema, tc.table_name, cu.column_name, tc.constraint_type FROM information_schema.TABLE_CONSTRAINTS tc JOIN information_schema.KEY_COLUMN_USAGE  cu ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name and tc.constraint_name=cu.constraint_name and tc.constraint_type='PRIMARY KEY') pk ON pk.table_schema=c.table_schema AND pk.table_name=c.table_name AND pk.column_name=c.column_name WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)}`;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        let str;\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, attribute) {\n    const dbDataType = this.attributeToSQL(attribute, { context: \"addColumn\", table, key });\n    const dataType = attribute.type || attribute;\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n    if (dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    } else if (dataType.type && dataType.type instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType.type) + query;\n    }\n    return query;\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (subQuery) => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = \"\";\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n      if (attributes[attributeName].startsWith(\"ENUM(\")) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace(\"ALTER COLUMN\", \"\");\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace(\"ALTER COLUMN\", \"\");\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n      sql.push(attrSql);\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(\", \")};`;\n  }\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || \"testfunc\";\n    language = language || \"plpgsql\";\n    returns = returns ? `RETURNS ${returns}` : \"\";\n    parameters = parameters || \"\";\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? \" RESTART IDENTITY\" : \"\",\n      options.cascade ? \" CASCADE\" : \"\"\n    ].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : \"\";\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n  showIndexesQuery(tableName) {\n    let schemaJoin = \"\";\n    let schemaWhere = \"\";\n    if (typeof tableName !== \"string\") {\n      schemaJoin = \", pg_namespace s\";\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n    return `SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;`;\n  }\n  showConstraintsQuery(tableName) {\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      \"from INFORMATION_SCHEMA.table_constraints\",\n      `WHERE table_name='${tableName}';`\n    ].join(\" \");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes, options) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return [\n      \"DROP INDEX\",\n      options && options.concurrently && \"CONCURRENTLY\",\n      `IF EXISTS ${this.quoteIdentifiers(indexName)}`\n    ].filter(Boolean).join(\" \");\n  }\n  addLimitAndOffset(options) {\n    let fragment = \"\";\n    if (options.limit != null) {\n      fragment += \" LIMIT \" + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += \" OFFSET \" + this.escape(options.offset);\n    }\n    return fragment;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let type;\n    if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map((value) => this.escape(value)).join(\", \")})`;\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += \"[]\";\n        }\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n    if (!type) {\n      type = attribute.type;\n    }\n    let sql = type.toString();\n    if (Object.prototype.hasOwnProperty.call(attribute, \"allowNull\") && !attribute.allowNull) {\n      sql += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += \" GENERATED BY DEFAULT AS IDENTITY\";\n      } else {\n        sql += \" SERIAL\";\n      }\n    }\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n    if (attribute.unique === true) {\n      sql += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      sql += \" PRIMARY KEY\";\n    }\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n      if (options.schema) {\n        schema = options.schema;\n      } else if ((!attribute.references.model || typeof attribute.references.model == \"string\") && options.table && options.table.schema) {\n        schema = options.table.schema;\n      }\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n      let referencesKey;\n      if (!options.withoutForeignKeyConstraints) {\n        if (attribute.references.key) {\n          referencesKey = this.quoteIdentifiers(attribute.references.key);\n        } else {\n          referencesKey = this.quoteIdentifier(\"id\");\n        }\n        sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n        if (attribute.onDelete) {\n          sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n        }\n        if (attribute.onUpdate) {\n          sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n        }\n        if (attribute.references.deferrable) {\n          sql += ` ${attribute.references.deferrable.toString(this)}`;\n        }\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      if (options && [\"addColumn\", \"changeColumn\"].includes(options.context)) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n    return sql;\n  }\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n  setConstraintQuery(columns, type) {\n    let columnFragment = \"ALL\";\n    if (columns) {\n      columnFragment = columns.map((column) => this.quoteIdentifier(column)).join(\", \");\n    }\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, \"DEFERRED\");\n  }\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, \"IMMEDIATE\");\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, __spreadValues({ key }, options));\n    }\n    return result;\n  }\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this._expandFunctionParamList(functionParams);\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : \"\"} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body)\n      throw new Error(\"createFunction missing some parameters. Did you pass functionName, returnType, language and body?\");\n    const paramList = this._expandFunctionParamList(params);\n    const variableList = options && options.variables ? this._expandFunctionVariableList(options.variables) : \"\";\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n    const statement = options && options.force ? \"CREATE OR REPLACE FUNCTION\" : \"CREATE FUNCTION\";\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n  dropFunction(functionName, params) {\n    if (!functionName)\n      throw new Error(\"requires functionName\");\n    const paramList = this._expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this._expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n  _expandFunctionParamList(params) {\n    if (params === void 0 || !Array.isArray(params)) {\n      throw new Error(\"_expandFunctionParamList: function parameters array required, including an empty one for no arguments\");\n    }\n    const paramList = [];\n    params.forEach((curParam) => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error(\"function or trigger used with a parameter without any type\");\n      }\n      const joined = paramDef.join(\" \");\n      if (joined)\n        paramList.push(joined);\n    });\n    return paramList.join(\", \");\n  }\n  _expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error(\"_expandFunctionVariableList: function variables must be an array\");\n    }\n    const variableDefinitions = [];\n    variables.forEach((variable) => {\n      if (!variable.name || !variable.type) {\n        throw new Error(\"function variable must have a name and type\");\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += \";\";\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(\" \");\n  }\n  expandOptions(options) {\n    return options === void 0 || _.isEmpty(options) ? \"\" : options.join(\" \");\n  }\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      \"after\": \"AFTER\",\n      \"before\": \"BEFORE\",\n      \"instead_of\": \"INSTEAD OF\",\n      \"after_constraint\": \"AFTER\"\n    };\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n    return EVENT_DECODER[eventSpecifier];\n  }\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === \"after_constraint\" ? \"CONSTRAINT \" : \"\";\n  }\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error(\"no table change events specified to trigger on\");\n    }\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        \"insert\": \"INSERT\",\n        \"update\": \"UPDATE\",\n        \"delete\": \"DELETE\",\n        \"truncate\": \"TRUNCATE\"\n      };\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === \"UPDATE\") {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(\", \")}`;\n        }\n      }\n      return eventSpec;\n    }).join(\" OR \");\n  }\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n    return enumName;\n  }\n  pgListEnums(tableName, attrName, options) {\n    let enumName = \"\";\n    const tableDetails = this.extractTableDetails(tableName, options);\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n    return `SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t JOIN pg_enum e ON t.oid = e.enumtypid JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map((value) => this.escape(value)).join(\", \")})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n    let sql = `DO ${this.escape(`BEGIN CREATE TYPE ${enumName} AS ${values}; EXCEPTION WHEN duplicate_object THEN null; END`)};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n    if (semver.gte(this.sequelize.options.databaseVersion, \"9.3.0\")) {\n      sql += \"IF NOT EXISTS \";\n    }\n    sql += this.escape(value);\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n    return sql;\n  }\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n  fromArray(text) {\n    text = text.replace(/^{/, \"\").replace(/}$/, \"\");\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n    if (matches.length < 1) {\n      return [];\n    }\n    matches = matches.map((m) => m.replace(/\",$/, \"\").replace(/,$/, \"\").replace(/(^\"|\"$)/g, \"\"));\n    return matches.slice(0, -1);\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    if (dataType.startsWith(\"ENUM(\")) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(tableName) {\n    return `SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n  _getForeignKeyReferencesQueryPrefix() {\n    return \"SELECT DISTINCT tc.constraint_name as constraint_name, tc.constraint_schema as constraint_schema, tc.constraint_catalog as constraint_catalog, tc.table_name as table_name,tc.table_schema as table_schema,tc.table_catalog as table_catalog,tc.initially_deferred as initially_deferred,tc.is_deferrable as is_deferrable,kcu.column_name as column_name,ccu.table_schema  AS referenced_table_schema,ccu.table_catalog  AS referenced_table_catalog,ccu.table_name  AS referenced_table_name,ccu.column_name AS referenced_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name \";\n  }\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${catalogName ? ` AND tc.table_catalog = '${catalogName}'` : \"\"}${schemaName ? ` AND tc.table_schema = '${schemaName}'` : \"\"}`;\n  }\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${schema ? ` AND tc.table_schema = '${schema}'` : \"\"}`;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || POSTGRES_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nmodule.exports = PostgresQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBa0I7QUFDNUMsK0JBQStCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3BFLGVBQWUsbUJBQU8sQ0FBQyxvREFBUTtBQUMvQixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0RBQWtELDhCQUE4QjtBQUNoRixvREFBb0QsNkJBQTZCO0FBQ2pGLDRDQUE0QywyQkFBMkI7QUFDdkUsa0RBQWtELDhCQUE4QjtBQUNoRjtBQUNBLDhCQUE4QixnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsaUJBQWlCO0FBQ3JIO0FBQ0E7QUFDQSxzQ0FBc0MsK0JBQStCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEIsUUFBUTtBQUMxRTtBQUNBO0FBQ0EsaUtBQWlLO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQixhQUFhLEtBQUssNkJBQTZCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0IsWUFBWSxHQUFHLFlBQVksS0FBSyxtQkFBbUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksRUFBRSxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsc0VBQXNFO0FBQ2pIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0EsMkJBQTJCLHNGQUFzRixFQUFFLGFBQWEsR0FBRyxpQkFBaUIsR0FBRyxTQUFTLEVBQUUsZ0JBQWdCO0FBQ2xMO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkIsRUFBRSxtQ0FBbUM7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHFCQUFxQixpRUFBaUU7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YscUJBQXFCLG1CQUFtQixtQkFBbUI7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsZ3BDQUFncEMsd0JBQXdCLHVCQUF1QixvQkFBb0I7QUFDbnRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSSxrQkFBa0IsSUFBSTtBQUMxRSwrREFBK0QsRUFBRTtBQUNqRSw0REFBNEQsRUFBRSxzQkFBc0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsS0FBSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYseUVBQXlFLEtBQUssZ0JBQWdCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxrQ0FBa0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYSxhQUFhLFdBQVcsRUFBRSxZQUFZO0FBQ2xGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCLGNBQWMscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQSwrQ0FBK0MsNEJBQTRCLGVBQWUsVUFBVTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBLFFBQVE7QUFDUiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSw0QkFBNEIscUNBQXFDLGNBQWMsOEJBQThCLFNBQVM7QUFDdEgsb0RBQW9EO0FBQ3BELFFBQVE7QUFDUiw0QkFBNEIscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyxlQUFlO0FBQ2xILGlDQUFpQyxvQ0FBb0MsSUFBSSwwQ0FBMEM7QUFDbkg7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hELHdDQUF3QyxvQ0FBb0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQyxJQUFJLFdBQVc7QUFDaEcsUUFBUTtBQUNSLDRCQUE0QixxQ0FBcUMsT0FBTyxXQUFXO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDLEtBQUssb0NBQW9DO0FBQ3BHO0FBQ0EsMEJBQTBCLDRCQUE0QixnQkFBZ0IsdUJBQXVCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxpREFBaUQsT0FBTyxHQUFHLFdBQVcsSUFBSSxTQUFTLGtCQUFrQixNQUFNLEtBQUssa0JBQWtCLFdBQVcsd0JBQXdCLE9BQU8sR0FBRztBQUMvSztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLDRDQUE0QywyQkFBMkI7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUk7QUFDcEU7QUFDQSw0QkFBNEIsT0FBTyxRQUFRLGFBQWEsYUFBYSxzQkFBc0IsT0FBTyxNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU07QUFDOUg7QUFDQSwwQkFBMEIsTUFBTSxFQUFFLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0EscVNBQXFTLFlBQVksa0hBQWtILFVBQVUsR0FBRyxhQUFhLGlHQUFpRztBQUM5aEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVSxFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsVUFBVSxHQUFHLGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQ0FBaUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUIsR0FBRyxjQUFjO0FBQ2hFO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0EscUJBQXFCLCtDQUErQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0IsK0JBQStCLEdBQUcsWUFBWSxLQUFLLG1CQUFtQjtBQUM1RyxRQUFRO0FBQ1IsMkJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCLEVBQUUsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBNkMsVUFBVSxtQ0FBbUMsRUFBRSxrQkFBa0IsRUFBRSxXQUFXLEtBQUssMkJBQTJCLEVBQUUsc0JBQXNCLGdCQUFnQixRQUFRLG9CQUFvQixhQUFhLEdBQUcsVUFBVSxFQUFFO0FBQ2hSO0FBQ0E7QUFDQSwyQkFBMkIsbUNBQW1DLEtBQUssNEJBQTRCLFNBQVM7QUFDeEc7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0MsS0FBSyw0QkFBNEIsWUFBWSxzQ0FBc0M7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxFQUFFLGFBQWEsR0FBRyxVQUFVLFlBQVksWUFBWSxZQUFZLGNBQWMsUUFBUSxNQUFNLEtBQUssbUJBQW1CLFNBQVMsR0FBRyxzQkFBc0I7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsVUFBVSxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0IsR0FBRyxVQUFVLGNBQWMsaUJBQWlCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlLEVBQUUsY0FBYztBQUN6RTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0RBQW9ELGVBQWUscUJBQXFCO0FBQzNIO0FBQ0Esb09BQW9PLG9CQUFvQixHQUFHLFVBQVU7QUFDclE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4REFBOEQ7QUFDckYsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IsaUNBQWlDLFVBQVUsS0FBSyxTQUFTLDJDQUEyQyxPQUFPO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQsTUFBTTtBQUNOLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc01BQXNNLFVBQVUsMENBQTBDO0FBQzFQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJDQUEyQyw2REFBNkQsVUFBVSxHQUFHLDBDQUEwQyxZQUFZLFFBQVEsRUFBRSx3Q0FBd0MsV0FBVyxRQUFRO0FBQzlQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBMkMsMkRBQTJELFVBQVUsNEJBQTRCLFdBQVcsR0FBRyxvQ0FBb0MsT0FBTyxRQUFRO0FBQzNOO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCLGtCQUFrQixrQ0FBa0M7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWdlbmVyYXRvci5qcz9iMGVjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vZGF0YS10eXBlc1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnlHZW5lcmF0b3IgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3Qgc2VtdmVyID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgUE9TVEdSRVNfUkVTRVJWRURfV09SRFMgPSBcImFsbCxhbmFseXNlLGFuYWx5emUsYW5kLGFueSxhcnJheSxhcyxhc2MsYXN5bW1ldHJpYyxhdXRob3JpemF0aW9uLGJpbmFyeSxib3RoLGNhc2UsY2FzdCxjaGVjayxjb2xsYXRlLGNvbGxhdGlvbixjb2x1bW4sY29uY3VycmVudGx5LGNvbnN0cmFpbnQsY3JlYXRlLGNyb3NzLGN1cnJlbnRfY2F0YWxvZyxjdXJyZW50X2RhdGUsY3VycmVudF9yb2xlLGN1cnJlbnRfc2NoZW1hLGN1cnJlbnRfdGltZSxjdXJyZW50X3RpbWVzdGFtcCxjdXJyZW50X3VzZXIsZGVmYXVsdCxkZWZlcnJhYmxlLGRlc2MsZGlzdGluY3QsZG8sZWxzZSxlbmQsZXhjZXB0LGZhbHNlLGZldGNoLGZvcixmb3JlaWduLGZyZWV6ZSxmcm9tLGZ1bGwsZ3JhbnQsZ3JvdXAsaGF2aW5nLGlsaWtlLGluLGluaXRpYWxseSxpbm5lcixpbnRlcnNlY3QsaW50byxpcyxpc251bGwsam9pbixsYXRlcmFsLGxlYWRpbmcsbGVmdCxsaWtlLGxpbWl0LGxvY2FsdGltZSxsb2NhbHRpbWVzdGFtcCxuYXR1cmFsLG5vdCxub3RudWxsLG51bGwsb2Zmc2V0LG9uLG9ubHksb3Isb3JkZXIsb3V0ZXIsb3ZlcmxhcHMscGxhY2luZyxwcmltYXJ5LHJlZmVyZW5jZXMscmV0dXJuaW5nLHJpZ2h0LHNlbGVjdCxzZXNzaW9uX3VzZXIsc2ltaWxhcixzb21lLHN5bW1ldHJpYyx0YWJsZSx0YWJsZXNhbXBsZSx0aGVuLHRvLHRyYWlsaW5nLHRydWUsdW5pb24sdW5pcXVlLHVzZXIsdXNpbmcsdmFyaWFkaWMsdmVyYm9zZSx3aGVuLHdoZXJlLHdpbmRvdyx3aXRoXCIuc3BsaXQoXCIsXCIpO1xuY2xhc3MgUG9zdGdyZXNRdWVyeUdlbmVyYXRvciBleHRlbmRzIEFic3RyYWN0UXVlcnlHZW5lcmF0b3Ige1xuICBzZXRTZWFyY2hQYXRoKHNlYXJjaFBhdGgpIHtcbiAgICByZXR1cm4gYFNFVCBzZWFyY2hfcGF0aCB0byAke3NlYXJjaFBhdGh9O2A7XG4gIH1cbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBjb2xsYXRlOiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgdmFsdWVzID0ge1xuICAgICAgZGF0YWJhc2U6IHRoaXMucXVvdGVUYWJsZShkYXRhYmFzZU5hbWUpLFxuICAgICAgZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2RpbmcgPyBgIEVOQ09ESU5HID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmVuY29kaW5nKX1gIDogXCJcIixcbiAgICAgIGNvbGxhdGlvbjogb3B0aW9ucy5jb2xsYXRlID8gYCBMQ19DT0xMQVRFID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbGxhdGUpfWAgOiBcIlwiLFxuICAgICAgY3R5cGU6IG9wdGlvbnMuY3R5cGUgPyBgIExDX0NUWVBFID0gJHt0aGlzLmVzY2FwZShvcHRpb25zLmN0eXBlKX1gIDogXCJcIixcbiAgICAgIHRlbXBsYXRlOiBvcHRpb25zLnRlbXBsYXRlID8gYCBURU1QTEFURSA9ICR7dGhpcy5lc2NhcGUob3B0aW9ucy50ZW1wbGF0ZSl9YCA6IFwiXCJcbiAgICB9O1xuICAgIHJldHVybiBgQ1JFQVRFIERBVEFCQVNFICR7dmFsdWVzLmRhdGFiYXNlfSR7dmFsdWVzLmVuY29kaW5nfSR7dmFsdWVzLmNvbGxhdGlvbn0ke3ZhbHVlcy5jdHlwZX0ke3ZhbHVlcy50ZW1wbGF0ZX07YDtcbiAgfVxuICBkcm9wRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgREFUQUJBU0UgSUYgRVhJU1RTICR7dGhpcy5xdW90ZVRhYmxlKGRhdGFiYXNlTmFtZSl9O2A7XG4gIH1cbiAgY3JlYXRlU2NoZW1hKHNjaGVtYSkge1xuICAgIGNvbnN0IGRhdGFiYXNlVmVyc2lvbiA9IF8uZ2V0KHRoaXMsIFwic2VxdWVsaXplLm9wdGlvbnMuZGF0YWJhc2VWZXJzaW9uXCIsIDApO1xuICAgIGlmIChkYXRhYmFzZVZlcnNpb24gJiYgc2VtdmVyLmd0ZShkYXRhYmFzZVZlcnNpb24sIFwiOS4yLjBcIikpIHtcbiAgICAgIHJldHVybiBgQ1JFQVRFIFNDSEVNQSBJRiBOT1QgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKX07YDtcbiAgICB9XG4gICAgcmV0dXJuIGBDUkVBVEUgU0NIRU1BICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKX07YDtcbiAgfVxuICBkcm9wU2NoZW1hKHNjaGVtYSkge1xuICAgIHJldHVybiBgRFJPUCBTQ0hFTUEgSUYgRVhJU1RTICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoc2NoZW1hKX0gQ0FTQ0FERTtgO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIHNjaGVtYV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnNjaGVtYXRhIFdIRVJFIHNjaGVtYV9uYW1lIDw+ICdpbmZvcm1hdGlvbl9zY2hlbWEnIEFORCBzY2hlbWFfbmFtZSAhPSAncHVibGljJyBBTkQgc2NoZW1hX25hbWUgIX4gRSdecGdfJztcIjtcbiAgfVxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0hPVyBTRVJWRVJfVkVSU0lPTlwiO1xuICB9XG4gIGNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhYmFzZVZlcnNpb24gPSBfLmdldCh0aGlzLCBcInNlcXVlbGl6ZS5vcHRpb25zLmRhdGFiYXNlVmVyc2lvblwiLCAwKTtcbiAgICBjb25zdCBhdHRyU3RyID0gW107XG4gICAgbGV0IGNvbW1lbnRzID0gXCJcIjtcbiAgICBsZXQgY29sdW1uQ29tbWVudHMgPSBcIlwiO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgaWYgKG9wdGlvbnMuY29tbWVudCAmJiB0eXBlb2Ygb3B0aW9ucy5jb21tZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb21tZW50cyArPSBgOyBDT01NRU5UIE9OIFRBQkxFICR7cXVvdGVkVGFibGV9IElTICR7dGhpcy5lc2NhcGUob3B0aW9ucy5jb21tZW50KX1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgcXVvdGVkQXR0ciA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpO1xuICAgICAgY29uc3QgaSA9IGF0dHJpYnV0ZXNbYXR0cl0uaW5kZXhPZihcIkNPTU1FTlQgXCIpO1xuICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGVzY2FwZWRDb21tZW50VGV4dCA9IHRoaXMuZXNjYXBlKGF0dHJpYnV0ZXNbYXR0cl0uc3Vic3RyaW5nKGkgKyA4KSk7XG4gICAgICAgIGNvbHVtbkNvbW1lbnRzICs9IGA7IENPTU1FTlQgT04gQ09MVU1OICR7cXVvdGVkVGFibGV9LiR7cXVvdGVkQXR0cn0gSVMgJHtlc2NhcGVkQ29tbWVudFRleHR9YDtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyXSA9IGF0dHJpYnV0ZXNbYXR0cl0uc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YVR5cGUgPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHIsIGF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgYXR0clN0ci5wdXNoKGAke3F1b3RlZEF0dHJ9ICR7ZGF0YVR5cGV9YCk7XG4gICAgfVxuICAgIGxldCBhdHRyaWJ1dGVzQ2xhdXNlID0gYXR0clN0ci5qb2luKFwiLCBcIik7XG4gICAgaWYgKG9wdGlvbnMudW5pcXVlS2V5cykge1xuICAgICAgXy5lYWNoKG9wdGlvbnMudW5pcXVlS2V5cywgKGNvbHVtbnMpID0+IHtcbiAgICAgICAgaWYgKGNvbHVtbnMuY3VzdG9tSW5kZXgpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIFVOSVFVRSAoJHtjb2x1bW5zLmZpZWxkcy5tYXAoKGZpZWxkKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihmaWVsZCkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBrcyA9IF8ucmVkdWNlKGF0dHJpYnV0ZXMsIChhY2MsIGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKS5qb2luKFwiLFwiKTtcbiAgICBpZiAocGtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgUFJJTUFSWSBLRVkgKCR7cGtzfSlgO1xuICAgIH1cbiAgICByZXR1cm4gYENSRUFURSBUQUJMRSAke2RhdGFiYXNlVmVyc2lvbiA9PT0gMCB8fCBzZW12ZXIuZ3RlKGRhdGFiYXNlVmVyc2lvbiwgXCI5LjEuMFwiKSA/IFwiSUYgTk9UIEVYSVNUUyBcIiA6IFwiXCJ9JHtxdW90ZWRUYWJsZX0gKCR7YXR0cmlidXRlc0NsYXVzZX0pJHtjb21tZW50c30ke2NvbHVtbkNvbW1lbnRzfTtgO1xuICB9XG4gIGRyb3BUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0ke29wdGlvbnMuY2FzY2FkZSA/IFwiIENBU0NBREVcIiA6IFwiXCJ9O2A7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMub3B0aW9ucy5zY2hlbWEgfHwgXCJwdWJsaWNcIjtcbiAgICByZXR1cm4gYFNFTEVDVCB0YWJsZV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyBXSEVSRSB0YWJsZV9zY2hlbWEgPSAke3RoaXMuZXNjYXBlKHNjaGVtYSl9IEFORCB0YWJsZV90eXBlIExJS0UgJyVUQUJMRScgQU5EIHRhYmxlX25hbWUgIT0gJ3NwYXRpYWxfcmVmX3N5cyc7YDtcbiAgfVxuICB0YWJsZUV4aXN0c1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlID0gdGFibGVOYW1lLnRhYmxlTmFtZSB8fCB0YWJsZU5hbWU7XG4gICAgY29uc3Qgc2NoZW1hID0gdGFibGVOYW1lLnNjaGVtYSB8fCBcInB1YmxpY1wiO1xuICAgIHJldHVybiBgU0VMRUNUIHRhYmxlX25hbWUgRlJPTSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIFdIRVJFIHRhYmxlX3NjaGVtYSA9ICR7dGhpcy5lc2NhcGUoc2NoZW1hKX0gQU5EIHRhYmxlX25hbWUgPSAke3RoaXMuZXNjYXBlKHRhYmxlKX1gO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSkge1xuICAgIHNjaGVtYSA9IHNjaGVtYSB8fCB0aGlzLm9wdGlvbnMuc2NoZW1hIHx8IFwicHVibGljXCI7XG4gICAgcmV0dXJuIGBTRUxFQ1QgcGsuY29uc3RyYWludF90eXBlIGFzIFwiQ29uc3RyYWludFwiLGMuY29sdW1uX25hbWUgYXMgXCJGaWVsZFwiLCBjLmNvbHVtbl9kZWZhdWx0IGFzIFwiRGVmYXVsdFwiLGMuaXNfbnVsbGFibGUgYXMgXCJOdWxsXCIsIChDQVNFIFdIRU4gYy51ZHRfbmFtZSA9ICdoc3RvcmUnIFRIRU4gYy51ZHRfbmFtZSBFTFNFIGMuZGF0YV90eXBlIEVORCkgfHwgKENBU0UgV0hFTiBjLmNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCBJUyBOT1QgTlVMTCBUSEVOICcoJyB8fCBjLmNoYXJhY3Rlcl9tYXhpbXVtX2xlbmd0aCB8fCAnKScgRUxTRSAnJyBFTkQpIGFzIFwiVHlwZVwiLCAoU0VMRUNUIGFycmF5X2FnZyhlLmVudW1sYWJlbCkgRlJPTSBwZ19jYXRhbG9nLnBnX3R5cGUgdCBKT0lOIHBnX2NhdGFsb2cucGdfZW51bSBlIE9OIHQub2lkPWUuZW51bXR5cGlkIFdIRVJFIHQudHlwbmFtZT1jLnVkdF9uYW1lKSBBUyBcInNwZWNpYWxcIiwgKFNFTEVDVCBwZ2QuZGVzY3JpcHRpb24gRlJPTSBwZ19jYXRhbG9nLnBnX3N0YXRpb19hbGxfdGFibGVzIEFTIHN0IElOTkVSIEpPSU4gcGdfY2F0YWxvZy5wZ19kZXNjcmlwdGlvbiBwZ2Qgb24gKHBnZC5vYmpvaWQ9c3QucmVsaWQpIFdIRVJFIGMub3JkaW5hbF9wb3NpdGlvbj1wZ2Qub2Jqc3ViaWQgQU5EIGMudGFibGVfbmFtZT1zdC5yZWxuYW1lKSBBUyBcIkNvbW1lbnRcIiBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5jb2x1bW5zIGMgTEVGVCBKT0lOIChTRUxFQ1QgdGMudGFibGVfc2NoZW1hLCB0Yy50YWJsZV9uYW1lLCBjdS5jb2x1bW5fbmFtZSwgdGMuY29uc3RyYWludF90eXBlIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLlRBQkxFX0NPTlNUUkFJTlRTIHRjIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLktFWV9DT0xVTU5fVVNBR0UgIGN1IE9OIHRjLnRhYmxlX3NjaGVtYT1jdS50YWJsZV9zY2hlbWEgYW5kIHRjLnRhYmxlX25hbWU9Y3UudGFibGVfbmFtZSBhbmQgdGMuY29uc3RyYWludF9uYW1lPWN1LmNvbnN0cmFpbnRfbmFtZSBhbmQgdGMuY29uc3RyYWludF90eXBlPSdQUklNQVJZIEtFWScpIHBrIE9OIHBrLnRhYmxlX3NjaGVtYT1jLnRhYmxlX3NjaGVtYSBBTkQgcGsudGFibGVfbmFtZT1jLnRhYmxlX25hbWUgQU5EIHBrLmNvbHVtbl9uYW1lPWMuY29sdW1uX25hbWUgV0hFUkUgYy50YWJsZV9uYW1lID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfSBBTkQgYy50YWJsZV9zY2hlbWEgPSAke3RoaXMuZXNjYXBlKHNjaGVtYSl9YDtcbiAgfVxuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBqc29uRnVuY3Rpb25SZWdleCA9IC9eXFxzKigoPzpbYS16XStfKXswLDJ9anNvbmI/KD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuICAgIGNvbnN0IGpzb25PcGVyYXRvclJlZ2V4ID0gL15cXHMqKC0+Pj98Iz4+P3xAPnw8QHxcXD9bfCZdP3xcXHx7Mn18Iy0pL2k7XG4gICAgY29uc3QgdG9rZW5DYXB0dXJlUmVnZXggPSAvXlxccyooKD86KFtgXCInXSkoPzooPyFcXDIpLnxcXDJ7Mn0pKlxcMil8W1xcd1xcZFxcc10rfFsoKS4sOystXSkvaTtcbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IGpzb25GdW5jdGlvblJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmIChmdW5jdGlvbk1hdGNoZXMpIHtcbiAgICAgICAgY3VycmVudEluZGV4ICs9IGZ1bmN0aW9uTWF0Y2hlc1swXS5pbmRleE9mKFwiKFwiKTtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvcGVyYXRvck1hdGNoZXMgPSBqc29uT3BlcmF0b3JSZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAob3BlcmF0b3JNYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBvcGVyYXRvck1hdGNoZXNbMF0ubGVuZ3RoO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRva2VuTWF0Y2hlcyA9IHRva2VuQ2FwdHVyZVJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIjtcIikge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGhhc0ludmFsaWRUb2tlbiB8PSBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cztcbiAgICBpZiAoaGFzSnNvbkZ1bmN0aW9uICYmIGhhc0ludmFsaWRUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGpzb24gc3RhdGVtZW50OiAke3N0bXR9YCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNKc29uRnVuY3Rpb247XG4gIH1cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgaWYgKHNtdGguY29uZGl0aW9ucykge1xuICAgICAgICBjb25zdCBjb25kaXRpb25zID0gdGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdChzbXRoLmNvbmRpdGlvbnMpLm1hcCgoY29uZGl0aW9uKSA9PiBgJHt0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbmRpdGlvbi5wYXRoWzBdLCBfLnRhaWwoY29uZGl0aW9uLnBhdGgpKX0gPSAnJHtjb25kaXRpb24udmFsdWV9J2ApO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9ucy5qb2luKFwiIEFORCBcIik7XG4gICAgICB9XG4gICAgICBpZiAoc210aC5wYXRoKSB7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChzbXRoLnBhdGgpKSB7XG4gICAgICAgICAgc3RyID0gc210aC5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gXy50b1BhdGgoc210aC5wYXRoKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXRocy5zaGlmdCgpO1xuICAgICAgICAgIHN0ciA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNtdGgudmFsdWUpIHtcbiAgICAgICAgICBzdHIgKz0gdXRpbC5mb3JtYXQoXCIgPSAlc1wiLCB0aGlzLmVzY2FwZShzbXRoLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhbmRsZVNlcXVlbGl6ZU1ldGhvZC5jYWxsKHRoaXMsIHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cbiAgYWRkQ29sdW1uUXVlcnkodGFibGUsIGtleSwgYXR0cmlidXRlKSB7XG4gICAgY29uc3QgZGJEYXRhVHlwZSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCB7IGNvbnRleHQ6IFwiYWRkQ29sdW1uXCIsIHRhYmxlLCBrZXkgfSk7XG4gICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGUudHlwZSB8fCBhdHRyaWJ1dGU7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlLCBrZXksIGRiRGF0YVR5cGUpO1xuICAgIGNvbnN0IHF1b3RlZEtleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGtleSk7XG4gICAgY29uc3QgcXVvdGVkVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlKSk7XG4gICAgbGV0IHF1ZXJ5ID0gYEFMVEVSIFRBQkxFICR7cXVvdGVkVGFibGV9IEFERCBDT0xVTU4gJHtxdW90ZWRLZXl9ICR7ZGVmaW5pdGlvbn07YDtcbiAgICBpZiAoZGF0YVR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgcXVlcnkgPSB0aGlzLnBnRW51bSh0YWJsZSwga2V5LCBkYXRhVHlwZSkgKyBxdWVyeTtcbiAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLnR5cGUgJiYgZGF0YVR5cGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5FTlVNKSB7XG4gICAgICBxdWVyeSA9IHRoaXMucGdFbnVtKHRhYmxlLCBrZXksIGRhdGFUeXBlLnR5cGUpICsgcXVlcnk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSkpO1xuICAgIGNvbnN0IHF1b3RlZEF0dHJpYnV0ZU5hbWUgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKTtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfSBEUk9QIENPTFVNTiAke3F1b3RlZEF0dHJpYnV0ZU5hbWV9O2A7XG4gIH1cbiAgY2hhbmdlQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcXVlcnkgPSAoc3ViUXVlcnkpID0+IGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBBTFRFUiBDT0xVTU4gJHtzdWJRdWVyeX07YDtcbiAgICBjb25zdCBzcWwgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IGRlZmluaXRpb24gPSB0aGlzLmRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0pO1xuICAgICAgbGV0IGF0dHJTcWwgPSBcIlwiO1xuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJOT1QgTlVMTFwiKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBTRVQgTk9UIE5VTExgKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZShcIk5PVCBOVUxMXCIsIFwiXCIpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IERST1AgTk9UIE5VTExgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiREVGQVVMVFwiKSkge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBTRVQgREVGQVVMVCAke2RlZmluaXRpb24ubWF0Y2goL0RFRkFVTFQgKFteO10rKS8pWzFdfWApO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8oREVGQVVMVFteO10rKS8sIFwiXCIpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9IERST1AgREVGQVVMVGApO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0uc3RhcnRzV2l0aChcIkVOVU0oXCIpKSB7XG4gICAgICAgIGF0dHJTcWwgKz0gdGhpcy5wZ0VudW0odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvXkVOVU1cXCguK1xcKS8sIHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUsIHsgc2NoZW1hOiBmYWxzZSB9KSk7XG4gICAgICAgIGRlZmluaXRpb24gKz0gYCBVU0lORyAoJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKX06OiR7dGhpcy5wZ0VudW1OYW1lKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSl9KWA7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5tYXRjaCgvVU5JUVVFOyokLykpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvVU5JUVVFOyokLywgXCJcIik7XG4gICAgICAgIGF0dHJTcWwgKz0gcXVlcnkoYEFERCBVTklRVUUgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9KWApLnJlcGxhY2UoXCJBTFRFUiBDT0xVTU5cIiwgXCJcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24ucmVwbGFjZSgvLis/KD89UkVGRVJFTkNFUykvLCBcIlwiKTtcbiAgICAgICAgYXR0clNxbCArPSBxdWVyeShgQUREIEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSkgJHtkZWZpbml0aW9ufWApLnJlcGxhY2UoXCJBTFRFUiBDT0xVTU5cIiwgXCJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyU3FsICs9IHF1ZXJ5KGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpfSBUWVBFICR7ZGVmaW5pdGlvbn1gKTtcbiAgICAgIH1cbiAgICAgIHNxbC5wdXNoKGF0dHJTcWwpO1xuICAgIH1cbiAgICByZXR1cm4gc3FsLmpvaW4oXCJcIik7XG4gIH1cbiAgcmVuYW1lQ29sdW1uUXVlcnkodGFibGVOYW1lLCBhdHRyQmVmb3JlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgYXR0clN0cmluZyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyU3RyaW5nLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0ckJlZm9yZSl9IFRPICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBgQUxURVIgVEFCTEUgJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVOQU1FIENPTFVNTiAke2F0dHJTdHJpbmcuam9pbihcIiwgXCIpfTtgO1xuICB9XG4gIGZuKGZuTmFtZSwgdGFibGVOYW1lLCBwYXJhbWV0ZXJzLCBib2R5LCByZXR1cm5zLCBsYW5ndWFnZSkge1xuICAgIGZuTmFtZSA9IGZuTmFtZSB8fCBcInRlc3RmdW5jXCI7XG4gICAgbGFuZ3VhZ2UgPSBsYW5ndWFnZSB8fCBcInBscGdzcWxcIjtcbiAgICByZXR1cm5zID0gcmV0dXJucyA/IGBSRVRVUk5TICR7cmV0dXJuc31gIDogXCJcIjtcbiAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCBcIlwiO1xuICAgIHJldHVybiBgQ1JFQVRFIE9SIFJFUExBQ0UgRlVOQ1RJT04gcGdfdGVtcC4ke2ZuTmFtZX0oJHtwYXJhbWV0ZXJzfSkgJHtyZXR1cm5zfSBBUyAkZnVuYyQgQkVHSU4gJHtib2R5fSBFTkQ7ICRmdW5jJCBMQU5HVUFHRSAke2xhbmd1YWdlfTsgU0VMRUNUICogRlJPTSBwZ190ZW1wLiR7Zm5OYW1lfSgpO2A7XG4gIH1cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGBUUlVOQ0FURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfWAsXG4gICAgICBvcHRpb25zLnJlc3RhcnRJZGVudGl0eSA/IFwiIFJFU1RBUlQgSURFTlRJVFlcIiA6IFwiXCIsXG4gICAgICBvcHRpb25zLmNhc2NhZGUgPyBcIiBDQVNDQURFXCIgOiBcIlwiXG4gICAgXS5qb2luKFwiXCIpO1xuICB9XG4gIGRlbGV0ZVF1ZXJ5KHRhYmxlTmFtZSwgd2hlcmUsIG9wdGlvbnMgPSB7fSwgbW9kZWwpIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0ID8gYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfWAgOiBcIlwiO1xuICAgIGxldCBwcmltYXJ5S2V5cyA9IFwiXCI7XG4gICAgbGV0IHByaW1hcnlLZXlzU2VsZWN0aW9uID0gXCJcIjtcbiAgICBpZiAod2hlcmVDbGF1c2UpIHtcbiAgICAgIHdoZXJlQ2xhdXNlID0gYCBXSEVSRSAke3doZXJlQ2xhdXNlfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBMSU1JVCBkZWxldGUgd2l0aG91dCBhIG1vZGVsLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBrcyA9IE9iamVjdC52YWx1ZXMobW9kZWwucHJpbWFyeUtleXMpLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrLmZpZWxkKSkuam9pbihcIixcIik7XG4gICAgICBwcmltYXJ5S2V5cyA9IG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCA+IDEgPyBgKCR7cGtzfSlgIDogcGtzO1xuICAgICAgcHJpbWFyeUtleXNTZWxlY3Rpb24gPSBwa3M7XG4gICAgICByZXR1cm4gYERFTEVURSBGUk9NICR7dGFibGV9IFdIRVJFICR7cHJpbWFyeUtleXN9IElOIChTRUxFQ1QgJHtwcmltYXJ5S2V5c1NlbGVjdGlvbn0gRlJPTSAke3RhYmxlfSR7d2hlcmVDbGF1c2V9JHtsaW1pdH0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RhYmxlfSR7d2hlcmVDbGF1c2V9YDtcbiAgfVxuICBzaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIGxldCBzY2hlbWFKb2luID0gXCJcIjtcbiAgICBsZXQgc2NoZW1hV2hlcmUgPSBcIlwiO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBzY2hlbWFKb2luID0gXCIsIHBnX25hbWVzcGFjZSBzXCI7XG4gICAgICBzY2hlbWFXaGVyZSA9IGAgQU5EIHMub2lkID0gdC5yZWxuYW1lc3BhY2UgQU5EIHMubnNwbmFtZSA9ICcke3RhYmxlTmFtZS5zY2hlbWF9J2A7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cbiAgICByZXR1cm4gYFNFTEVDVCBpLnJlbG5hbWUgQVMgbmFtZSwgaXguaW5kaXNwcmltYXJ5IEFTIHByaW1hcnksIGl4LmluZGlzdW5pcXVlIEFTIHVuaXF1ZSwgaXguaW5ka2V5IEFTIGluZGtleSwgYXJyYXlfYWdnKGEuYXR0bnVtKSBhcyBjb2x1bW5faW5kZXhlcywgYXJyYXlfYWdnKGEuYXR0bmFtZSkgQVMgY29sdW1uX25hbWVzLCBwZ19nZXRfaW5kZXhkZWYoaXguaW5kZXhyZWxpZCkgQVMgZGVmaW5pdGlvbiBGUk9NIHBnX2NsYXNzIHQsIHBnX2NsYXNzIGksIHBnX2luZGV4IGl4LCBwZ19hdHRyaWJ1dGUgYSR7c2NoZW1hSm9pbn0gV0hFUkUgdC5vaWQgPSBpeC5pbmRyZWxpZCBBTkQgaS5vaWQgPSBpeC5pbmRleHJlbGlkIEFORCBhLmF0dHJlbGlkID0gdC5vaWQgQU5EIHQucmVsa2luZCA9ICdyJyBhbmQgdC5yZWxuYW1lID0gJyR7dGFibGVOYW1lfScke3NjaGVtYVdoZXJlfSBHUk9VUCBCWSBpLnJlbG5hbWUsIGl4LmluZGV4cmVsaWQsIGl4LmluZGlzcHJpbWFyeSwgaXguaW5kaXN1bmlxdWUsIGl4LmluZGtleSBPUkRFUiBCWSBpLnJlbG5hbWU7YDtcbiAgfVxuICBzaG93Q29uc3RyYWludHNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ1NFTEVDVCBjb25zdHJhaW50X2NhdGFsb2cgQVMgXCJjb25zdHJhaW50Q2F0YWxvZ1wiLCcsXG4gICAgICAnY29uc3RyYWludF9zY2hlbWEgQVMgXCJjb25zdHJhaW50U2NoZW1hXCIsJyxcbiAgICAgICdjb25zdHJhaW50X25hbWUgQVMgXCJjb25zdHJhaW50TmFtZVwiLCcsXG4gICAgICAndGFibGVfY2F0YWxvZyBBUyBcInRhYmxlQ2F0YWxvZ1wiLCcsXG4gICAgICAndGFibGVfc2NoZW1hIEFTIFwidGFibGVTY2hlbWFcIiwnLFxuICAgICAgJ3RhYmxlX25hbWUgQVMgXCJ0YWJsZU5hbWVcIiwnLFxuICAgICAgJ2NvbnN0cmFpbnRfdHlwZSBBUyBcImNvbnN0cmFpbnRUeXBlXCIsJyxcbiAgICAgICdpc19kZWZlcnJhYmxlIEFTIFwiaXNEZWZlcnJhYmxlXCIsJyxcbiAgICAgICdpbml0aWFsbHlfZGVmZXJyZWQgQVMgXCJpbml0aWFsbHlEZWZlcnJlZFwiJyxcbiAgICAgIFwiZnJvbSBJTkZPUk1BVElPTl9TQ0hFTUEudGFibGVfY29uc3RyYWludHNcIixcbiAgICAgIGBXSEVSRSB0YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nO2BcbiAgICBdLmpvaW4oXCIgXCIpO1xuICB9XG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbihcIl9cIil9YCk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICBcIkRST1AgSU5ERVhcIixcbiAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5jb25jdXJyZW50bHkgJiYgXCJDT05DVVJSRU5UTFlcIixcbiAgICAgIGBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcnMoaW5kZXhOYW1lKX1gXG4gICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG4gIH1cbiAgYWRkTGltaXRBbmRPZmZzZXQob3B0aW9ucykge1xuICAgIGxldCBmcmFnbWVudCA9IFwiXCI7XG4gICAgaWYgKG9wdGlvbnMubGltaXQgIT0gbnVsbCkge1xuICAgICAgZnJhZ21lbnQgKz0gXCIgTElNSVQgXCIgKyB0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIGZyYWdtZW50ICs9IFwiIE9GRlNFVCBcIiArIHRoaXMuZXNjYXBlKG9wdGlvbnMub2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9XG4gIGF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KGF0dHJpYnV0ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZSA9IHtcbiAgICAgICAgdHlwZTogYXR0cmlidXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgdHlwZTtcbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSB8fCBhdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSAmJiBhdHRyaWJ1dGUudHlwZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgIGNvbnN0IGVudW1UeXBlID0gYXR0cmlidXRlLnR5cGUudHlwZSB8fCBhdHRyaWJ1dGUudHlwZTtcbiAgICAgIGxldCB2YWx1ZXMgPSBhdHRyaWJ1dGUudmFsdWVzO1xuICAgICAgaWYgKGVudW1UeXBlLnZhbHVlcyAmJiAhYXR0cmlidXRlLnZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBlbnVtVHlwZS52YWx1ZXM7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHR5cGUgPSBgRU5VTSgke3ZhbHVlcy5tYXAoKHZhbHVlKSA9PiB0aGlzLmVzY2FwZSh2YWx1ZSkpLmpvaW4oXCIsIFwiKX0pYDtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZKSB7XG4gICAgICAgICAgdHlwZSArPSBcIltdXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlcyBmb3IgRU5VTSBoYXZlbid0IGJlZW4gZGVmaW5lZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9IGF0dHJpYnV0ZS50eXBlO1xuICAgIH1cbiAgICBsZXQgc3FsID0gdHlwZS50b1N0cmluZygpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlLCBcImFsbG93TnVsbFwiKSAmJiAhYXR0cmlidXRlLmFsbG93TnVsbCkge1xuICAgICAgc3FsICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS5hdXRvSW5jcmVtZW50SWRlbnRpdHkpIHtcbiAgICAgICAgc3FsICs9IFwiIEdFTkVSQVRFRCBCWSBERUZBVUxUIEFTIElERU5USVRZXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcWwgKz0gXCIgU0VSSUFMXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChVdGlscy5kZWZhdWx0VmFsdWVTY2hlbWFibGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIHNxbCArPSBgIERFRkFVTFQgJHt0aGlzLmVzY2FwZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlLCBhdHRyaWJ1dGUpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudW5pcXVlID09PSB0cnVlKSB7XG4gICAgICBzcWwgKz0gXCIgVU5JUVVFXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucHJpbWFyeUtleSkge1xuICAgICAgc3FsICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgbGV0IHJlZmVyZW5jZXNUYWJsZSA9IHRoaXMucXVvdGVUYWJsZShhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCk7XG4gICAgICBsZXQgc2NoZW1hO1xuICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgfSBlbHNlIGlmICgoIWF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsIHx8IHR5cGVvZiBhdHRyaWJ1dGUucmVmZXJlbmNlcy5tb2RlbCA9PSBcInN0cmluZ1wiKSAmJiBvcHRpb25zLnRhYmxlICYmIG9wdGlvbnMudGFibGUuc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYSA9IG9wdGlvbnMudGFibGUuc2NoZW1hO1xuICAgICAgfVxuICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICByZWZlcmVuY2VzVGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEoe1xuICAgICAgICAgIHRhYmxlTmFtZTogcmVmZXJlbmNlc1RhYmxlLFxuICAgICAgICAgIF9zY2hlbWE6IHNjaGVtYVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVmZXJlbmNlc0tleTtcbiAgICAgIGlmICghb3B0aW9ucy53aXRob3V0Rm9yZWlnbktleUNvbnN0cmFpbnRzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgICByZWZlcmVuY2VzS2V5ID0gdGhpcy5xdW90ZUlkZW50aWZpZXJzKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmZXJlbmNlc0tleSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKFwiaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3FsICs9IGAgUkVGRVJFTkNFUyAke3JlZmVyZW5jZXNUYWJsZX0gKCR7cmVmZXJlbmNlc0tleX0pYDtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5vbkRlbGV0ZSkge1xuICAgICAgICAgIHNxbCArPSBgIE9OIERFTEVURSAke2F0dHJpYnV0ZS5vbkRlbGV0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICAgIHNxbCArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzLmRlZmVycmFibGUpIHtcbiAgICAgICAgICBzcWwgKz0gYCAke2F0dHJpYnV0ZS5yZWZlcmVuY2VzLmRlZmVycmFibGUudG9TdHJpbmcodGhpcyl9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLmNvbW1lbnQgJiYgdHlwZW9mIGF0dHJpYnV0ZS5jb21tZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAob3B0aW9ucyAmJiBbXCJhZGRDb2x1bW5cIiwgXCJjaGFuZ2VDb2x1bW5cIl0uaW5jbHVkZXMob3B0aW9ucy5jb250ZXh0KSkge1xuICAgICAgICBjb25zdCBxdW90ZWRBdHRyID0gdGhpcy5xdW90ZUlkZW50aWZpZXIob3B0aW9ucy5rZXkpO1xuICAgICAgICBjb25zdCBlc2NhcGVkQ29tbWVudFRleHQgPSB0aGlzLmVzY2FwZShhdHRyaWJ1dGUuY29tbWVudCk7XG4gICAgICAgIHNxbCArPSBgOyBDT01NRU5UIE9OIENPTFVNTiAke3RoaXMucXVvdGVUYWJsZShvcHRpb25zLnRhYmxlKX0uJHtxdW90ZWRBdHRyfSBJUyAke2VzY2FwZWRDb21tZW50VGV4dH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3FsICs9IGAgQ09NTUVOVCAke2F0dHJpYnV0ZS5jb21tZW50fWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH1cbiAgZGVmZXJDb25zdHJhaW50c1F1ZXJ5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kZWZlcnJhYmxlLnRvU3RyaW5nKHRoaXMpO1xuICB9XG4gIHNldENvbnN0cmFpbnRRdWVyeShjb2x1bW5zLCB0eXBlKSB7XG4gICAgbGV0IGNvbHVtbkZyYWdtZW50ID0gXCJBTExcIjtcbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgY29sdW1uRnJhZ21lbnQgPSBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihjb2x1bW4pKS5qb2luKFwiLCBcIik7XG4gICAgfVxuICAgIHJldHVybiBgU0VUIENPTlNUUkFJTlRTICR7Y29sdW1uRnJhZ21lbnR9ICR7dHlwZX1gO1xuICB9XG4gIHNldERlZmVycmVkUXVlcnkoY29sdW1ucykge1xuICAgIHJldHVybiB0aGlzLnNldENvbnN0cmFpbnRRdWVyeShjb2x1bW5zLCBcIkRFRkVSUkVEXCIpO1xuICB9XG4gIHNldEltbWVkaWF0ZVF1ZXJ5KGNvbHVtbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRDb25zdHJhaW50UXVlcnkoY29sdW1ucywgXCJJTU1FRElBVEVcIik7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICByZXN1bHRbYXR0cmlidXRlLmZpZWxkIHx8IGtleV0gPSB0aGlzLmF0dHJpYnV0ZVRvU1FMKGF0dHJpYnV0ZSwgX19zcHJlYWRWYWx1ZXMoeyBrZXkgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNyZWF0ZVRyaWdnZXIodGFibGVOYW1lLCB0cmlnZ2VyTmFtZSwgZXZlbnRUeXBlLCBmaXJlT25TcGVjLCBmdW5jdGlvbk5hbWUsIGZ1bmN0aW9uUGFyYW1zLCBvcHRpb25zQXJyYXkpIHtcbiAgICBjb25zdCBkZWNvZGVkRXZlbnRUeXBlID0gdGhpcy5kZWNvZGVUcmlnZ2VyRXZlbnRUeXBlKGV2ZW50VHlwZSk7XG4gICAgY29uc3QgZXZlbnRTcGVjID0gdGhpcy5leHBhbmRUcmlnZ2VyRXZlbnRTcGVjKGZpcmVPblNwZWMpO1xuICAgIGNvbnN0IGV4cGFuZGVkT3B0aW9ucyA9IHRoaXMuZXhwYW5kT3B0aW9ucyhvcHRpb25zQXJyYXkpO1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KGZ1bmN0aW9uUGFyYW1zKTtcbiAgICByZXR1cm4gYENSRUFURSAke3RoaXMudHJpZ2dlckV2ZW50VHlwZUlzQ29uc3RyYWludChldmVudFR5cGUpfVRSSUdHRVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcih0cmlnZ2VyTmFtZSl9ICR7ZGVjb2RlZEV2ZW50VHlwZX0gJHtldmVudFNwZWN9IE9OICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9JHtleHBhbmRlZE9wdGlvbnMgPyBgICR7ZXhwYW5kZWRPcHRpb25zfWAgOiBcIlwifSBFWEVDVVRFIFBST0NFRFVSRSAke2Z1bmN0aW9uTmFtZX0oJHtwYXJhbUxpc3R9KTtgO1xuICB9XG4gIGRyb3BUcmlnZ2VyKHRhYmxlTmFtZSwgdHJpZ2dlck5hbWUpIHtcbiAgICByZXR1cm4gYERST1AgVFJJR0dFUiAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyaWdnZXJOYW1lKX0gT04gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gUkVTVFJJQ1Q7YDtcbiAgfVxuICByZW5hbWVUcmlnZ2VyKHRhYmxlTmFtZSwgb2xkVHJpZ2dlck5hbWUsIG5ld1RyaWdnZXJOYW1lKSB7XG4gICAgcmV0dXJuIGBBTFRFUiBUUklHR0VSICR7dGhpcy5xdW90ZUlkZW50aWZpZXIob2xkVHJpZ2dlck5hbWUpfSBPTiAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBSRU5BTUUgVE8gJHt0aGlzLnF1b3RlSWRlbnRpZmllcihuZXdUcmlnZ2VyTmFtZSl9O2A7XG4gIH1cbiAgY3JlYXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBwYXJhbXMsIHJldHVyblR5cGUsIGxhbmd1YWdlLCBib2R5LCBvcHRpb25zQXJyYXksIG9wdGlvbnMpIHtcbiAgICBpZiAoIWZ1bmN0aW9uTmFtZSB8fCAhcmV0dXJuVHlwZSB8fCAhbGFuZ3VhZ2UgfHwgIWJvZHkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcmVhdGVGdW5jdGlvbiBtaXNzaW5nIHNvbWUgcGFyYW1ldGVycy4gRGlkIHlvdSBwYXNzIGZ1bmN0aW9uTmFtZSwgcmV0dXJuVHlwZSwgbGFuZ3VhZ2UgYW5kIGJvZHk/XCIpO1xuICAgIGNvbnN0IHBhcmFtTGlzdCA9IHRoaXMuX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0KHBhcmFtcyk7XG4gICAgY29uc3QgdmFyaWFibGVMaXN0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnZhcmlhYmxlcyA/IHRoaXMuX2V4cGFuZEZ1bmN0aW9uVmFyaWFibGVMaXN0KG9wdGlvbnMudmFyaWFibGVzKSA6IFwiXCI7XG4gICAgY29uc3QgZXhwYW5kZWRPcHRpb25zQXJyYXkgPSB0aGlzLmV4cGFuZE9wdGlvbnMob3B0aW9uc0FycmF5KTtcbiAgICBjb25zdCBzdGF0ZW1lbnQgPSBvcHRpb25zICYmIG9wdGlvbnMuZm9yY2UgPyBcIkNSRUFURSBPUiBSRVBMQUNFIEZVTkNUSU9OXCIgOiBcIkNSRUFURSBGVU5DVElPTlwiO1xuICAgIHJldHVybiBgJHtzdGF0ZW1lbnR9ICR7ZnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pIFJFVFVSTlMgJHtyZXR1cm5UeXBlfSBBUyAkZnVuYyQgJHt2YXJpYWJsZUxpc3R9IEJFR0lOICR7Ym9keX0gRU5EOyAkZnVuYyQgbGFuZ3VhZ2UgJyR7bGFuZ3VhZ2V9JyR7ZXhwYW5kZWRPcHRpb25zQXJyYXl9O2A7XG4gIH1cbiAgZHJvcEZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgcGFyYW1zKSB7XG4gICAgaWYgKCFmdW5jdGlvbk5hbWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZXF1aXJlcyBmdW5jdGlvbk5hbWVcIik7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKTtcbiAgICByZXR1cm4gYERST1AgRlVOQ1RJT04gJHtmdW5jdGlvbk5hbWV9KCR7cGFyYW1MaXN0fSkgUkVTVFJJQ1Q7YDtcbiAgfVxuICByZW5hbWVGdW5jdGlvbihvbGRGdW5jdGlvbk5hbWUsIHBhcmFtcywgbmV3RnVuY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgcGFyYW1MaXN0ID0gdGhpcy5fZXhwYW5kRnVuY3Rpb25QYXJhbUxpc3QocGFyYW1zKTtcbiAgICByZXR1cm4gYEFMVEVSIEZVTkNUSU9OICR7b2xkRnVuY3Rpb25OYW1lfSgke3BhcmFtTGlzdH0pIFJFTkFNRSBUTyAke25ld0Z1bmN0aW9uTmFtZX07YDtcbiAgfVxuICBwZ0VzY2FwZUFuZFF1b3RlKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnF1b3RlSWRlbnRpZmllcihVdGlscy5yZW1vdmVUaWNrcyh0aGlzLmVzY2FwZSh2YWwpLCBcIidcIikpO1xuICB9XG4gIF9leHBhbmRGdW5jdGlvblBhcmFtTGlzdChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDAgfHwgIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX2V4cGFuZEZ1bmN0aW9uUGFyYW1MaXN0OiBmdW5jdGlvbiBwYXJhbWV0ZXJzIGFycmF5IHJlcXVpcmVkLCBpbmNsdWRpbmcgYW4gZW1wdHkgb25lIGZvciBubyBhcmd1bWVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtTGlzdCA9IFtdO1xuICAgIHBhcmFtcy5mb3JFYWNoKChjdXJQYXJhbSkgPT4ge1xuICAgICAgY29uc3QgcGFyYW1EZWYgPSBbXTtcbiAgICAgIGlmIChjdXJQYXJhbS50eXBlKSB7XG4gICAgICAgIGlmIChjdXJQYXJhbS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICBwYXJhbURlZi5wdXNoKGN1clBhcmFtLmRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1clBhcmFtLm5hbWUpIHtcbiAgICAgICAgICBwYXJhbURlZi5wdXNoKGN1clBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtRGVmLnB1c2goY3VyUGFyYW0udHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmdW5jdGlvbiBvciB0cmlnZ2VyIHVzZWQgd2l0aCBhIHBhcmFtZXRlciB3aXRob3V0IGFueSB0eXBlXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgam9pbmVkID0gcGFyYW1EZWYuam9pbihcIiBcIik7XG4gICAgICBpZiAoam9pbmVkKVxuICAgICAgICBwYXJhbUxpc3QucHVzaChqb2luZWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJhbUxpc3Quam9pbihcIiwgXCIpO1xuICB9XG4gIF9leHBhbmRGdW5jdGlvblZhcmlhYmxlTGlzdCh2YXJpYWJsZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFyaWFibGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX2V4cGFuZEZ1bmN0aW9uVmFyaWFibGVMaXN0OiBmdW5jdGlvbiB2YXJpYWJsZXMgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFyaWFibGVEZWZpbml0aW9ucyA9IFtdO1xuICAgIHZhcmlhYmxlcy5mb3JFYWNoKCh2YXJpYWJsZSkgPT4ge1xuICAgICAgaWYgKCF2YXJpYWJsZS5uYW1lIHx8ICF2YXJpYWJsZS50eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZ1bmN0aW9uIHZhcmlhYmxlIG11c3QgaGF2ZSBhIG5hbWUgYW5kIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBsZXQgdmFyaWFibGVEZWZpbml0aW9uID0gYERFQ0xBUkUgJHt2YXJpYWJsZS5uYW1lfSAke3ZhcmlhYmxlLnR5cGV9YDtcbiAgICAgIGlmICh2YXJpYWJsZS5kZWZhdWx0KSB7XG4gICAgICAgIHZhcmlhYmxlRGVmaW5pdGlvbiArPSBgIDo9ICR7dmFyaWFibGUuZGVmYXVsdH1gO1xuICAgICAgfVxuICAgICAgdmFyaWFibGVEZWZpbml0aW9uICs9IFwiO1wiO1xuICAgICAgdmFyaWFibGVEZWZpbml0aW9ucy5wdXNoKHZhcmlhYmxlRGVmaW5pdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhcmlhYmxlRGVmaW5pdGlvbnMuam9pbihcIiBcIik7XG4gIH1cbiAgZXhwYW5kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMgPT09IHZvaWQgMCB8fCBfLmlzRW1wdHkob3B0aW9ucykgPyBcIlwiIDogb3B0aW9ucy5qb2luKFwiIFwiKTtcbiAgfVxuICBkZWNvZGVUcmlnZ2VyRXZlbnRUeXBlKGV2ZW50U3BlY2lmaWVyKSB7XG4gICAgY29uc3QgRVZFTlRfREVDT0RFUiA9IHtcbiAgICAgIFwiYWZ0ZXJcIjogXCJBRlRFUlwiLFxuICAgICAgXCJiZWZvcmVcIjogXCJCRUZPUkVcIixcbiAgICAgIFwiaW5zdGVhZF9vZlwiOiBcIklOU1RFQUQgT0ZcIixcbiAgICAgIFwiYWZ0ZXJfY29uc3RyYWludFwiOiBcIkFGVEVSXCJcbiAgICB9O1xuICAgIGlmICghRVZFTlRfREVDT0RFUltldmVudFNwZWNpZmllcl0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0cmlnZ2VyIGV2ZW50IHNwZWNpZmllZDogJHtldmVudFNwZWNpZmllcn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIEVWRU5UX0RFQ09ERVJbZXZlbnRTcGVjaWZpZXJdO1xuICB9XG4gIHRyaWdnZXJFdmVudFR5cGVJc0NvbnN0cmFpbnQoZXZlbnRTcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gZXZlbnRTcGVjaWZpZXIgPT09IFwiYWZ0ZXJfY29uc3RyYWludFwiID8gXCJDT05TVFJBSU5UIFwiIDogXCJcIjtcbiAgfVxuICBleHBhbmRUcmlnZ2VyRXZlbnRTcGVjKGZpcmVPblNwZWMpIHtcbiAgICBpZiAoXy5pc0VtcHR5KGZpcmVPblNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyB0YWJsZSBjaGFuZ2UgZXZlbnRzIHNwZWNpZmllZCB0byB0cmlnZ2VyIG9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gXy5tYXAoZmlyZU9uU3BlYywgKGZpcmVWYWx1ZSwgZmlyZUtleSkgPT4ge1xuICAgICAgY29uc3QgRVZFTlRfTUFQID0ge1xuICAgICAgICBcImluc2VydFwiOiBcIklOU0VSVFwiLFxuICAgICAgICBcInVwZGF0ZVwiOiBcIlVQREFURVwiLFxuICAgICAgICBcImRlbGV0ZVwiOiBcIkRFTEVURVwiLFxuICAgICAgICBcInRydW5jYXRlXCI6IFwiVFJVTkNBVEVcIlxuICAgICAgfTtcbiAgICAgIGlmICghRVZFTlRfTUFQW2ZpcmVWYWx1ZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJzZVRyaWdnZXJFdmVudFNwZWM6IHVuZGVmaW5lZCB0cmlnZ2VyIGV2ZW50ICR7ZmlyZUtleX1gKTtcbiAgICAgIH1cbiAgICAgIGxldCBldmVudFNwZWMgPSBFVkVOVF9NQVBbZmlyZVZhbHVlXTtcbiAgICAgIGlmIChldmVudFNwZWMgPT09IFwiVVBEQVRFXCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlyZVZhbHVlKSAmJiBmaXJlVmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV2ZW50U3BlYyArPSBgIE9GICR7ZmlyZVZhbHVlLmpvaW4oXCIsIFwiKX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZlbnRTcGVjO1xuICAgIH0pLmpvaW4oXCIgT1IgXCIpO1xuICB9XG4gIHBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgdGFibGVEZXRhaWxzID0gdGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgbGV0IGVudW1OYW1lID0gVXRpbHMuYWRkVGlja3MoVXRpbHMuZ2VuZXJhdGVFbnVtTmFtZSh0YWJsZURldGFpbHMudGFibGVOYW1lLCBhdHRyKSwgJ1wiJyk7XG4gICAgaWYgKG9wdGlvbnMuc2NoZW1hICE9PSBmYWxzZSAmJiB0YWJsZURldGFpbHMuc2NoZW1hKSB7XG4gICAgICBlbnVtTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKHRhYmxlRGV0YWlscy5zY2hlbWEpICsgdGFibGVEZXRhaWxzLmRlbGltaXRlciArIGVudW1OYW1lO1xuICAgIH1cbiAgICByZXR1cm4gZW51bU5hbWU7XG4gIH1cbiAgcGdMaXN0RW51bXModGFibGVOYW1lLCBhdHRyTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBlbnVtTmFtZSA9IFwiXCI7XG4gICAgY29uc3QgdGFibGVEZXRhaWxzID0gdGhpcy5leHRyYWN0VGFibGVEZXRhaWxzKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKHRhYmxlRGV0YWlscy50YWJsZU5hbWUgJiYgYXR0ck5hbWUpIHtcbiAgICAgIGVudW1OYW1lID0gYCBBTkQgdC50eXBuYW1lPSR7dGhpcy5wZ0VudW1OYW1lKHRhYmxlRGV0YWlscy50YWJsZU5hbWUsIGF0dHJOYW1lLCB7IHNjaGVtYTogZmFsc2UgfSkucmVwbGFjZSgvXCIvZywgXCInXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgU0VMRUNUIHQudHlwbmFtZSBlbnVtX25hbWUsIGFycmF5X2FnZyhlLmVudW1sYWJlbCBPUkRFUiBCWSBlbnVtc29ydG9yZGVyKSBlbnVtX3ZhbHVlIEZST00gcGdfdHlwZSB0IEpPSU4gcGdfZW51bSBlIE9OIHQub2lkID0gZS5lbnVtdHlwaWQgSk9JTiBwZ19jYXRhbG9nLnBnX25hbWVzcGFjZSBuIE9OIG4ub2lkID0gdC50eXBuYW1lc3BhY2UgV0hFUkUgbi5uc3BuYW1lID0gJyR7dGFibGVEZXRhaWxzLnNjaGVtYX0nJHtlbnVtTmFtZX0gR1JPVVAgQlkgMWA7XG4gIH1cbiAgcGdFbnVtKHRhYmxlTmFtZSwgYXR0ciwgZGF0YVR5cGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIsIG9wdGlvbnMpO1xuICAgIGxldCB2YWx1ZXM7XG4gICAgaWYgKGRhdGFUeXBlLnZhbHVlcykge1xuICAgICAgdmFsdWVzID0gYEVOVU0oJHtkYXRhVHlwZS52YWx1ZXMubWFwKCh2YWx1ZSkgPT4gdGhpcy5lc2NhcGUodmFsdWUpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlcyA9IGRhdGFUeXBlLnRvU3RyaW5nKCkubWF0Y2goL15FTlVNXFwoLitcXCkvKVswXTtcbiAgICB9XG4gICAgbGV0IHNxbCA9IGBETyAke3RoaXMuZXNjYXBlKGBCRUdJTiBDUkVBVEUgVFlQRSAke2VudW1OYW1lfSBBUyAke3ZhbHVlc307IEVYQ0VQVElPTiBXSEVOIGR1cGxpY2F0ZV9vYmplY3QgVEhFTiBudWxsOyBFTkRgKX07YDtcbiAgICBpZiAoISFvcHRpb25zICYmIG9wdGlvbnMuZm9yY2UgPT09IHRydWUpIHtcbiAgICAgIHNxbCA9IHRoaXMucGdFbnVtRHJvcCh0YWJsZU5hbWUsIGF0dHIpICsgc3FsO1xuICAgIH1cbiAgICByZXR1cm4gc3FsO1xuICB9XG4gIHBnRW51bUFkZCh0YWJsZU5hbWUsIGF0dHIsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW51bU5hbWUgPSB0aGlzLnBnRW51bU5hbWUodGFibGVOYW1lLCBhdHRyKTtcbiAgICBsZXQgc3FsID0gYEFMVEVSIFRZUEUgJHtlbnVtTmFtZX0gQUREIFZBTFVFIGA7XG4gICAgaWYgKHNlbXZlci5ndGUodGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kYXRhYmFzZVZlcnNpb24sIFwiOS4zLjBcIikpIHtcbiAgICAgIHNxbCArPSBcIklGIE5PVCBFWElTVFMgXCI7XG4gICAgfVxuICAgIHNxbCArPSB0aGlzLmVzY2FwZSh2YWx1ZSk7XG4gICAgaWYgKG9wdGlvbnMuYmVmb3JlKSB7XG4gICAgICBzcWwgKz0gYCBCRUZPUkUgJHt0aGlzLmVzY2FwZShvcHRpb25zLmJlZm9yZSl9YDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWZ0ZXIpIHtcbiAgICAgIHNxbCArPSBgIEFGVEVSICR7dGhpcy5lc2NhcGUob3B0aW9ucy5hZnRlcil9YDtcbiAgICB9XG4gICAgcmV0dXJuIHNxbDtcbiAgfVxuICBwZ0VudW1Ecm9wKHRhYmxlTmFtZSwgYXR0ciwgZW51bU5hbWUpIHtcbiAgICBlbnVtTmFtZSA9IGVudW1OYW1lIHx8IHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIpO1xuICAgIHJldHVybiBgRFJPUCBUWVBFIElGIEVYSVNUUyAke2VudW1OYW1lfTsgYDtcbiAgfVxuICBmcm9tQXJyYXkodGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL157LywgXCJcIikucmVwbGFjZSgvfSQvLCBcIlwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IHRleHQubWF0Y2goLyhcIig/OlxcXFwufFteXCJcXFxcXFxcXF0pKlwifFteLF0qKSg/OlxccyosXFxzKnxcXHMqJCkvaWcpO1xuICAgIGlmIChtYXRjaGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbWF0Y2hlcyA9IG1hdGNoZXMubWFwKChtKSA9PiBtLnJlcGxhY2UoL1wiLCQvLCBcIlwiKS5yZXBsYWNlKC8sJC8sIFwiXCIpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIlwiKSk7XG4gICAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgLTEpO1xuICB9XG4gIGRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHIsIGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJTRVJJQUxcIikpIHtcbiAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIkJJR0lOVFwiKSkge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJTRVJJQUxcIiwgXCJCSUdTRVJJQUxcIik7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIkJJR0lOVFwiLCBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJTTUFMTElOVFwiKSkge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJTRVJJQUxcIiwgXCJTTUFMTFNFUklBTFwiKTtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiU01BTExJTlRcIiwgXCJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJJTlRFR0VSXCIsIFwiXCIpO1xuICAgICAgfVxuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiTk9UIE5VTExcIiwgXCJcIik7XG4gICAgfVxuICAgIGlmIChkYXRhVHlwZS5zdGFydHNXaXRoKFwiRU5VTShcIikpIHtcbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZSgvXkVOVU1cXCguK1xcKS8sIHRoaXMucGdFbnVtTmFtZSh0YWJsZU5hbWUsIGF0dHIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFUeXBlO1xuICB9XG4gIGdldEZvcmVpZ25LZXlzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1QgY29ubmFtZSBhcyBjb25zdHJhaW50X25hbWUsIHBnX2NhdGFsb2cucGdfZ2V0X2NvbnN0cmFpbnRkZWYoci5vaWQsIHRydWUpIGFzIGNvbmRlZiBGUk9NIHBnX2NhdGFsb2cucGdfY29uc3RyYWludCByIFdIRVJFIHIuY29ucmVsaWQgPSAoU0VMRUNUIG9pZCBGUk9NIHBnX2NsYXNzIFdIRVJFIHJlbG5hbWUgPSAnJHt0YWJsZU5hbWV9JyBMSU1JVCAxKSBBTkQgci5jb250eXBlID0gJ2YnIE9SREVSIEJZIDE7YDtcbiAgfVxuICBfZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeVByZWZpeCgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgRElTVElOQ1QgdGMuY29uc3RyYWludF9uYW1lIGFzIGNvbnN0cmFpbnRfbmFtZSwgdGMuY29uc3RyYWludF9zY2hlbWEgYXMgY29uc3RyYWludF9zY2hlbWEsIHRjLmNvbnN0cmFpbnRfY2F0YWxvZyBhcyBjb25zdHJhaW50X2NhdGFsb2csIHRjLnRhYmxlX25hbWUgYXMgdGFibGVfbmFtZSx0Yy50YWJsZV9zY2hlbWEgYXMgdGFibGVfc2NoZW1hLHRjLnRhYmxlX2NhdGFsb2cgYXMgdGFibGVfY2F0YWxvZyx0Yy5pbml0aWFsbHlfZGVmZXJyZWQgYXMgaW5pdGlhbGx5X2RlZmVycmVkLHRjLmlzX2RlZmVycmFibGUgYXMgaXNfZGVmZXJyYWJsZSxrY3UuY29sdW1uX25hbWUgYXMgY29sdW1uX25hbWUsY2N1LnRhYmxlX3NjaGVtYSAgQVMgcmVmZXJlbmNlZF90YWJsZV9zY2hlbWEsY2N1LnRhYmxlX2NhdGFsb2cgIEFTIHJlZmVyZW5jZWRfdGFibGVfY2F0YWxvZyxjY3UudGFibGVfbmFtZSAgQVMgcmVmZXJlbmNlZF90YWJsZV9uYW1lLGNjdS5jb2x1bW5fbmFtZSBBUyByZWZlcmVuY2VkX2NvbHVtbl9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlX2NvbnN0cmFpbnRzIEFTIHRjIEpPSU4gaW5mb3JtYXRpb25fc2NoZW1hLmtleV9jb2x1bW5fdXNhZ2UgQVMga2N1IE9OIHRjLmNvbnN0cmFpbnRfbmFtZSA9IGtjdS5jb25zdHJhaW50X25hbWUgSk9JTiBpbmZvcm1hdGlvbl9zY2hlbWEuY29uc3RyYWludF9jb2x1bW5fdXNhZ2UgQVMgY2N1IE9OIGNjdS5jb25zdHJhaW50X25hbWUgPSB0Yy5jb25zdHJhaW50X25hbWUgXCI7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeSh0YWJsZU5hbWUsIGNhdGFsb2dOYW1lLCBzY2hlbWFOYW1lKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX2dldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnlQcmVmaXgoKX1XSEVSRSBjb25zdHJhaW50X3R5cGUgPSAnRk9SRUlHTiBLRVknIEFORCB0Yy50YWJsZV9uYW1lID0gJyR7dGFibGVOYW1lfScke2NhdGFsb2dOYW1lID8gYCBBTkQgdGMudGFibGVfY2F0YWxvZyA9ICcke2NhdGFsb2dOYW1lfSdgIDogXCJcIn0ke3NjaGVtYU5hbWUgPyBgIEFORCB0Yy50YWJsZV9zY2hlbWEgPSAnJHtzY2hlbWFOYW1lfSdgIDogXCJcIn1gO1xuICB9XG4gIGdldEZvcmVpZ25LZXlSZWZlcmVuY2VRdWVyeSh0YWJsZSwgY29sdW1uTmFtZSkge1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRhYmxlLnRhYmxlTmFtZSB8fCB0YWJsZTtcbiAgICBjb25zdCBzY2hlbWEgPSB0YWJsZS5zY2hlbWE7XG4gICAgcmV0dXJuIGAke3RoaXMuX2dldEZvcmVpZ25LZXlSZWZlcmVuY2VzUXVlcnlQcmVmaXgoKX1XSEVSRSBjb25zdHJhaW50X3R5cGUgPSAnRk9SRUlHTiBLRVknIEFORCB0Yy50YWJsZV9uYW1lPScke3RhYmxlTmFtZX0nIEFORCAga2N1LmNvbHVtbl9uYW1lID0gJyR7Y29sdW1uTmFtZX0nJHtzY2hlbWEgPyBgIEFORCB0Yy50YWJsZV9zY2hlbWEgPSAnJHtzY2hlbWF9J2AgOiBcIlwifWA7XG4gIH1cbiAgZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGZvcmVpZ25LZXkpIHtcbiAgICByZXR1cm4gYEFMVEVSIFRBQkxFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IERST1AgQ09OU1RSQUlOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpfTtgO1xuICB9XG4gIHF1b3RlSWRlbnRpZmllcihpZGVudGlmaWVyLCBmb3JjZSkge1xuICAgIGNvbnN0IG9wdEZvcmNlUXVvdGUgPSBmb3JjZSB8fCBmYWxzZTtcbiAgICBjb25zdCBvcHRRdW90ZUlkZW50aWZpZXJzID0gdGhpcy5vcHRpb25zLnF1b3RlSWRlbnRpZmllcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IHJhd0lkZW50aWZpZXIgPSBVdGlscy5yZW1vdmVUaWNrcyhpZGVudGlmaWVyLCAnXCInKTtcbiAgICBpZiAob3B0Rm9yY2VRdW90ZSA9PT0gdHJ1ZSB8fCBvcHRRdW90ZUlkZW50aWZpZXJzICE9PSBmYWxzZSB8fCBpZGVudGlmaWVyLmluY2x1ZGVzKFwiLlwiKSB8fCBpZGVudGlmaWVyLmluY2x1ZGVzKFwiLT5cIikgfHwgUE9TVEdSRVNfUkVTRVJWRURfV09SRFMuaW5jbHVkZXMocmF3SWRlbnRpZmllci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKHJhd0lkZW50aWZpZXIsICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gcmF3SWRlbnRpZmllcjtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBQb3N0Z3Jlc1F1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-interface.js":
/*!*************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query-interface.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DataTypes = __webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Deferrable = __webpack_require__(/*! ../../deferrable */ \"(rsc)/./node_modules/sequelize/lib/deferrable.js\");\nclass PostgresQueryInterface extends QueryInterface {\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n    let sql = \"\";\n    let promises = [];\n    let i = 0;\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: true, raw: true, type: QueryTypes.SELECT })));\n      }\n    }\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n    const addEnumValue = (field, value, relativeValue, position = \"before\", spliceStart = promises.length) => {\n      const valueOptions = __spreadValues({}, options);\n      valueOptions.before = null;\n      valueOptions.after = null;\n      switch (position) {\n        case \"after\":\n          valueOptions.after = relativeValue;\n          break;\n        case \"before\":\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(tableName, field, value, valueOptions), valueOptions);\n      });\n    };\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n      if (type instanceof DataTypes.ENUM || type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM) {\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), __spreadProps(__spreadValues({}, options), { raw: true }));\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n            if (newIdx === -1) {\n              continue;\n            }\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, \"before\", promisesLength);\n            }\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, \"after\");\n            }\n          }\n          enumIdx++;\n        }\n      }\n    }\n    const result = await promises.reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n    return result;\n  }\n  async getForeignKeyReferencesForTable(table, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database, table.schema);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map((fkMeta) => {\n      const _a = Utils.camelizeObjectKeys(fkMeta), { initiallyDeferred, isDeferrable } = _a, remaining = __objRest(_a, [\"initiallyDeferred\", \"isDeferrable\"]);\n      return __spreadProps(__spreadValues({}, remaining), {\n        deferrable: isDeferrable === \"NO\" ? Deferrable.NOT : initiallyDeferred === \"NO\" ? Deferrable.INITIALLY_IMMEDIATE : Deferrable.INITIALLY_DEFERRED\n      });\n    });\n  }\n  async dropEnum(enumName, options) {\n    options = options || {};\n    return this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)), __spreadProps(__spreadValues({}, options), { raw: true }));\n  }\n  async dropAllEnums(options) {\n    options = options || {};\n    const enums = await this.pgListEnums(null, options);\n    return await Promise.all(enums.map((result) => this.sequelize.query(this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)), __spreadProps(__spreadValues({}, options), { raw: true }))));\n  }\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { plain: false, raw: true, type: QueryTypes.SELECT }));\n  }\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: \"tableName\" });\n    if (!instanceTable) {\n      return;\n    }\n    const getTableName = (!options || !options.schema || options.schema === \"public\" ? \"\" : `${options.schema}_`) + tableName;\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), { raw: true })));\n      }\n    }\n    await Promise.all(promises);\n  }\n}\nexports.PostgresQueryInterface = PostgresQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMEVBQWtCO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQywwRUFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjLGlEQUFpRDtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxjQUFjLFdBQVc7QUFDakssV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0NBQWtDO0FBQ3ZGLDRDQUE0QztBQUM1QztBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMkpBQTJKLGNBQWMsV0FBVztBQUNwTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJNQUEyTSxjQUFjLFdBQVc7QUFDcE87QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYyxrREFBa0Q7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixlQUFlO0FBQzlHO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYyxXQUFXO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3F1ZXJ5LWludGVyZmFjZS5qcz9iY2ZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9xdWVyeS10eXBlc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1pbnRlcmZhY2VcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IERlZmVycmFibGUgPSByZXF1aXJlKFwiLi4vLi4vZGVmZXJyYWJsZVwiKTtcbmNsYXNzIFBvc3RncmVzUXVlcnlJbnRlcmZhY2UgZXh0ZW5kcyBRdWVyeUludGVyZmFjZSB7XG4gIGFzeW5jIGVuc3VyZUVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucywgbW9kZWwpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyk7XG4gICAgY29uc3Qga2V5TGVuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IHNxbCA9IFwiXCI7XG4gICAgbGV0IHByb21pc2VzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXlzW2ldXTtcbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcbiAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0gfHwgdHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSAmJiB0eXBlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnTGlzdEVudW1zKHRhYmxlTmFtZSwgYXR0cmlidXRlLmZpZWxkIHx8IGtleXNbaV0sIG9wdGlvbnMpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgcGxhaW46IHRydWUsIHJhdzogdHJ1ZSwgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QgfSkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBwcm9taXNlcyA9IFtdO1xuICAgIGxldCBlbnVtSWR4ID0gMDtcbiAgICBjb25zdCBhZGRFbnVtVmFsdWUgPSAoZmllbGQsIHZhbHVlLCByZWxhdGl2ZVZhbHVlLCBwb3NpdGlvbiA9IFwiYmVmb3JlXCIsIHNwbGljZVN0YXJ0ID0gcHJvbWlzZXMubGVuZ3RoKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZU9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyk7XG4gICAgICB2YWx1ZU9wdGlvbnMuYmVmb3JlID0gbnVsbDtcbiAgICAgIHZhbHVlT3B0aW9ucy5hZnRlciA9IG51bGw7XG4gICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJhZnRlclwiOlxuICAgICAgICAgIHZhbHVlT3B0aW9ucy5hZnRlciA9IHJlbGF0aXZlVmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiZWZvcmVcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZU9wdGlvbnMuYmVmb3JlID0gcmVsYXRpdmVWYWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByb21pc2VzLnNwbGljZShzcGxpY2VTdGFydCwgMCwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW1BZGQodGFibGVOYW1lLCBmaWVsZCwgdmFsdWUsIHZhbHVlT3B0aW9ucyksIHZhbHVlT3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBrZXlMZW47IGkrKykge1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlc1trZXlzW2ldXTtcbiAgICAgIGNvbnN0IHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcbiAgICAgIGNvbnN0IGVudW1UeXBlID0gdHlwZS50eXBlIHx8IHR5cGU7XG4gICAgICBjb25zdCBmaWVsZCA9IGF0dHJpYnV0ZS5maWVsZCB8fCBrZXlzW2ldO1xuICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSB8fCB0eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkFSUkFZICYmIGVudW1UeXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkVOVU0pIHtcbiAgICAgICAgaWYgKCFyZXN1bHRzW2VudW1JZHhdKSB7XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZWxpemUucXVlcnkodGhpcy5xdWVyeUdlbmVyYXRvci5wZ0VudW0odGFibGVOYW1lLCBmaWVsZCwgZW51bVR5cGUsIG9wdGlvbnMpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyByYXc6IHRydWUgfSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKCEhcmVzdWx0c1tlbnVtSWR4XSAmJiAhIW1vZGVsKSB7XG4gICAgICAgICAgY29uc3QgZW51bVZhbHMgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmZyb21BcnJheShyZXN1bHRzW2VudW1JZHhdLmVudW1fdmFsdWUpO1xuICAgICAgICAgIGNvbnN0IHZhbHMgPSBlbnVtVHlwZS52YWx1ZXM7XG4gICAgICAgICAgbGV0IGxhc3RPbGRFbnVtVmFsdWU7XG4gICAgICAgICAgbGV0IHJpZ2h0ZXN0UG9zaXRpb24gPSAtMTtcbiAgICAgICAgICBmb3IgKGxldCBvbGRJbmRleCA9IDA7IG9sZEluZGV4IDwgZW51bVZhbHMubGVuZ3RoOyBvbGRJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbnVtVmFsID0gZW51bVZhbHNbb2xkSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbmV3SWR4ID0gdmFscy5pbmRleE9mKGVudW1WYWwpO1xuICAgICAgICAgICAgbGFzdE9sZEVudW1WYWx1ZSA9IGVudW1WYWw7XG4gICAgICAgICAgICBpZiAobmV3SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlc0JlZm9yZSA9IHZhbHMuc2xpY2UoMCwgbmV3SWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzTGVuZ3RoID0gcHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgcmV2ZXJzZUlkeCA9IG5ld1ZhbHVlc0JlZm9yZS5sZW5ndGggLSAxOyByZXZlcnNlSWR4ID49IDA7IHJldmVyc2VJZHgtLSkge1xuICAgICAgICAgICAgICBpZiAofmVudW1WYWxzLmluZGV4T2YobmV3VmFsdWVzQmVmb3JlW3JldmVyc2VJZHhdKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZEVudW1WYWx1ZShmaWVsZCwgbmV3VmFsdWVzQmVmb3JlW3JldmVyc2VJZHhdLCBsYXN0T2xkRW51bVZhbHVlLCBcImJlZm9yZVwiLCBwcm9taXNlc0xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3SWR4ID4gcmlnaHRlc3RQb3NpdGlvbikge1xuICAgICAgICAgICAgICByaWdodGVzdFBvc2l0aW9uID0gbmV3SWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdE9sZEVudW1WYWx1ZSAmJiByaWdodGVzdFBvc2l0aW9uIDwgdmFscy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdFbnVtVmFsdWVzID0gdmFscy5zbGljZShyaWdodGVzdFBvc2l0aW9uICsgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCByZXZlcnNlSWR4ID0gcmVtYWluaW5nRW51bVZhbHVlcy5sZW5ndGggLSAxOyByZXZlcnNlSWR4ID49IDA7IHJldmVyc2VJZHgtLSkge1xuICAgICAgICAgICAgICBhZGRFbnVtVmFsdWUoZmllbGQsIHJlbWFpbmluZ0VudW1WYWx1ZXNbcmV2ZXJzZUlkeF0sIGxhc3RPbGRFbnVtVmFsdWUsIFwiYWZ0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVudW1JZHgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlcy5yZWR1Y2UoYXN5bmMgKHByb21pc2UsIGFzeW5jRnVuY3Rpb24pID0+IGF3YWl0IGFzeW5jRnVuY3Rpb24oYXdhaXQgcHJvbWlzZSksIFByb21pc2UucmVzb2x2ZSgpKTtcbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyLl9yZWZyZXNoRHluYW1pY09JRHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlPcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHR5cGU6IFF1ZXJ5VHlwZXMuRk9SRUlHTktFWVNcbiAgICB9KTtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNRdWVyeSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUsIHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZSwgdGFibGUuc2NoZW1hKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgcXVlcnlPcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCgoZmtNZXRhKSA9PiB7XG4gICAgICBjb25zdCBfYSA9IFV0aWxzLmNhbWVsaXplT2JqZWN0S2V5cyhma01ldGEpLCB7IGluaXRpYWxseURlZmVycmVkLCBpc0RlZmVycmFibGUgfSA9IF9hLCByZW1haW5pbmcgPSBfX29ialJlc3QoX2EsIFtcImluaXRpYWxseURlZmVycmVkXCIsIFwiaXNEZWZlcnJhYmxlXCJdKTtcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCByZW1haW5pbmcpLCB7XG4gICAgICAgIGRlZmVycmFibGU6IGlzRGVmZXJyYWJsZSA9PT0gXCJOT1wiID8gRGVmZXJyYWJsZS5OT1QgOiBpbml0aWFsbHlEZWZlcnJlZCA9PT0gXCJOT1wiID8gRGVmZXJyYWJsZS5JTklUSUFMTFlfSU1NRURJQVRFIDogRGVmZXJyYWJsZS5JTklUSUFMTFlfREVGRVJSRURcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRyb3BFbnVtKGVudW1OYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtRHJvcChudWxsLCBudWxsLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRXNjYXBlQW5kUXVvdGUoZW51bU5hbWUpKSwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgcmF3OiB0cnVlIH0pKTtcbiAgfVxuICBhc3luYyBkcm9wQWxsRW51bXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGVudW1zID0gYXdhaXQgdGhpcy5wZ0xpc3RFbnVtcyhudWxsLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoZW51bXMubWFwKChyZXN1bHQpID0+IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IucGdFbnVtRHJvcChudWxsLCBudWxsLCB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRXNjYXBlQW5kUXVvdGUocmVzdWx0LmVudW1fbmFtZSkpLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyByYXc6IHRydWUgfSkpKSk7XG4gIH1cbiAgYXN5bmMgcGdMaXN0RW51bXModGFibGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgc3FsID0gdGhpcy5xdWVyeUdlbmVyYXRvci5wZ0xpc3RFbnVtcyh0YWJsZU5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHBsYWluOiBmYWxzZSwgcmF3OiB0cnVlLCB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVCB9KSk7XG4gIH1cbiAgYXN5bmMgZHJvcFRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGF3YWl0IHN1cGVyLmRyb3BUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgY29uc3QgaW5zdGFuY2VUYWJsZSA9IHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5nZXRNb2RlbCh0YWJsZU5hbWUsIHsgYXR0cmlidXRlOiBcInRhYmxlTmFtZVwiIH0pO1xuICAgIGlmICghaW5zdGFuY2VUYWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBnZXRUYWJsZU5hbWUgPSAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2NoZW1hIHx8IG9wdGlvbnMuc2NoZW1hID09PSBcInB1YmxpY1wiID8gXCJcIiA6IGAke29wdGlvbnMuc2NoZW1hfV9gKSArIHRhYmxlTmFtZTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaW5zdGFuY2VUYWJsZS5yYXdBdHRyaWJ1dGVzKTtcbiAgICBjb25zdCBrZXlMZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUxlbjsgaSsrKSB7XG4gICAgICBpZiAoaW5zdGFuY2VUYWJsZS5yYXdBdHRyaWJ1dGVzW2tleXNbaV1dLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnBnRW51bURyb3AoZ2V0VGFibGVOYW1lLCBrZXlzW2ldKTtcbiAgICAgICAgb3B0aW9ucy5zdXBwb3J0c1NlYXJjaFBhdGggPSBmYWxzZTtcbiAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHJhdzogdHJ1ZSB9KSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIH1cbn1cbmV4cG9ydHMuUG9zdGdyZXNRdWVyeUludGVyZmFjZSA9IFBvc3RncmVzUXVlcnlJbnRlcmZhY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1pbnRlcmZhY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/query.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:pg\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const stringReplaceFunc = (value) => typeof value === \"string\" ? value.replace(/\\0/g, \"\\\\0\") : value;\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = values.map(stringReplaceFunc);\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = [];\n      let i = 0;\n      const seen = {};\n      const replacementFunc = (match, key, values2) => {\n        if (seen[key] !== void 0) {\n          return seen[key];\n        }\n        if (values2[key] !== void 0) {\n          i = i + 1;\n          bindParam.push(stringReplaceFunc(values2[key]));\n          seen[key] = `$${i}`;\n          return `$${i}`;\n        }\n        return void 0;\n      };\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    }\n    return [sql, bindParam];\n  }\n  async run(sql, parameters) {\n    const { connection } = this;\n    if (!_.isEmpty(this.options.searchPath)) {\n      sql = this.sequelize.getQueryInterface().queryGenerator.setSearchPath(this.options.searchPath) + sql;\n    }\n    if (this.sequelize.options.minifyAliases && this.options.includeAliases) {\n      _.toPairs(this.options.includeAliases).sort((a, b) => b[1].length - a[1].length).forEach(([alias, original]) => {\n        const reg = new RegExp(_.escapeRegExp(original), \"g\");\n        sql = sql.replace(reg, alias);\n      });\n    }\n    this.sql = sql;\n    const query = parameters && parameters.length ? new Promise((resolve, reject) => connection.query(sql, parameters, (error, result) => error ? reject(error) : resolve(result))) : new Promise((resolve, reject) => connection.query(sql, (error, result) => error ? reject(error) : resolve(result)));\n    const complete = this._logQuery(sql, debug, parameters);\n    let queryResult;\n    const errForStack = new Error();\n    try {\n      queryResult = await query;\n    } catch (error) {\n      if (error.code === \"ECONNRESET\" || /Unable to set non-blocking to true/i.test(error) || /SSL SYSCALL error: EOF detected/i.test(error) || /Local: Authentication failure/i.test(error) || error.message === \"Query read timeout\") {\n        connection._invalid = true;\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error, errForStack.stack);\n    }\n    complete();\n    let rows = Array.isArray(queryResult) ? queryResult.reduce((allRows, r) => allRows.concat(r.rows || []), []) : queryResult.rows;\n    const rowCount = Array.isArray(queryResult) ? queryResult.reduce((count, r) => Number.isFinite(r.rowCount) ? count + r.rowCount : count, 0) : queryResult.rowCount || 0;\n    if (this.sequelize.options.minifyAliases && this.options.aliasesMapping) {\n      rows = rows.map((row) => _.toPairs(row).reduce((acc, [key, value]) => {\n        const mapping = this.options.aliasesMapping.get(key);\n        acc[mapping || key] = value;\n        return acc;\n      }, {}));\n    }\n    const isTableNameQuery = sql.startsWith(\"SELECT table_name FROM information_schema.tables\");\n    const isRelNameQuery = sql.startsWith(\"SELECT relname FROM pg_class WHERE oid IN\");\n    if (isRelNameQuery) {\n      return rows.map((row) => ({\n        name: row.relname,\n        tableName: row.relname.split(\"_\")[0]\n      }));\n    }\n    if (isTableNameQuery) {\n      return rows.map((row) => Object.values(row));\n    }\n    if (rows[0] && rows[0].sequelize_caught_exception !== void 0) {\n      if (rows[0].sequelize_caught_exception !== null) {\n        throw this.formatError({\n          sql,\n          parameters,\n          code: \"23505\",\n          detail: rows[0].sequelize_caught_exception\n        });\n      }\n      for (const row of rows) {\n        delete row.sequelize_caught_exception;\n      }\n    }\n    if (this.isShowIndexesQuery()) {\n      for (const row of rows) {\n        const attributes = /ON .*? (?:USING .*?\\s)?\\(([^]*)\\)/gi.exec(row.definition)[1].split(\",\");\n        const columns = _.zipObject(row.column_indexes, this.sequelize.getQueryInterface().queryGenerator.fromArray(row.column_names));\n        delete row.column_indexes;\n        delete row.column_names;\n        let field;\n        let attribute;\n        row.fields = row.indkey.split(\" \").map((indKey, index) => {\n          field = columns[indKey];\n          if (!field) {\n            return null;\n          }\n          attribute = attributes[index];\n          return {\n            attribute: field,\n            collate: attribute.match(/COLLATE \"(.*?)\"/) ? /COLLATE \"(.*?)\"/.exec(attribute)[1] : void 0,\n            order: attribute.includes(\"DESC\") ? \"DESC\" : attribute.includes(\"ASC\") ? \"ASC\" : void 0,\n            length: void 0\n          };\n        }).filter((n) => n !== null);\n        delete row.columns;\n      }\n      return rows;\n    }\n    if (this.isForeignKeysQuery()) {\n      const result = [];\n      for (const row of rows) {\n        let defParts;\n        if (row.condef !== void 0 && (defParts = row.condef.match(/FOREIGN KEY \\((.+)\\) REFERENCES (.+)\\((.+)\\)( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?( ON (UPDATE|DELETE) (CASCADE|RESTRICT))?/))) {\n          row.id = row.constraint_name;\n          row.table = defParts[2];\n          row.from = defParts[1];\n          row.to = defParts[3];\n          let i;\n          for (i = 5; i <= 8; i += 3) {\n            if (/(UPDATE|DELETE)/.test(defParts[i])) {\n              row[`on_${defParts[i].toLowerCase()}`] = defParts[i + 1];\n            }\n          }\n        }\n        result.push(row);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      let result = rows;\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const attrsMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toLowerCase()] = k;\n          return m;\n        }, {});\n        result = rows.map((row) => {\n          return _.mapKeys(row, (value, key) => {\n            const targetAttr = attrsMap[key];\n            if (typeof targetAttr === \"string\" && targetAttr !== key) {\n              return targetAttr;\n            }\n            return key;\n          });\n        });\n      }\n      return this.handleSelectQuery(result);\n    }\n    if (QueryTypes.DESCRIBE === this.options.type) {\n      const result = {};\n      for (const row of rows) {\n        result[row.Field] = {\n          type: row.Type.toUpperCase(),\n          allowNull: row.Null === \"YES\",\n          defaultValue: row.Default,\n          comment: row.Comment,\n          special: row.special ? this.sequelize.getQueryInterface().queryGenerator.fromArray(row.special) : [],\n          primaryKey: row.Constraint === \"PRIMARY KEY\"\n        };\n        if (result[row.Field].type === \"BOOLEAN\") {\n          result[row.Field].defaultValue = { \"false\": false, \"true\": true }[result[row.Field].defaultValue];\n          if (result[row.Field].defaultValue === void 0) {\n            result[row.Field].defaultValue = null;\n          }\n        }\n        if (typeof result[row.Field].defaultValue === \"string\") {\n          result[row.Field].defaultValue = result[row.Field].defaultValue.replace(/'/g, \"\");\n          if (result[row.Field].defaultValue.includes(\"::\")) {\n            const split = result[row.Field].defaultValue.split(\"::\");\n            if (split[1].toLowerCase() !== \"regclass)\") {\n              result[row.Field].defaultValue = split[0];\n            }\n          }\n        }\n      }\n      return result;\n    }\n    if (this.isVersionQuery()) {\n      return rows[0].server_version;\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return rows;\n    }\n    if (QueryTypes.BULKUPDATE === this.options.type) {\n      if (!this.options.returning) {\n        return parseInt(rowCount, 10);\n      }\n      return this.handleSelectQuery(rows);\n    }\n    if (QueryTypes.BULKDELETE === this.options.type) {\n      return parseInt(rowCount, 10);\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery()) {\n      if (this.instance && this.instance.dataValues) {\n        if (this.isInsertQuery() && !this.isUpsertQuery() && rowCount === 0) {\n          throw new sequelizeErrors.EmptyResultError();\n        }\n        for (const key in rows[0]) {\n          if (Object.prototype.hasOwnProperty.call(rows[0], key)) {\n            const record = rows[0][key];\n            const attr = _.find(this.model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n            this.instance.dataValues[attr && attr.fieldName || key] = record;\n          }\n        }\n      }\n      if (this.isUpsertQuery()) {\n        return [\n          this.instance,\n          null\n        ];\n      }\n      return [\n        this.instance || rows && (this.options.plain && rows[0] || rows) || void 0,\n        rowCount\n      ];\n    }\n    if (this.isRawQuery()) {\n      return [rows, queryResult];\n    }\n    return rows;\n  }\n  formatError(err, errStack) {\n    let match;\n    let table;\n    let index;\n    let fields;\n    let errors;\n    let message;\n    const code = err.code || err.sqlState;\n    const errMessage = err.message || err.messagePrimary;\n    const errDetail = err.detail || err.messageDetail;\n    switch (code) {\n      case \"23503\":\n        index = errMessage.match(/violates foreign key constraint \"(.+?)\"/);\n        index = index ? index[1] : void 0;\n        table = errMessage.match(/on table \"(.+?)\"/);\n        table = table ? table[1] : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          message: errMessage,\n          fields: null,\n          index,\n          table,\n          parent: err,\n          stack: errStack\n        });\n      case \"23505\":\n        if (errDetail && (match = errDetail.replace(/\"/g, \"\").match(/Key \\((.*?)\\)=\\((.*?)\\)/))) {\n          fields = _.zipObject(match[1].split(\", \"), match[2].split(\", \"));\n          errors = [];\n          message = \"Validation error\";\n          _.forOwn(fields, (value, field) => {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n          });\n          if (this.model && this.model.uniqueKeys) {\n            _.forOwn(this.model.uniqueKeys, (constraint) => {\n              if (_.isEqual(constraint.fields, Object.keys(fields)) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n          return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n        }\n        return new sequelizeErrors.UniqueConstraintError({\n          message: errMessage,\n          parent: err,\n          stack: errStack\n        });\n      case \"23P01\":\n        match = errDetail.match(/Key \\((.*?)\\)=\\((.*?)\\)/);\n        if (match) {\n          fields = _.zipObject(match[1].split(\", \"), match[2].split(\", \"));\n        }\n        message = \"Exclusion constraint error\";\n        return new sequelizeErrors.ExclusionConstraintError({\n          message,\n          constraint: err.constraint,\n          fields,\n          table: err.table,\n          parent: err,\n          stack: errStack\n        });\n      case \"42704\":\n        if (err.sql && /(CONSTRAINT|INDEX)/gi.test(err.sql)) {\n          message = \"Unknown constraint error\";\n          index = errMessage.match(/(?:constraint|index) \"(.+?)\"/i);\n          index = index ? index[1] : void 0;\n          table = errMessage.match(/relation \"(.+?)\"/i);\n          table = table ? table[1] : void 0;\n          throw new sequelizeErrors.UnknownConstraintError({\n            message,\n            constraint: index,\n            fields,\n            table,\n            parent: err,\n            stack: errStack\n          });\n        }\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  isForeignKeysQuery() {\n    return /SELECT conname as constraint_name, pg_catalog\\.pg_get_constraintdef\\(r\\.oid, true\\) as condef FROM pg_catalog\\.pg_constraint r WHERE r\\.conrelid = \\(SELECT oid FROM pg_class WHERE relname = '.*' LIMIT 1\\) AND r\\.contype = 'f' ORDER BY 1;/.test(this.sql);\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9xdWVyeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHdCQUF3QjtBQUMvRixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QixxQkFBcUIsRUFBRTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw4QkFBOEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2REFBNkQsdURBQXVEO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQSx5UEFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvcG9zdGdyZXMvcXVlcnkuanM/NTk5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6cGdcIik7XG5jbGFzcyBRdWVyeSBleHRlbmRzIEFic3RyYWN0UXVlcnkge1xuICBzdGF0aWMgZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QpIHtcbiAgICBjb25zdCBzdHJpbmdSZXBsYWNlRnVuYyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUucmVwbGFjZSgvXFwwL2csIFwiXFxcXDBcIikgOiB2YWx1ZTtcbiAgICBsZXQgYmluZFBhcmFtO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIGJpbmRQYXJhbSA9IHZhbHVlcy5tYXAoc3RyaW5nUmVwbGFjZUZ1bmMpO1xuICAgICAgc3FsID0gQWJzdHJhY3RRdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIHZhbHVlcywgZGlhbGVjdCwgeyBza2lwVmFsdWVSZXBsYWNlOiB0cnVlIH0pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBiaW5kUGFyYW0gPSBbXTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50RnVuYyA9IChtYXRjaCwga2V5LCB2YWx1ZXMyKSA9PiB7XG4gICAgICAgIGlmIChzZWVuW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBzZWVuW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlczJba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaSA9IGkgKyAxO1xuICAgICAgICAgIGJpbmRQYXJhbS5wdXNoKHN0cmluZ1JlcGxhY2VGdW5jKHZhbHVlczJba2V5XSkpO1xuICAgICAgICAgIHNlZW5ba2V5XSA9IGAkJHtpfWA7XG4gICAgICAgICAgcmV0dXJuIGAkJHtpfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCByZXBsYWNlbWVudEZ1bmMpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gW3NxbCwgYmluZFBhcmFtXTtcbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB0aGlzO1xuICAgIGlmICghXy5pc0VtcHR5KHRoaXMub3B0aW9ucy5zZWFyY2hQYXRoKSkge1xuICAgICAgc3FsID0gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5xdWVyeUdlbmVyYXRvci5zZXRTZWFyY2hQYXRoKHRoaXMub3B0aW9ucy5zZWFyY2hQYXRoKSArIHNxbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiB0aGlzLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMpIHtcbiAgICAgIF8udG9QYWlycyh0aGlzLm9wdGlvbnMuaW5jbHVkZUFsaWFzZXMpLnNvcnQoKGEsIGIpID0+IGJbMV0ubGVuZ3RoIC0gYVsxXS5sZW5ndGgpLmZvckVhY2goKFthbGlhcywgb3JpZ2luYWxdKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZyA9IG5ldyBSZWdFeHAoXy5lc2NhcGVSZWdFeHAob3JpZ2luYWwpLCBcImdcIik7XG4gICAgICAgIHNxbCA9IHNxbC5yZXBsYWNlKHJlZywgYWxpYXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuc3FsID0gc3FsO1xuICAgIGNvbnN0IHF1ZXJ5ID0gcGFyYW1ldGVycyAmJiBwYXJhbWV0ZXJzLmxlbmd0aCA/IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNvbm5lY3Rpb24ucXVlcnkoc3FsLCBwYXJhbWV0ZXJzLCAoZXJyb3IsIHJlc3VsdCkgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZShyZXN1bHQpKSkgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBjb25uZWN0aW9uLnF1ZXJ5KHNxbCwgKGVycm9yLCByZXN1bHQpID0+IGVycm9yID8gcmVqZWN0KGVycm9yKSA6IHJlc29sdmUocmVzdWx0KSkpO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgbGV0IHF1ZXJ5UmVzdWx0O1xuICAgIGNvbnN0IGVyckZvclN0YWNrID0gbmV3IEVycm9yKCk7XG4gICAgdHJ5IHtcbiAgICAgIHF1ZXJ5UmVzdWx0ID0gYXdhaXQgcXVlcnk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVDT05OUkVTRVRcIiB8fCAvVW5hYmxlIHRvIHNldCBub24tYmxvY2tpbmcgdG8gdHJ1ZS9pLnRlc3QoZXJyb3IpIHx8IC9TU0wgU1lTQ0FMTCBlcnJvcjogRU9GIGRldGVjdGVkL2kudGVzdChlcnJvcikgfHwgL0xvY2FsOiBBdXRoZW50aWNhdGlvbiBmYWlsdXJlL2kudGVzdChlcnJvcikgfHwgZXJyb3IubWVzc2FnZSA9PT0gXCJRdWVyeSByZWFkIHRpbWVvdXRcIikge1xuICAgICAgICBjb25uZWN0aW9uLl9pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgIGVycm9yLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvciwgZXJyRm9yU3RhY2suc3RhY2spO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpO1xuICAgIGxldCByb3dzID0gQXJyYXkuaXNBcnJheShxdWVyeVJlc3VsdCkgPyBxdWVyeVJlc3VsdC5yZWR1Y2UoKGFsbFJvd3MsIHIpID0+IGFsbFJvd3MuY29uY2F0KHIucm93cyB8fCBbXSksIFtdKSA6IHF1ZXJ5UmVzdWx0LnJvd3M7XG4gICAgY29uc3Qgcm93Q291bnQgPSBBcnJheS5pc0FycmF5KHF1ZXJ5UmVzdWx0KSA/IHF1ZXJ5UmVzdWx0LnJlZHVjZSgoY291bnQsIHIpID0+IE51bWJlci5pc0Zpbml0ZShyLnJvd0NvdW50KSA/IGNvdW50ICsgci5yb3dDb3VudCA6IGNvdW50LCAwKSA6IHF1ZXJ5UmVzdWx0LnJvd0NvdW50IHx8IDA7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMubWluaWZ5QWxpYXNlcyAmJiB0aGlzLm9wdGlvbnMuYWxpYXNlc01hcHBpbmcpIHtcbiAgICAgIHJvd3MgPSByb3dzLm1hcCgocm93KSA9PiBfLnRvUGFpcnMocm93KS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcHBpbmcgPSB0aGlzLm9wdGlvbnMuYWxpYXNlc01hcHBpbmcuZ2V0KGtleSk7XG4gICAgICAgIGFjY1ttYXBwaW5nIHx8IGtleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KSk7XG4gICAgfVxuICAgIGNvbnN0IGlzVGFibGVOYW1lUXVlcnkgPSBzcWwuc3RhcnRzV2l0aChcIlNFTEVDVCB0YWJsZV9uYW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlc1wiKTtcbiAgICBjb25zdCBpc1JlbE5hbWVRdWVyeSA9IHNxbC5zdGFydHNXaXRoKFwiU0VMRUNUIHJlbG5hbWUgRlJPTSBwZ19jbGFzcyBXSEVSRSBvaWQgSU5cIik7XG4gICAgaWYgKGlzUmVsTmFtZVF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAoKHJvdykgPT4gKHtcbiAgICAgICAgbmFtZTogcm93LnJlbG5hbWUsXG4gICAgICAgIHRhYmxlTmFtZTogcm93LnJlbG5hbWUuc3BsaXQoXCJfXCIpWzBdXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChpc1RhYmxlTmFtZVF1ZXJ5KSB7XG4gICAgICByZXR1cm4gcm93cy5tYXAoKHJvdykgPT4gT2JqZWN0LnZhbHVlcyhyb3cpKTtcbiAgICB9XG4gICAgaWYgKHJvd3NbMF0gJiYgcm93c1swXS5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAocm93c1swXS5zZXF1ZWxpemVfY2F1Z2h0X2V4Y2VwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKHtcbiAgICAgICAgICBzcWwsXG4gICAgICAgICAgcGFyYW1ldGVycyxcbiAgICAgICAgICBjb2RlOiBcIjIzNTA1XCIsXG4gICAgICAgICAgZGV0YWlsOiByb3dzWzBdLnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBkZWxldGUgcm93LnNlcXVlbGl6ZV9jYXVnaHRfZXhjZXB0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gL09OIC4qPyAoPzpVU0lORyAuKj9cXHMpP1xcKChbXl0qKVxcKS9naS5leGVjKHJvdy5kZWZpbml0aW9uKVsxXS5zcGxpdChcIixcIik7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSBfLnppcE9iamVjdChyb3cuY29sdW1uX2luZGV4ZXMsIHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucXVlcnlHZW5lcmF0b3IuZnJvbUFycmF5KHJvdy5jb2x1bW5fbmFtZXMpKTtcbiAgICAgICAgZGVsZXRlIHJvdy5jb2x1bW5faW5kZXhlcztcbiAgICAgICAgZGVsZXRlIHJvdy5jb2x1bW5fbmFtZXM7XG4gICAgICAgIGxldCBmaWVsZDtcbiAgICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgICAgcm93LmZpZWxkcyA9IHJvdy5pbmRrZXkuc3BsaXQoXCIgXCIpLm1hcCgoaW5kS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgIGZpZWxkID0gY29sdW1uc1tpbmRLZXldO1xuICAgICAgICAgIGlmICghZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0cmlidXRlOiBmaWVsZCxcbiAgICAgICAgICAgIGNvbGxhdGU6IGF0dHJpYnV0ZS5tYXRjaCgvQ09MTEFURSBcIiguKj8pXCIvKSA/IC9DT0xMQVRFIFwiKC4qPylcIi8uZXhlYyhhdHRyaWJ1dGUpWzFdIDogdm9pZCAwLFxuICAgICAgICAgICAgb3JkZXI6IGF0dHJpYnV0ZS5pbmNsdWRlcyhcIkRFU0NcIikgPyBcIkRFU0NcIiA6IGF0dHJpYnV0ZS5pbmNsdWRlcyhcIkFTQ1wiKSA/IFwiQVNDXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICBsZW5ndGg6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbCk7XG4gICAgICAgIGRlbGV0ZSByb3cuY29sdW1ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0ZvcmVpZ25LZXlzUXVlcnkoKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIGxldCBkZWZQYXJ0cztcbiAgICAgICAgaWYgKHJvdy5jb25kZWYgIT09IHZvaWQgMCAmJiAoZGVmUGFydHMgPSByb3cuY29uZGVmLm1hdGNoKC9GT1JFSUdOIEtFWSBcXCgoLispXFwpIFJFRkVSRU5DRVMgKC4rKVxcKCguKylcXCkoIE9OIChVUERBVEV8REVMRVRFKSAoQ0FTQ0FERXxSRVNUUklDVCkpPyggT04gKFVQREFURXxERUxFVEUpIChDQVNDQURFfFJFU1RSSUNUKSk/LykpKSB7XG4gICAgICAgICAgcm93LmlkID0gcm93LmNvbnN0cmFpbnRfbmFtZTtcbiAgICAgICAgICByb3cudGFibGUgPSBkZWZQYXJ0c1syXTtcbiAgICAgICAgICByb3cuZnJvbSA9IGRlZlBhcnRzWzFdO1xuICAgICAgICAgIHJvdy50byA9IGRlZlBhcnRzWzNdO1xuICAgICAgICAgIGxldCBpO1xuICAgICAgICAgIGZvciAoaSA9IDU7IGkgPD0gODsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAoLyhVUERBVEV8REVMRVRFKS8udGVzdChkZWZQYXJ0c1tpXSkpIHtcbiAgICAgICAgICAgICAgcm93W2Bvbl8ke2RlZlBhcnRzW2ldLnRvTG93ZXJDYXNlKCl9YF0gPSBkZWZQYXJ0c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1NlbGVjdFF1ZXJ5KCkpIHtcbiAgICAgIGxldCByZXN1bHQgPSByb3dzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYXcgPT09IGZhbHNlICYmIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYXR0cnNNYXAgPSBfLnJlZHVjZSh0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXMsIChtLCB2LCBrKSA9PiB7XG4gICAgICAgICAgbVtrLnRvTG93ZXJDYXNlKCldID0gaztcbiAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXN1bHQgPSByb3dzLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIF8ubWFwS2V5cyhyb3csICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRBdHRyID0gYXR0cnNNYXBba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0QXR0ciA9PT0gXCJzdHJpbmdcIiAmJiB0YXJnZXRBdHRyICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldEF0dHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChRdWVyeVR5cGVzLkRFU0NSSUJFID09PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgIHJlc3VsdFtyb3cuRmllbGRdID0ge1xuICAgICAgICAgIHR5cGU6IHJvdy5UeXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiByb3cuTnVsbCA9PT0gXCJZRVNcIixcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IHJvdy5EZWZhdWx0LFxuICAgICAgICAgIGNvbW1lbnQ6IHJvdy5Db21tZW50LFxuICAgICAgICAgIHNwZWNpYWw6IHJvdy5zcGVjaWFsID8gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5xdWVyeUdlbmVyYXRvci5mcm9tQXJyYXkocm93LnNwZWNpYWwpIDogW10sXG4gICAgICAgICAgcHJpbWFyeUtleTogcm93LkNvbnN0cmFpbnQgPT09IFwiUFJJTUFSWSBLRVlcIlxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0W3Jvdy5GaWVsZF0udHlwZSA9PT0gXCJCT09MRUFOXCIpIHtcbiAgICAgICAgICByZXN1bHRbcm93LkZpZWxkXS5kZWZhdWx0VmFsdWUgPSB7IFwiZmFsc2VcIjogZmFsc2UsIFwidHJ1ZVwiOiB0cnVlIH1bcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlXTtcbiAgICAgICAgICBpZiAocmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0gcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlLnJlcGxhY2UoLycvZywgXCJcIik7XG4gICAgICAgICAgaWYgKHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZS5pbmNsdWRlcyhcIjo6XCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpdCA9IHJlc3VsdFtyb3cuRmllbGRdLmRlZmF1bHRWYWx1ZS5zcGxpdChcIjo6XCIpO1xuICAgICAgICAgICAgaWYgKHNwbGl0WzFdLnRvTG93ZXJDYXNlKCkgIT09IFwicmVnY2xhc3MpXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0W3Jvdy5GaWVsZF0uZGVmYXVsdFZhbHVlID0gc3BsaXRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1ZlcnNpb25RdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcm93c1swXS5zZXJ2ZXJfdmVyc2lvbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTaG93T3JEZXNjcmliZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICBpZiAoUXVlcnlUeXBlcy5CVUxLVVBEQVRFID09PSB0aGlzLm9wdGlvbnMudHlwZSkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChyb3dDb3VudCwgMTApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocm93cyk7XG4gICAgfVxuICAgIGlmIChRdWVyeVR5cGVzLkJVTEtERUxFVEUgPT09IHRoaXMub3B0aW9ucy50eXBlKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQocm93Q291bnQsIDEwKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlLmRhdGFWYWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpICYmICF0aGlzLmlzVXBzZXJ0UXVlcnkoKSAmJiByb3dDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRW1wdHlSZXN1bHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJvd3NbMF0pIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJvd3NbMF0sIGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJvd3NbMF1ba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBfLmZpbmQodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUuZmllbGROYW1lID09PSBrZXkgfHwgYXR0cmlidXRlLmZpZWxkID09PSBrZXkpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHIgJiYgYXR0ci5maWVsZE5hbWUgfHwga2V5XSA9IHJlY29yZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2UsXG4gICAgICAgICAgbnVsbFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSB8fCByb3dzICYmICh0aGlzLm9wdGlvbnMucGxhaW4gJiYgcm93c1swXSB8fCByb3dzKSB8fCB2b2lkIDAsXG4gICAgICAgIHJvd0NvdW50XG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Jhd1F1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcm93cywgcXVlcnlSZXN1bHRdO1xuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCB0YWJsZTtcbiAgICBsZXQgaW5kZXg7XG4gICAgbGV0IGZpZWxkcztcbiAgICBsZXQgZXJyb3JzO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIGNvbnN0IGNvZGUgPSBlcnIuY29kZSB8fCBlcnIuc3FsU3RhdGU7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGVyci5tZXNzYWdlIHx8IGVyci5tZXNzYWdlUHJpbWFyeTtcbiAgICBjb25zdCBlcnJEZXRhaWwgPSBlcnIuZGV0YWlsIHx8IGVyci5tZXNzYWdlRGV0YWlsO1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSBcIjIzNTAzXCI6XG4gICAgICAgIGluZGV4ID0gZXJyTWVzc2FnZS5tYXRjaCgvdmlvbGF0ZXMgZm9yZWlnbiBrZXkgY29uc3RyYWludCBcIiguKz8pXCIvKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCA/IGluZGV4WzFdIDogdm9pZCAwO1xuICAgICAgICB0YWJsZSA9IGVyck1lc3NhZ2UubWF0Y2goL29uIHRhYmxlIFwiKC4rPylcIi8pO1xuICAgICAgICB0YWJsZSA9IHRhYmxlID8gdGFibGVbMV0gOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGVyck1lc3NhZ2UsXG4gICAgICAgICAgZmllbGRzOiBudWxsLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCIyMzUwNVwiOlxuICAgICAgICBpZiAoZXJyRGV0YWlsICYmIChtYXRjaCA9IGVyckRldGFpbC5yZXBsYWNlKC9cIi9nLCBcIlwiKS5tYXRjaCgvS2V5IFxcKCguKj8pXFwpPVxcKCguKj8pXFwpLykpKSB7XG4gICAgICAgICAgZmllbGRzID0gXy56aXBPYmplY3QobWF0Y2hbMV0uc3BsaXQoXCIsIFwiKSwgbWF0Y2hbMl0uc3BsaXQoXCIsIFwiKSk7XG4gICAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgICAgbWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgICAgICAgIF8uZm9yT3duKGZpZWxkcywgKHZhbHVlLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5tb2RlbC51bmlxdWVLZXlzKSB7XG4gICAgICAgICAgICBfLmZvck93bih0aGlzLm1vZGVsLnVuaXF1ZUtleXMsIChjb25zdHJhaW50KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChfLmlzRXF1YWwoY29uc3RyYWludC5maWVsZHMsIE9iamVjdC5rZXlzKGZpZWxkcykpICYmICEhY29uc3RyYWludC5tc2cpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gY29uc3RyYWludC5tc2c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHsgbWVzc2FnZSwgZXJyb3JzLCBwYXJlbnQ6IGVyciwgZmllbGRzLCBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBlcnJNZXNzYWdlLFxuICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCIyM1AwMVwiOlxuICAgICAgICBtYXRjaCA9IGVyckRldGFpbC5tYXRjaCgvS2V5IFxcKCguKj8pXFwpPVxcKCguKj8pXFwpLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGZpZWxkcyA9IF8uemlwT2JqZWN0KG1hdGNoWzFdLnNwbGl0KFwiLCBcIiksIG1hdGNoWzJdLnNwbGl0KFwiLCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgPSBcIkV4Y2x1c2lvbiBjb25zdHJhaW50IGVycm9yXCI7XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBjb25zdHJhaW50OiBlcnIuY29uc3RyYWludCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdGFibGU6IGVyci50YWJsZSxcbiAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICBzdGFjazogZXJyU3RhY2tcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiNDI3MDRcIjpcbiAgICAgICAgaWYgKGVyci5zcWwgJiYgLyhDT05TVFJBSU5UfElOREVYKS9naS50ZXN0KGVyci5zcWwpKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IFwiVW5rbm93biBjb25zdHJhaW50IGVycm9yXCI7XG4gICAgICAgICAgaW5kZXggPSBlcnJNZXNzYWdlLm1hdGNoKC8oPzpjb25zdHJhaW50fGluZGV4KSBcIiguKz8pXCIvaSk7XG4gICAgICAgICAgaW5kZXggPSBpbmRleCA/IGluZGV4WzFdIDogdm9pZCAwO1xuICAgICAgICAgIHRhYmxlID0gZXJyTWVzc2FnZS5tYXRjaCgvcmVsYXRpb24gXCIoLis/KVwiL2kpO1xuICAgICAgICAgIHRhYmxlID0gdGFibGUgPyB0YWJsZVsxXSA6IHZvaWQgMDtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGNvbnN0cmFpbnQ6IGluZGV4LFxuICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICBwYXJlbnQ6IGVycixcbiAgICAgICAgICAgIHN0YWNrOiBlcnJTdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5EYXRhYmFzZUVycm9yKGVyciwgeyBzdGFjazogZXJyU3RhY2sgfSk7XG4gICAgfVxuICB9XG4gIGlzRm9yZWlnbktleXNRdWVyeSgpIHtcbiAgICByZXR1cm4gL1NFTEVDVCBjb25uYW1lIGFzIGNvbnN0cmFpbnRfbmFtZSwgcGdfY2F0YWxvZ1xcLnBnX2dldF9jb25zdHJhaW50ZGVmXFwoclxcLm9pZCwgdHJ1ZVxcKSBhcyBjb25kZWYgRlJPTSBwZ19jYXRhbG9nXFwucGdfY29uc3RyYWludCByIFdIRVJFIHJcXC5jb25yZWxpZCA9IFxcKFNFTEVDVCBvaWQgRlJPTSBwZ19jbGFzcyBXSEVSRSByZWxuYW1lID0gJy4qJyBMSU1JVCAxXFwpIEFORCByXFwuY29udHlwZSA9ICdmJyBPUkRFUiBCWSAxOy8udGVzdCh0aGlzLnNxbCk7XG4gIH1cbiAgZ2V0SW5zZXJ0SWRGaWVsZCgpIHtcbiAgICByZXR1cm4gXCJpZFwiO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/postgres/range.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/postgres/range.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n  return parseType(bound);\n}\nfunction stringify(data) {\n  if (data === null)\n    return null;\n  if (!Array.isArray(data))\n    throw new Error(\"range must be an array\");\n  if (!data.length)\n    return \"empty\";\n  if (data.length !== 2)\n    throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false)\n      data.inclusive = [false, false];\n    else if (!data.inclusive)\n      data.inclusive = [true, false];\n    else if (data.inclusive === true)\n      data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\"))\n        data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\"))\n        data[index] = value.value;\n    }\n  });\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\nexports.stringify = stringify;\nfunction parse(value, parser) {\n  if (value === null)\n    return null;\n  if (value === \"empty\") {\n    return [];\n  }\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2)\n    return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\nexports.parse = parse;\n//# sourceMappingURL=range.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9wb3N0Z3Jlcy9yYW5nZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksNkNBQTZDLEdBQUcsV0FBVyxFQUFFLDhCQUE4QjtBQUN2RztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Bvc3RncmVzL3JhbmdlLmpzPzM3ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVJhbmdlQm91bmQoYm91bmQpIHtcbiAgaWYgKGJvdW5kID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKGJvdW5kID09PSBJbmZpbml0eSB8fCBib3VuZCA9PT0gLUluZmluaXR5KSB7XG4gICAgcmV0dXJuIGJvdW5kLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm91bmQpO1xufVxuZnVuY3Rpb24gcGFyc2VSYW5nZUJvdW5kKGJvdW5kLCBwYXJzZVR5cGUpIHtcbiAgaWYgKCFib3VuZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChib3VuZCA9PT0gXCJpbmZpbml0eVwiKSB7XG4gICAgcmV0dXJuIEluZmluaXR5O1xuICB9XG4gIGlmIChib3VuZCA9PT0gXCItaW5maW5pdHlcIikge1xuICAgIHJldHVybiAtSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlVHlwZShib3VuZCk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICBpZiAoZGF0YSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInJhbmdlIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gIGlmICghZGF0YS5sZW5ndGgpXG4gICAgcmV0dXJuIFwiZW1wdHlcIjtcbiAgaWYgKGRhdGEubGVuZ3RoICE9PSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInJhbmdlIGFycmF5IGxlbmd0aCBtdXN0IGJlIDAgKGVtcHR5KSBvciAyIChsb3dlciBhbmQgdXBwZXIgYm91bmRzKVwiKTtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImluY2x1c2l2ZVwiKSkge1xuICAgIGlmIChkYXRhLmluY2x1c2l2ZSA9PT0gZmFsc2UpXG4gICAgICBkYXRhLmluY2x1c2l2ZSA9IFtmYWxzZSwgZmFsc2VdO1xuICAgIGVsc2UgaWYgKCFkYXRhLmluY2x1c2l2ZSlcbiAgICAgIGRhdGEuaW5jbHVzaXZlID0gW3RydWUsIGZhbHNlXTtcbiAgICBlbHNlIGlmIChkYXRhLmluY2x1c2l2ZSA9PT0gdHJ1ZSlcbiAgICAgIGRhdGEuaW5jbHVzaXZlID0gW3RydWUsIHRydWVdO1xuICB9IGVsc2Uge1xuICAgIGRhdGEuaW5jbHVzaXZlID0gW3RydWUsIGZhbHNlXTtcbiAgfVxuICBfLmVhY2goZGF0YSwgKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJpbmNsdXNpdmVcIikpXG4gICAgICAgIGRhdGEuaW5jbHVzaXZlW2luZGV4XSA9ICEhdmFsdWUuaW5jbHVzaXZlO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ2YWx1ZVwiKSlcbiAgICAgICAgZGF0YVtpbmRleF0gPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBsb3dlckJvdW5kID0gc3RyaW5naWZ5UmFuZ2VCb3VuZChkYXRhWzBdKTtcbiAgY29uc3QgdXBwZXJCb3VuZCA9IHN0cmluZ2lmeVJhbmdlQm91bmQoZGF0YVsxXSk7XG4gIHJldHVybiBgJHsoZGF0YS5pbmNsdXNpdmVbMF0gPyBcIltcIiA6IFwiKFwiKSArIGxvd2VyQm91bmR9LCR7dXBwZXJCb3VuZH0ke2RhdGEuaW5jbHVzaXZlWzFdID8gXCJdXCIgOiBcIilcIn1gO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5mdW5jdGlvbiBwYXJzZSh2YWx1ZSwgcGFyc2VyKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHZhbHVlID09PSBcImVtcHR5XCIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZhbHVlLnN1YnN0cmluZygxLCB2YWx1ZS5sZW5ndGggLSAxKS5zcGxpdChcIixcIiwgMik7XG4gIGlmIChyZXN1bHQubGVuZ3RoICE9PSAyKVxuICAgIHJldHVybiB2YWx1ZTtcbiAgcmVzdWx0ID0gcmVzdWx0Lm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHBhcnNlUmFuZ2VCb3VuZChpdGVtLCBwYXJzZXIpLFxuICAgICAgaW5jbHVzaXZlOiBpbmRleCA9PT0gMCA/IHZhbHVlWzBdID09PSBcIltcIiA6IHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSBcIl1cIlxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/postgres/range.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst SequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").snowflake);\nconst debug = logger.debugContext(\"connection:snowflake\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"snowflake\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"snowflake-sdk\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n  async connect(config) {\n    const connectionConfig = __spreadValues({\n      account: config.host,\n      username: config.username,\n      password: config.password,\n      database: config.database,\n      warehouse: config.warehouse,\n      role: config.role\n    }, config.dialectOptions);\n    try {\n      const connection = await new Promise((resolve, reject) => {\n        this.lib.createConnection(connectionConfig).connect((err, conn) => {\n          if (err) {\n            console.log(err);\n            reject(err);\n          } else {\n            resolve(conn);\n          }\n        });\n      });\n      debug(\"connection acquired\");\n      if (!this.sequelize.config.keepDefaultTimezone) {\n        const tzOffset = this.sequelize.options.timezone === \"+00:00\" ? \"Etc/UTC\" : this.sequelize.options.timezone;\n        const isNamedTzOffset = /\\//.test(tzOffset);\n        if (isNamedTzOffset) {\n          await new Promise((resolve, reject) => {\n            connection.execute({\n              sqlText: `ALTER SESSION SET timezone = '${tzOffset}'`,\n              complete(err) {\n                if (err) {\n                  console.log(err);\n                  reject(err);\n                } else {\n                  resolve();\n                }\n              }\n            });\n          });\n        } else {\n          throw Error(\"only support time zone name for snowflake!\");\n        }\n      }\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case \"ER_ACCESS_DENIED_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case \"EHOSTUNREACH\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (!connection.isUp()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      connection.destroy((err) => {\n        if (err) {\n          console.error(`Unable to disconnect: ${err.message}`);\n          reject(err);\n        } else {\n          console.log(`Disconnected connection with id: ${connection.getId()}`);\n          resolve(connection.getId());\n        }\n      });\n    });\n  }\n  validate(connection) {\n    return connection.isUp();\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLGtIQUFnQztBQUMxRSx3QkFBd0IsbUJBQU8sQ0FBQyx3RUFBYztBQUM5QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFvQjtBQUMvQyxrQkFBa0IsMkdBQXFDO0FBQ3ZEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBLFVBQVU7QUFDViwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Nub3dmbGFrZS9jb25uZWN0aW9uLW1hbmFnZXIuanM/NTM5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgU2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikuc25vd2ZsYWtlO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiY29ubmVjdGlvbjpzbm93Zmxha2VcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcInNub3dmbGFrZVwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHNlcXVlbGl6ZS5jb25maWcucG9ydCA9IHNlcXVlbGl6ZS5jb25maWcucG9ydCB8fCAzMzA2O1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgdGhpcy5saWIgPSB0aGlzLl9sb2FkRGlhbGVjdE1vZHVsZShcInNub3dmbGFrZS1zZGtcIik7XG4gICAgdGhpcy5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIF9yZWZyZXNoVHlwZVBhcnNlcihkYXRhVHlwZSkge1xuICAgIHBhcnNlclN0b3JlLnJlZnJlc2goZGF0YVR5cGUpO1xuICB9XG4gIF9jbGVhclR5cGVQYXJzZXIoKSB7XG4gICAgcGFyc2VyU3RvcmUuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgX3R5cGVjYXN0KGZpZWxkLCBuZXh0KSB7XG4gICAgaWYgKHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKSkge1xuICAgICAgcmV0dXJuIHBhcnNlclN0b3JlLmdldChmaWVsZC50eXBlKShmaWVsZCwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucywgbmV4dCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChjb25maWcpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgYWNjb3VudDogY29uZmlnLmhvc3QsXG4gICAgICB1c2VybmFtZTogY29uZmlnLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IGNvbmZpZy5wYXNzd29yZCxcbiAgICAgIGRhdGFiYXNlOiBjb25maWcuZGF0YWJhc2UsXG4gICAgICB3YXJlaG91c2U6IGNvbmZpZy53YXJlaG91c2UsXG4gICAgICByb2xlOiBjb25maWcucm9sZVxuICAgIH0sIGNvbmZpZy5kaWFsZWN0T3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMubGliLmNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbkNvbmZpZykuY29ubmVjdCgoZXJyLCBjb25uKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNvbm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRlYnVnKFwiY29ubmVjdGlvbiBhY3F1aXJlZFwiKTtcbiAgICAgIGlmICghdGhpcy5zZXF1ZWxpemUuY29uZmlnLmtlZXBEZWZhdWx0VGltZXpvbmUpIHtcbiAgICAgICAgY29uc3QgdHpPZmZzZXQgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lID09PSBcIiswMDowMFwiID8gXCJFdGMvVVRDXCIgOiB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnRpbWV6b25lO1xuICAgICAgICBjb25zdCBpc05hbWVkVHpPZmZzZXQgPSAvXFwvLy50ZXN0KHR6T2Zmc2V0KTtcbiAgICAgICAgaWYgKGlzTmFtZWRUek9mZnNldCkge1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uZXhlY3V0ZSh7XG4gICAgICAgICAgICAgIHNxbFRleHQ6IGBBTFRFUiBTRVNTSU9OIFNFVCB0aW1lem9uZSA9ICcke3R6T2Zmc2V0fSdgLFxuICAgICAgICAgICAgICBjb21wbGV0ZShlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKFwib25seSBzdXBwb3J0IHRpbWUgem9uZSBuYW1lIGZvciBzbm93Zmxha2UhXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgY2FzZSBcIkVDT05OUkVGVVNFRFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQ29ubmVjdGlvblJlZnVzZWRFcnJvcihlcnIpO1xuICAgICAgICBjYXNlIFwiRVJfQUNDRVNTX0RFTklFRF9FUlJPUlwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuQWNjZXNzRGVuaWVkRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVOT1RGT1VORFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdEZvdW5kRXJyb3IoZXJyKTtcbiAgICAgICAgY2FzZSBcIkVIT1NUVU5SRUFDSFwiOlxuICAgICAgICAgIHRocm93IG5ldyBTZXF1ZWxpemVFcnJvcnMuSG9zdE5vdFJlYWNoYWJsZUVycm9yKGVycik7XG4gICAgICAgIGNhc2UgXCJFSU5WQUxcIjpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkludmFsaWRDb25uZWN0aW9uRXJyb3IoZXJyKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgU2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhc3luYyBkaXNjb25uZWN0KGNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIWNvbm5lY3Rpb24uaXNVcCgpKSB7XG4gICAgICBkZWJ1ZyhcImNvbm5lY3Rpb24gdHJpZWQgdG8gZGlzY29ubmVjdCBidXQgd2FzIGFscmVhZHkgYXQgQ0xPU0VEIHN0YXRlXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29ubmVjdGlvbi5kZXN0cm95KChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBkaXNjb25uZWN0OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBEaXNjb25uZWN0ZWQgY29ubmVjdGlvbiB3aXRoIGlkOiAke2Nvbm5lY3Rpb24uZ2V0SWQoKX1gKTtcbiAgICAgICAgICByZXNvbHZlKGNvbm5lY3Rpb24uZ2V0SWQoKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlKGNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbi5pc1VwKCk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uTWFuYWdlciA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25NYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/data-types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/data-types.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst momentTz = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nmodule.exports = (BaseTypes) => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.snowflake.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.snowflake = [\"DATETIME\"];\n  BaseTypes.STRING.types.snowflake = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.snowflake = [\"STRING\"];\n  BaseTypes.TEXT.types.snowflake = [\"BLOB\"];\n  BaseTypes.TINYINT.types.snowflake = [\"TINY\"];\n  BaseTypes.SMALLINT.types.snowflake = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.snowflake = [\"INT24\"];\n  BaseTypes.INTEGER.types.snowflake = [\"LONG\"];\n  BaseTypes.BIGINT.types.snowflake = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.snowflake = [\"FLOAT\"];\n  BaseTypes.TIME.types.snowflake = [\"TIME\"];\n  BaseTypes.DATEONLY.types.snowflake = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.snowflake = [\"TINY\"];\n  BaseTypes.BLOB.types.snowflake = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.snowflake = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.snowflake = false;\n  BaseTypes.ENUM.types.snowflake = false;\n  BaseTypes.REAL.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.snowflake = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.snowflake = [\"JSON\"];\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR(36)\";\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    TEXT,\n    DATE,\n    BOOLEAN,\n    DATEONLY,\n    UUID,\n    JSON: JSONTYPE\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMscURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCLE9BQU8sRUFBRSxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvZGF0YS10eXBlcy5qcz9hOTI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbW9tZW50VHogPSByZXF1aXJlKFwibW9tZW50LXRpbWV6b25lXCIpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBCYXNlVHlwZXMuQUJTVFJBQ1QucHJvdG90eXBlLmRpYWxlY3RUeXBlcyA9IFwiaHR0cHM6Ly9kZXYuc25vd2ZsYWtlLmNvbS9kb2MvcmVmbWFuLzUuNy9lbi9kYXRhLXR5cGVzLmh0bWxcIjtcbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMuc25vd2ZsYWtlID0gW1wiREFURVRJTUVcIl07XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMuc25vd2ZsYWtlID0gW1wiVkFSX1NUUklOR1wiXTtcbiAgQmFzZVR5cGVzLkNIQVIudHlwZXMuc25vd2ZsYWtlID0gW1wiU1RSSU5HXCJdO1xuICBCYXNlVHlwZXMuVEVYVC50eXBlcy5zbm93Zmxha2UgPSBbXCJCTE9CXCJdO1xuICBCYXNlVHlwZXMuVElOWUlOVC50eXBlcy5zbm93Zmxha2UgPSBbXCJUSU5ZXCJdO1xuICBCYXNlVHlwZXMuU01BTExJTlQudHlwZXMuc25vd2ZsYWtlID0gW1wiU0hPUlRcIl07XG4gIEJhc2VUeXBlcy5NRURJVU1JTlQudHlwZXMuc25vd2ZsYWtlID0gW1wiSU5UMjRcIl07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLnNub3dmbGFrZSA9IFtcIkxPTkdcIl07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMuc25vd2ZsYWtlID0gW1wiTE9OR0xPTkdcIl07XG4gIEJhc2VUeXBlcy5GTE9BVC50eXBlcy5zbm93Zmxha2UgPSBbXCJGTE9BVFwiXTtcbiAgQmFzZVR5cGVzLlRJTUUudHlwZXMuc25vd2ZsYWtlID0gW1wiVElNRVwiXTtcbiAgQmFzZVR5cGVzLkRBVEVPTkxZLnR5cGVzLnNub3dmbGFrZSA9IFtcIkRBVEVcIl07XG4gIEJhc2VUeXBlcy5CT09MRUFOLnR5cGVzLnNub3dmbGFrZSA9IFtcIlRJTllcIl07XG4gIEJhc2VUeXBlcy5CTE9CLnR5cGVzLnNub3dmbGFrZSA9IFtcIlRJTllCTE9CXCIsIFwiQkxPQlwiLCBcIkxPTkdCTE9CXCJdO1xuICBCYXNlVHlwZXMuREVDSU1BTC50eXBlcy5zbm93Zmxha2UgPSBbXCJORVdERUNJTUFMXCJdO1xuICBCYXNlVHlwZXMuVVVJRC50eXBlcy5zbm93Zmxha2UgPSBmYWxzZTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMuc25vd2ZsYWtlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLnNub3dmbGFrZSA9IFtcIkRPVUJMRVwiXTtcbiAgQmFzZVR5cGVzLkRPVUJMRS50eXBlcy5zbm93Zmxha2UgPSBbXCJET1VCTEVcIl07XG4gIEJhc2VUeXBlcy5HRU9NRVRSWS50eXBlcy5zbm93Zmxha2UgPSBbXCJHRU9NRVRSWVwiXTtcbiAgQmFzZVR5cGVzLkpTT04udHlwZXMuc25vd2ZsYWtlID0gW1wiSlNPTlwiXTtcbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlRJTUVTVEFNUFwiO1xuICAgIH1cbiAgICBfc3RyaW5naWZ5KGRhdGUsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICAgIGRhdGUgPSB0aGlzLl9hcHBseVRpbWV6b25lKGRhdGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGF0ZS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTU1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRlLmZvcm1hdChcIllZWVktTU0tREQgSEg6bW06c3NcIik7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdHJpbmcoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAobW9tZW50VHoudHouem9uZShvcHRpb25zLnRpbWV6b25lKSkge1xuICAgICAgICB2YWx1ZSA9IG1vbWVudFR6LnR6KHZhbHVlLCBvcHRpb25zLnRpbWV6b25lKS50b0RhdGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUoYCR7dmFsdWV9ICR7b3B0aW9ucy50aW1lem9uZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURU9OTFkgZXh0ZW5kcyBCYXNlVHlwZXMuREFURU9OTFkge1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnN0cmluZygpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBVVUlEIGV4dGVuZHMgQmFzZVR5cGVzLlVVSUQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVkFSQ0hBUigzNilcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlRFWFRcIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQk9PTEVBTiBleHRlbmRzIEJhc2VUeXBlcy5CT09MRUFOIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIkJPT0xFQU5cIjtcbiAgICB9XG4gIH1cbiAgY2xhc3MgSlNPTlRZUEUgZXh0ZW5kcyBCYXNlVHlwZXMuSlNPTiB7XG4gICAgX3N0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMub3BlcmF0aW9uID09PSBcIndoZXJlXCIgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgVEVYVCxcbiAgICBEQVRFLFxuICAgIEJPT0xFQU4sXG4gICAgREFURU9OTFksXG4gICAgVVVJRCxcbiAgICBKU09OOiBKU09OVFlQRVxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").snowflake);\nconst { SnowflakeQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-interface.js\");\nclass SnowflakeDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SnowflakeQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSnowflakeDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  \"VALUES ()\": true,\n  \"LIMIT ON UPDATE\": true,\n  lock: true,\n  forShare: \"LOCK IN SHARE MODE\",\n  settingIsolationLevelDuringTransaction: false,\n  inserts: {\n    ignoreDuplicates: \" IGNORE\",\n    updateOnDuplicate: false\n  },\n  index: {\n    collate: false,\n    length: true,\n    parser: true,\n    type: true,\n    using: 1\n  },\n  constraints: {\n    dropConstraint: false,\n    check: false\n  },\n  indexViaAlter: true,\n  indexHints: true,\n  NUMERIC: true,\n  GEOMETRY: false,\n  JSON: false,\n  REGEXP: true,\n  schemas: true\n});\nSnowflakeDialect.prototype.defaultVersion = \"5.7.0\";\nSnowflakeDialect.prototype.Query = Query;\nSnowflakeDialect.prototype.QueryGenerator = QueryGenerator;\nSnowflakeDialect.prototype.DataTypes = DataTypes;\nSnowflakeDialect.prototype.name = \"snowflake\";\nSnowflakeDialect.prototype.TICK_CHAR = '\"';\nSnowflakeDialect.prototype.TICK_CHAR_LEFT = SnowflakeDialect.prototype.TICK_CHAR;\nSnowflakeDialect.prototype.TICK_CHAR_RIGHT = SnowflakeDialect.prototype.TICK_CHAR;\nmodule.exports = SnowflakeDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMseUdBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywrRUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxtR0FBbUI7QUFDbEQsa0JBQWtCLDJHQUFxQztBQUN2RCxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsbUdBQW1CO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3Nub3dmbGFrZS9pbmRleC5qcz9jNjU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBBYnN0cmFjdERpYWxlY3QgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RcIik7XG5jb25zdCBDb25uZWN0aW9uTWFuYWdlciA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb24tbWFuYWdlclwiKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZShcIi4vcXVlcnlcIik7XG5jb25zdCBRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLnNub3dmbGFrZTtcbmNvbnN0IHsgU25vd2ZsYWtlUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNsYXNzIFNub3dmbGFrZURpYWxlY3QgZXh0ZW5kcyBBYnN0cmFjdERpYWxlY3Qge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBuZXcgQ29ubmVjdGlvbk1hbmFnZXIodGhpcywgc2VxdWVsaXplKTtcbiAgICB0aGlzLnF1ZXJ5R2VuZXJhdG9yID0gbmV3IFF1ZXJ5R2VuZXJhdG9yKHtcbiAgICAgIF9kaWFsZWN0OiB0aGlzLFxuICAgICAgc2VxdWVsaXplXG4gICAgfSk7XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IG5ldyBTbm93Zmxha2VRdWVyeUludGVyZmFjZShzZXF1ZWxpemUsIHRoaXMucXVlcnlHZW5lcmF0b3IpO1xuICB9XG59XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyA9IF8ubWVyZ2UoXy5jbG9uZURlZXAoQWJzdHJhY3REaWFsZWN0LnByb3RvdHlwZS5zdXBwb3J0cyksIHtcbiAgXCJWQUxVRVMgKClcIjogdHJ1ZSxcbiAgXCJMSU1JVCBPTiBVUERBVEVcIjogdHJ1ZSxcbiAgbG9jazogdHJ1ZSxcbiAgZm9yU2hhcmU6IFwiTE9DSyBJTiBTSEFSRSBNT0RFXCIsXG4gIHNldHRpbmdJc29sYXRpb25MZXZlbER1cmluZ1RyYW5zYWN0aW9uOiBmYWxzZSxcbiAgaW5zZXJ0czoge1xuICAgIGlnbm9yZUR1cGxpY2F0ZXM6IFwiIElHTk9SRVwiLFxuICAgIHVwZGF0ZU9uRHVwbGljYXRlOiBmYWxzZVxuICB9LFxuICBpbmRleDoge1xuICAgIGNvbGxhdGU6IGZhbHNlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwYXJzZXI6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSxcbiAgICB1c2luZzogMVxuICB9LFxuICBjb25zdHJhaW50czoge1xuICAgIGRyb3BDb25zdHJhaW50OiBmYWxzZSxcbiAgICBjaGVjazogZmFsc2VcbiAgfSxcbiAgaW5kZXhWaWFBbHRlcjogdHJ1ZSxcbiAgaW5kZXhIaW50czogdHJ1ZSxcbiAgTlVNRVJJQzogdHJ1ZSxcbiAgR0VPTUVUUlk6IGZhbHNlLFxuICBKU09OOiBmYWxzZSxcbiAgUkVHRVhQOiB0cnVlLFxuICBzY2hlbWFzOiB0cnVlXG59KTtcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLmRlZmF1bHRWZXJzaW9uID0gXCI1LjcuMFwiO1xuU25vd2ZsYWtlRGlhbGVjdC5wcm90b3R5cGUuUXVlcnkgPSBRdWVyeTtcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlF1ZXJ5R2VuZXJhdG9yID0gUXVlcnlHZW5lcmF0b3I7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5EYXRhVHlwZXMgPSBEYXRhVHlwZXM7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5uYW1lID0gXCJzbm93Zmxha2VcIjtcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUiA9ICdcIic7XG5Tbm93Zmxha2VEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVJfTEVGVCA9IFNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcblNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9SSUdIVCA9IFNub3dmbGFrZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUjtcbm1vZHVsZS5leHBvcnRzID0gU25vd2ZsYWtlRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-generator.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/query-generator.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst Op = __webpack_require__(/*! ../../operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  \"CONSTRAINT_NAME as constraint_name\",\n  \"CONSTRAINT_NAME as constraintName\",\n  \"CONSTRAINT_SCHEMA as constraintSchema\",\n  \"CONSTRAINT_SCHEMA as constraintCatalog\",\n  \"TABLE_NAME as tableName\",\n  \"TABLE_SCHEMA as tableSchema\",\n  \"TABLE_SCHEMA as tableCatalog\",\n  \"COLUMN_NAME as columnName\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\",\n  \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\",\n  \"REFERENCED_TABLE_NAME as referencedTableName\",\n  \"REFERENCED_COLUMN_NAME as referencedColumnName\"\n].join(\",\");\nconst SNOWFLAKE_RESERVED_WORDS = \"account,all,alter,and,any,as,between,by,case,cast,check,column,connect,connections,constraint,create,cross,current,current_date,current_time,current_timestamp,current_user,database,delete,distinct,drop,else,exists,false,following,for,from,full,grant,group,gscluster,having,ilike,in,increment,inner,insert,intersect,into,is,issue,join,lateral,left,like,localtime,localtimestamp,minus,natural,not,null,of,on,or,order,organization,qualify,regexp,revoke,right,rlike,row,rows,sample,schema,select,set,some,start,table,tablesample,then,to,trigger,true,try_cast,union,unique,update,using,values,view,when,whenever,where,with\".split(\",\");\nconst typeWithoutDefault = /* @__PURE__ */ new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\nclass SnowflakeQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\n      \"CREATE DATABASE IF NOT EXISTS\",\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      \";\"\n    ]);\n  }\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n  versionQuery() {\n    return \"SELECT CURRENT_VERSION()\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr))\n        continue;\n      const dataType = attributes[attr];\n      let match;\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return Utils.joinSQLFragments([\n      \"CREATE TABLE IF NOT EXISTS\",\n      table,\n      `(${attributesClause})`,\n      options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      \";\"\n    ]);\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n  showTablesQuery(database) {\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      database ? `AND TABLE_SCHEMA = ${this.escape(database)}` : \"AND TABLE_SCHEMA NOT IN ( 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\",\n      \";\"\n    ]);\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\",\n      `AND TABLE_SCHEMA = ${schema !== void 0 ? this.escape(schema) : \"CURRENT_SCHEMA()\"}`,\n      `AND TABLE_NAME = ${this.escape(tableName)}`,\n      \";\"\n    ]);\n  }\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(table),\n      \"ADD\",\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: \"addColumn\",\n        tableName: table,\n        foreignKey: key\n      }),\n      \";\"\n    ]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP\",\n      this.quoteIdentifier(attributeName),\n      \";\"\n    ]);\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = (...subQuerys) => Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"ALTER COLUMN\",\n      ...subQuerys,\n      \";\"\n    ]);\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      const attrSql = [];\n      if (definition.includes(\"NOT NULL\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET NOT NULL\"));\n        definition = definition.replace(\"NOT NULL\", \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP NOT NULL\"));\n      }\n      if (definition.includes(\"DEFAULT\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"SET DEFAULT\", definition.match(/DEFAULT ([^;]+)/)[1]));\n        definition = definition.replace(/(DEFAULT[^;]+)/, \"\").trim();\n      } else if (!definition.includes(\"REFERENCES\")) {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"DROP DEFAULT\"));\n      }\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, \"\");\n        attrSql.push(query(\"ADD UNIQUE (\", this.quoteIdentifier(attributeName), \")\").replace(\"ALTER COLUMN\", \"\"));\n      }\n      if (definition.includes(\"REFERENCES\")) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        attrSql.push(query(\"ADD FOREIGN KEY (\", this.quoteIdentifier(attributeName), \")\", definition).replace(\"ALTER COLUMN\", \"\"));\n      } else {\n        attrSql.push(query(this.quoteIdentifier(attributeName), \"TYPE\", definition));\n      }\n      sql.push(attrSql.join(\"\"));\n    }\n    return sql.join(\"\");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`'${attrBefore}' '${attrName}' ${definition}`);\n    }\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"RENAME COLUMN\",\n      attrString.join(\" to \"),\n      \";\"\n    ]);\n  }\n  handleSequelizeMethod(attr, tableName, factory, options, prepend) {\n    if (attr instanceof Utils.Json) {\n      if (attr.conditions) {\n        const conditions = this.parseConditionObject(attr.conditions).map((condition) => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (attr.path) {\n        let str;\n        if (this._checkValidJsonStatement(attr.path)) {\n          str = attr.path;\n        } else {\n          const paths = _.toPath(attr.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (attr.value) {\n          str += util.format(\" = %s\", this.escape(attr.value));\n        }\n        return str;\n      }\n    } else if (attr instanceof Utils.Cast) {\n      if (/timestamp/i.test(attr.type)) {\n        attr.type = \"datetime\";\n      } else if (attr.json && /boolean/i.test(attr.type)) {\n        attr.type = \"char\";\n      } else if (/double precision/i.test(attr.type) || /boolean/i.test(attr.type) || /integer/i.test(attr.type)) {\n        attr.type = \"decimal\";\n      } else if (/text/i.test(attr.type)) {\n        attr.type = \"char\";\n      }\n    }\n    return super.handleSequelizeMethod(attr, tableName, factory, options, prepend);\n  }\n  truncateTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      \"TRUNCATE\",\n      this.quoteTable(tableName)\n    ]);\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit && ` LIMIT ${this.escape(options.limit)}`;\n    let primaryKeys = \"\";\n    let primaryKeysSelection = \"\";\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (limit) {\n      if (!model) {\n        throw new Error(\"Cannot LIMIT delete without a model.\");\n      }\n      const pks = Object.values(model.primaryKeys).map((pk) => this.quoteIdentifier(pk.field)).join(\",\");\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return Utils.joinSQLFragments([\n        \"DELETE FROM\",\n        table,\n        \"WHERE\",\n        primaryKeys,\n        \"IN (SELECT\",\n        primaryKeysSelection,\n        \"FROM\",\n        table,\n        whereClause,\n        limit,\n        \")\",\n        \";\"\n      ]);\n    }\n    return Utils.joinSQLFragments([\n      \"DELETE FROM\",\n      table,\n      whereClause,\n      \";\"\n    ]);\n  }\n  showIndexesQuery() {\n    return \"SELECT '' FROM DUAL\";\n  }\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\n      \"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\",\n      \"CONSTRAINT_NAME AS constraintName,\",\n      \"CONSTRAINT_SCHEMA AS constraintSchema,\",\n      \"CONSTRAINT_TYPE AS constraintType,\",\n      \"TABLE_NAME AS tableName,\",\n      \"TABLE_SCHEMA AS tableSchema\",\n      \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\",\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      \";\"\n    ]);\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return Utils.joinSQLFragments([\n      \"DROP INDEX\",\n      this.quoteIdentifier(indexName),\n      \"ON\",\n      this.quoteTable(tableName),\n      \";\"\n    ]);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n    if (attribute.autoIncrement) {\n      template += \" AUTOINCREMENT\";\n    }\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes(\"PRIMARY KEY\")) {\n      dataType = dataType.replace(\"PRIMARY KEY\", \"\");\n    }\n    if (dataType.includes(\"SERIAL\")) {\n      if (dataType.includes(\"BIGINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"BIGSERIAL\");\n        dataType = dataType.replace(\"BIGINT\", \"\");\n      } else if (dataType.includes(\"SMALLINT\")) {\n        dataType = dataType.replace(\"SERIAL\", \"SMALLSERIAL\");\n        dataType = dataType.replace(\"SMALLINT\", \"\");\n      } else {\n        dataType = dataType.replace(\"INTEGER\", \"\");\n      }\n      dataType = dataType.replace(\"NOT NULL\", \"\");\n    }\n    return dataType;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      \"AND REFERENCED_TABLE_NAME IS NOT NULL\",\n      \";\"\n    ]);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\n      \"SELECT\",\n      FOREIGN_KEY_FIELDS,\n      \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\",\n      \"WHERE (\",\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      \") OR (\",\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        \"AND REFERENCED_TABLE_NAME IS NOT NULL\"\n      ],\n      \")\"\n    ]);\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      \"ALTER TABLE\",\n      this.quoteTable(tableName),\n      \"DROP FOREIGN KEY\",\n      this.quoteIdentifier(foreignKey),\n      \";\"\n    ]);\n  }\n  addLimitAndOffset(options) {\n    let fragment = [];\n    if (options.offset !== null && options.offset !== void 0 && options.offset !== 0) {\n      fragment = fragment.concat([\" LIMIT \", this.escape(options.limit), \" OFFSET \", this.escape(options.offset)]);\n    } else if (options.limit !== null && options.limit !== void 0) {\n      fragment = [\" LIMIT \", this.escape(options.limit)];\n    }\n    return fragment.join(\"\");\n  }\n  quoteIdentifier(identifier, force) {\n    const optForceQuote = force || false;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    if (optForceQuote === true || optQuoteIdentifiers !== false || identifier.includes(\".\") || identifier.includes(\"->\") || SNOWFLAKE_RESERVED_WORDS.includes(rawIdentifier.toLowerCase())) {\n      return Utils.addTicks(rawIdentifier, '\"');\n    }\n    return rawIdentifier;\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\nmodule.exports = SnowflakeQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0VBQWE7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsNEdBQTZCO0FBQ3BFLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3BDLDhDQUE4QyxJQUFJLGtCQUFrQixJQUFJO0FBQ3hFLHdEQUF3RCxFQUFFO0FBQzFELDBEQUEwRCxFQUFFLHNCQUFzQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDZCQUE2QjtBQUMvRSw0Q0FBNEMsNkJBQTZCO0FBQ3pFLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0NBQW9DO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLG9DQUFvQztBQUM1RjtBQUNBLFVBQVU7QUFDViwwQkFBMEIsNEJBQTRCLEVBQUUsb0NBQW9DO0FBQzVGO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLDRCQUE0QixFQUFFLFNBQVM7QUFDL0Q7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLDRCQUE0QixFQUFFLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsR0FBRyx5QkFBeUI7QUFDdEU7QUFDQSwwQ0FBMEMsaUNBQWlDLEdBQUcsc0VBQXNFO0FBQ3BKO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCLElBQUksa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQiwyRUFBMkUsNkJBQTZCO0FBQ3hHLDRDQUE0QyxnQkFBZ0I7QUFDNUQsb0NBQW9DLGdCQUFnQjtBQUNwRCx5Q0FBeUMsa0JBQWtCO0FBQzNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUE2RDtBQUN6RiwwQkFBMEIsdUJBQXVCO0FBQ2pELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RyxvREFBb0Q7QUFDcEQsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVyxLQUFLLFNBQVMsSUFBSSxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLHlFQUF5RSxLQUFLLGdCQUFnQjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQyxrREFBa0QsZUFBZTtBQUNqRSwyQ0FBMkMsV0FBVztBQUN0RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9DQUFvQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0IsR0FBRyxTQUFTO0FBQzdFLHdDQUF3QyxRQUFRLGVBQWUsU0FBUztBQUN4RTtBQUNBLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQSx5QkFBeUIsK0NBQStDO0FBQ3hFLFFBQVE7QUFDUix5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVSw2QkFBNkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsVUFBVTtBQUNoRiwrREFBK0QsV0FBVztBQUMxRTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25ELHlEQUF5RCxpQkFBaUI7QUFDMUUsd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLDhDQUE4QyxpQkFBaUI7QUFDL0QsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc25vd2ZsYWtlL3F1ZXJ5LWdlbmVyYXRvci5qcz83ZGI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuLi8uLi9vcGVyYXRvcnNcIik7XG5jb25zdCBKU09OX0ZVTkNUSU9OX1JFR0VYID0gL15cXHMqKCg/OlthLXpdK18pezAsMn1qc29uYj8oPzpfW2Etel0rKXswLDJ9KVxcKFteKV0qXFwpL2k7XG5jb25zdCBKU09OX09QRVJBVE9SX1JFR0VYID0gL15cXHMqKC0+Pj98QD58PEB8XFw/W3wmXT98XFx8ezJ9fCMtKS9pO1xuY29uc3QgVE9LRU5fQ0FQVFVSRV9SRUdFWCA9IC9eXFxzKigoPzooW2BcIiddKSg/Oig/IVxcMikufFxcMnsyfSkqXFwyKXxbXFx3XFxkXFxzXSt8WygpLiw7Ky1dKS9pO1xuY29uc3QgRk9SRUlHTl9LRVlfRklFTERTID0gW1xuICBcIkNPTlNUUkFJTlRfTkFNRSBhcyBjb25zdHJhaW50X25hbWVcIixcbiAgXCJDT05TVFJBSU5UX05BTUUgYXMgY29uc3RyYWludE5hbWVcIixcbiAgXCJDT05TVFJBSU5UX1NDSEVNQSBhcyBjb25zdHJhaW50U2NoZW1hXCIsXG4gIFwiQ09OU1RSQUlOVF9TQ0hFTUEgYXMgY29uc3RyYWludENhdGFsb2dcIixcbiAgXCJUQUJMRV9OQU1FIGFzIHRhYmxlTmFtZVwiLFxuICBcIlRBQkxFX1NDSEVNQSBhcyB0YWJsZVNjaGVtYVwiLFxuICBcIlRBQkxFX1NDSEVNQSBhcyB0YWJsZUNhdGFsb2dcIixcbiAgXCJDT0xVTU5fTkFNRSBhcyBjb2x1bW5OYW1lXCIsXG4gIFwiUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgYXMgcmVmZXJlbmNlZFRhYmxlU2NoZW1hXCIsXG4gIFwiUkVGRVJFTkNFRF9UQUJMRV9TQ0hFTUEgYXMgcmVmZXJlbmNlZFRhYmxlQ2F0YWxvZ1wiLFxuICBcIlJFRkVSRU5DRURfVEFCTEVfTkFNRSBhcyByZWZlcmVuY2VkVGFibGVOYW1lXCIsXG4gIFwiUkVGRVJFTkNFRF9DT0xVTU5fTkFNRSBhcyByZWZlcmVuY2VkQ29sdW1uTmFtZVwiXG5dLmpvaW4oXCIsXCIpO1xuY29uc3QgU05PV0ZMQUtFX1JFU0VSVkVEX1dPUkRTID0gXCJhY2NvdW50LGFsbCxhbHRlcixhbmQsYW55LGFzLGJldHdlZW4sYnksY2FzZSxjYXN0LGNoZWNrLGNvbHVtbixjb25uZWN0LGNvbm5lY3Rpb25zLGNvbnN0cmFpbnQsY3JlYXRlLGNyb3NzLGN1cnJlbnQsY3VycmVudF9kYXRlLGN1cnJlbnRfdGltZSxjdXJyZW50X3RpbWVzdGFtcCxjdXJyZW50X3VzZXIsZGF0YWJhc2UsZGVsZXRlLGRpc3RpbmN0LGRyb3AsZWxzZSxleGlzdHMsZmFsc2UsZm9sbG93aW5nLGZvcixmcm9tLGZ1bGwsZ3JhbnQsZ3JvdXAsZ3NjbHVzdGVyLGhhdmluZyxpbGlrZSxpbixpbmNyZW1lbnQsaW5uZXIsaW5zZXJ0LGludGVyc2VjdCxpbnRvLGlzLGlzc3VlLGpvaW4sbGF0ZXJhbCxsZWZ0LGxpa2UsbG9jYWx0aW1lLGxvY2FsdGltZXN0YW1wLG1pbnVzLG5hdHVyYWwsbm90LG51bGwsb2Ysb24sb3Isb3JkZXIsb3JnYW5pemF0aW9uLHF1YWxpZnkscmVnZXhwLHJldm9rZSxyaWdodCxybGlrZSxyb3cscm93cyxzYW1wbGUsc2NoZW1hLHNlbGVjdCxzZXQsc29tZSxzdGFydCx0YWJsZSx0YWJsZXNhbXBsZSx0aGVuLHRvLHRyaWdnZXIsdHJ1ZSx0cnlfY2FzdCx1bmlvbix1bmlxdWUsdXBkYXRlLHVzaW5nLHZhbHVlcyx2aWV3LHdoZW4sd2hlbmV2ZXIsd2hlcmUsd2l0aFwiLnNwbGl0KFwiLFwiKTtcbmNvbnN0IHR5cGVXaXRob3V0RGVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIkJMT0JcIiwgXCJURVhUXCIsIFwiR0VPTUVUUllcIiwgXCJKU09OXCJdKTtcbmNsYXNzIFNub3dmbGFrZVF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RRdWVyeUdlbmVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLk9wZXJhdG9yTWFwID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5PcGVyYXRvck1hcCksIHtcbiAgICAgIFtPcC5yZWdleHBdOiBcIlJFR0VYUFwiLFxuICAgICAgW09wLm5vdFJlZ2V4cF06IFwiTk9UIFJFR0VYUFwiXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlRGF0YWJhc2VRdWVyeShkYXRhYmFzZU5hbWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY2hhcnNldDogbnVsbCxcbiAgICAgIGNvbGxhdGU6IG51bGxcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBEQVRBQkFTRSBJRiBOT1QgRVhJU1RTXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhYmFzZU5hbWUpLFxuICAgICAgb3B0aW9ucy5jaGFyc2V0ICYmIGBERUZBVUxUIENIQVJBQ1RFUiBTRVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNoYXJzZXQpfWAsXG4gICAgICBvcHRpb25zLmNvbGxhdGUgJiYgYERFRkFVTFQgQ09MTEFURSAke3RoaXMuZXNjYXBlKG9wdGlvbnMuY29sbGF0ZSl9YCxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgZHJvcERhdGFiYXNlUXVlcnkoZGF0YWJhc2VOYW1lKSB7XG4gICAgcmV0dXJuIGBEUk9QIERBVEFCQVNFIElGIEVYSVNUUyAke3RoaXMucXVvdGVJZGVudGlmaWVyKGRhdGFiYXNlTmFtZSl9O2A7XG4gIH1cbiAgY3JlYXRlU2NoZW1hKCkge1xuICAgIHJldHVybiBcIlNIT1cgVEFCTEVTXCI7XG4gIH1cbiAgc2hvd1NjaGVtYXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTSE9XIFRBQkxFU1wiO1xuICB9XG4gIHZlcnNpb25RdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgQ1VSUkVOVF9WRVJTSU9OKClcIjtcbiAgfVxuICBjcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBjaGFyc2V0OiBudWxsLFxuICAgICAgcm93Rm9ybWF0OiBudWxsXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgY29uc3QgcHJpbWFyeUtleXMgPSBbXTtcbiAgICBjb25zdCBmb3JlaWduS2V5cyA9IHt9O1xuICAgIGNvbnN0IGF0dHJTdHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgbGV0IG1hdGNoO1xuICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgIG1hdGNoID0gZGF0YVR5cGUubWF0Y2goL14oLispIChSRUZFUkVOQ0VTLiopJC8pO1xuICAgICAgICAgIGF0dHJTdHIucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX0gJHttYXRjaFsxXS5yZXBsYWNlKFwiUFJJTUFSWSBLRVlcIiwgXCJcIil9YCk7XG4gICAgICAgICAgZm9yZWlnbktleXNbYXR0cl0gPSBtYXRjaFsyXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyU3RyLnB1c2goYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cil9ICR7ZGF0YVR5cGUucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBtYXRjaCA9IGRhdGFUeXBlLm1hdGNoKC9eKC4rKSAoUkVGRVJFTkNFUy4qKSQvKTtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke21hdGNoWzFdfWApO1xuICAgICAgICBmb3JlaWduS2V5c1thdHRyXSA9IG1hdGNoWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clN0ci5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBhdHRyaWJ1dGVzQ2xhdXNlID0gYXR0clN0ci5qb2luKFwiLCBcIik7XG4gICAgY29uc3QgcGtTdHJpbmcgPSBwcmltYXJ5S2V5cy5tYXAoKHBrKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihwaykpLmpvaW4oXCIsIFwiKTtcbiAgICBpZiAob3B0aW9ucy51bmlxdWVLZXlzKSB7XG4gICAgICBfLmVhY2gob3B0aW9ucy51bmlxdWVLZXlzLCAoY29sdW1ucywgaW5kZXhOYW1lKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGluZGV4TmFtZSA9IGB1bmlxXyR7dGFibGVOYW1lfV8ke2NvbHVtbnMuZmllbGRzLmpvaW4oXCJfXCIpfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNDbGF1c2UgKz0gYCwgVU5JUVVFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoaW5kZXhOYW1lKX0gKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0cmlidXRlc0NsYXVzZSArPSBgLCBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBma2V5IGluIGZvcmVpZ25LZXlzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvcmVpZ25LZXlzLCBma2V5KSkge1xuICAgICAgICBhdHRyaWJ1dGVzQ2xhdXNlICs9IGAsIEZPUkVJR04gS0VZICgke3RoaXMucXVvdGVJZGVudGlmaWVyKGZrZXkpfSkgJHtmb3JlaWduS2V5c1tma2V5XX1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkNSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTXCIsXG4gICAgICB0YWJsZSxcbiAgICAgIGAoJHthdHRyaWJ1dGVzQ2xhdXNlfSlgLFxuICAgICAgb3B0aW9ucy5jb21tZW50ICYmIHR5cGVvZiBvcHRpb25zLmNvbW1lbnQgPT09IFwic3RyaW5nXCIgJiYgYENPTU1FTlQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmNvbW1lbnQpfWAsXG4gICAgICBvcHRpb25zLmNoYXJzZXQgJiYgYERFRkFVTFQgQ0hBUlNFVD0ke29wdGlvbnMuY2hhcnNldH1gLFxuICAgICAgb3B0aW9ucy5jb2xsYXRlICYmIGBDT0xMQVRFICR7b3B0aW9ucy5jb2xsYXRlfWAsXG4gICAgICBvcHRpb25zLnJvd0Zvcm1hdCAmJiBgUk9XX0ZPUk1BVD0ke29wdGlvbnMucm93Rm9ybWF0fWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKSB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnF1b3RlVGFibGUodGhpcy5hZGRTY2hlbWEoe1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgX3NjaGVtYTogc2NoZW1hLFxuICAgICAgX3NjaGVtYURlbGltaXRlcjogc2NoZW1hRGVsaW1pdGVyXG4gICAgfSkpO1xuICAgIHJldHVybiBgU0hPVyBGVUxMIENPTFVNTlMgRlJPTSAke3RhYmxlfTtgO1xuICB9XG4gIHNob3dUYWJsZXNRdWVyeShkYXRhYmFzZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRSdcIixcbiAgICAgIGRhdGFiYXNlID8gYEFORCBUQUJMRV9TQ0hFTUEgPSAke3RoaXMuZXNjYXBlKGRhdGFiYXNlKX1gIDogXCJBTkQgVEFCTEVfU0NIRU1BIE5PVCBJTiAoICdJTkZPUk1BVElPTl9TQ0hFTUEnLCAnUEVSRk9STUFOQ0VfU0NIRU1BJywgJ1NZUycpXCIsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGUpIHtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0YWJsZS50YWJsZU5hbWUgfHwgdGFibGU7XG4gICAgY29uc3Qgc2NoZW1hID0gdGFibGUuc2NoZW1hO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUIFRBQkxFX05BTUUgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuVEFCTEVTIFdIRVJFIFRBQkxFX1RZUEUgPSAnQkFTRSBUQUJMRSdcIixcbiAgICAgIGBBTkQgVEFCTEVfU0NIRU1BID0gJHtzY2hlbWEgIT09IHZvaWQgMCA/IHRoaXMuZXNjYXBlKHNjaGVtYSkgOiBcIkNVUlJFTlRfU0NIRU1BKClcIn1gLFxuICAgICAgYEFORCBUQUJMRV9OQU1FID0gJHt0aGlzLmVzY2FwZSh0YWJsZU5hbWUpfWAsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGFkZENvbHVtblF1ZXJ5KHRhYmxlLCBrZXksIGRhdGFUeXBlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlKSxcbiAgICAgIFwiQUREXCIsXG4gICAgICB0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpLFxuICAgICAgdGhpcy5hdHRyaWJ1dGVUb1NRTChkYXRhVHlwZSwge1xuICAgICAgICBjb250ZXh0OiBcImFkZENvbHVtblwiLFxuICAgICAgICB0YWJsZU5hbWU6IHRhYmxlLFxuICAgICAgICBmb3JlaWduS2V5OiBrZXlcbiAgICAgIH0pLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICByZW1vdmVDb2x1bW5RdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiRFJPUFwiLFxuICAgICAgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICB9XG4gIGNoYW5nZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHF1ZXJ5ID0gKC4uLnN1YlF1ZXJ5cykgPT4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiQUxURVIgQ09MVU1OXCIsXG4gICAgICAuLi5zdWJRdWVyeXMsXG4gICAgICBcIjtcIlxuICAgIF0pO1xuICAgIGNvbnN0IHNxbCA9IFtdO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBsZXQgZGVmaW5pdGlvbiA9IHRoaXMuZGF0YVR5cGVNYXBwaW5nKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICBjb25zdCBhdHRyU3FsID0gW107XG4gICAgICBpZiAoZGVmaW5pdGlvbi5pbmNsdWRlcyhcIk5PVCBOVUxMXCIpKSB7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeSh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCJTRVQgTk9UIE5VTExcIikpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKFwiTk9UIE5VTExcIiwgXCJcIikudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICghZGVmaW5pdGlvbi5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIkRST1AgTk9UIE5VTExcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5jbHVkZXMoXCJERUZBVUxUXCIpKSB7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeSh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCJTRVQgREVGQVVMVFwiLCBkZWZpbml0aW9uLm1hdGNoKC9ERUZBVUxUIChbXjtdKykvKVsxXSkpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8oREVGQVVMVFteO10rKS8sIFwiXCIpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZmluaXRpb24uaW5jbHVkZXMoXCJSRUZFUkVOQ0VTXCIpKSB7XG4gICAgICAgIGF0dHJTcWwucHVzaChxdWVyeSh0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCJEUk9QIERFRkFVTFRcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24ubWF0Y2goL1VOSVFVRTsqJC8pKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uLnJlcGxhY2UoL1VOSVFVRTsqJC8sIFwiXCIpO1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkoXCJBREQgVU5JUVVFIChcIiwgdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlTmFtZSksIFwiKVwiKS5yZXBsYWNlKFwiQUxURVIgQ09MVU1OXCIsIFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLmluY2x1ZGVzKFwiUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbi5yZXBsYWNlKC8uKz8oPz1SRUZFUkVOQ0VTKS8sIFwiXCIpO1xuICAgICAgICBhdHRyU3FsLnB1c2gocXVlcnkoXCJBREQgRk9SRUlHTiBLRVkgKFwiLCB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGVOYW1lKSwgXCIpXCIsIGRlZmluaXRpb24pLnJlcGxhY2UoXCJBTFRFUiBDT0xVTU5cIiwgXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0clNxbC5wdXNoKHF1ZXJ5KHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJpYnV0ZU5hbWUpLCBcIlRZUEVcIiwgZGVmaW5pdGlvbikpO1xuICAgICAgfVxuICAgICAgc3FsLnB1c2goYXR0clNxbC5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNxbC5qb2luKFwiXCIpO1xuICB9XG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ckJlZm9yZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGF0dHJTdHJpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBhdHRyaWJ1dGVzW2F0dHJOYW1lXTtcbiAgICAgIGF0dHJTdHJpbmcucHVzaChgJyR7YXR0ckJlZm9yZX0nICcke2F0dHJOYW1lfScgJHtkZWZpbml0aW9ufWApO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkFMVEVSIFRBQkxFXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiUkVOQU1FIENPTFVNTlwiLFxuICAgICAgYXR0clN0cmluZy5qb2luKFwiIHRvIFwiKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCkge1xuICAgIGlmIChhdHRyIGluc3RhbmNlb2YgVXRpbHMuSnNvbikge1xuICAgICAgaWYgKGF0dHIuY29uZGl0aW9ucykge1xuICAgICAgICBjb25zdCBjb25kaXRpb25zID0gdGhpcy5wYXJzZUNvbmRpdGlvbk9iamVjdChhdHRyLmNvbmRpdGlvbnMpLm1hcCgoY29uZGl0aW9uKSA9PiBgJHt0aGlzLmpzb25QYXRoRXh0cmFjdGlvblF1ZXJ5KGNvbmRpdGlvbi5wYXRoWzBdLCBfLnRhaWwoY29uZGl0aW9uLnBhdGgpKX0gPSAnJHtjb25kaXRpb24udmFsdWV9J2ApO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9ucy5qb2luKFwiIEFORCBcIik7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ci5wYXRoKSB7XG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0aGlzLl9jaGVja1ZhbGlkSnNvblN0YXRlbWVudChhdHRyLnBhdGgpKSB7XG4gICAgICAgICAgc3RyID0gYXR0ci5wYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhdGhzID0gXy50b1BhdGgoYXR0ci5wYXRoKTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXRocy5zaGlmdCgpO1xuICAgICAgICAgIHN0ciA9IHRoaXMuanNvblBhdGhFeHRyYWN0aW9uUXVlcnkoY29sdW1uLCBwYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0dHIudmFsdWUpIHtcbiAgICAgICAgICBzdHIgKz0gdXRpbC5mb3JtYXQoXCIgPSAlc1wiLCB0aGlzLmVzY2FwZShhdHRyLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF0dHIgaW5zdGFuY2VvZiBVdGlscy5DYXN0KSB7XG4gICAgICBpZiAoL3RpbWVzdGFtcC9pLnRlc3QoYXR0ci50eXBlKSkge1xuICAgICAgICBhdHRyLnR5cGUgPSBcImRhdGV0aW1lXCI7XG4gICAgICB9IGVsc2UgaWYgKGF0dHIuanNvbiAmJiAvYm9vbGVhbi9pLnRlc3QoYXR0ci50eXBlKSkge1xuICAgICAgICBhdHRyLnR5cGUgPSBcImNoYXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoL2RvdWJsZSBwcmVjaXNpb24vaS50ZXN0KGF0dHIudHlwZSkgfHwgL2Jvb2xlYW4vaS50ZXN0KGF0dHIudHlwZSkgfHwgL2ludGVnZXIvaS50ZXN0KGF0dHIudHlwZSkpIHtcbiAgICAgICAgYXR0ci50eXBlID0gXCJkZWNpbWFsXCI7XG4gICAgICB9IGVsc2UgaWYgKC90ZXh0L2kudGVzdChhdHRyLnR5cGUpKSB7XG4gICAgICAgIGF0dHIudHlwZSA9IFwiY2hhclwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kKGF0dHIsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gIH1cbiAgdHJ1bmNhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSkge1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiVFJVTkNBVEVcIixcbiAgICAgIHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpXG4gICAgXSk7XG4gIH1cbiAgZGVsZXRlUXVlcnkodGFibGVOYW1lLCB3aGVyZSwgb3B0aW9ucyA9IHt9LCBtb2RlbCkge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgbGV0IHdoZXJlQ2xhdXNlID0gdGhpcy5nZXRXaGVyZUNvbmRpdGlvbnMod2hlcmUsIG51bGwsIG1vZGVsLCBvcHRpb25zKTtcbiAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXQgJiYgYCBMSU1JVCAke3RoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpfWA7XG4gICAgbGV0IHByaW1hcnlLZXlzID0gXCJcIjtcbiAgICBsZXQgcHJpbWFyeUtleXNTZWxlY3Rpb24gPSBcIlwiO1xuICAgIGlmICh3aGVyZUNsYXVzZSkge1xuICAgICAgd2hlcmVDbGF1c2UgPSBgV0hFUkUgJHt3aGVyZUNsYXVzZX1gO1xuICAgIH1cbiAgICBpZiAobGltaXQpIHtcbiAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IExJTUlUIGRlbGV0ZSB3aXRob3V0IGEgbW9kZWwuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGtzID0gT2JqZWN0LnZhbHVlcyhtb2RlbC5wcmltYXJ5S2V5cykubWFwKChwaykgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIocGsuZmllbGQpKS5qb2luKFwiLFwiKTtcbiAgICAgIHByaW1hcnlLZXlzID0gbW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZXMubGVuZ3RoID4gMSA/IGAoJHtwa3N9KWAgOiBwa3M7XG4gICAgICBwcmltYXJ5S2V5c1NlbGVjdGlvbiA9IHBrcztcbiAgICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgICAgXCJERUxFVEUgRlJPTVwiLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgXCJXSEVSRVwiLFxuICAgICAgICBwcmltYXJ5S2V5cyxcbiAgICAgICAgXCJJTiAoU0VMRUNUXCIsXG4gICAgICAgIHByaW1hcnlLZXlzU2VsZWN0aW9uLFxuICAgICAgICBcIkZST01cIixcbiAgICAgICAgdGFibGUsXG4gICAgICAgIHdoZXJlQ2xhdXNlLFxuICAgICAgICBsaW1pdCxcbiAgICAgICAgXCIpXCIsXG4gICAgICAgIFwiO1wiXG4gICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJERUxFVEUgRlJPTVwiLFxuICAgICAgdGFibGUsXG4gICAgICB3aGVyZUNsYXVzZSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgc2hvd0luZGV4ZXNRdWVyeSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgJycgRlJPTSBEVUFMXCI7XG4gIH1cbiAgc2hvd0NvbnN0cmFpbnRzUXVlcnkodGFibGUsIGNvbnN0cmFpbnROYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIGNvbnN0IHNjaGVtYU5hbWUgPSB0YWJsZS5zY2hlbWE7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1QgQ09OU1RSQUlOVF9DQVRBTE9HIEFTIGNvbnN0cmFpbnRDYXRhbG9nLFwiLFxuICAgICAgXCJDT05TVFJBSU5UX05BTUUgQVMgY29uc3RyYWludE5hbWUsXCIsXG4gICAgICBcIkNPTlNUUkFJTlRfU0NIRU1BIEFTIGNvbnN0cmFpbnRTY2hlbWEsXCIsXG4gICAgICBcIkNPTlNUUkFJTlRfVFlQRSBBUyBjb25zdHJhaW50VHlwZSxcIixcbiAgICAgIFwiVEFCTEVfTkFNRSBBUyB0YWJsZU5hbWUsXCIsXG4gICAgICBcIlRBQkxFX1NDSEVNQSBBUyB0YWJsZVNjaGVtYVwiLFxuICAgICAgXCJmcm9tIElORk9STUFUSU9OX1NDSEVNQS5UQUJMRV9DT05TVFJBSU5UU1wiLFxuICAgICAgYFdIRVJFIHRhYmxlX25hbWU9JyR7dGFibGVOYW1lfSdgLFxuICAgICAgY29uc3RyYWludE5hbWUgJiYgYEFORCBjb25zdHJhaW50X25hbWUgPSAnJHtjb25zdHJhaW50TmFtZX0nYCxcbiAgICAgIHNjaGVtYU5hbWUgJiYgYEFORCBUQUJMRV9TQ0hFTUEgPSAnJHtzY2hlbWFOYW1lfSdgLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICByZW1vdmVJbmRleFF1ZXJ5KHRhYmxlTmFtZSwgaW5kZXhOYW1lT3JBdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGluZGV4TmFtZSA9IGluZGV4TmFtZU9yQXR0cmlidXRlcztcbiAgICBpZiAodHlwZW9mIGluZGV4TmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgaW5kZXhOYW1lID0gVXRpbHMudW5kZXJzY29yZShgJHt0YWJsZU5hbWV9XyR7aW5kZXhOYW1lT3JBdHRyaWJ1dGVzLmpvaW4oXCJfXCIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbHMuam9pblNRTEZyYWdtZW50cyhbXG4gICAgICBcIkRST1AgSU5ERVhcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGluZGV4TmFtZSksXG4gICAgICBcIk9OXCIsXG4gICAgICB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKSxcbiAgICAgIFwiO1wiXG4gICAgXSk7XG4gIH1cbiAgYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlKSkge1xuICAgICAgYXR0cmlidXRlID0ge1xuICAgICAgICB0eXBlOiBhdHRyaWJ1dGVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGF0dHJpYnV0ZVN0cmluZyA9IGF0dHJpYnV0ZS50eXBlLnRvU3RyaW5nKHsgZXNjYXBlOiB0aGlzLmVzY2FwZS5iaW5kKHRoaXMpIH0pO1xuICAgIGxldCB0ZW1wbGF0ZSA9IGF0dHJpYnV0ZVN0cmluZztcbiAgICBpZiAoYXR0cmlidXRlLmFsbG93TnVsbCA9PT0gZmFsc2UpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gXCIgQVVUT0lOQ1JFTUVOVFwiO1xuICAgIH1cbiAgICBpZiAoIXR5cGVXaXRob3V0RGVmYXVsdC5oYXMoYXR0cmlidXRlU3RyaW5nKSAmJiBhdHRyaWJ1dGUudHlwZS5fYmluYXJ5ICE9PSB0cnVlICYmIFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBERUZBVUxUICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSl9YDtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS51bmlxdWUgPT09IHRydWUpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFVOSVFVRVwiO1xuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnByaW1hcnlLZXkpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIFBSSU1BUlkgS0VZXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuY29tbWVudCkge1xuICAgICAgdGVtcGxhdGUgKz0gYCBDT01NRU5UICR7dGhpcy5lc2NhcGUoYXR0cmlidXRlLmNvbW1lbnQpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuZmlyc3QpIHtcbiAgICAgIHRlbXBsYXRlICs9IFwiIEZJUlNUXCI7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUuYWZ0ZXIpIHtcbiAgICAgIHRlbXBsYXRlICs9IGAgQUZURVIgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyaWJ1dGUuYWZ0ZXIpfWA7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID09PSBcImFkZENvbHVtblwiICYmIG9wdGlvbnMuZm9yZWlnbktleSkge1xuICAgICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKG9wdGlvbnMuZm9yZWlnbktleSk7XG4gICAgICAgIGNvbnN0IGZrTmFtZSA9IHRoaXMucXVvdGVJZGVudGlmaWVyKGAke29wdGlvbnMudGFibGVOYW1lfV8ke2F0dHJOYW1lfV9mb3JlaWduX2lkeGApO1xuICAgICAgICB0ZW1wbGF0ZSArPSBgLCBBREQgQ09OU1RSQUlOVCAke2ZrTmFtZX0gRk9SRUlHTiBLRVkgKCR7YXR0ck5hbWV9KWA7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZSArPSBgIFJFRkVSRU5DRVMgJHt0aGlzLnF1b3RlVGFibGUoYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwpfWA7XG4gICAgICBpZiAoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cmlidXRlLnJlZmVyZW5jZXMua2V5KX0pYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlICs9IGAgKCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJpZFwiKX0pYDtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUub25EZWxldGUpIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYCBPTiBERUxFVEUgJHthdHRyaWJ1dGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZS5vblVwZGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZSArPSBgIE9OIFVQREFURSAke2F0dHJpYnV0ZS5vblVwZGF0ZS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuICBhdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIHJlc3VsdFthdHRyaWJ1dGUuZmllbGQgfHwga2V5XSA9IHRoaXMuYXR0cmlidXRlVG9TUUwoYXR0cmlidXRlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEluZGV4ID0gMDtcbiAgICBsZXQgb3BlbmluZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgY2xvc2luZ0JyYWNrZXRzID0gMDtcbiAgICBsZXQgaGFzSnNvbkZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGhhc0ludmFsaWRUb2tlbiA9IGZhbHNlO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZXggPCBzdG10Lmxlbmd0aCkge1xuICAgICAgY29uc3Qgc3RyaW5nID0gc3RtdC5zdWJzdHIoY3VycmVudEluZGV4KTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uTWF0Y2hlcyA9IEpTT05fRlVOQ1RJT05fUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKGZ1bmN0aW9uTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gZnVuY3Rpb25NYXRjaGVzWzBdLmluZGV4T2YoXCIoXCIpO1xuICAgICAgICBoYXNKc29uRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZXJhdG9yTWF0Y2hlcyA9IEpTT05fT1BFUkFUT1JfUkVHRVguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKG9wZXJhdG9yTWF0Y2hlcykge1xuICAgICAgICBjdXJyZW50SW5kZXggKz0gb3BlcmF0b3JNYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgaGFzSnNvbkZ1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b2tlbk1hdGNoZXMgPSBUT0tFTl9DQVBUVVJFX1JFR0VYLmV4ZWMoc3RyaW5nKTtcbiAgICAgIGlmICh0b2tlbk1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRUb2tlbiA9IHRva2VuTWF0Y2hlc1sxXTtcbiAgICAgICAgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICAgICAgb3BlbmluZ0JyYWNrZXRzKys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICBjbG9zaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIjtcIikge1xuICAgICAgICAgIGhhc0ludmFsaWRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEluZGV4ICs9IHRva2VuTWF0Y2hlc1swXS5sZW5ndGg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgKGhhc0ludmFsaWRUb2tlbiB8fCBvcGVuaW5nQnJhY2tldHMgIT09IGNsb3NpbmdCcmFja2V0cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBqc29uIHN0YXRlbWVudDogJHtzdG10fWApO1xuICAgIH1cbiAgICByZXR1cm4gaGFzSnNvbkZ1bmN0aW9uO1xuICB9XG4gIGRhdGFUeXBlTWFwcGluZyh0YWJsZU5hbWUsIGF0dHIsIGRhdGFUeXBlKSB7XG4gICAgaWYgKGRhdGFUeXBlLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpIHtcbiAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJTRVJJQUxcIikpIHtcbiAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIkJJR0lOVFwiKSkge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJTRVJJQUxcIiwgXCJCSUdTRVJJQUxcIik7XG4gICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUucmVwbGFjZShcIkJJR0lOVFwiLCBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJTTUFMTElOVFwiKSkge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJTRVJJQUxcIiwgXCJTTUFMTFNFUklBTFwiKTtcbiAgICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiU01BTExJTlRcIiwgXCJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlLnJlcGxhY2UoXCJJTlRFR0VSXCIsIFwiXCIpO1xuICAgICAgfVxuICAgICAgZGF0YVR5cGUgPSBkYXRhVHlwZS5yZXBsYWNlKFwiTk9UIE5VTExcIiwgXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhVHlwZTtcbiAgfVxuICBnZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlLCBzY2hlbWFOYW1lKSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUudGFibGVOYW1lIHx8IHRhYmxlO1xuICAgIHJldHVybiBVdGlscy5qb2luU1FMRnJhZ21lbnRzKFtcbiAgICAgIFwiU0VMRUNUXCIsXG4gICAgICBGT1JFSUdOX0tFWV9GSUVMRFMsXG4gICAgICBgRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRSB3aGVyZSBUQUJMRV9OQU1FID0gJyR7dGFibGVOYW1lfSdgLFxuICAgICAgYEFORCBDT05TVFJBSU5UX05BTUUhPSdQUklNQVJZJyBBTkQgQ09OU1RSQUlOVF9TQ0hFTUE9JyR7c2NoZW1hTmFtZX0nYCxcbiAgICAgIFwiQU5EIFJFRkVSRU5DRURfVEFCTEVfTkFNRSBJUyBOT1QgTlVMTFwiLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBnZXRGb3JlaWduS2V5UXVlcnkodGFibGUsIGNvbHVtbk5hbWUpIHtcbiAgICBjb25zdCBxdW90ZWRTY2hlbWFOYW1lID0gdGFibGUuc2NoZW1hID8gd3JhcFNpbmdsZVF1b3RlKHRhYmxlLnNjaGVtYSkgOiBcIlwiO1xuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHdyYXBTaW5nbGVRdW90ZSh0YWJsZS50YWJsZU5hbWUgfHwgdGFibGUpO1xuICAgIGNvbnN0IHF1b3RlZENvbHVtbk5hbWUgPSB3cmFwU2luZ2xlUXVvdGUoY29sdW1uTmFtZSk7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJTRUxFQ1RcIixcbiAgICAgIEZPUkVJR05fS0VZX0ZJRUxEUyxcbiAgICAgIFwiRlJPTSBJTkZPUk1BVElPTl9TQ0hFTUEuS0VZX0NPTFVNTl9VU0FHRVwiLFxuICAgICAgXCJXSEVSRSAoXCIsXG4gICAgICBbXG4gICAgICAgIGBSRUZFUkVOQ0VEX1RBQkxFX05BTUUgPSAke3F1b3RlZFRhYmxlTmFtZX1gLFxuICAgICAgICB0YWJsZS5zY2hlbWEgJiYgYEFORCBSRUZFUkVOQ0VEX1RBQkxFX1NDSEVNQSA9ICR7cXVvdGVkU2NoZW1hTmFtZX1gLFxuICAgICAgICBgQU5EIFJFRkVSRU5DRURfQ09MVU1OX05BTUUgPSAke3F1b3RlZENvbHVtbk5hbWV9YFxuICAgICAgXSxcbiAgICAgIFwiKSBPUiAoXCIsXG4gICAgICBbXG4gICAgICAgIGBUQUJMRV9OQU1FID0gJHtxdW90ZWRUYWJsZU5hbWV9YCxcbiAgICAgICAgdGFibGUuc2NoZW1hICYmIGBBTkQgVEFCTEVfU0NIRU1BID0gJHtxdW90ZWRTY2hlbWFOYW1lfWAsXG4gICAgICAgIGBBTkQgQ09MVU1OX05BTUUgPSAke3F1b3RlZENvbHVtbk5hbWV9YCxcbiAgICAgICAgXCJBTkQgUkVGRVJFTkNFRF9UQUJMRV9OQU1FIElTIE5PVCBOVUxMXCJcbiAgICAgIF0sXG4gICAgICBcIilcIlxuICAgIF0pO1xuICB9XG4gIGRyb3BGb3JlaWduS2V5UXVlcnkodGFibGVOYW1lLCBmb3JlaWduS2V5KSB7XG4gICAgcmV0dXJuIFV0aWxzLmpvaW5TUUxGcmFnbWVudHMoW1xuICAgICAgXCJBTFRFUiBUQUJMRVwiLFxuICAgICAgdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksXG4gICAgICBcIkRST1AgRk9SRUlHTiBLRVlcIixcbiAgICAgIHRoaXMucXVvdGVJZGVudGlmaWVyKGZvcmVpZ25LZXkpLFxuICAgICAgXCI7XCJcbiAgICBdKTtcbiAgfVxuICBhZGRMaW1pdEFuZE9mZnNldChvcHRpb25zKSB7XG4gICAgbGV0IGZyYWdtZW50ID0gW107XG4gICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9PSBudWxsICYmIG9wdGlvbnMub2Zmc2V0ICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5vZmZzZXQgIT09IDApIHtcbiAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuY29uY2F0KFtcIiBMSU1JVCBcIiwgdGhpcy5lc2NhcGUob3B0aW9ucy5saW1pdCksIFwiIE9GRlNFVCBcIiwgdGhpcy5lc2NhcGUob3B0aW9ucy5vZmZzZXQpXSk7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmxpbWl0ICE9PSBudWxsICYmIG9wdGlvbnMubGltaXQgIT09IHZvaWQgMCkge1xuICAgICAgZnJhZ21lbnQgPSBbXCIgTElNSVQgXCIsIHRoaXMuZXNjYXBlKG9wdGlvbnMubGltaXQpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50LmpvaW4oXCJcIik7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgY29uc3Qgb3B0Rm9yY2VRdW90ZSA9IGZvcmNlIHx8IGZhbHNlO1xuICAgIGNvbnN0IG9wdFF1b3RlSWRlbnRpZmllcnMgPSB0aGlzLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyAhPT0gZmFsc2U7XG4gICAgY29uc3QgcmF3SWRlbnRpZmllciA9IFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsICdcIicpO1xuICAgIGlmIChvcHRGb3JjZVF1b3RlID09PSB0cnVlIHx8IG9wdFF1b3RlSWRlbnRpZmllcnMgIT09IGZhbHNlIHx8IGlkZW50aWZpZXIuaW5jbHVkZXMoXCIuXCIpIHx8IGlkZW50aWZpZXIuaW5jbHVkZXMoXCItPlwiKSB8fCBTTk9XRkxBS0VfUkVTRVJWRURfV09SRFMuaW5jbHVkZXMocmF3SWRlbnRpZmllci50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKHJhd0lkZW50aWZpZXIsICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gcmF3SWRlbnRpZmllcjtcbiAgfVxufVxuZnVuY3Rpb24gd3JhcFNpbmdsZVF1b3RlKGlkZW50aWZpZXIpIHtcbiAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKGlkZW50aWZpZXIsIFwiJ1wiKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gU25vd2ZsYWtlUXVlcnlHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS1nZW5lcmF0b3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-interface.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/query-interface.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nclass SnowflakeQueryInterface extends QueryInterface {\n  async removeColumn(tableName, columnName, options) {\n    options = options || {};\n    const [results] = await this.sequelize.query(this.queryGenerator.getForeignKeyQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, columnName), __spreadValues({ raw: true }, options));\n    if (results.length && results[0].constraint_name !== \"PRIMARY\") {\n      await Promise.all(results.map((constraint) => this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, constraint.constraint_name), __spreadValues({ raw: true }, options))));\n    }\n    return await this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, columnName), __spreadValues({ raw: true }, options));\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    const model = options.model;\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName.tableName ? tableName : {\n      tableName,\n      schema: this.sequelize.config.database\n    }, constraintName);\n    const constraints = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: this.sequelize.QueryTypes.SHOWCONSTRAINTS\n    }));\n    const constraint = constraints[0];\n    let query;\n    if (!constraint || !constraint.constraintType) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      query = this.queryGenerator.dropForeignKeyQuery(tableName, constraintName);\n    } else {\n      query = this.queryGenerator.removeIndexQuery(constraint.tableName, constraint.constraintName);\n    }\n    return await this.sequelize.query(query, options);\n  }\n}\nexports.SnowflakeQueryInterface = SnowflakeQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDaEUsbUJBQW1CLG1CQUFPLENBQUMsNEVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDLFdBQVc7QUFDaEQ7QUFDQSwwS0FBMEssV0FBVztBQUNyTDtBQUNBLHFIQUFxSCxXQUFXO0FBQ2hJO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUZBQXVGO0FBQ3ZGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixXQUFXLFdBQVc7QUFDckU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc25vd2ZsYWtlL3F1ZXJ5LWludGVyZmFjZS5qcz82MjJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IFF1ZXJ5VHlwZXMgPSByZXF1aXJlKFwiLi4vLi4vcXVlcnktdHlwZXNcIik7XG5jbGFzcyBTbm93Zmxha2VRdWVyeUludGVyZmFjZSBleHRlbmRzIFF1ZXJ5SW50ZXJmYWNlIHtcbiAgYXN5bmMgcmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZ2V0Rm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZS50YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiB7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBzY2hlbWE6IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZVxuICAgIH0sIGNvbHVtbk5hbWUpLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoICYmIHJlc3VsdHNbMF0uY29uc3RyYWludF9uYW1lICE9PSBcIlBSSU1BUllcIikge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocmVzdWx0cy5tYXAoKGNvbnN0cmFpbnQpID0+IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHRoaXMucXVlcnlHZW5lcmF0b3IuZHJvcEZvcmVpZ25LZXlRdWVyeSh0YWJsZU5hbWUsIGNvbnN0cmFpbnQuY29uc3RyYWludF9uYW1lKSwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpKSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeSh0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgY29sdW1uTmFtZSksIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyB1cHNlcnQodGFibGVOYW1lLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgd2hlcmUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuVVBTRVJUO1xuICAgIG9wdGlvbnMudXBkYXRlT25EdXBsaWNhdGUgPSBPYmplY3Qua2V5cyh1cGRhdGVWYWx1ZXMpO1xuICAgIGNvbnN0IG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmluc2VydFF1ZXJ5KHRhYmxlTmFtZSwgaW5zZXJ0VmFsdWVzLCBtb2RlbC5yYXdBdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoc3FsLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyByZW1vdmVDb25zdHJhaW50KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZS50YWJsZU5hbWUgPyB0YWJsZU5hbWUgOiB7XG4gICAgICB0YWJsZU5hbWUsXG4gICAgICBzY2hlbWE6IHRoaXMuc2VxdWVsaXplLmNvbmZpZy5kYXRhYmFzZVxuICAgIH0sIGNvbnN0cmFpbnROYW1lKTtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHtcbiAgICAgIHR5cGU6IHRoaXMuc2VxdWVsaXplLlF1ZXJ5VHlwZXMuU0hPV0NPTlNUUkFJTlRTXG4gICAgfSkpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBjb25zdHJhaW50c1swXTtcbiAgICBsZXQgcXVlcnk7XG4gICAgaWYgKCFjb25zdHJhaW50IHx8ICFjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ29uc3RyYWludCAke2NvbnN0cmFpbnROYW1lfSBvbiB0YWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgLFxuICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50TmFtZSxcbiAgICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50LmNvbnN0cmFpbnRUeXBlID09PSBcIkZPUkVJR04gS0VZXCIpIHtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5kcm9wRm9yZWlnbktleVF1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucmVtb3ZlSW5kZXhRdWVyeShjb25zdHJhaW50LnRhYmxlTmFtZSwgY29uc3RyYWludC5jb25zdHJhaW50TmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShxdWVyeSwgb3B0aW9ucyk7XG4gIH1cbn1cbmV4cG9ydHMuU25vd2ZsYWtlUXVlcnlJbnRlcmZhY2UgPSBTbm93Zmxha2VRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/snowflake/query.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst ER_DUP_ENTRY = 1062;\nconst ER_DEADLOCK = 1213;\nconst ER_ROW_IS_REFERENCED = 1451;\nconst ER_NO_REFERENCED_ROW = 1452;\nconst debug = logger.debugContext(\"sql:snowflake\");\nclass Query extends AbstractQuery {\n  static formatBindParameters(sql, values, dialect) {\n    const bindParam = [];\n    const replacementFunc = (_match, key, values_) => {\n      if (values_[key] !== void 0) {\n        bindParam.push(values_[key]);\n        return \"?\";\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, bindParam.length > 0 ? bindParam : void 0];\n  }\n  async run(sql, parameters) {\n    this.sql = sql;\n    const { connection, options } = this;\n    const showWarnings = this.sequelize.options.showWarnings || options.showWarnings;\n    const complete = this._logQuery(sql, debug, parameters);\n    if (parameters) {\n      debug(\"parameters(%j)\", parameters);\n    }\n    let results;\n    try {\n      results = await new Promise((resolve, reject) => {\n        connection.execute({\n          sqlText: sql,\n          binds: parameters,\n          complete(err, _stmt, rows) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(rows);\n            }\n          }\n        });\n      });\n    } catch (error) {\n      if (options.transaction && error.errno === ER_DEADLOCK) {\n        try {\n          await options.transaction.rollback();\n        } catch (error_) {\n        }\n        options.transaction.finished = \"rollback\";\n      }\n      error.sql = sql;\n      error.parameters = parameters;\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n    if (showWarnings && results && results.warningStatus > 0) {\n      await this.logWarnings(results);\n    }\n    return this.formatResults(results);\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      this.handleInsertQuery(data);\n      if (!this.instance) {\n        if (data.constructor.name === \"ResultSetHeader\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = data[this.getInsertIdField()];\n          result = [];\n          for (let i = startId; i < startId + data.affectedRows; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = data[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw === false && this.sequelize.options.quoteIdentifiers === false) {\n        const sfAttrMap = _.reduce(this.model.rawAttributes, (m, v, k) => {\n          m[k.toUpperCase()] = k;\n          return m;\n        }, {});\n        data = data.map((data2) => _.reduce(data2, (prev, value, key) => {\n          if (value !== void 0 && sfAttrMap[key]) {\n            prev[sfAttrMap[key]] = value;\n            delete prev[key];\n          }\n          return prev;\n        }, data2));\n      }\n      this.options.fieldMap = _.mapKeys(this.options.fieldMap, (v, k) => {\n        return k.toUpperCase();\n      });\n      return this.handleSelectQuery(data);\n    }\n    if (this.isShowTablesQuery()) {\n      return this.handleShowTablesQuery(data);\n    }\n    if (this.isDescribeQuery()) {\n      result = {};\n      for (const _result of data) {\n        result[_result.Field] = {\n          type: _result.Type.toUpperCase(),\n          allowNull: _result.Null === \"YES\",\n          defaultValue: _result.Default,\n          primaryKey: _result.Key === \"PRI\",\n          autoIncrement: Object.prototype.hasOwnProperty.call(_result, \"Extra\") && _result.Extra.toLowerCase() === \"auto_increment\",\n          comment: _result.Comment ? _result.Comment : null\n        };\n      }\n      return result;\n    }\n    if (this.isShowIndexesQuery()) {\n      return this.handleShowIndexesQuery(data);\n    }\n    if (this.isCallQuery()) {\n      return data[0];\n    }\n    if (this.isBulkUpdateQuery() || this.isBulkDeleteQuery()) {\n      return data[0][\"number of rows updated\"];\n    }\n    if (this.isVersionQuery()) {\n      return data[0].version;\n    }\n    if (this.isForeignKeysQuery()) {\n      return data;\n    }\n    if (this.isUpsertQuery()) {\n      return [result, data.affectedRows === 1];\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery()) {\n      return [result, data.affectedRows];\n    }\n    if (this.isShowConstraintsQuery()) {\n      return data;\n    }\n    if (this.isRawQuery()) {\n      return [data, data];\n    }\n    return result;\n  }\n  async logWarnings(results) {\n    const warningResults = await this.run(\"SHOW WARNINGS\");\n    const warningMessage = `Snowflake Warnings (${this.connection.uuid || \"default\"}): `;\n    const messages = [];\n    for (const _warningRow of warningResults) {\n      if (_warningRow === void 0 || typeof _warningRow[Symbol.iterator] !== \"function\") {\n        continue;\n      }\n      for (const _warningResult of _warningRow) {\n        if (Object.prototype.hasOwnProperty.call(_warningResult, \"Message\")) {\n          messages.push(_warningResult.Message);\n        } else {\n          for (const _objectKey of _warningResult.keys()) {\n            messages.push([_objectKey, _warningResult[_objectKey]].join(\": \"));\n          }\n        }\n      }\n    }\n    this.sequelize.log(warningMessage + messages.join(\"; \"), this.options);\n    return results;\n  }\n  formatError(err) {\n    const errCode = err.errno || err.code;\n    switch (errCode) {\n      case ER_DUP_ENTRY: {\n        const match = err.message.match(/Duplicate entry '([\\s\\S]*)' for key '?((.|\\s)*?)'?$/);\n        let fields = {};\n        let message = \"Validation error\";\n        const values = match ? match[1].split(\"-\") : void 0;\n        const fieldKey = match ? match[2] : void 0;\n        const fieldVal = match ? match[1] : void 0;\n        const uniqueKey = this.model && this.model.uniqueKeys[fieldKey];\n        if (uniqueKey) {\n          if (uniqueKey.msg)\n            message = uniqueKey.msg;\n          fields = _.zipObject(uniqueKey.fields, values);\n        } else {\n          fields[fieldKey] = fieldVal;\n        }\n        const errors = [];\n        _.forOwn(fields, (value, field) => {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, value, this.instance, \"not_unique\"));\n        });\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case ER_ROW_IS_REFERENCED:\n      case ER_NO_REFERENCED_ROW: {\n        const match = err.message.match(/CONSTRAINT ([`\"])(.*)\\1 FOREIGN KEY \\(\\1(.*)\\1\\) REFERENCES \\1(.*)\\1 \\(\\1(.*)\\1\\)/);\n        const quoteChar = match ? match[1] : \"`\";\n        const fields = match ? match[3].split(new RegExp(`${quoteChar}, *${quoteChar}`)) : void 0;\n        return new sequelizeErrors.ForeignKeyConstraintError({\n          reltype: String(errCode) === String(ER_ROW_IS_REFERENCED) ? \"parent\" : \"child\",\n          table: match ? match[4] : void 0,\n          fields,\n          value: fields && fields.length && this.instance && this.instance[fields[0]] || void 0,\n          index: match ? match[2] : void 0,\n          parent: err\n        });\n      }\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n  handleShowIndexesQuery(data) {\n    data = data.reduce((acc, item) => {\n      if (!(item.Key_name in acc)) {\n        acc[item.Key_name] = item;\n        item.fields = [];\n      }\n      acc[item.Key_name].fields[item.Seq_in_index - 1] = {\n        attribute: item.Column_name,\n        length: item.Sub_part || void 0,\n        order: item.Collation === \"A\" ? \"ASC\" : void 0\n      };\n      delete item.column_name;\n      return acc;\n    }, {});\n    return _.map(data, (item) => ({\n      primary: item.Key_name === \"PRIMARY\",\n      fields: item.fields,\n      name: item.Key_name,\n      tableName: item.Table,\n      unique: item.Non_unique !== 1,\n      type: item.Index_type\n    }));\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRSwwQkFBMEIscUVBQXFFO0FBQy9GO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQ0FBa0M7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDJEQUEyRCxzQ0FBc0M7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLEtBQUssVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zbm93Zmxha2UvcXVlcnkuanM/NjY2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi4vLi4vZXJyb3JzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2xvZ2dlclwiKTtcbmNvbnN0IEVSX0RVUF9FTlRSWSA9IDEwNjI7XG5jb25zdCBFUl9ERUFETE9DSyA9IDEyMTM7XG5jb25zdCBFUl9ST1dfSVNfUkVGRVJFTkNFRCA9IDE0NTE7XG5jb25zdCBFUl9OT19SRUZFUkVOQ0VEX1JPVyA9IDE0NTI7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6c25vd2ZsYWtlXCIpO1xuY2xhc3MgUXVlcnkgZXh0ZW5kcyBBYnN0cmFjdFF1ZXJ5IHtcbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgY29uc3QgYmluZFBhcmFtID0gW107XG4gICAgY29uc3QgcmVwbGFjZW1lbnRGdW5jID0gKF9tYXRjaCwga2V5LCB2YWx1ZXNfKSA9PiB7XG4gICAgICBpZiAodmFsdWVzX1trZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgYmluZFBhcmFtLnB1c2godmFsdWVzX1trZXldKTtcbiAgICAgICAgcmV0dXJuIFwiP1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9O1xuICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHJlcGxhY2VtZW50RnVuYylbMF07XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbS5sZW5ndGggPiAwID8gYmluZFBhcmFtIDogdm9pZCAwXTtcbiAgfVxuICBhc3luYyBydW4oc3FsLCBwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uLCBvcHRpb25zIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNob3dXYXJuaW5ncyA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc2hvd1dhcm5pbmdzIHx8IG9wdGlvbnMuc2hvd1dhcm5pbmdzO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgaWYgKHBhcmFtZXRlcnMpIHtcbiAgICAgIGRlYnVnKFwicGFyYW1ldGVycyglailcIiwgcGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGxldCByZXN1bHRzO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHRzID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmV4ZWN1dGUoe1xuICAgICAgICAgIHNxbFRleHQ6IHNxbCxcbiAgICAgICAgICBiaW5kczogcGFyYW1ldGVycyxcbiAgICAgICAgICBjb21wbGV0ZShlcnIsIF9zdG10LCByb3dzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShyb3dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uICYmIGVycm9yLmVycm5vID09PSBFUl9ERUFETE9DSykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG9wdGlvbnMudHJhbnNhY3Rpb24ucm9sbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3JfKSB7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCA9IFwicm9sbGJhY2tcIjtcbiAgICAgIH1cbiAgICAgIGVycm9yLnNxbCA9IHNxbDtcbiAgICAgIGVycm9yLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgdGhyb3cgdGhpcy5mb3JtYXRFcnJvcihlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGlmIChzaG93V2FybmluZ3MgJiYgcmVzdWx0cyAmJiByZXN1bHRzLndhcm5pbmdTdGF0dXMgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLmxvZ1dhcm5pbmdzKHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3JtYXRSZXN1bHRzKHJlc3VsdHMpO1xuICB9XG4gIGZvcm1hdFJlc3VsdHMoZGF0YSkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmluc3RhbmNlO1xuICAgIGlmICh0aGlzLmlzSW5zZXJ0UXVlcnkoZGF0YSkpIHtcbiAgICAgIHRoaXMuaGFuZGxlSW5zZXJ0UXVlcnkoZGF0YSk7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gXCJSZXN1bHRTZXRIZWFkZXJcIiAmJiB0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPT09IHRoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiB0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXSkge1xuICAgICAgICAgIGNvbnN0IHN0YXJ0SWQgPSBkYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJZDsgaSA8IHN0YXJ0SWQgKyBkYXRhLmFmZmVjdGVkUm93czsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IFt0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZF06IGkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2VsZWN0UXVlcnkoKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYXcgPT09IGZhbHNlICYmIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMucXVvdGVJZGVudGlmaWVycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2ZBdHRyTWFwID0gXy5yZWR1Y2UodGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzLCAobSwgdiwgaykgPT4ge1xuICAgICAgICAgIG1bay50b1VwcGVyQ2FzZSgpXSA9IGs7XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgZGF0YSA9IGRhdGEubWFwKChkYXRhMikgPT4gXy5yZWR1Y2UoZGF0YTIsIChwcmV2LCB2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDAgJiYgc2ZBdHRyTWFwW2tleV0pIHtcbiAgICAgICAgICAgIHByZXZbc2ZBdHRyTWFwW2tleV1dID0gdmFsdWU7XG4gICAgICAgICAgICBkZWxldGUgcHJldltrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSwgZGF0YTIpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucy5maWVsZE1hcCA9IF8ubWFwS2V5cyh0aGlzLm9wdGlvbnMuZmllbGRNYXAsICh2LCBrKSA9PiB7XG4gICAgICAgIHJldHVybiBrLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbGVjdFF1ZXJ5KGRhdGEpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVTaG93VGFibGVzUXVlcnkoZGF0YSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiBkYXRhKSB7XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0LkZpZWxkXSA9IHtcbiAgICAgICAgICB0eXBlOiBfcmVzdWx0LlR5cGUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQuTnVsbCA9PT0gXCJZRVNcIixcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IF9yZXN1bHQuRGVmYXVsdCxcbiAgICAgICAgICBwcmltYXJ5S2V5OiBfcmVzdWx0LktleSA9PT0gXCJQUklcIixcbiAgICAgICAgICBhdXRvSW5jcmVtZW50OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX3Jlc3VsdCwgXCJFeHRyYVwiKSAmJiBfcmVzdWx0LkV4dHJhLnRvTG93ZXJDYXNlKCkgPT09IFwiYXV0b19pbmNyZW1lbnRcIixcbiAgICAgICAgICBjb21tZW50OiBfcmVzdWx0LkNvbW1lbnQgPyBfcmVzdWx0LkNvbW1lbnQgOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dJbmRleGVzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDYWxsUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGFbMF07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQnVsa1VwZGF0ZVF1ZXJ5KCkgfHwgdGhpcy5pc0J1bGtEZWxldGVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YVswXVtcIm51bWJlciBvZiByb3dzIHVwZGF0ZWRcIl07XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVmVyc2lvblF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBkYXRhWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRm9yZWlnbktleXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcHNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgZGF0YS5hZmZlY3RlZFJvd3MgPT09IDFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KCkgfHwgdGhpcy5pc1VwZGF0ZVF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBkYXRhLmFmZmVjdGVkUm93c107XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd0NvbnN0cmFpbnRzUXVlcnkoKSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUmF3UXVlcnkoKSkge1xuICAgICAgcmV0dXJuIFtkYXRhLCBkYXRhXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBsb2dXYXJuaW5ncyhyZXN1bHRzKSB7XG4gICAgY29uc3Qgd2FybmluZ1Jlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1bihcIlNIT1cgV0FSTklOR1NcIik7XG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgU25vd2ZsYWtlIFdhcm5pbmdzICgke3RoaXMuY29ubmVjdGlvbi51dWlkIHx8IFwiZGVmYXVsdFwifSk6IGA7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IF93YXJuaW5nUm93IG9mIHdhcm5pbmdSZXN1bHRzKSB7XG4gICAgICBpZiAoX3dhcm5pbmdSb3cgPT09IHZvaWQgMCB8fCB0eXBlb2YgX3dhcm5pbmdSb3dbU3ltYm9sLml0ZXJhdG9yXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBfd2FybmluZ1Jlc3VsdCBvZiBfd2FybmluZ1Jvdykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF93YXJuaW5nUmVzdWx0LCBcIk1lc3NhZ2VcIikpIHtcbiAgICAgICAgICBtZXNzYWdlcy5wdXNoKF93YXJuaW5nUmVzdWx0Lk1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgX29iamVjdEtleSBvZiBfd2FybmluZ1Jlc3VsdC5rZXlzKCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goW19vYmplY3RLZXksIF93YXJuaW5nUmVzdWx0W19vYmplY3RLZXldXS5qb2luKFwiOiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNlcXVlbGl6ZS5sb2cod2FybmluZ01lc3NhZ2UgKyBtZXNzYWdlcy5qb2luKFwiOyBcIiksIHRoaXMub3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgY29uc3QgZXJyQ29kZSA9IGVyci5lcnJubyB8fCBlcnIuY29kZTtcbiAgICBzd2l0Y2ggKGVyckNvZGUpIHtcbiAgICAgIGNhc2UgRVJfRFVQX0VOVFJZOiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZXJyLm1lc3NhZ2UubWF0Y2goL0R1cGxpY2F0ZSBlbnRyeSAnKFtcXHNcXFNdKiknIGZvciBrZXkgJz8oKC58XFxzKSo/KSc/JC8pO1xuICAgICAgICBsZXQgZmllbGRzID0ge307XG4gICAgICAgIGxldCBtZXNzYWdlID0gXCJWYWxpZGF0aW9uIGVycm9yXCI7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQoXCItXCIpIDogdm9pZCAwO1xuICAgICAgICBjb25zdCBmaWVsZEtleSA9IG1hdGNoID8gbWF0Y2hbMl0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGZpZWxkVmFsID0gbWF0Y2ggPyBtYXRjaFsxXSA6IHZvaWQgMDtcbiAgICAgICAgY29uc3QgdW5pcXVlS2V5ID0gdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnVuaXF1ZUtleXNbZmllbGRLZXldO1xuICAgICAgICBpZiAodW5pcXVlS2V5KSB7XG4gICAgICAgICAgaWYgKHVuaXF1ZUtleS5tc2cpXG4gICAgICAgICAgICBtZXNzYWdlID0gdW5pcXVlS2V5Lm1zZztcbiAgICAgICAgICBmaWVsZHMgPSBfLnppcE9iamVjdCh1bmlxdWVLZXkuZmllbGRzLCB2YWx1ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpZWxkc1tmaWVsZEtleV0gPSBmaWVsZFZhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgXy5mb3JPd24oZmllbGRzLCAodmFsdWUsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5WYWxpZGF0aW9uRXJyb3JJdGVtKHRoaXMuZ2V0VW5pcXVlQ29uc3RyYWludEVycm9yTWVzc2FnZShmaWVsZCksIFwidW5pcXVlIHZpb2xhdGlvblwiLCBmaWVsZCwgdmFsdWUsIHRoaXMuaW5zdGFuY2UsIFwibm90X3VuaXF1ZVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5VbmlxdWVDb25zdHJhaW50RXJyb3IoeyBtZXNzYWdlLCBlcnJvcnMsIHBhcmVudDogZXJyLCBmaWVsZHMgfSk7XG4gICAgICB9XG4gICAgICBjYXNlIEVSX1JPV19JU19SRUZFUkVOQ0VEOlxuICAgICAgY2FzZSBFUl9OT19SRUZFUkVOQ0VEX1JPVzoge1xuICAgICAgICBjb25zdCBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9DT05TVFJBSU5UIChbYFwiXSkoLiopXFwxIEZPUkVJR04gS0VZIFxcKFxcMSguKilcXDFcXCkgUkVGRVJFTkNFUyBcXDEoLiopXFwxIFxcKFxcMSguKilcXDFcXCkvKTtcbiAgICAgICAgY29uc3QgcXVvdGVDaGFyID0gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiYFwiO1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBtYXRjaCA/IG1hdGNoWzNdLnNwbGl0KG5ldyBSZWdFeHAoYCR7cXVvdGVDaGFyfSwgKiR7cXVvdGVDaGFyfWApKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcih7XG4gICAgICAgICAgcmVsdHlwZTogU3RyaW5nKGVyckNvZGUpID09PSBTdHJpbmcoRVJfUk9XX0lTX1JFRkVSRU5DRUQpID8gXCJwYXJlbnRcIiA6IFwiY2hpbGRcIixcbiAgICAgICAgICB0YWJsZTogbWF0Y2ggPyBtYXRjaFs0XSA6IHZvaWQgMCxcbiAgICAgICAgICBmaWVsZHMsXG4gICAgICAgICAgdmFsdWU6IGZpZWxkcyAmJiBmaWVsZHMubGVuZ3RoICYmIHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZVtmaWVsZHNbMF1dIHx8IHZvaWQgMCxcbiAgICAgICAgICBpbmRleDogbWF0Y2ggPyBtYXRjaFsyXSA6IHZvaWQgMCxcbiAgICAgICAgICBwYXJlbnQ6IGVyclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLkRhdGFiYXNlRXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlU2hvd0luZGV4ZXNRdWVyeShkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEucmVkdWNlKChhY2MsIGl0ZW0pID0+IHtcbiAgICAgIGlmICghKGl0ZW0uS2V5X25hbWUgaW4gYWNjKSkge1xuICAgICAgICBhY2NbaXRlbS5LZXlfbmFtZV0gPSBpdGVtO1xuICAgICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgfVxuICAgICAgYWNjW2l0ZW0uS2V5X25hbWVdLmZpZWxkc1tpdGVtLlNlcV9pbl9pbmRleCAtIDFdID0ge1xuICAgICAgICBhdHRyaWJ1dGU6IGl0ZW0uQ29sdW1uX25hbWUsXG4gICAgICAgIGxlbmd0aDogaXRlbS5TdWJfcGFydCB8fCB2b2lkIDAsXG4gICAgICAgIG9yZGVyOiBpdGVtLkNvbGxhdGlvbiA9PT0gXCJBXCIgPyBcIkFTQ1wiIDogdm9pZCAwXG4gICAgICB9O1xuICAgICAgZGVsZXRlIGl0ZW0uY29sdW1uX25hbWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICByZXR1cm4gXy5tYXAoZGF0YSwgKGl0ZW0pID0+ICh7XG4gICAgICBwcmltYXJ5OiBpdGVtLktleV9uYW1lID09PSBcIlBSSU1BUllcIixcbiAgICAgIGZpZWxkczogaXRlbS5maWVsZHMsXG4gICAgICBuYW1lOiBpdGVtLktleV9uYW1lLFxuICAgICAgdGFibGVOYW1lOiBpdGVtLlRhYmxlLFxuICAgICAgdW5pcXVlOiBpdGVtLk5vbl91bmlxdWUgIT09IDEsXG4gICAgICB0eXBlOiBpdGVtLkluZGV4X3R5cGVcbiAgICB9KSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IFF1ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/snowflake/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst AbstractConnectionManager = __webpack_require__(/*! ../abstract/connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/connection-manager.js\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"connection:sqlite\");\nconst dataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").sqlite);\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"sqlite\");\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n    if (this.sequelize.options.host === \"localhost\") {\n      delete this.sequelize.options.host;\n    }\n    this.connections = {};\n    this.lib = this._loadDialectModule(\"sqlite3\");\n    this.refreshTypeParser(dataTypes);\n  }\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map((connection) => promisify((callback) => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || \"default\";\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || \":memory:\";\n    }\n    options.inMemory = options.storage === \":memory:\" ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, (err) => {\n        if (err)\n          return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n    if (this.sequelize.config.password) {\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      connection.run(\"PRAGMA FOREIGN_KEYS=ON\");\n    }\n    return connection;\n  }\n  releaseConnection(connection, force) {\n    if (connection.filename === \":memory:\" && force !== true)\n      return;\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports[\"default\"] = ConnectionManager;\n//# sourceMappingURL=connection-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGtDQUFrQyxtQkFBTyxDQUFDLGtIQUFnQztBQUMxRSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDhFQUFvQjtBQUMvQztBQUNBLGtCQUFrQix3R0FBa0M7QUFDcEQsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMsc0RBQXNEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMseUJBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvY29ubmVjdGlvbi1tYW5hZ2VyLmpzPzNhNGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IEFic3RyYWN0Q29ubmVjdGlvbk1hbmFnZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJjb25uZWN0aW9uOnNxbGl0ZVwiKTtcbmNvbnN0IGRhdGFUeXBlcyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhLXR5cGVzXCIpLnNxbGl0ZTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBwYXJzZXJTdG9yZSA9IHJlcXVpcmUoXCIuLi9wYXJzZXJTdG9yZVwiKShcInNxbGl0ZVwiKTtcbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRpYWxlY3QsIHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKGRpYWxlY3QsIHNlcXVlbGl6ZSk7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuaG9zdCA9PT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgZGVsZXRlIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuaG9zdDtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aW9ucyA9IHt9O1xuICAgIHRoaXMubGliID0gdGhpcy5fbG9hZERpYWxlY3RNb2R1bGUoXCJzcWxpdGUzXCIpO1xuICAgIHRoaXMucmVmcmVzaFR5cGVQYXJzZXIoZGF0YVR5cGVzKTtcbiAgfVxuICBhc3luYyBfb25Qcm9jZXNzRXhpdCgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmNvbm5lY3Rpb25zKS5tYXAoKGNvbm5lY3Rpb24pID0+IHByb21pc2lmeSgoY2FsbGJhY2spID0+IHRoaXMuY29ubmVjdGlvbnNbY29ubmVjdGlvbl0uY2xvc2UoY2FsbGJhY2spKSgpKSk7XG4gICAgcmV0dXJuIHN1cGVyLl9vblByb2Nlc3NFeGl0LmNhbGwodGhpcyk7XG4gIH1cbiAgX3JlZnJlc2hUeXBlUGFyc2VyKGRhdGFUeXBlKSB7XG4gICAgcGFyc2VyU3RvcmUucmVmcmVzaChkYXRhVHlwZSk7XG4gIH1cbiAgX2NsZWFyVHlwZVBhcnNlcigpIHtcbiAgICBwYXJzZXJTdG9yZS5jbGVhcigpO1xuICB9XG4gIGFzeW5jIGdldENvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXVpZCA9IG9wdGlvbnMudXVpZCB8fCBcImRlZmF1bHRcIjtcbiAgICBpZiAoISF0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLnN0b3JhZ2UgIT09IG51bGwgJiYgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5zdG9yYWdlICE9PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMuc3RvcmFnZSA9IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuc3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5zdG9yYWdlID0gdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5ob3N0IHx8IFwiOm1lbW9yeTpcIjtcbiAgICB9XG4gICAgb3B0aW9ucy5pbk1lbW9yeSA9IG9wdGlvbnMuc3RvcmFnZSA9PT0gXCI6bWVtb3J5OlwiID8gMSA6IDA7XG4gICAgY29uc3QgZGlhbGVjdE9wdGlvbnMgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3RPcHRpb25zO1xuICAgIGNvbnN0IGRlZmF1bHRSZWFkV3JpdGVNb2RlID0gdGhpcy5saWIuT1BFTl9SRUFEV1JJVEUgfCB0aGlzLmxpYi5PUEVOX0NSRUFURTtcbiAgICBvcHRpb25zLnJlYWRXcml0ZU1vZGUgPSBkaWFsZWN0T3B0aW9ucyAmJiBkaWFsZWN0T3B0aW9ucy5tb2RlIHx8IGRlZmF1bHRSZWFkV3JpdGVNb2RlO1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25zW29wdGlvbnMuaW5NZW1vcnkgfHwgb3B0aW9ucy51dWlkXSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuaW5NZW1vcnkgJiYgKG9wdGlvbnMucmVhZFdyaXRlTW9kZSAmIHRoaXMubGliLk9QRU5fQ1JFQVRFKSAhPT0gMCkge1xuICAgICAgZnMubWtkaXJTeW5jKHBhdGguZGlybmFtZShvcHRpb25zLnN0b3JhZ2UpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbnNbb3B0aW9ucy5pbk1lbW9yeSB8fCBvcHRpb25zLnV1aWRdID0gbmV3IHRoaXMubGliLkRhdGFiYXNlKG9wdGlvbnMuc3RvcmFnZSwgb3B0aW9ucy5yZWFkV3JpdGVNb2RlLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgc2VxdWVsaXplRXJyb3JzLkNvbm5lY3Rpb25FcnJvcihlcnIpKTtcbiAgICAgICAgZGVidWcoYGNvbm5lY3Rpb24gYWNxdWlyZWQgJHtvcHRpb25zLnV1aWR9YCk7XG4gICAgICAgIHJlc29sdmUodGhpcy5jb25uZWN0aW9uc1tvcHRpb25zLmluTWVtb3J5IHx8IG9wdGlvbnMudXVpZF0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLmNvbmZpZy5wYXNzd29yZCkge1xuICAgICAgY29ubmVjdGlvbi5ydW4oYFBSQUdNQSBLRVk9JHt0aGlzLnNlcXVlbGl6ZS5lc2NhcGUodGhpcy5zZXF1ZWxpemUuY29uZmlnLnBhc3N3b3JkKX1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZm9yZWlnbktleXMgIT09IGZhbHNlKSB7XG4gICAgICBjb25uZWN0aW9uLnJ1bihcIlBSQUdNQSBGT1JFSUdOX0tFWVM9T05cIik7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0aW9uO1xuICB9XG4gIHJlbGVhc2VDb25uZWN0aW9uKGNvbm5lY3Rpb24sIGZvcmNlKSB7XG4gICAgaWYgKGNvbm5lY3Rpb24uZmlsZW5hbWUgPT09IFwiOm1lbW9yeTpcIiAmJiBmb3JjZSAhPT0gdHJ1ZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoY29ubmVjdGlvbi51dWlkKSB7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICBkZWJ1ZyhgY29ubmVjdGlvbiByZWxlYXNlZCAke2Nvbm5lY3Rpb24udXVpZH1gKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW2Nvbm5lY3Rpb24udXVpZF07XG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb25NYW5hZ2VyO1xubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvbk1hbmFnZXIgPSBDb25uZWN0aW9uTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24tbWFuYWdlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/data-types.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/data-types.js ***!
  \******************************************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (BaseTypes) => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.sqlite.org/datatype3.html\");\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._zerofill || dataType._unsigned) {\n      warn(`SQLite does not support '${dataType.key}' with UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._unsigned = void 0;\n      dataType._zerofill = void 0;\n    }\n  }\n  BaseTypes.DATE.types.sqlite = [\"DATETIME\"];\n  BaseTypes.STRING.types.sqlite = [\"VARCHAR\", \"VARCHAR BINARY\"];\n  BaseTypes.CHAR.types.sqlite = [\"CHAR\", \"CHAR BINARY\"];\n  BaseTypes.TEXT.types.sqlite = [\"TEXT\"];\n  BaseTypes.TINYINT.types.sqlite = [\"TINYINT\"];\n  BaseTypes.SMALLINT.types.sqlite = [\"SMALLINT\"];\n  BaseTypes.MEDIUMINT.types.sqlite = [\"MEDIUMINT\"];\n  BaseTypes.INTEGER.types.sqlite = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.sqlite = [\"BIGINT\"];\n  BaseTypes.FLOAT.types.sqlite = [\"FLOAT\"];\n  BaseTypes.TIME.types.sqlite = [\"TIME\"];\n  BaseTypes.DATEONLY.types.sqlite = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.sqlite = [\"TINYINT\"];\n  BaseTypes.BLOB.types.sqlite = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.sqlite = [\"DECIMAL\"];\n  BaseTypes.UUID.types.sqlite = [\"UUID\"];\n  BaseTypes.ENUM.types.sqlite = false;\n  BaseTypes.REAL.types.sqlite = [\"REAL\"];\n  BaseTypes.DOUBLE.types.sqlite = [\"DOUBLE PRECISION\"];\n  BaseTypes.GEOMETRY.types.sqlite = false;\n  BaseTypes.JSON.types.sqlite = [\"JSON\", \"JSONB\"];\n  class JSONTYPE extends BaseTypes.JSON {\n    static parse(data) {\n      return JSON.parse(data);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    static parse(date, options) {\n      if (!date.includes(\"+\")) {\n        return new Date(date + options.timezone);\n      }\n      return new Date(date);\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(date) {\n      return date;\n    }\n  }\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return `VARCHAR BINARY(${this._length})`;\n      }\n      return super.toSql(this);\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn(\"SQLite does not support TEXT with options. Plain `TEXT` will be used instead.\");\n        this._length = void 0;\n      }\n      return \"TEXT\";\n    }\n  }\n  class CITEXT extends BaseTypes.CITEXT {\n    toSql() {\n      return \"TEXT COLLATE NOCASE\";\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return `CHAR BINARY(${this._length})`;\n      }\n      return super.toSql();\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    toSql() {\n      let result = this.key;\n      if (this._unsigned) {\n        result += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        result += \" ZEROFILL\";\n      }\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      return result;\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n  }\n  class REAL extends BaseTypes.REAL {\n  }\n  function parseFloating(value) {\n    if (typeof value !== \"string\") {\n      return value;\n    }\n    if (value === \"NaN\") {\n      return NaN;\n    }\n    if (value === \"Infinity\") {\n      return Infinity;\n    }\n    if (value === \"-Infinity\") {\n      return -Infinity;\n    }\n  }\n  for (const floating of [FLOAT, DOUBLE, REAL]) {\n    floating.parse = parseFloating;\n  }\n  for (const num of [FLOAT, DOUBLE, REAL, TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT]) {\n    num.prototype.toSql = NUMBER.prototype.toSql;\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"TEXT\";\n    }\n  }\n  return {\n    DATE,\n    DATEONLY,\n    STRING,\n    CHAR,\n    NUMBER,\n    FLOAT,\n    REAL,\n    \"DOUBLE PRECISION\": DOUBLE,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    INTEGER,\n    BIGINT,\n    TEXT,\n    ENUM,\n    JSON: JSONTYPE,\n    CITEXT\n  };\n};\n//# sourceMappingURL=data-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvZGF0YS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsc0NBQXNDLGFBQWE7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkM7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL2RhdGEtdHlwZXMuanM/YzY0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gKEJhc2VUeXBlcykgPT4ge1xuICBjb25zdCB3YXJuID0gQmFzZVR5cGVzLkFCU1RSQUNULndhcm4uYmluZCh2b2lkIDAsIFwiaHR0cHM6Ly93d3cuc3FsaXRlLm9yZy9kYXRhdHlwZTMuaHRtbFwiKTtcbiAgZnVuY3Rpb24gcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyhkYXRhVHlwZSkge1xuICAgIGlmIChkYXRhVHlwZS5femVyb2ZpbGwgfHwgZGF0YVR5cGUuX3Vuc2lnbmVkKSB7XG4gICAgICB3YXJuKGBTUUxpdGUgZG9lcyBub3Qgc3VwcG9ydCAnJHtkYXRhVHlwZS5rZXl9JyB3aXRoIFVOU0lHTkVEIG9yIFpFUk9GSUxMLiBQbGFpbiAnJHtkYXRhVHlwZS5rZXl9JyB3aWxsIGJlIHVzZWQgaW5zdGVhZC5gKTtcbiAgICAgIGRhdGFUeXBlLl91bnNpZ25lZCA9IHZvaWQgMDtcbiAgICAgIGRhdGFUeXBlLl96ZXJvZmlsbCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgQmFzZVR5cGVzLkRBVEUudHlwZXMuc3FsaXRlID0gW1wiREFURVRJTUVcIl07XG4gIEJhc2VUeXBlcy5TVFJJTkcudHlwZXMuc3FsaXRlID0gW1wiVkFSQ0hBUlwiLCBcIlZBUkNIQVIgQklOQVJZXCJdO1xuICBCYXNlVHlwZXMuQ0hBUi50eXBlcy5zcWxpdGUgPSBbXCJDSEFSXCIsIFwiQ0hBUiBCSU5BUllcIl07XG4gIEJhc2VUeXBlcy5URVhULnR5cGVzLnNxbGl0ZSA9IFtcIlRFWFRcIl07XG4gIEJhc2VUeXBlcy5USU5ZSU5ULnR5cGVzLnNxbGl0ZSA9IFtcIlRJTllJTlRcIl07XG4gIEJhc2VUeXBlcy5TTUFMTElOVC50eXBlcy5zcWxpdGUgPSBbXCJTTUFMTElOVFwiXTtcbiAgQmFzZVR5cGVzLk1FRElVTUlOVC50eXBlcy5zcWxpdGUgPSBbXCJNRURJVU1JTlRcIl07XG4gIEJhc2VUeXBlcy5JTlRFR0VSLnR5cGVzLnNxbGl0ZSA9IFtcIklOVEVHRVJcIl07XG4gIEJhc2VUeXBlcy5CSUdJTlQudHlwZXMuc3FsaXRlID0gW1wiQklHSU5UXCJdO1xuICBCYXNlVHlwZXMuRkxPQVQudHlwZXMuc3FsaXRlID0gW1wiRkxPQVRcIl07XG4gIEJhc2VUeXBlcy5USU1FLnR5cGVzLnNxbGl0ZSA9IFtcIlRJTUVcIl07XG4gIEJhc2VUeXBlcy5EQVRFT05MWS50eXBlcy5zcWxpdGUgPSBbXCJEQVRFXCJdO1xuICBCYXNlVHlwZXMuQk9PTEVBTi50eXBlcy5zcWxpdGUgPSBbXCJUSU5ZSU5UXCJdO1xuICBCYXNlVHlwZXMuQkxPQi50eXBlcy5zcWxpdGUgPSBbXCJUSU5ZQkxPQlwiLCBcIkJMT0JcIiwgXCJMT05HQkxPQlwiXTtcbiAgQmFzZVR5cGVzLkRFQ0lNQUwudHlwZXMuc3FsaXRlID0gW1wiREVDSU1BTFwiXTtcbiAgQmFzZVR5cGVzLlVVSUQudHlwZXMuc3FsaXRlID0gW1wiVVVJRFwiXTtcbiAgQmFzZVR5cGVzLkVOVU0udHlwZXMuc3FsaXRlID0gZmFsc2U7XG4gIEJhc2VUeXBlcy5SRUFMLnR5cGVzLnNxbGl0ZSA9IFtcIlJFQUxcIl07XG4gIEJhc2VUeXBlcy5ET1VCTEUudHlwZXMuc3FsaXRlID0gW1wiRE9VQkxFIFBSRUNJU0lPTlwiXTtcbiAgQmFzZVR5cGVzLkdFT01FVFJZLnR5cGVzLnNxbGl0ZSA9IGZhbHNlO1xuICBCYXNlVHlwZXMuSlNPTi50eXBlcy5zcWxpdGUgPSBbXCJKU09OXCIsIFwiSlNPTkJcIl07XG4gIGNsYXNzIEpTT05UWVBFIGV4dGVuZHMgQmFzZVR5cGVzLkpTT04ge1xuICAgIHN0YXRpYyBwYXJzZShkYXRhKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgREFURSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFkYXRlLmluY2x1ZGVzKFwiK1wiKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSArIG9wdGlvbnMudGltZXpvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgIH1cbiAgfVxuICBjbGFzcyBEQVRFT05MWSBleHRlbmRzIEJhc2VUeXBlcy5EQVRFT05MWSB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGUpIHtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgfVxuICBjbGFzcyBTVFJJTkcgZXh0ZW5kcyBCYXNlVHlwZXMuU1RSSU5HIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9iaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGBWQVJDSEFSIEJJTkFSWSgke3RoaXMuX2xlbmd0aH0pYDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdXBlci50b1NxbCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5URVhUIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIGlmICh0aGlzLl9sZW5ndGgpIHtcbiAgICAgICAgd2FybihcIlNRTGl0ZSBkb2VzIG5vdCBzdXBwb3J0IFRFWFQgd2l0aCBvcHRpb25zLiBQbGFpbiBgVEVYVGAgd2lsbCBiZSB1c2VkIGluc3RlYWQuXCIpO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gXCJURVhUXCI7XG4gICAgfVxuICB9XG4gIGNsYXNzIENJVEVYVCBleHRlbmRzIEJhc2VUeXBlcy5DSVRFWFQge1xuICAgIHRvU3FsKCkge1xuICAgICAgcmV0dXJuIFwiVEVYVCBDT0xMQVRFIE5PQ0FTRVwiO1xuICAgIH1cbiAgfVxuICBjbGFzcyBDSEFSIGV4dGVuZHMgQmFzZVR5cGVzLkNIQVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgaWYgKHRoaXMuX2JpbmFyeSkge1xuICAgICAgICByZXR1cm4gYENIQVIgQklOQVJZKCR7dGhpcy5fbGVuZ3RofSlgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1cGVyLnRvU3FsKCk7XG4gICAgfVxuICB9XG4gIGNsYXNzIE5VTUJFUiBleHRlbmRzIEJhc2VUeXBlcy5OVU1CRVIge1xuICAgIHRvU3FsKCkge1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMua2V5O1xuICAgICAgaWYgKHRoaXMuX3Vuc2lnbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiBVTlNJR05FRFwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3plcm9maWxsKSB7XG4gICAgICAgIHJlc3VsdCArPSBcIiBaRVJPRklMTFwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCkge1xuICAgICAgICByZXN1bHQgKz0gYCgke3RoaXMuX2xlbmd0aH1gO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RlY2ltYWxzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGAsJHt0aGlzLl9kZWNpbWFsc31gO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIGNsYXNzIFRJTllJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuVElOWUlOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgU01BTExJTlQgZXh0ZW5kcyBCYXNlVHlwZXMuU01BTExJTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIE1FRElVTUlOVCBleHRlbmRzIEJhc2VUeXBlcy5NRURJVU1JTlQge1xuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xuICAgICAgc3VwZXIobGVuZ3RoKTtcbiAgICAgIHJlbW92ZVVuc3VwcG9ydGVkSW50ZWdlck9wdGlvbnModGhpcyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIElOVEVHRVIgZXh0ZW5kcyBCYXNlVHlwZXMuSU5URUdFUiB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgQklHSU5UIGV4dGVuZHMgQmFzZVR5cGVzLkJJR0lOVCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XG4gICAgICBzdXBlcihsZW5ndGgpO1xuICAgICAgcmVtb3ZlVW5zdXBwb3J0ZWRJbnRlZ2VyT3B0aW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgY2xhc3MgRkxPQVQgZXh0ZW5kcyBCYXNlVHlwZXMuRkxPQVQge1xuICB9XG4gIGNsYXNzIERPVUJMRSBleHRlbmRzIEJhc2VUeXBlcy5ET1VCTEUge1xuICB9XG4gIGNsYXNzIFJFQUwgZXh0ZW5kcyBCYXNlVHlwZXMuUkVBTCB7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VGbG9hdGluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBcIk5hTlwiKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IFwiSW5maW5pdHlcIikge1xuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IFwiLUluZmluaXR5XCIpIHtcbiAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgZmxvYXRpbmcgb2YgW0ZMT0FULCBET1VCTEUsIFJFQUxdKSB7XG4gICAgZmxvYXRpbmcucGFyc2UgPSBwYXJzZUZsb2F0aW5nO1xuICB9XG4gIGZvciAoY29uc3QgbnVtIG9mIFtGTE9BVCwgRE9VQkxFLCBSRUFMLCBUSU5ZSU5ULCBTTUFMTElOVCwgTUVESVVNSU5ULCBJTlRFR0VSLCBCSUdJTlRdKSB7XG4gICAgbnVtLnByb3RvdHlwZS50b1NxbCA9IE5VTUJFUi5wcm90b3R5cGUudG9TcWw7XG4gIH1cbiAgY2xhc3MgRU5VTSBleHRlbmRzIEJhc2VUeXBlcy5FTlVNIHtcbiAgICB0b1NxbCgpIHtcbiAgICAgIHJldHVybiBcIlRFWFRcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBEQVRFLFxuICAgIERBVEVPTkxZLFxuICAgIFNUUklORyxcbiAgICBDSEFSLFxuICAgIE5VTUJFUixcbiAgICBGTE9BVCxcbiAgICBSRUFMLFxuICAgIFwiRE9VQkxFIFBSRUNJU0lPTlwiOiBET1VCTEUsXG4gICAgVElOWUlOVCxcbiAgICBTTUFMTElOVCxcbiAgICBNRURJVU1JTlQsXG4gICAgSU5URUdFUixcbiAgICBCSUdJTlQsXG4gICAgVEVYVCxcbiAgICBFTlVNLFxuICAgIEpTT046IEpTT05UWVBFLFxuICAgIENJVEVYVFxuICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGEtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/data-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst AbstractDialect = __webpack_require__(/*! ../abstract */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/index.js\");\nconst ConnectionManager = __webpack_require__(/*! ./connection-manager */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/connection-manager.js\");\nconst Query = __webpack_require__(/*! ./query */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query.js\");\nconst QueryGenerator = __webpack_require__(/*! ./query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-generator.js\");\nconst DataTypes = (__webpack_require__(/*! ../../data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\").sqlite);\nconst { SQLiteQueryInterface } = __webpack_require__(/*! ./query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-interface.js\");\nclass SqliteDialect extends AbstractDialect {\n  constructor(sequelize) {\n    super();\n    this.sequelize = sequelize;\n    this.connectionManager = new ConnectionManager(this, sequelize);\n    this.queryGenerator = new QueryGenerator({\n      _dialect: this,\n      sequelize\n    });\n    this.queryInterface = new SQLiteQueryInterface(sequelize, this.queryGenerator);\n  }\n}\nSqliteDialect.prototype.supports = _.merge(_.cloneDeep(AbstractDialect.prototype.supports), {\n  DEFAULT: false,\n  \"DEFAULT VALUES\": true,\n  \"UNION ALL\": false,\n  \"RIGHT JOIN\": false,\n  inserts: {\n    ignoreDuplicates: \" OR IGNORE\",\n    updateOnDuplicate: \" ON CONFLICT DO UPDATE SET\",\n    conflictFields: true,\n    onConflictWhere: true\n  },\n  index: {\n    using: false,\n    where: true,\n    functionBased: true\n  },\n  transactionOptions: {\n    type: true\n  },\n  constraints: {\n    addConstraint: false,\n    dropConstraint: false\n  },\n  groupedLimit: false,\n  JSON: true\n});\nSqliteDialect.prototype.defaultVersion = \"3.8.0\";\nSqliteDialect.prototype.Query = Query;\nSqliteDialect.prototype.DataTypes = DataTypes;\nSqliteDialect.prototype.name = \"sqlite\";\nSqliteDialect.prototype.TICK_CHAR = \"`\";\nSqliteDialect.prototype.TICK_CHAR_LEFT = SqliteDialect.prototype.TICK_CHAR;\nSqliteDialect.prototype.TICK_CHAR_RIGHT = SqliteDialect.prototype.TICK_CHAR;\nmodule.exports = SqliteDialect;\nmodule.exports.SqliteDialect = SqliteDialect;\nmodule.exports[\"default\"] = SqliteDialect;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsd0JBQXdCLG1CQUFPLENBQUMsa0ZBQWE7QUFDN0MsMEJBQTBCLG1CQUFPLENBQUMsc0dBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyw0RUFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDbEQsa0JBQWtCLHdHQUFrQztBQUNwRCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0dBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZGlhbGVjdHMvc3FsaXRlL2luZGV4LmpzP2IwYzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IEFic3RyYWN0RGlhbGVjdCA9IHJlcXVpcmUoXCIuLi9hYnN0cmFjdFwiKTtcbmNvbnN0IENvbm5lY3Rpb25NYW5hZ2VyID0gcmVxdWlyZShcIi4vY29ubmVjdGlvbi1tYW5hZ2VyXCIpO1xuY29uc3QgUXVlcnkgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcbmNvbnN0IFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4vcXVlcnktZ2VuZXJhdG9yXCIpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL2RhdGEtdHlwZXNcIikuc3FsaXRlO1xuY29uc3QgeyBTUUxpdGVRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4vcXVlcnktaW50ZXJmYWNlXCIpO1xuY2xhc3MgU3FsaXRlRGlhbGVjdCBleHRlbmRzIEFic3RyYWN0RGlhbGVjdCB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXF1ZWxpemUgPSBzZXF1ZWxpemU7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcih0aGlzLCBzZXF1ZWxpemUpO1xuICAgIHRoaXMucXVlcnlHZW5lcmF0b3IgPSBuZXcgUXVlcnlHZW5lcmF0b3Ioe1xuICAgICAgX2RpYWxlY3Q6IHRoaXMsXG4gICAgICBzZXF1ZWxpemVcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXJ5SW50ZXJmYWNlID0gbmV3IFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlKHNlcXVlbGl6ZSwgdGhpcy5xdWVyeUdlbmVyYXRvcik7XG4gIH1cbn1cblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzID0gXy5tZXJnZShfLmNsb25lRGVlcChBYnN0cmFjdERpYWxlY3QucHJvdG90eXBlLnN1cHBvcnRzKSwge1xuICBERUZBVUxUOiBmYWxzZSxcbiAgXCJERUZBVUxUIFZBTFVFU1wiOiB0cnVlLFxuICBcIlVOSU9OIEFMTFwiOiBmYWxzZSxcbiAgXCJSSUdIVCBKT0lOXCI6IGZhbHNlLFxuICBpbnNlcnRzOiB7XG4gICAgaWdub3JlRHVwbGljYXRlczogXCIgT1IgSUdOT1JFXCIsXG4gICAgdXBkYXRlT25EdXBsaWNhdGU6IFwiIE9OIENPTkZMSUNUIERPIFVQREFURSBTRVRcIixcbiAgICBjb25mbGljdEZpZWxkczogdHJ1ZSxcbiAgICBvbkNvbmZsaWN0V2hlcmU6IHRydWVcbiAgfSxcbiAgaW5kZXg6IHtcbiAgICB1c2luZzogZmFsc2UsXG4gICAgd2hlcmU6IHRydWUsXG4gICAgZnVuY3Rpb25CYXNlZDogdHJ1ZVxuICB9LFxuICB0cmFuc2FjdGlvbk9wdGlvbnM6IHtcbiAgICB0eXBlOiB0cnVlXG4gIH0sXG4gIGNvbnN0cmFpbnRzOiB7XG4gICAgYWRkQ29uc3RyYWludDogZmFsc2UsXG4gICAgZHJvcENvbnN0cmFpbnQ6IGZhbHNlXG4gIH0sXG4gIGdyb3VwZWRMaW1pdDogZmFsc2UsXG4gIEpTT046IHRydWVcbn0pO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuZGVmYXVsdFZlcnNpb24gPSBcIjMuOC4wXCI7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5RdWVyeSA9IFF1ZXJ5O1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuRGF0YVR5cGVzID0gRGF0YVR5cGVzO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUubmFtZSA9IFwic3FsaXRlXCI7XG5TcWxpdGVEaWFsZWN0LnByb3RvdHlwZS5USUNLX0NIQVIgPSBcImBcIjtcblNxbGl0ZURpYWxlY3QucHJvdG90eXBlLlRJQ0tfQ0hBUl9MRUZUID0gU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xuU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSX1JJR0hUID0gU3FsaXRlRGlhbGVjdC5wcm90b3R5cGUuVElDS19DSEFSO1xubW9kdWxlLmV4cG9ydHMgPSBTcWxpdGVEaWFsZWN0O1xubW9kdWxlLmV4cG9ydHMuU3FsaXRlRGlhbGVjdCA9IFNxbGl0ZURpYWxlY3Q7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gU3FsaXRlRGlhbGVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-generator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-generator.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Transaction = __webpack_require__(/*! ../../transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst MySqlQueryGenerator = __webpack_require__(/*! ../mysql/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/query-generator.js\");\nconst AbstractQueryGenerator = __webpack_require__(/*! ../abstract/query-generator */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-generator.js\");\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  versionQuery() {\n    return \"SELECT sqlite_version() as `version`\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter((definition) => definition.includes(\"PRIMARY KEY\")).length > 1;\n    const attrArray = [];\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes(\"AUTOINCREMENT\");\n        let dataTypeString = dataType;\n        if (dataType.includes(\"PRIMARY KEY\")) {\n          if (dataType.includes(\"INT\")) {\n            dataTypeString = containsAutoIncrement ? \"INTEGER PRIMARY KEY AUTOINCREMENT\" : \"INTEGER PRIMARY KEY\";\n            if (dataType.includes(\" REFERENCES\")) {\n              dataTypeString += dataType.substr(dataType.indexOf(\" REFERENCES\"));\n            }\n          }\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes(\"NOT NULL\")) {\n              dataTypeString = dataType.replace(\" PRIMARY KEY\", \"\");\n            } else {\n              dataTypeString = dataType.replace(\"PRIMARY KEY\", \"NOT NULL\");\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(\", \");\n    const pkString = primaryKeys.map((pk) => this.quoteIdentifier(pk)).join(\", \");\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns) => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map((field) => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map((val) => val.toISOString());\n    }\n    return value;\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      }\n    }\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: \"addColumn\" });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n    return this.replaceBooleanDefaults(sql);\n  }\n  showTablesQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, { context: \"UPDATE\" }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = __spreadProps(__spreadValues({}, options), { bindParam });\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(\",\")} ${this.whereQuery(where, whereOptions)}`;\n    }\n    return { query, bind };\n  }\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable(\"sqlite_sequence\")} WHERE ${this.quoteIdentifier(\"name\")} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), \"`\"), \"'\")};` : \"\"\n    ].join(\"\");\n  }\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n        if (Object.prototype.hasOwnProperty.call(dataType, \"allowNull\") && !dataType.allowNull) {\n          sql += \" NOT NULL\";\n        }\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n        if (dataType.unique === true) {\n          sql += \" UNIQUE\";\n        }\n        if (dataType.primaryKey) {\n          sql += \" PRIMARY KEY\";\n          if (dataType.autoIncrement) {\n            sql += \" AUTOINCREMENT\";\n          }\n        }\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier(\"id\");\n          }\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n        }\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n    return result;\n  }\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n    return `${sql};`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n  removeColumnQuery(tableName, attributes) {\n    attributes = this.attributesToSQL(attributes);\n    let backupTableName;\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${createTableSql.replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`).replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};DROP TABLE ${quotedTableName};ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n    let backupTableName;\n    attributes = this.attributesToSQL(attributes);\n    if (typeof tableName === \"object\") {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map((attr) => attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)).join(\", \");\n    const attributeNamesExport = Object.keys(attributes).map((attr) => this.quoteIdentifier(attr)).join(\", \");\n    return `${this.createTableQuery(backupTableName, attributes)}INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};DROP TABLE ${quotedTableName};${this.createTableQuery(tableName, attributes)}INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};DROP TABLE ${quotedBackupTableName};`;\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"-- SQLite is not able to choose the isolation level REPEATABLE READ.\";\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return \"PRAGMA read_uncommitted = ON;\";\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"PRAGMA read_uncommitted = OFF;\";\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return \"-- SQLite's default isolation level is SERIALIZABLE. Nothing to do.\";\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, \"DEFAULT 0\").replace(/DEFAULT '?true'?/g, \"DEFAULT 1\");\n  }\n  getForeignKeysQuery(tableName) {\n    return `PRAGMA foreign_key_list(${this.quoteTable(this.addSchema(tableName))})`;\n  }\n  tableExistsQuery(tableName) {\n    return `SELECT name FROM sqlite_master WHERE type='table' AND name=${this.escape(this.addSchema(tableName))};`;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n}\nmodule.exports = SQLiteQueryGenerator;\n//# sourceMappingURL=query-generator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxnRUFBYTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDL0MsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLDRCQUE0QixtQkFBTyxDQUFDLHNHQUEwQjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyw0R0FBNkI7QUFDcEU7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzRUFBc0U7QUFDeEc7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0EsOENBQThDLE9BQU8sR0FBRyxRQUFRLEVBQUU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQsNERBQTRELEVBQUUsc0JBQXNCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxzQkFBc0I7QUFDNUUseUJBQXlCLDJCQUEyQixFQUFFLFlBQVk7QUFDbEUsK0JBQStCLHdCQUF3QixNQUFNLFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLEVBQUU7QUFDckosUUFBUTtBQUNSLHVCQUF1QiwwQkFBMEIsR0FBRyw0RUFBNEUsbUJBQW1CLGFBQWE7QUFDaEs7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWMsV0FBVztBQUNqRjtBQUNBLHdCQUF3Qiw0QkFBNEIsTUFBTSxrQkFBa0Isb0NBQW9DLDRCQUE0QixFQUFFLHNDQUFzQyxRQUFRLDJCQUEyQjtBQUN2TixNQUFNO0FBQ04sd0JBQXdCLDRCQUE0QixNQUFNLGtCQUFrQixFQUFFLHFDQUFxQztBQUNuSDtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsbUNBQW1DLGNBQWMsb0NBQW9DLFFBQVEsOEJBQThCLElBQUkseUVBQXlFO0FBQ3hNO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBLHlEQUF5RCw0QkFBNEIsRUFBRSxhQUFhLFFBQVEsMkJBQTJCO0FBQ3ZJO0FBQ0EsMEJBQTBCLDRCQUE0QixFQUFFLFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGdDQUFnQyxpQkFBaUIsR0FBRyxjQUFjO0FBQ2xFO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEdBQUcsZ0NBQWdDO0FBQ25GO0FBQ0EsbUNBQW1DLGdDQUFnQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx1Q0FBdUMsRUFBRTtBQUN6RTtBQUNBO0FBQ0EsNERBQTRELFVBQVUsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1EQUFtRCxjQUFjLHVCQUF1QixTQUFTLGdCQUFnQixPQUFPLGlCQUFpQixhQUFhLGlCQUFpQixFQUFFLDZDQUE2QyxjQUFjLGlCQUFpQixTQUFTLGdCQUFnQixPQUFPLHVCQUF1QixhQUFhLHVCQUF1QjtBQUM5VjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVDQUF1QyxnQkFBZ0IsbUJBQW1CLHNCQUFzQiwyQkFBMkIsbUNBQW1DLG1CQUFtQixzQkFBc0IsR0FBRyxjQUFjLHVCQUF1QixTQUFTLGdCQUFnQixPQUFPLGlCQUFpQixhQUFhLGlCQUFpQixjQUFjLHVCQUF1QixZQUFZLGlCQUFpQjtBQUM5WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHNDQUFzQyxLQUFLLDJCQUEyQjtBQUN6SztBQUNBLGNBQWMsbURBQW1ELGNBQWMsdUJBQXVCLFNBQVMsc0JBQXNCLE9BQU8saUJBQWlCLGFBQWEsaUJBQWlCLEVBQUUsNkNBQTZDLGNBQWMsaUJBQWlCLFNBQVMsc0JBQXNCLE9BQU8sdUJBQXVCLGFBQWEsdUJBQXVCO0FBQzFXO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQSxvQkFBb0IsMEJBQTBCLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7QUFDQTtBQUNBLHlFQUF5RSx3Q0FBd0M7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9xdWVyeS1nZW5lcmF0b3IuanM/MTI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZQcm9wcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xudmFyIF9fZ2V0T3duUHJvcERlc2NzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEsIGIpID0+IF9fZGVmUHJvcHMoYSwgX19nZXRPd25Qcm9wRGVzY3MoYikpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuLi8uLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgTXlTcWxRdWVyeUdlbmVyYXRvciA9IHJlcXVpcmUoXCIuLi9teXNxbC9xdWVyeS1nZW5lcmF0b3JcIik7XG5jb25zdCBBYnN0cmFjdFF1ZXJ5R2VuZXJhdG9yID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWdlbmVyYXRvclwiKTtcbmNsYXNzIFNRTGl0ZVF1ZXJ5R2VuZXJhdG9yIGV4dGVuZHMgTXlTcWxRdWVyeUdlbmVyYXRvciB7XG4gIGNyZWF0ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gXCJTRUxFQ1QgbmFtZSBGUk9NIGBzcWxpdGVfbWFzdGVyYCBXSEVSRSB0eXBlPSd0YWJsZScgYW5kIG5hbWUhPSdzcWxpdGVfc2VxdWVuY2UnO1wiO1xuICB9XG4gIHNob3dTY2hlbWFzUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIG5hbWUgRlJPTSBgc3FsaXRlX21hc3RlcmAgV0hFUkUgdHlwZT0ndGFibGUnIGFuZCBuYW1lIT0nc3FsaXRlX3NlcXVlbmNlJztcIjtcbiAgfVxuICB2ZXJzaW9uUXVlcnkoKSB7XG4gICAgcmV0dXJuIFwiU0VMRUNUIHNxbGl0ZV92ZXJzaW9uKCkgYXMgYHZlcnNpb25gXCI7XG4gIH1cbiAgY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwcmltYXJ5S2V5cyA9IFtdO1xuICAgIGNvbnN0IG5lZWRzTXVsdGlwbGVQcmltYXJ5S2V5cyA9IE9iamVjdC52YWx1ZXMoYXR0cmlidXRlcykuZmlsdGVyKChkZWZpbml0aW9uKSA9PiBkZWZpbml0aW9uLmluY2x1ZGVzKFwiUFJJTUFSWSBLRVlcIikpLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgYXR0ckFycmF5ID0gW107XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICBjb25zdCBjb250YWluc0F1dG9JbmNyZW1lbnQgPSBkYXRhVHlwZS5pbmNsdWRlcyhcIkFVVE9JTkNSRU1FTlRcIik7XG4gICAgICAgIGxldCBkYXRhVHlwZVN0cmluZyA9IGRhdGFUeXBlO1xuICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCJQUklNQVJZIEtFWVwiKSkge1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIklOVFwiKSkge1xuICAgICAgICAgICAgZGF0YVR5cGVTdHJpbmcgPSBjb250YWluc0F1dG9JbmNyZW1lbnQgPyBcIklOVEVHRVIgUFJJTUFSWSBLRVkgQVVUT0lOQ1JFTUVOVFwiIDogXCJJTlRFR0VSIFBSSU1BUlkgS0VZXCI7XG4gICAgICAgICAgICBpZiAoZGF0YVR5cGUuaW5jbHVkZXMoXCIgUkVGRVJFTkNFU1wiKSkge1xuICAgICAgICAgICAgICBkYXRhVHlwZVN0cmluZyArPSBkYXRhVHlwZS5zdWJzdHIoZGF0YVR5cGUuaW5kZXhPZihcIiBSRUZFUkVOQ0VTXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5lZWRzTXVsdGlwbGVQcmltYXJ5S2V5cykge1xuICAgICAgICAgICAgcHJpbWFyeUtleXMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIGlmIChkYXRhVHlwZS5pbmNsdWRlcyhcIk5PVCBOVUxMXCIpKSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nID0gZGF0YVR5cGUucmVwbGFjZShcIiBQUklNQVJZIEtFWVwiLCBcIlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFUeXBlU3RyaW5nID0gZGF0YVR5cGUucmVwbGFjZShcIlBSSU1BUlkgS0VZXCIsIFwiTk9UIE5VTExcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJBcnJheS5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpfSAke2RhdGFUeXBlU3RyaW5nfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGxldCBhdHRyU3RyID0gYXR0ckFycmF5LmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBwa1N0cmluZyA9IHByaW1hcnlLZXlzLm1hcCgocGspID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKHBrKSkuam9pbihcIiwgXCIpO1xuICAgIGlmIChvcHRpb25zLnVuaXF1ZUtleXMpIHtcbiAgICAgIF8uZWFjaChvcHRpb25zLnVuaXF1ZUtleXMsIChjb2x1bW5zKSA9PiB7XG4gICAgICAgIGlmIChjb2x1bW5zLmN1c3RvbUluZGV4KSB7XG4gICAgICAgICAgYXR0clN0ciArPSBgLCBVTklRVUUgKCR7Y29sdW1ucy5maWVsZHMubWFwKChmaWVsZCkgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoZmllbGQpKS5qb2luKFwiLCBcIil9KWA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGtTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgYXR0clN0ciArPSBgLCBQUklNQVJZIEtFWSAoJHtwa1N0cmluZ30pYDtcbiAgICB9XG4gICAgY29uc3Qgc3FsID0gYENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICR7dGFibGV9ICgke2F0dHJTdHJ9KTtgO1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VCb29sZWFuRGVmYXVsdHMoc3FsKTtcbiAgfVxuICBib29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyAxIDogMDtcbiAgfVxuICBfY2hlY2tWYWxpZEpzb25TdGF0ZW1lbnQoc3RtdCkge1xuICAgIGlmICh0eXBlb2Ygc3RtdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBqc29uRnVuY3Rpb25SZWdleCA9IC9eXFxzKihqc29uKD86X1thLXpdKyl7MCwyfSlcXChbXildKlxcKS9pO1xuICAgIGNvbnN0IHRva2VuQ2FwdHVyZVJlZ2V4ID0gL15cXHMqKCg/OihbYFwiJ10pKD86KD8hXFwyKS58XFwyezJ9KSpcXDIpfFtcXHdcXGRcXHNdK3xbKCkuLDsrLV0pL2k7XG4gICAgbGV0IGN1cnJlbnRJbmRleCA9IDA7XG4gICAgbGV0IG9wZW5pbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGNsb3NpbmdCcmFja2V0cyA9IDA7XG4gICAgbGV0IGhhc0pzb25GdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBoYXNJbnZhbGlkVG9rZW4gPSBmYWxzZTtcbiAgICB3aGlsZSAoY3VycmVudEluZGV4IDwgc3RtdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHN0cmluZyA9IHN0bXQuc3Vic3RyKGN1cnJlbnRJbmRleCk7XG4gICAgICBjb25zdCBmdW5jdGlvbk1hdGNoZXMgPSBqc29uRnVuY3Rpb25SZWdleC5leGVjKHN0cmluZyk7XG4gICAgICBpZiAoZnVuY3Rpb25NYXRjaGVzKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCArPSBmdW5jdGlvbk1hdGNoZXNbMF0uaW5kZXhPZihcIihcIik7XG4gICAgICAgIGhhc0pzb25GdW5jdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5NYXRjaGVzID0gdG9rZW5DYXB0dXJlUmVnZXguZXhlYyhzdHJpbmcpO1xuICAgICAgaWYgKHRva2VuTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBjYXB0dXJlZFRva2VuID0gdG9rZW5NYXRjaGVzWzFdO1xuICAgICAgICBpZiAoY2FwdHVyZWRUb2tlbiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICBvcGVuaW5nQnJhY2tldHMrKztcbiAgICAgICAgfSBlbHNlIGlmIChjYXB0dXJlZFRva2VuID09PSBcIilcIikge1xuICAgICAgICAgIGNsb3NpbmdCcmFja2V0cysrO1xuICAgICAgICB9IGVsc2UgaWYgKGNhcHR1cmVkVG9rZW4gPT09IFwiO1wiKSB7XG4gICAgICAgICAgaGFzSW52YWxpZFRva2VuID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SW5kZXggKz0gdG9rZW5NYXRjaGVzWzBdLmxlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaGFzSW52YWxpZFRva2VuIHw9IG9wZW5pbmdCcmFja2V0cyAhPT0gY2xvc2luZ0JyYWNrZXRzO1xuICAgIGlmIChoYXNKc29uRnVuY3Rpb24gJiYgaGFzSW52YWxpZFRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQganNvbiBzdGF0ZW1lbnQ6ICR7c3RtdH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc0pzb25GdW5jdGlvbjtcbiAgfVxuICBfdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsKSA9PiB2YWwudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBoYW5kbGVTZXF1ZWxpemVNZXRob2Qoc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKSB7XG4gICAgaWYgKHNtdGggaW5zdGFuY2VvZiBVdGlscy5Kc29uKSB7XG4gICAgICByZXR1cm4gc3VwZXIuaGFuZGxlU2VxdWVsaXplTWV0aG9kKHNtdGgsIHRhYmxlTmFtZSwgZmFjdG9yeSwgb3B0aW9ucywgcHJlcGVuZCk7XG4gICAgfVxuICAgIGlmIChzbXRoIGluc3RhbmNlb2YgVXRpbHMuQ2FzdCkge1xuICAgICAgaWYgKC90aW1lc3RhbXAvaS50ZXN0KHNtdGgudHlwZSkpIHtcbiAgICAgICAgc210aC50eXBlID0gXCJkYXRldGltZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQWJzdHJhY3RRdWVyeUdlbmVyYXRvci5wcm90b3R5cGUuaGFuZGxlU2VxdWVsaXplTWV0aG9kLmNhbGwodGhpcywgc210aCwgdGFibGVOYW1lLCBmYWN0b3J5LCBvcHRpb25zLCBwcmVwZW5kKTtcbiAgfVxuICBhZGRDb2x1bW5RdWVyeSh0YWJsZSwga2V5LCBkYXRhVHlwZSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBhdHRyaWJ1dGVzW2tleV0gPSBkYXRhVHlwZTtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzLCB7IGNvbnRleHQ6IFwiYWRkQ29sdW1uXCIgfSk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gYCR7dGhpcy5xdW90ZUlkZW50aWZpZXIoa2V5KX0gJHtmaWVsZHNba2V5XX1gO1xuICAgIGNvbnN0IHNxbCA9IGBBTFRFUiBUQUJMRSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZSl9IEFERCAke2F0dHJpYnV0ZX07YDtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlQm9vbGVhbkRlZmF1bHRzKHNxbCk7XG4gIH1cbiAgc2hvd1RhYmxlc1F1ZXJ5KCkge1xuICAgIHJldHVybiBcIlNFTEVDVCBuYW1lIEZST00gYHNxbGl0ZV9tYXN0ZXJgIFdIRVJFIHR5cGU9J3RhYmxlJyBhbmQgbmFtZSE9J3NxbGl0ZV9zZXF1ZW5jZSc7XCI7XG4gIH1cbiAgdXBkYXRlUXVlcnkodGFibGVOYW1lLCBhdHRyVmFsdWVIYXNoLCB3aGVyZSwgb3B0aW9ucywgYXR0cmlidXRlcykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIF8uZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zKTtcbiAgICBhdHRyVmFsdWVIYXNoID0gVXRpbHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGF0dHJWYWx1ZUhhc2gsIG9wdGlvbnMub21pdE51bGwsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgY29uc3QgYmluZCA9IFtdO1xuICAgIGNvbnN0IGJpbmRQYXJhbSA9IG9wdGlvbnMuYmluZFBhcmFtIHx8IHRoaXMuYmluZFBhcmFtKGJpbmQpO1xuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICBfLmVhY2goYXR0cmlidXRlcywgKGF0dHJpYnV0ZSwga2V5KSA9PiB7XG4gICAgICAgIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUuZmllbGQpIHtcbiAgICAgICAgICBtb2RlbEF0dHJpYnV0ZU1hcFthdHRyaWJ1dGUuZmllbGRdID0gYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0clZhbHVlSGFzaCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyVmFsdWVIYXNoW2tleV07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QgfHwgb3B0aW9ucy5iaW5kUGFyYW0gPT09IGZhbHNlKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGtleSl9PSR7dGhpcy5lc2NhcGUodmFsdWUsIG1vZGVsQXR0cmlidXRlTWFwICYmIG1vZGVsQXR0cmlidXRlTWFwW2tleV0gfHwgdm9pZCAwLCB7IGNvbnRleHQ6IFwiVVBEQVRFXCIgfSl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMucHVzaChgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihrZXkpfT0ke3RoaXMuZm9ybWF0KHZhbHVlLCBtb2RlbEF0dHJpYnV0ZU1hcCAmJiBtb2RlbEF0dHJpYnV0ZU1hcFtrZXldIHx8IHZvaWQgMCwgeyBjb250ZXh0OiBcIlVQREFURVwiIH0sIGJpbmRQYXJhbSl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBxdWVyeTtcbiAgICBjb25zdCB3aGVyZU9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwgeyBiaW5kUGFyYW0gfSk7XG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHtcbiAgICAgIHF1ZXJ5ID0gYFVQREFURSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSBTRVQgJHt2YWx1ZXMuam9pbihcIixcIil9IFdIRVJFIHJvd2lkIElOIChTRUxFQ1Qgcm93aWQgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3RoaXMud2hlcmVRdWVyeSh3aGVyZSwgd2hlcmVPcHRpb25zKX0gTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBgVVBEQVRFICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9IFNFVCAke3ZhbHVlcy5qb2luKFwiLFwiKX0gJHt0aGlzLndoZXJlUXVlcnkod2hlcmUsIHdoZXJlT3B0aW9ucyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHsgcXVlcnksIGJpbmQgfTtcbiAgfVxuICB0cnVuY2F0ZVRhYmxlUXVlcnkodGFibGVOYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gW1xuICAgICAgYERFTEVURSBGUk9NICR7dGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSl9YCxcbiAgICAgIG9wdGlvbnMucmVzdGFydElkZW50aXR5ID8gYDsgREVMRVRFIEZST00gJHt0aGlzLnF1b3RlVGFibGUoXCJzcWxpdGVfc2VxdWVuY2VcIil9IFdIRVJFICR7dGhpcy5xdW90ZUlkZW50aWZpZXIoXCJuYW1lXCIpfSA9ICR7VXRpbHMuYWRkVGlja3MoVXRpbHMucmVtb3ZlVGlja3ModGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSksIFwiYFwiKSwgXCInXCIpfTtgIDogXCJcIlxuICAgIF0uam9pbihcIlwiKTtcbiAgfVxuICBkZWxldGVRdWVyeSh0YWJsZU5hbWUsIHdoZXJlLCBvcHRpb25zID0ge30sIG1vZGVsKSB7XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB0aGlzLm9wdGlvbnMpO1xuICAgIGxldCB3aGVyZUNsYXVzZSA9IHRoaXMuZ2V0V2hlcmVDb25kaXRpb25zKHdoZXJlLCBudWxsLCBtb2RlbCwgb3B0aW9ucyk7XG4gICAgaWYgKHdoZXJlQ2xhdXNlKSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGBXSEVSRSAke3doZXJlQ2xhdXNlfWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxpbWl0KSB7XG4gICAgICB3aGVyZUNsYXVzZSA9IGBXSEVSRSByb3dpZCBJTiAoU0VMRUNUIHJvd2lkIEZST00gJHt0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKX0gJHt3aGVyZUNsYXVzZX0gTElNSVQgJHt0aGlzLmVzY2FwZShvcHRpb25zLmxpbWl0KX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIGBERUxFVEUgRlJPTSAke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSAke3doZXJlQ2xhdXNlfWA7XG4gIH1cbiAgYXR0cmlidXRlc1RvU1FMKGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgY29uc3QgZGF0YVR5cGUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgY29uc3QgZmllbGROYW1lID0gZGF0YVR5cGUuZmllbGQgfHwgbmFtZTtcbiAgICAgIGlmIChfLmlzT2JqZWN0KGRhdGFUeXBlKSkge1xuICAgICAgICBsZXQgc3FsID0gZGF0YVR5cGUudHlwZS50b1N0cmluZygpO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFUeXBlLCBcImFsbG93TnVsbFwiKSAmJiAhZGF0YVR5cGUuYWxsb3dOdWxsKSB7XG4gICAgICAgICAgc3FsICs9IFwiIE5PVCBOVUxMXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmRlZmF1bHRWYWx1ZVNjaGVtYWJsZShkYXRhVHlwZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgc3FsICs9IGAgREVGQVVMVCAke3RoaXMuZXNjYXBlKGRhdGFUeXBlLmRlZmF1bHRWYWx1ZSwgZGF0YVR5cGUpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlLnVuaXF1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHNxbCArPSBcIiBVTklRVUVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUucHJpbWFyeUtleSkge1xuICAgICAgICAgIHNxbCArPSBcIiBQUklNQVJZIEtFWVwiO1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5hdXRvSW5jcmVtZW50KSB7XG4gICAgICAgICAgICBzcWwgKz0gXCIgQVVUT0lOQ1JFTUVOVFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVR5cGUucmVmZXJlbmNlcykge1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXNUYWJsZSA9IHRoaXMucXVvdGVUYWJsZShkYXRhVHlwZS5yZWZlcmVuY2VzLm1vZGVsKTtcbiAgICAgICAgICBsZXQgcmVmZXJlbmNlc0tleTtcbiAgICAgICAgICBpZiAoZGF0YVR5cGUucmVmZXJlbmNlcy5rZXkpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihkYXRhVHlwZS5yZWZlcmVuY2VzLmtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXNLZXkgPSB0aGlzLnF1b3RlSWRlbnRpZmllcihcImlkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzcWwgKz0gYCBSRUZFUkVOQ0VTICR7cmVmZXJlbmNlc1RhYmxlfSAoJHtyZWZlcmVuY2VzS2V5fSlgO1xuICAgICAgICAgIGlmIChkYXRhVHlwZS5vbkRlbGV0ZSkge1xuICAgICAgICAgICAgc3FsICs9IGAgT04gREVMRVRFICR7ZGF0YVR5cGUub25EZWxldGUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YVR5cGUub25VcGRhdGUpIHtcbiAgICAgICAgICAgIHNxbCArPSBgIE9OIFVQREFURSAke2RhdGFUeXBlLm9uVXBkYXRlLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBzcWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRhdGFUeXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHNob3dJbmRleGVzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBQUkFHTUEgSU5ERVhfTElTVCgke3RoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpfSlgO1xuICB9XG4gIHNob3dDb25zdHJhaW50c1F1ZXJ5KHRhYmxlTmFtZSwgY29uc3RyYWludE5hbWUpIHtcbiAgICBsZXQgc3FsID0gYFNFTEVDVCBzcWwgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHRibF9uYW1lPScke3RhYmxlTmFtZX0nYDtcbiAgICBpZiAoY29uc3RyYWludE5hbWUpIHtcbiAgICAgIHNxbCArPSBgIEFORCBzcWwgTElLRSAnJSR7Y29uc3RyYWludE5hbWV9JSdgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7c3FsfTtgO1xuICB9XG4gIHJlbW92ZUluZGV4UXVlcnkodGFibGVOYW1lLCBpbmRleE5hbWVPckF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgaW5kZXhOYW1lID0gaW5kZXhOYW1lT3JBdHRyaWJ1dGVzO1xuICAgIGlmICh0eXBlb2YgaW5kZXhOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpbmRleE5hbWUgPSBVdGlscy51bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtpbmRleE5hbWVPckF0dHJpYnV0ZXMuam9pbihcIl9cIil9YCk7XG4gICAgfVxuICAgIHJldHVybiBgRFJPUCBJTkRFWCBJRiBFWElTVFMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihpbmRleE5hbWUpfWA7XG4gIH1cbiAgZGVzY3JpYmVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgc2NoZW1hLCBzY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICBjb25zdCB0YWJsZSA9IHtcbiAgICAgIF9zY2hlbWE6IHNjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHNjaGVtYURlbGltaXRlcixcbiAgICAgIHRhYmxlTmFtZVxuICAgIH07XG4gICAgcmV0dXJuIGBQUkFHTUEgVEFCTEVfSU5GTygke3RoaXMucXVvdGVUYWJsZSh0aGlzLmFkZFNjaGVtYSh0YWJsZSkpfSk7YDtcbiAgfVxuICBkZXNjcmliZUNyZWF0ZVRhYmxlUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1Qgc3FsIEZST00gc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0nJHt0YWJsZU5hbWV9JztgO1xuICB9XG4gIHJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKTtcbiAgICBsZXQgYmFja3VwVGFibGVOYW1lO1xuICAgIGlmICh0eXBlb2YgdGFibGVOYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSB7XG4gICAgICAgIHRhYmxlTmFtZTogYCR7dGFibGVOYW1lLnRhYmxlTmFtZX1fYmFja3VwYCxcbiAgICAgICAgc2NoZW1hOiB0YWJsZU5hbWUuc2NoZW1hXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBiYWNrdXBUYWJsZU5hbWUgPSBgJHt0YWJsZU5hbWV9X2JhY2t1cGA7XG4gICAgfVxuICAgIGNvbnN0IHF1b3RlZFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IHF1b3RlZEJhY2t1cFRhYmxlTmFtZSA9IHRoaXMucXVvdGVUYWJsZShiYWNrdXBUYWJsZU5hbWUpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKChhdHRyKSA9PiB0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKSkuam9pbihcIiwgXCIpO1xuICAgIHJldHVybiBgJHt0aGlzLmNyZWF0ZVRhYmxlUXVlcnkoYmFja3VwVGFibGVOYW1lLCBhdHRyaWJ1dGVzKX1JTlNFUlQgSU5UTyAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gU0VMRUNUICR7YXR0cmlidXRlTmFtZXN9IEZST00gJHtxdW90ZWRUYWJsZU5hbWV9O0RST1AgVEFCTEUgJHtxdW90ZWRUYWJsZU5hbWV9OyR7dGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KHRhYmxlTmFtZSwgYXR0cmlidXRlcyl9SU5TRVJUIElOVE8gJHtxdW90ZWRUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzfSBGUk9NICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtEUk9QIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfTtgO1xuICB9XG4gIF9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIGNyZWF0ZVRhYmxlU3FsKSB7XG4gICAgbGV0IGJhY2t1cFRhYmxlTmFtZTtcbiAgICBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzVG9TUUwoYXR0cmlidXRlcyk7XG4gICAgaWYgKHR5cGVvZiB0YWJsZU5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IHtcbiAgICAgICAgdGFibGVOYW1lOiBgJHt0YWJsZU5hbWUudGFibGVOYW1lfV9iYWNrdXBgLFxuICAgICAgICBzY2hlbWE6IHRhYmxlTmFtZS5zY2hlbWFcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhY2t1cFRhYmxlTmFtZSA9IGAke3RhYmxlTmFtZX1fYmFja3VwYDtcbiAgICB9XG4gICAgY29uc3QgcXVvdGVkVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKHRhYmxlTmFtZSk7XG4gICAgY29uc3QgcXVvdGVkQmFja3VwVGFibGVOYW1lID0gdGhpcy5xdW90ZVRhYmxlKGJhY2t1cFRhYmxlTmFtZSk7XG4gICAgY29uc3QgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoKGF0dHIpID0+IHRoaXMucXVvdGVJZGVudGlmaWVyKGF0dHIpKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIGAke2NyZWF0ZVRhYmxlU3FsLnJlcGxhY2UoYENSRUFURSBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZX1gLCBgQ1JFQVRFIFRBQkxFICR7cXVvdGVkQmFja3VwVGFibGVOYW1lfWApLnJlcGxhY2UoYENSRUFURSBUQUJMRSAke3F1b3RlZFRhYmxlTmFtZS5yZXBsYWNlKC9gL2csICdcIicpfWAsIGBDUkVBVEUgVEFCTEUgJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9YCl9SU5TRVJUIElOVE8gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzfSBGUk9NICR7cXVvdGVkVGFibGVOYW1lfTtEUk9QIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfTtBTFRFUiBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX0gUkVOQU1FIFRPICR7cXVvdGVkVGFibGVOYW1lfTtgO1xuICB9XG4gIHJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIGF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgYmFja3VwVGFibGVOYW1lO1xuICAgIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXNUb1NRTChhdHRyaWJ1dGVzKTtcbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0ge1xuICAgICAgICB0YWJsZU5hbWU6IGAke3RhYmxlTmFtZS50YWJsZU5hbWV9X2JhY2t1cGAsXG4gICAgICAgIHNjaGVtYTogdGFibGVOYW1lLnNjaGVtYVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFja3VwVGFibGVOYW1lID0gYCR7dGFibGVOYW1lfV9iYWNrdXBgO1xuICAgIH1cbiAgICBjb25zdCBxdW90ZWRUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUodGFibGVOYW1lKTtcbiAgICBjb25zdCBxdW90ZWRCYWNrdXBUYWJsZU5hbWUgPSB0aGlzLnF1b3RlVGFibGUoYmFja3VwVGFibGVOYW1lKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lc0ltcG9ydCA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgoYXR0cikgPT4gYXR0ck5hbWVBZnRlciA9PT0gYXR0ciA/IGAke3RoaXMucXVvdGVJZGVudGlmaWVyKGF0dHJOYW1lQmVmb3JlKX0gQVMgJHt0aGlzLnF1b3RlSWRlbnRpZmllcihhdHRyKX1gIDogdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lc0V4cG9ydCA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLm1hcCgoYXR0cikgPT4gdGhpcy5xdW90ZUlkZW50aWZpZXIoYXR0cikpLmpvaW4oXCIsIFwiKTtcbiAgICByZXR1cm4gYCR7dGhpcy5jcmVhdGVUYWJsZVF1ZXJ5KGJhY2t1cFRhYmxlTmFtZSwgYXR0cmlidXRlcyl9SU5TRVJUIElOVE8gJHtxdW90ZWRCYWNrdXBUYWJsZU5hbWV9IFNFTEVDVCAke2F0dHJpYnV0ZU5hbWVzSW1wb3J0fSBGUk9NICR7cXVvdGVkVGFibGVOYW1lfTtEUk9QIFRBQkxFICR7cXVvdGVkVGFibGVOYW1lfTske3RoaXMuY3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMpfUlOU0VSVCBJTlRPICR7cXVvdGVkVGFibGVOYW1lfSBTRUxFQ1QgJHthdHRyaWJ1dGVOYW1lc0V4cG9ydH0gRlJPTSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07RFJPUCBUQUJMRSAke3F1b3RlZEJhY2t1cFRhYmxlTmFtZX07YDtcbiAgfVxuICBzdGFydFRyYW5zYWN0aW9uUXVlcnkodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24ucGFyZW50KSB7XG4gICAgICByZXR1cm4gYFNBVkVQT0lOVCAke3RoaXMucXVvdGVJZGVudGlmaWVyKHRyYW5zYWN0aW9uLm5hbWUpfTtgO1xuICAgIH1cbiAgICByZXR1cm4gYEJFR0lOICR7dHJhbnNhY3Rpb24ub3B0aW9ucy50eXBlfSBUUkFOU0FDVElPTjtgO1xuICB9XG4gIHNldElzb2xhdGlvbkxldmVsUXVlcnkodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVQRUFUQUJMRV9SRUFEOlxuICAgICAgICByZXR1cm4gXCItLSBTUUxpdGUgaXMgbm90IGFibGUgdG8gY2hvb3NlIHRoZSBpc29sYXRpb24gbGV2ZWwgUkVQRUFUQUJMRSBSRUFELlwiO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlJFQURfVU5DT01NSVRURUQ6XG4gICAgICAgIHJldHVybiBcIlBSQUdNQSByZWFkX3VuY29tbWl0dGVkID0gT047XCI7XG4gICAgICBjYXNlIFRyYW5zYWN0aW9uLklTT0xBVElPTl9MRVZFTFMuUkVBRF9DT01NSVRURUQ6XG4gICAgICAgIHJldHVybiBcIlBSQUdNQSByZWFkX3VuY29tbWl0dGVkID0gT0ZGO1wiO1xuICAgICAgY2FzZSBUcmFuc2FjdGlvbi5JU09MQVRJT05fTEVWRUxTLlNFUklBTElaQUJMRTpcbiAgICAgICAgcmV0dXJuIFwiLS0gU1FMaXRlJ3MgZGVmYXVsdCBpc29sYXRpb24gbGV2ZWwgaXMgU0VSSUFMSVpBQkxFLiBOb3RoaW5nIHRvIGRvLlwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGlzb2xhdGlvbiBsZXZlbDogJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgcmVwbGFjZUJvb2xlYW5EZWZhdWx0cyhzcWwpIHtcbiAgICByZXR1cm4gc3FsLnJlcGxhY2UoL0RFRkFVTFQgJz9mYWxzZSc/L2csIFwiREVGQVVMVCAwXCIpLnJlcGxhY2UoL0RFRkFVTFQgJz90cnVlJz8vZywgXCJERUZBVUxUIDFcIik7XG4gIH1cbiAgZ2V0Rm9yZWlnbktleXNRdWVyeSh0YWJsZU5hbWUpIHtcbiAgICByZXR1cm4gYFBSQUdNQSBmb3JlaWduX2tleV9saXN0KCR7dGhpcy5xdW90ZVRhYmxlKHRoaXMuYWRkU2NoZW1hKHRhYmxlTmFtZSkpfSlgO1xuICB9XG4gIHRhYmxlRXhpc3RzUXVlcnkodGFibGVOYW1lKSB7XG4gICAgcmV0dXJuIGBTRUxFQ1QgbmFtZSBGUk9NIHNxbGl0ZV9tYXN0ZXIgV0hFUkUgdHlwZT0ndGFibGUnIEFORCBuYW1lPSR7dGhpcy5lc2NhcGUodGhpcy5hZGRTY2hlbWEodGFibGVOYW1lKSl9O2A7XG4gIH1cbiAgcXVvdGVJZGVudGlmaWVyKGlkZW50aWZpZXIsIGZvcmNlKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFkZFRpY2tzKFV0aWxzLnJlbW92ZVRpY2tzKGlkZW50aWZpZXIsIFwiYFwiKSwgXCJgXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNRTGl0ZVF1ZXJ5R2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnktZ2VuZXJhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-generator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query-interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst { QueryInterface } = __webpack_require__(/*! ../abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst { cloneDeep } = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nclass SQLiteQueryInterface extends QueryInterface {\n  async removeColumn(tableName, attributeName, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    delete fields[attributeName];\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const fields = await this.describeTable(tableName, options);\n    Object.assign(fields[attributeName], this.normalizeAttribute(dataTypeOrOptions));\n    const sql = this.queryGenerator.removeColumnQuery(tableName, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const fields = await this.assertTableHasColumn(tableName, attrNameBefore, options);\n    fields[attrNameAfter] = __spreadValues({}, fields[attrNameBefore]);\n    delete fields[attrNameBefore];\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, attrNameAfter, fields);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    let createTableSql;\n    const constraints = await this.showConstraint(tableName, constraintName);\n    const constraint = constraints.find((constaint) => constaint.constraintName === constraintName);\n    if (!constraint) {\n      throw new sequelizeErrors.UnknownConstraintError({\n        message: `Constraint ${constraintName} on table ${tableName} does not exist`,\n        constraint: constraintName,\n        table: tableName\n      });\n    }\n    createTableSql = constraint.sql;\n    constraint.constraintName = this.queryGenerator.quoteIdentifier(constraint.constraintName);\n    let constraintSnippet = `, CONSTRAINT ${constraint.constraintName} ${constraint.constraintType} ${constraint.constraintCondition}`;\n    if (constraint.constraintType === \"FOREIGN KEY\") {\n      const referenceTableName = this.queryGenerator.quoteTable(constraint.referenceTableName);\n      constraint.referenceTableKeys = constraint.referenceTableKeys.map((columnName) => this.queryGenerator.quoteIdentifier(columnName));\n      const referenceTableKeys = constraint.referenceTableKeys.join(\", \");\n      constraintSnippet += ` REFERENCES ${referenceTableName} (${referenceTableKeys})`;\n      constraintSnippet += ` ON UPDATE ${constraint.updateAction}`;\n      constraintSnippet += ` ON DELETE ${constraint.deleteAction}`;\n    }\n    createTableSql = createTableSql.replace(constraintSnippet, \"\");\n    createTableSql += \";\";\n    const fields = await this.describeTable(tableName, options);\n    const sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = cloneDeep(options);\n    const constraintSnippet = this.queryGenerator.getConstraintSnippet(tableName, options);\n    const describeCreateTableSql = this.queryGenerator.describeCreateTableQuery(tableName);\n    const constraints = await this.sequelize.query(describeCreateTableSql, __spreadProps(__spreadValues({}, options), { type: QueryTypes.SELECT, raw: true }));\n    let sql = constraints[0].sql;\n    const index = sql.length - 1;\n    const createTableSql = `${sql.substr(0, index)}, ${constraintSnippet})${sql.substr(index + 1)};`;\n    const fields = await this.describeTable(tableName, options);\n    sql = this.queryGenerator._alterConstraintQuery(tableName, fields, createTableSql);\n    const subQueries = sql.split(\";\").filter((q) => q !== \"\");\n    for (const subQuery of subQueries)\n      await this.sequelize.query(`${subQuery};`, __spreadValues({ raw: true }, options));\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const database = this.sequelize.config.database;\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, database);\n    const result = await this.sequelize.query(query, options);\n    return result.map((row) => ({\n      tableName,\n      columnName: row.from,\n      referencedTableName: row.table,\n      referencedColumnName: row.to,\n      tableCatalog: database,\n      referencedTableCatalog: database\n    }));\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    await this._dropAllTables(tableNames, skip, options);\n    await this.sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), { type: QueryTypes.DESCRIBE });\n    const sqlIndexes = this.queryGenerator.showIndexesQuery(tableName);\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      const indexes = await this.sequelize.query(sqlIndexes, options);\n      for (const prop in data) {\n        data[prop].unique = false;\n      }\n      for (const index of indexes) {\n        for (const field of index.fields) {\n          if (index.unique !== void 0) {\n            data[field.attribute].unique = index.unique;\n          }\n        }\n      }\n      const foreignKeys = await this.getForeignKeyReferencesForTable(tableName, options);\n      for (const foreignKey of foreignKeys) {\n        data[foreignKey.columnName].references = {\n          model: foreignKey.referencedTableName,\n          key: foreignKey.referencedColumnName\n        };\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n}\nexports.SQLiteQueryInterface = SQLiteQueryInterface;\n//# sourceMappingURL=query-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLHdFQUFjO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFtQjtBQUM5QyxRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsNEdBQTZCO0FBQ2hFLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsZ0VBQWE7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBb0MsVUFBVSxvQkFBb0IsV0FBVztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0IsV0FBVyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDJCQUEyQixFQUFFLDJCQUEyQixFQUFFLCtCQUErQjtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvQkFBb0IsR0FBRyxtQkFBbUI7QUFDcEYseUNBQXlDLHdCQUF3QjtBQUNqRSx5Q0FBeUMsd0JBQXdCO0FBQ2pFO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsY0FBYyxvQ0FBb0M7QUFDNUo7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUIsSUFBSSxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDbkc7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLG9DQUFvQyxVQUFVLG9CQUFvQixXQUFXO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYywyQkFBMkI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVSwwQ0FBMEM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFEQUFxRCxVQUFVLDBDQUEwQztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnktaW50ZXJmYWNlLmpzPzNhNTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IHNlcXVlbGl6ZUVycm9ycyA9IHJlcXVpcmUoXCIuLi8uLi9lcnJvcnNcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3QgeyBRdWVyeUludGVyZmFjZSB9ID0gcmVxdWlyZShcIi4uL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IHsgY2xvbmVEZWVwIH0gPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNsYXNzIFNRTGl0ZVF1ZXJ5SW50ZXJmYWNlIGV4dGVuZHMgUXVlcnlJbnRlcmZhY2Uge1xuICBhc3luYyByZW1vdmVDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVOYW1lLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZmllbGRzID0gYXdhaXQgdGhpcy5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgZGVsZXRlIGZpZWxkc1thdHRyaWJ1dGVOYW1lXTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KFwiO1wiKS5maWx0ZXIoKHEpID0+IHEgIT09IFwiXCIpO1xuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcylcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgY2hhbmdlQ29sdW1uKHRhYmxlTmFtZSwgYXR0cmlidXRlTmFtZSwgZGF0YVR5cGVPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKGZpZWxkc1thdHRyaWJ1dGVOYW1lXSwgdGhpcy5ub3JtYWxpemVBdHRyaWJ1dGUoZGF0YVR5cGVPck9wdGlvbnMpKTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbW92ZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgZmllbGRzKTtcbiAgICBjb25zdCBzdWJRdWVyaWVzID0gc3FsLnNwbGl0KFwiO1wiKS5maWx0ZXIoKHEpID0+IHEgIT09IFwiXCIpO1xuICAgIGZvciAoY29uc3Qgc3ViUXVlcnkgb2Ygc3ViUXVlcmllcylcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KGAke3N1YlF1ZXJ5fTtgLCBfX3NwcmVhZFZhbHVlcyh7IHJhdzogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gIH1cbiAgYXN5bmMgcmVuYW1lQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmFzc2VydFRhYmxlSGFzQ29sdW1uKHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIG9wdGlvbnMpO1xuICAgIGZpZWxkc1thdHRyTmFtZUFmdGVyXSA9IF9fc3ByZWFkVmFsdWVzKHt9LCBmaWVsZHNbYXR0ck5hbWVCZWZvcmVdKTtcbiAgICBkZWxldGUgZmllbGRzW2F0dHJOYW1lQmVmb3JlXTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnJlbmFtZUNvbHVtblF1ZXJ5KHRhYmxlTmFtZSwgYXR0ck5hbWVCZWZvcmUsIGF0dHJOYW1lQWZ0ZXIsIGZpZWxkcyk7XG4gICAgY29uc3Qgc3ViUXVlcmllcyA9IHNxbC5zcGxpdChcIjtcIikuZmlsdGVyKChxKSA9PiBxICE9PSBcIlwiKTtcbiAgICBmb3IgKGNvbnN0IHN1YlF1ZXJ5IG9mIHN1YlF1ZXJpZXMpXG4gICAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShgJHtzdWJRdWVyeX07YCwgX19zcHJlYWRWYWx1ZXMoeyByYXc6IHRydWUgfSwgb3B0aW9ucykpO1xuICB9XG4gIGFzeW5jIHJlbW92ZUNvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBjcmVhdGVUYWJsZVNxbDtcbiAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IHRoaXMuc2hvd0NvbnN0cmFpbnQodGFibGVOYW1lLCBjb25zdHJhaW50TmFtZSk7XG4gICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzLmZpbmQoKGNvbnN0YWludCkgPT4gY29uc3RhaW50LmNvbnN0cmFpbnROYW1lID09PSBjb25zdHJhaW50TmFtZSk7XG4gICAgaWYgKCFjb25zdHJhaW50KSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlVua25vd25Db25zdHJhaW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ29uc3RyYWludCAke2NvbnN0cmFpbnROYW1lfSBvbiB0YWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgLFxuICAgICAgICBjb25zdHJhaW50OiBjb25zdHJhaW50TmFtZSxcbiAgICAgICAgdGFibGU6IHRhYmxlTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRhYmxlU3FsID0gY29uc3RyYWludC5zcWw7XG4gICAgY29uc3RyYWludC5jb25zdHJhaW50TmFtZSA9IHRoaXMucXVlcnlHZW5lcmF0b3IucXVvdGVJZGVudGlmaWVyKGNvbnN0cmFpbnQuY29uc3RyYWludE5hbWUpO1xuICAgIGxldCBjb25zdHJhaW50U25pcHBldCA9IGAsIENPTlNUUkFJTlQgJHtjb25zdHJhaW50LmNvbnN0cmFpbnROYW1lfSAke2NvbnN0cmFpbnQuY29uc3RyYWludFR5cGV9ICR7Y29uc3RyYWludC5jb25zdHJhaW50Q29uZGl0aW9ufWA7XG4gICAgaWYgKGNvbnN0cmFpbnQuY29uc3RyYWludFR5cGUgPT09IFwiRk9SRUlHTiBLRVlcIikge1xuICAgICAgY29uc3QgcmVmZXJlbmNlVGFibGVOYW1lID0gdGhpcy5xdWVyeUdlbmVyYXRvci5xdW90ZVRhYmxlKGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVOYW1lKTtcbiAgICAgIGNvbnN0cmFpbnQucmVmZXJlbmNlVGFibGVLZXlzID0gY29uc3RyYWludC5yZWZlcmVuY2VUYWJsZUtleXMubWFwKChjb2x1bW5OYW1lKSA9PiB0aGlzLnF1ZXJ5R2VuZXJhdG9yLnF1b3RlSWRlbnRpZmllcihjb2x1bW5OYW1lKSk7XG4gICAgICBjb25zdCByZWZlcmVuY2VUYWJsZUtleXMgPSBjb25zdHJhaW50LnJlZmVyZW5jZVRhYmxlS2V5cy5qb2luKFwiLCBcIik7XG4gICAgICBjb25zdHJhaW50U25pcHBldCArPSBgIFJFRkVSRU5DRVMgJHtyZWZlcmVuY2VUYWJsZU5hbWV9ICgke3JlZmVyZW5jZVRhYmxlS2V5c30pYDtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gVVBEQVRFICR7Y29uc3RyYWludC51cGRhdGVBY3Rpb259YDtcbiAgICAgIGNvbnN0cmFpbnRTbmlwcGV0ICs9IGAgT04gREVMRVRFICR7Y29uc3RyYWludC5kZWxldGVBY3Rpb259YDtcbiAgICB9XG4gICAgY3JlYXRlVGFibGVTcWwgPSBjcmVhdGVUYWJsZVNxbC5yZXBsYWNlKGNvbnN0cmFpbnRTbmlwcGV0LCBcIlwiKTtcbiAgICBjcmVhdGVUYWJsZVNxbCArPSBcIjtcIjtcbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLl9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkcywgY3JlYXRlVGFibGVTcWwpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoXCI7XCIpLmZpbHRlcigocSkgPT4gcSAhPT0gXCJcIik7XG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKVxuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyBhZGRDb25zdHJhaW50KHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkcyBtdXN0IGJlIHNwZWNpZmllZCB0aHJvdWdoIG9wdGlvbnMuZmllbGRzXCIpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMudHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uc3RyYWludCB0eXBlIG11c3QgYmUgc3BlY2lmaWVkIHRocm91Z2ggb3B0aW9ucy50eXBlXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRTbmlwcGV0ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRDb25zdHJhaW50U25pcHBldCh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlc2NyaWJlQ3JlYXRlVGFibGVTcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlc2NyaWJlQ3JlYXRlVGFibGVRdWVyeSh0YWJsZU5hbWUpO1xuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoZGVzY3JpYmVDcmVhdGVUYWJsZVNxbCwgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5TRUxFQ1QsIHJhdzogdHJ1ZSB9KSk7XG4gICAgbGV0IHNxbCA9IGNvbnN0cmFpbnRzWzBdLnNxbDtcbiAgICBjb25zdCBpbmRleCA9IHNxbC5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGNyZWF0ZVRhYmxlU3FsID0gYCR7c3FsLnN1YnN0cigwLCBpbmRleCl9LCAke2NvbnN0cmFpbnRTbmlwcGV0fSkke3NxbC5zdWJzdHIoaW5kZXggKyAxKX07YDtcbiAgICBjb25zdCBmaWVsZHMgPSBhd2FpdCB0aGlzLmRlc2NyaWJlVGFibGUodGFibGVOYW1lLCBvcHRpb25zKTtcbiAgICBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLl9hbHRlckNvbnN0cmFpbnRRdWVyeSh0YWJsZU5hbWUsIGZpZWxkcywgY3JlYXRlVGFibGVTcWwpO1xuICAgIGNvbnN0IHN1YlF1ZXJpZXMgPSBzcWwuc3BsaXQoXCI7XCIpLmZpbHRlcigocSkgPT4gcSAhPT0gXCJcIik7XG4gICAgZm9yIChjb25zdCBzdWJRdWVyeSBvZiBzdWJRdWVyaWVzKVxuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUucXVlcnkoYCR7c3ViUXVlcnl9O2AsIF9fc3ByZWFkVmFsdWVzKHsgcmF3OiB0cnVlIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBhc3luYyBnZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRhdGFiYXNlID0gdGhpcy5zZXF1ZWxpemUuY29uZmlnLmRhdGFiYXNlO1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeUdlbmVyYXRvci5nZXRGb3JlaWduS2V5c1F1ZXJ5KHRhYmxlTmFtZSwgZGF0YWJhc2UpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VxdWVsaXplLnF1ZXJ5KHF1ZXJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCgocm93KSA9PiAoe1xuICAgICAgdGFibGVOYW1lLFxuICAgICAgY29sdW1uTmFtZTogcm93LmZyb20sXG4gICAgICByZWZlcmVuY2VkVGFibGVOYW1lOiByb3cudGFibGUsXG4gICAgICByZWZlcmVuY2VkQ29sdW1uTmFtZTogcm93LnRvLFxuICAgICAgdGFibGVDYXRhbG9nOiBkYXRhYmFzZSxcbiAgICAgIHJlZmVyZW5jZWRUYWJsZUNhdGFsb2c6IGRhdGFiYXNlXG4gICAgfSkpO1xuICB9XG4gIGFzeW5jIGRyb3BBbGxUYWJsZXMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNraXAgPSBvcHRpb25zLnNraXAgfHwgW107XG4gICAgY29uc3QgdGFibGVOYW1lcyA9IGF3YWl0IHRoaXMuc2hvd0FsbFRhYmxlcyhvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcIlBSQUdNQSBmb3JlaWduX2tleXMgPSBPRkZcIiwgb3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy5fZHJvcEFsbFRhYmxlcyh0YWJsZU5hbWVzLCBza2lwLCBvcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShcIlBSQUdNQSBmb3JlaWduX2tleXMgPSBPTlwiLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucykge1xuICAgIGxldCBzY2hlbWEgPSBudWxsO1xuICAgIGxldCBzY2hlbWFEZWxpbWl0ZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc2NoZW1hID0gb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hIHx8IG51bGw7XG4gICAgICBzY2hlbWFEZWxpbWl0ZXIgPSBvcHRpb25zLnNjaGVtYURlbGltaXRlciB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRhYmxlTmFtZSA9PT0gXCJvYmplY3RcIiAmJiB0YWJsZU5hbWUgIT09IG51bGwpIHtcbiAgICAgIHNjaGVtYSA9IHRhYmxlTmFtZS5zY2hlbWE7XG4gICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICAgIH1cbiAgICBjb25zdCBzcWwgPSB0aGlzLnF1ZXJ5R2VuZXJhdG9yLmRlc2NyaWJlVGFibGVRdWVyeSh0YWJsZU5hbWUsIHNjaGVtYSwgc2NoZW1hRGVsaW1pdGVyKTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgdHlwZTogUXVlcnlUeXBlcy5ERVNDUklCRSB9KTtcbiAgICBjb25zdCBzcWxJbmRleGVzID0gdGhpcy5xdWVyeUdlbmVyYXRvci5zaG93SW5kZXhlc1F1ZXJ5KHRhYmxlTmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKF8uaXNFbXB0eShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlc2NyaXB0aW9uIGZvdW5kIGZvciBcIiR7dGFibGVOYW1lfVwiIHRhYmxlLiBDaGVjayB0aGUgdGFibGUgbmFtZSBhbmQgc2NoZW1hOyByZW1lbWJlciwgdGhleSBfYXJlXyBjYXNlIHNlbnNpdGl2ZS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ZXMgPSBhd2FpdCB0aGlzLnNlcXVlbGl6ZS5xdWVyeShzcWxJbmRleGVzLCBvcHRpb25zKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFbcHJvcF0udW5pcXVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGV4ZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBpbmRleC5maWVsZHMpIHtcbiAgICAgICAgICBpZiAoaW5kZXgudW5pcXVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRhdGFbZmllbGQuYXR0cmlidXRlXS51bmlxdWUgPSBpbmRleC51bmlxdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JlaWduS2V5cyA9IGF3YWl0IHRoaXMuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpO1xuICAgICAgZm9yIChjb25zdCBmb3JlaWduS2V5IG9mIGZvcmVpZ25LZXlzKSB7XG4gICAgICAgIGRhdGFbZm9yZWlnbktleS5jb2x1bW5OYW1lXS5yZWZlcmVuY2VzID0ge1xuICAgICAgICAgIG1vZGVsOiBmb3JlaWduS2V5LnJlZmVyZW5jZWRUYWJsZU5hbWUsXG4gICAgICAgICAga2V5OiBmb3JlaWduS2V5LnJlZmVyZW5jZWRDb2x1bW5OYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5vcmlnaW5hbCAmJiBlLm9yaWdpbmFsLmNvZGUgPT09IFwiRVJfTk9fU1VDSF9UQUJMRVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZGVzY3JpcHRpb24gZm91bmQgZm9yIFwiJHt0YWJsZU5hbWV9XCIgdGFibGUuIENoZWNrIHRoZSB0YWJsZSBuYW1lIGFuZCBzY2hlbWE7IHJlbWVtYmVyLCB0aGV5IF9hcmVfIGNhc2Ugc2Vuc2l0aXZlLmApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuU1FMaXRlUXVlcnlJbnRlcmZhY2UgPSBTUUxpdGVRdWVyeUludGVyZmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWludGVyZmFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query-interface.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/query.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ../../utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst AbstractQuery = __webpack_require__(/*! ../abstract/query */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query.js\");\nconst QueryTypes = __webpack_require__(/*! ../../query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst parserStore = __webpack_require__(/*! ../parserStore */ \"(rsc)/./node_modules/sequelize/lib/dialects/parserStore.js\")(\"sqlite\");\nconst { logger } = __webpack_require__(/*! ../../utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"sql:sqlite\");\nfunction stringifyIfBigint(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n  _collectModels(include, prefix) {\n    const ret = {};\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n    return ret;\n  }\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      return results.map((row) => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      const prefixes = this._collectModels(this.options.include);\n      results = results.map((result2) => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = { \"0\": false, \"1\": true }[result[_result.name].defaultValue];\n        }\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n        const query = this;\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n        if (!parameters)\n          parameters = [];\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n        tableNames = tableNames.filter((tableName) => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map((tableName) => new Promise((resolve2) => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n            resolve2();\n          });\n        })));\n      }\n      return executeSql();\n    }));\n  }\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map((constraintSql) => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map((column) => Utils.removeTicks(column));\n      }\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\": {\n        if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n        let fields = [];\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(\", \");\n        } else {\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \").map((columnWithTable) => columnWithTable.split(\".\")[1]);\n          }\n        }\n        const errors = [];\n        let message = \"Validation error\";\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n        }\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, (constraint) => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async (item) => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n      return item;\n    }));\n  }\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n    return \"all\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports[\"default\"] = Query;\n//# sourceMappingURL=query.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIsY0FBYyxtQkFBTyxDQUFDLGdFQUFhO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLHdGQUFtQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBbUI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsd0VBQWM7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQWdCO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsOEVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE1BQU07QUFDNUIsT0FBTztBQUNQLHVFQUF1RSx3QkFBd0I7QUFDL0YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0E7QUFDQSx1RUFBdUUsd0JBQXdCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG1CQUFtQixPQUFPLEdBQUcsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0NBQWdDO0FBQ2hFLDBCQUEwQixxRUFBcUU7QUFDL0Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx1QkFBdUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxFQUFFO0FBQzFHLHdHQUF3RyxFQUFFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkNBQTJDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLDJEQUEyRCx1REFBdUQ7QUFDbEg7QUFDQTtBQUNBLHVEQUF1RCxpQkFBaUI7QUFDeEU7QUFDQSx3REFBd0QsaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9xdWVyeS5qcz9lODFlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmNvbnN0IEFic3RyYWN0UXVlcnkgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3QvcXVlcnlcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4uLy4uL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4uLy4uL2Vycm9yc1wiKTtcbmNvbnN0IHBhcnNlclN0b3JlID0gcmVxdWlyZShcIi4uL3BhcnNlclN0b3JlXCIpKFwic3FsaXRlXCIpO1xuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBkZWJ1ZyA9IGxvZ2dlci5kZWJ1Z0NvbnRleHQoXCJzcWw6c3FsaXRlXCIpO1xuZnVuY3Rpb24gc3RyaW5naWZ5SWZCaWdpbnQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgQWJzdHJhY3RRdWVyeSB7XG4gIGdldEluc2VydElkRmllbGQoKSB7XG4gICAgcmV0dXJuIFwibGFzdElEXCI7XG4gIH1cbiAgc3RhdGljIGZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0KSB7XG4gICAgbGV0IGJpbmRQYXJhbTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBiaW5kUGFyYW0gPSB7fTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGJpbmRQYXJhbVtgJCR7aSArIDF9YF0gPSB2O1xuICAgICAgfSk7XG4gICAgICBzcWwgPSBBYnN0cmFjdFF1ZXJ5LmZvcm1hdEJpbmRQYXJhbWV0ZXJzKHNxbCwgdmFsdWVzLCBkaWFsZWN0LCB7IHNraXBWYWx1ZVJlcGxhY2U6IHRydWUgfSlbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGJpbmRQYXJhbSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHZhbHVlcykpIHtcbiAgICAgICAgICBiaW5kUGFyYW1bYCQke2t9YF0gPSB2YWx1ZXNba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNxbCA9IEFic3RyYWN0UXVlcnkuZm9ybWF0QmluZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIGRpYWxlY3QsIHsgc2tpcFZhbHVlUmVwbGFjZTogdHJ1ZSB9KVswXTtcbiAgICB9XG4gICAgcmV0dXJuIFtzcWwsIGJpbmRQYXJhbV07XG4gIH1cbiAgX2NvbGxlY3RNb2RlbHMoaW5jbHVkZSwgcHJlZml4KSB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgX2luY2x1ZGUgb2YgaW5jbHVkZSkge1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAoIXByZWZpeCkge1xuICAgICAgICAgIGtleSA9IF9pbmNsdWRlLmFzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IGAke3ByZWZpeH0uJHtfaW5jbHVkZS5hc31gO1xuICAgICAgICB9XG4gICAgICAgIHJldFtrZXldID0gX2luY2x1ZGUubW9kZWw7XG4gICAgICAgIGlmIChfaW5jbHVkZS5pbmNsdWRlKSB7XG4gICAgICAgICAgXy5tZXJnZShyZXQsIHRoaXMuX2NvbGxlY3RNb2RlbHMoX2luY2x1ZGUuaW5jbHVkZSwga2V5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBfaGFuZGxlUXVlcnlSZXNwb25zZShtZXRhRGF0YSwgY29sdW1uVHlwZXMsIGVyciwgcmVzdWx0cywgZXJyU3RhY2spIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnIuc3FsID0gdGhpcy5zcWw7XG4gICAgICB0aHJvdyB0aGlzLmZvcm1hdEVycm9yKGVyciwgZXJyU3RhY2spO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5pbnN0YW5jZTtcbiAgICBpZiAodGhpcy5pc0luc2VydFF1ZXJ5KHJlc3VsdHMsIG1ldGFEYXRhKSB8fCB0aGlzLmlzVXBzZXJ0UXVlcnkoKSkge1xuICAgICAgdGhpcy5oYW5kbGVJbnNlcnRRdWVyeShyZXN1bHRzLCBtZXRhRGF0YSk7XG4gICAgICBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKG1ldGFEYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiU3RhdGVtZW50XCIgJiYgdGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5hdXRvSW5jcmVtZW50QXR0cmlidXRlID09PSB0aGlzLm1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgdGhpcy5tb2RlbC5yYXdBdHRyaWJ1dGVzW3RoaXMubW9kZWwucHJpbWFyeUtleUF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICBjb25zdCBzdGFydElkID0gbWV0YURhdGFbdGhpcy5nZXRJbnNlcnRJZEZpZWxkKCldIC0gbWV0YURhdGEuY2hhbmdlcyArIDE7XG4gICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWQ7IGkgPCBzdGFydElkICsgbWV0YURhdGEuY2hhbmdlczsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IFt0aGlzLm1vZGVsLnJhd0F0dHJpYnV0ZXNbdGhpcy5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlXS5maWVsZF06IGkgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IG1ldGFEYXRhW3RoaXMuZ2V0SW5zZXJ0SWRGaWVsZCgpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dUYWJsZXNRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cy5tYXAoKHJvdykgPT4gcm93Lm5hbWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Nob3dDb25zdHJhaW50c1F1ZXJ5KCkpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdHM7XG4gICAgICBpZiAocmVzdWx0cyAmJiByZXN1bHRzWzBdICYmIHJlc3VsdHNbMF0uc3FsKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VDb25zdHJhaW50c0Zyb21TcWwocmVzdWx0c1swXS5zcWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RRdWVyeSgpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJhdykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZWxlY3RRdWVyeShyZXN1bHRzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZWZpeGVzID0gdGhpcy5fY29sbGVjdE1vZGVscyh0aGlzLm9wdGlvbnMuaW5jbHVkZSk7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5tYXAoKHJlc3VsdDIpID0+IHtcbiAgICAgICAgcmV0dXJuIF8ubWFwVmFsdWVzKHJlc3VsdDIsICh2YWx1ZSwgbmFtZSkgPT4ge1xuICAgICAgICAgIGxldCBtb2RlbDtcbiAgICAgICAgICBpZiAobmFtZS5pbmNsdWRlcyhcIi5cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RpbmQgPSBuYW1lLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICAgICAgICAgIG1vZGVsID0gcHJlZml4ZXNbbmFtZS5zdWJzdHIoMCwgbGFzdGluZCldO1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKGxhc3RpbmQgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWwgPSB0aGlzLm9wdGlvbnMubW9kZWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRhYmxlTmFtZSA9IG1vZGVsLmdldFRhYmxlTmFtZSgpLnRvU3RyaW5nKCkucmVwbGFjZSgvYC9nLCBcIlwiKTtcbiAgICAgICAgICBjb25zdCB0YWJsZVR5cGVzID0gY29sdW1uVHlwZXNbdGFibGVOYW1lXSB8fCB7fTtcbiAgICAgICAgICBpZiAodGFibGVUeXBlcyAmJiAhKG5hbWUgaW4gdGFibGVUeXBlcykpIHtcbiAgICAgICAgICAgIF8uZm9yT3duKG1vZGVsLnJhd0F0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0ga2V5ICYmIGF0dHJpYnV0ZS5maWVsZCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGUuZmllbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YWJsZVR5cGVzLCBuYW1lKSA/IHRoaXMuYXBwbHlQYXJzZXJzKHRhYmxlVHlwZXNbbmFtZV0sIHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VsZWN0UXVlcnkocmVzdWx0cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzU2hvd09yRGVzY3JpYmVRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKFwiUFJBR01BIElOREVYX0xJU1RcIikpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNob3dJbmRleGVzUXVlcnkocmVzdWx0cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcyhcIlBSQUdNQSBJTkRFWF9JTkZPXCIpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKFwiUFJBR01BIFRBQkxFX0lORk9cIikpIHtcbiAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgbGV0IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3QgX3Jlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChfcmVzdWx0LmRmbHRfdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB2b2lkIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoX3Jlc3VsdC5kZmx0X3ZhbHVlID09PSBcIk5VTExcIikge1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVmYXVsdFZhbHVlID0gX3Jlc3VsdC5kZmx0X3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtfcmVzdWx0Lm5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6IF9yZXN1bHQudHlwZSxcbiAgICAgICAgICBhbGxvd051bGw6IF9yZXN1bHQubm90bnVsbCA9PT0gMCxcbiAgICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJpbWFyeUtleTogX3Jlc3VsdC5wayAhPT0gMFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdWx0W19yZXN1bHQubmFtZV0udHlwZSA9PT0gXCJUSU5ZSU5UKDEpXCIpIHtcbiAgICAgICAgICByZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWUgPSB7IFwiMFwiOiBmYWxzZSwgXCIxXCI6IHRydWUgfVtyZXN1bHRbX3Jlc3VsdC5uYW1lXS5kZWZhdWx0VmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlID0gcmVzdWx0W19yZXN1bHQubmFtZV0uZGVmYXVsdFZhbHVlLnJlcGxhY2UoLycvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcyhcIlBSQUdNQSBmb3JlaWduX2tleXM7XCIpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3FsLmluY2x1ZGVzKFwiUFJBR01BIGZvcmVpZ25fa2V5c1wiKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLnNxbC5pbmNsdWRlcyhcIlBSQUdNQSBmb3JlaWduX2tleV9saXN0XCIpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgaWYgKFtRdWVyeVR5cGVzLkJVTEtVUERBVEUsIFF1ZXJ5VHlwZXMuQlVMS0RFTEVURV0uaW5jbHVkZXModGhpcy5vcHRpb25zLnR5cGUpKSB7XG4gICAgICByZXR1cm4gbWV0YURhdGEuY2hhbmdlcztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLlZFUlNJT04pIHtcbiAgICAgIHJldHVybiByZXN1bHRzWzBdLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gUXVlcnlUeXBlcy5SQVcpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0cywgbWV0YURhdGFdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Vwc2VydFF1ZXJ5KCkpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBudWxsXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNJbnNlcnRRdWVyeSgpKSB7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgbWV0YURhdGEuY2hhbmdlc107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgcnVuKHNxbCwgcGFyYW1ldGVycykge1xuICAgIGNvbnN0IGNvbm4gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgdGhpcy5zcWwgPSBzcWw7XG4gICAgY29uc3QgbWV0aG9kID0gdGhpcy5nZXREYXRhYmFzZU1ldGhvZCgpO1xuICAgIGNvbnN0IGNvbXBsZXRlID0gdGhpcy5fbG9nUXVlcnkoc3FsLCBkZWJ1ZywgcGFyYW1ldGVycyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGNvbm4uc2VyaWFsaXplKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtblR5cGVzID0ge307XG4gICAgICBjb25zdCBlcnJGb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgICAgY29uc3QgZXhlY3V0ZVNxbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHNxbC5zdGFydHNXaXRoKFwiLS0gXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyRXhlY3V0ZShleGVjdXRpb25FcnJvciwgcmVzdWx0cykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShxdWVyeS5faGFuZGxlUXVlcnlSZXNwb25zZSh0aGlzLCBjb2x1bW5UeXBlcywgZXhlY3V0aW9uRXJyb3IsIHJlc3VsdHMsIGVyckZvclN0YWNrLnN0YWNrKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1ldGVycylcbiAgICAgICAgICBwYXJhbWV0ZXJzID0gW107XG4gICAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QocGFyYW1ldGVycykpIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXJhbWV0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgbmV3UGFyYW1ldGVyc1tgJHtrZXl9YF0gPSBzdHJpbmdpZnlJZkJpZ2ludChwYXJhbWV0ZXJzW2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbWV0ZXJzID0gbmV3UGFyYW1ldGVycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycy5tYXAoc3RyaW5naWZ5SWZCaWdpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5bbWV0aG9kXShzcWwsIHBhcmFtZXRlcnMsIGFmdGVyRXhlY3V0ZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmdldERhdGFiYXNlTWV0aG9kKCkgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgbGV0IHRhYmxlTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudGFibGVOYW1lcykge1xuICAgICAgICAgIHRhYmxlTmFtZXMgPSB0aGlzLm9wdGlvbnMudGFibGVOYW1lcztcbiAgICAgICAgfSBlbHNlIGlmICgvRlJPTSBgKC4qPylgL2kuZXhlYyh0aGlzLnNxbCkpIHtcbiAgICAgICAgICB0YWJsZU5hbWVzLnB1c2goL0ZST00gYCguKj8pYC9pLmV4ZWModGhpcy5zcWwpWzFdKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZU5hbWVzID0gdGFibGVOYW1lcy5maWx0ZXIoKHRhYmxlTmFtZSkgPT4gISh0YWJsZU5hbWUgaW4gY29sdW1uVHlwZXMpICYmIHRhYmxlTmFtZSAhPT0gXCJzcWxpdGVfbWFzdGVyXCIpO1xuICAgICAgICBpZiAoIXRhYmxlTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4ZWN1dGVTcWwoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0YWJsZU5hbWVzLm1hcCgodGFibGVOYW1lKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZTIpID0+IHtcbiAgICAgICAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUucmVwbGFjZSgvYC9nLCBcIlwiKTtcbiAgICAgICAgICBjb2x1bW5UeXBlc1t0YWJsZU5hbWVdID0ge307XG4gICAgICAgICAgY29ubi5hbGwoYFBSQUdNQSB0YWJsZV9pbmZvKFxcYCR7dGFibGVOYW1lfVxcYClgLCAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uVHlwZXNbdGFibGVOYW1lXVtyZXN1bHQubmFtZV0gPSByZXN1bHQudHlwZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZTIoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGVjdXRlU3FsKCk7XG4gICAgfSkpO1xuICB9XG4gIHBhcnNlQ29uc3RyYWludHNGcm9tU3FsKHNxbCkge1xuICAgIGxldCBjb25zdHJhaW50cyA9IHNxbC5zcGxpdChcIkNPTlNUUkFJTlQgXCIpO1xuICAgIGxldCByZWZlcmVuY2VUYWJsZU5hbWUsIHJlZmVyZW5jZVRhYmxlS2V5cywgdXBkYXRlQWN0aW9uLCBkZWxldGVBY3Rpb247XG4gICAgY29uc3RyYWludHMuc3BsaWNlKDAsIDEpO1xuICAgIGNvbnN0cmFpbnRzID0gY29uc3RyYWludHMubWFwKChjb25zdHJhaW50U3FsKSA9PiB7XG4gICAgICBpZiAoY29uc3RyYWludFNxbC5pbmNsdWRlcyhcIlJFRkVSRU5DRVNcIikpIHtcbiAgICAgICAgdXBkYXRlQWN0aW9uID0gY29uc3RyYWludFNxbC5tYXRjaCgvT04gVVBEQVRFIChDQVNDQURFfFNFVCBOVUxMfFJFU1RSSUNUfE5PIEFDVElPTnxTRVQgREVGQVVMVCl7MX0vKTtcbiAgICAgICAgZGVsZXRlQWN0aW9uID0gY29uc3RyYWludFNxbC5tYXRjaCgvT04gREVMRVRFIChDQVNDQURFfFNFVCBOVUxMfFJFU1RSSUNUfE5PIEFDVElPTnxTRVQgREVGQVVMVCl7MX0vKTtcbiAgICAgICAgaWYgKHVwZGF0ZUFjdGlvbikge1xuICAgICAgICAgIHVwZGF0ZUFjdGlvbiA9IHVwZGF0ZUFjdGlvblsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsZXRlQWN0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlQWN0aW9uID0gZGVsZXRlQWN0aW9uWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXNSZWdleCA9IC9SRUZFUkVOQ0VTLitcXCgoPzpbXikoXSt8XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSpcXCkvO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VDb25kaXRpb25zID0gY29uc3RyYWludFNxbC5tYXRjaChyZWZlcmVuY2VzUmVnZXgpWzBdLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgcmVmZXJlbmNlVGFibGVOYW1lID0gVXRpbHMucmVtb3ZlVGlja3MocmVmZXJlbmNlQ29uZGl0aW9uc1sxXSk7XG4gICAgICAgIGxldCBjb2x1bW5OYW1lcyA9IHJlZmVyZW5jZUNvbmRpdGlvbnNbMl07XG4gICAgICAgIGNvbHVtbk5hbWVzID0gY29sdW1uTmFtZXMucmVwbGFjZSgvXFwofFxcKS9nLCBcIlwiKS5zcGxpdChcIiwgXCIpO1xuICAgICAgICByZWZlcmVuY2VUYWJsZUtleXMgPSBjb2x1bW5OYW1lcy5tYXAoKGNvbHVtbikgPT4gVXRpbHMucmVtb3ZlVGlja3MoY29sdW1uKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJhaW50Q29uZGl0aW9uID0gY29uc3RyYWludFNxbC5tYXRjaCgvXFwoKD86W14pKF0rfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqXFwpLylbMF07XG4gICAgICBjb25zdHJhaW50U3FsID0gY29uc3RyYWludFNxbC5yZXBsYWNlKC9cXCguK1xcKS8sIFwiXCIpO1xuICAgICAgY29uc3QgY29uc3RyYWludCA9IGNvbnN0cmFpbnRTcWwuc3BsaXQoXCIgXCIpO1xuICAgICAgaWYgKFtcIlBSSU1BUllcIiwgXCJGT1JFSUdOXCJdLmluY2x1ZGVzKGNvbnN0cmFpbnRbMV0pKSB7XG4gICAgICAgIGNvbnN0cmFpbnRbMV0gKz0gXCIgS0VZXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb25zdHJhaW50TmFtZTogVXRpbHMucmVtb3ZlVGlja3MoY29uc3RyYWludFswXSksXG4gICAgICAgIGNvbnN0cmFpbnRUeXBlOiBjb25zdHJhaW50WzFdLFxuICAgICAgICB1cGRhdGVBY3Rpb24sXG4gICAgICAgIGRlbGV0ZUFjdGlvbixcbiAgICAgICAgc3FsOiBzcWwucmVwbGFjZSgvXCIvZywgXCJgXCIpLFxuICAgICAgICBjb25zdHJhaW50Q29uZGl0aW9uLFxuICAgICAgICByZWZlcmVuY2VUYWJsZU5hbWUsXG4gICAgICAgIHJlZmVyZW5jZVRhYmxlS2V5c1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29uc3RyYWludHM7XG4gIH1cbiAgYXBwbHlQYXJzZXJzKHR5cGUsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGUuaW5jbHVkZXMoXCIoXCIpKSB7XG4gICAgICB0eXBlID0gdHlwZS5zdWJzdHIoMCwgdHlwZS5pbmRleE9mKFwiKFwiKSk7XG4gICAgfVxuICAgIHR5cGUgPSB0eXBlLnJlcGxhY2UoXCJVTlNJR05FRFwiLCBcIlwiKS5yZXBsYWNlKFwiWkVST0ZJTExcIiwgXCJcIik7XG4gICAgdHlwZSA9IHR5cGUudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgY29uc3QgcGFyc2UgPSBwYXJzZXJTdG9yZS5nZXQodHlwZSk7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHBhcnNlKSB7XG4gICAgICByZXR1cm4gcGFyc2UodmFsdWUsIHsgdGltZXpvbmU6IHRoaXMuc2VxdWVsaXplLm9wdGlvbnMudGltZXpvbmUgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmb3JtYXRFcnJvcihlcnIsIGVyclN0YWNrKSB7XG4gICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgY2FzZSBcIlNRTElURV9DT05TVFJBSU5UX1VOSVFVRVwiOlxuICAgICAgY2FzZSBcIlNRTElURV9DT05TVFJBSU5UX1BSSU1BUllLRVlcIjpcbiAgICAgIGNhc2UgXCJTUUxJVEVfQ09OU1RSQUlOVF9UUklHR0VSXCI6XG4gICAgICBjYXNlIFwiU1FMSVRFX0NPTlNUUkFJTlRfRk9SRUlHTktFWVwiOlxuICAgICAgY2FzZSBcIlNRTElURV9DT05TVFJBSU5UXCI6IHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiRk9SRUlHTiBLRVkgY29uc3RyYWludCBmYWlsZWRcIikpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHNlcXVlbGl6ZUVycm9ycy5Gb3JlaWduS2V5Q29uc3RyYWludEVycm9yKHtcbiAgICAgICAgICAgIHBhcmVudDogZXJyLFxuICAgICAgICAgICAgc3RhY2s6IGVyclN0YWNrXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkcyA9IFtdO1xuICAgICAgICBsZXQgbWF0Y2ggPSBlcnIubWVzc2FnZS5tYXRjaCgvY29sdW1ucyAoLio/KSBhcmUvKTtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgZmllbGRzID0gbWF0Y2hbMV0uc3BsaXQoXCIsIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IGVyci5tZXNzYWdlLm1hdGNoKC9VTklRVUUgY29uc3RyYWludCBmYWlsZWQ6ICguKikvKTtcbiAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2gubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIGZpZWxkcyA9IG1hdGNoWzFdLnNwbGl0KFwiLCBcIikubWFwKChjb2x1bW5XaXRoVGFibGUpID0+IGNvbHVtbldpdGhUYWJsZS5zcGxpdChcIi5cIilbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIlZhbGlkYXRpb24gZXJyb3JcIjtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3JzLlZhbGlkYXRpb25FcnJvckl0ZW0odGhpcy5nZXRVbmlxdWVDb25zdHJhaW50RXJyb3JNZXNzYWdlKGZpZWxkKSwgXCJ1bmlxdWUgdmlvbGF0aW9uXCIsIGZpZWxkLCB0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2VbZmllbGRdLCB0aGlzLmluc3RhbmNlLCBcIm5vdF91bmlxdWVcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgXy5mb3JPd24odGhpcy5tb2RlbC51bmlxdWVLZXlzLCAoY29uc3RyYWludCkgPT4ge1xuICAgICAgICAgICAgaWYgKF8uaXNFcXVhbChjb25zdHJhaW50LmZpZWxkcywgZmllbGRzKSAmJiAhIWNvbnN0cmFpbnQubXNnKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBjb25zdHJhaW50Lm1zZztcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlVuaXF1ZUNvbnN0cmFpbnRFcnJvcih7IG1lc3NhZ2UsIGVycm9ycywgcGFyZW50OiBlcnIsIGZpZWxkcywgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcIlNRTElURV9CVVNZXCI6XG4gICAgICAgIHJldHVybiBuZXcgc2VxdWVsaXplRXJyb3JzLlRpbWVvdXRFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBzZXF1ZWxpemVFcnJvcnMuRGF0YWJhc2VFcnJvcihlcnIsIHsgc3RhY2s6IGVyclN0YWNrIH0pO1xuICAgIH1cbiAgfVxuICBhc3luYyBoYW5kbGVTaG93SW5kZXhlc1F1ZXJ5KGRhdGEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZGF0YS5yZXZlcnNlKCkubWFwKGFzeW5jIChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmZpZWxkcyA9IFtdO1xuICAgICAgaXRlbS5wcmltYXJ5ID0gZmFsc2U7XG4gICAgICBpdGVtLnVuaXF1ZSA9ICEhaXRlbS51bmlxdWU7XG4gICAgICBpdGVtLmNvbnN0cmFpbnROYW1lID0gaXRlbS5uYW1lO1xuICAgICAgY29uc3QgY29sdW1ucyA9IGF3YWl0IHRoaXMucnVuKGBQUkFHTUEgSU5ERVhfSU5GTyhcXGAke2l0ZW0ubmFtZX1cXGApYCk7XG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbiBvZiBjb2x1bW5zKSB7XG4gICAgICAgIGl0ZW0uZmllbGRzW2NvbHVtbi5zZXFub10gPSB7XG4gICAgICAgICAgYXR0cmlidXRlOiBjb2x1bW4ubmFtZSxcbiAgICAgICAgICBsZW5ndGg6IHZvaWQgMCxcbiAgICAgICAgICBvcmRlcjogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KSk7XG4gIH1cbiAgZ2V0RGF0YWJhc2VNZXRob2QoKSB7XG4gICAgaWYgKHRoaXMuaXNJbnNlcnRRdWVyeSgpIHx8IHRoaXMuaXNVcGRhdGVRdWVyeSgpIHx8IHRoaXMuaXNVcHNlcnRRdWVyeSgpIHx8IHRoaXMuaXNCdWxrVXBkYXRlUXVlcnkoKSB8fCB0aGlzLnNxbC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiQ1JFQVRFIFRFTVBPUkFSWSBUQUJMRVwiLnRvTG93ZXJDYXNlKCkpIHx8IHRoaXMub3B0aW9ucy50eXBlID09PSBRdWVyeVR5cGVzLkJVTEtERUxFVEUpIHtcbiAgICAgIHJldHVybiBcInJ1blwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJhbGxcIjtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcbm1vZHVsZS5leHBvcnRzLlF1ZXJ5ID0gUXVlcnk7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gUXVlcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  withSqliteForeignKeysOff: () => withSqliteForeignKeysOff\n});\nasync function withSqliteForeignKeysOff(sequelize, options, cb) {\n  try {\n    await sequelize.query(\"PRAGMA foreign_keys = OFF\", options);\n    return await cb();\n  } finally {\n    await sequelize.query(\"PRAGMA foreign_keys = ON\", options);\n  }\n}\n//# sourceMappingURL=sqlite-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9kaWFsZWN0cy9zcWxpdGUvc3FsaXRlLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2RpYWxlY3RzL3NxbGl0ZS9zcWxpdGUtdXRpbHMuanM/MThlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZjogKCkgPT4gd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmXG59KTtcbmFzeW5jIGZ1bmN0aW9uIHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZihzZXF1ZWxpemUsIG9wdGlvbnMsIGNiKSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgc2VxdWVsaXplLnF1ZXJ5KFwiUFJBR01BIGZvcmVpZ25fa2V5cyA9IE9GRlwiLCBvcHRpb25zKTtcbiAgICByZXR1cm4gYXdhaXQgY2IoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBzZXF1ZWxpemUucXVlcnkoXCJQUkFHTUEgZm9yZWlnbl9rZXlzID0gT05cIiwgb3B0aW9ucyk7XG4gIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNxbGl0ZS11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/aggregate-error.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/aggregate-error.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => aggregate_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass AggregateError extends import_base_error.default {\n  constructor(errors) {\n    super();\n    __publicField(this, \"errors\");\n    this.errors = errors;\n    this.name = \"AggregateError\";\n  }\n  toString() {\n    const message = `AggregateError of:\n${this.errors.map((error) => error === this ? \"[Circular AggregateError]\" : error instanceof AggregateError ? String(error).replace(/\\n$/, \"\").replace(/^/gm, \"  \") : String(error).replace(/^/gm, \"    \").substring(2)).join(\"\\n\")}\n`;\n    return message;\n  }\n}\nvar aggregate_error_default = AggregateError;\n//# sourceMappingURL=aggregate-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYWdncmVnYXRlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9hZ2dyZWdhdGUtZXJyb3IuanM/YWNlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBhZ2dyZWdhdGVfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgQWdncmVnYXRlRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoZXJyb3JzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZXJyb3JzXCIpO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubmFtZSA9IFwiQWdncmVnYXRlRXJyb3JcIjtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYEFnZ3JlZ2F0ZUVycm9yIG9mOlxuJHt0aGlzLmVycm9ycy5tYXAoKGVycm9yKSA9PiBlcnJvciA9PT0gdGhpcyA/IFwiW0NpcmN1bGFyIEFnZ3JlZ2F0ZUVycm9yXVwiIDogZXJyb3IgaW5zdGFuY2VvZiBBZ2dyZWdhdGVFcnJvciA/IFN0cmluZyhlcnJvcikucmVwbGFjZSgvXFxuJC8sIFwiXCIpLnJlcGxhY2UoL14vZ20sIFwiICBcIikgOiBTdHJpbmcoZXJyb3IpLnJlcGxhY2UoL14vZ20sIFwiICAgIFwiKS5zdWJzdHJpbmcoMikpLmpvaW4oXCJcXG5cIil9XG5gO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG59XG52YXIgYWdncmVnYXRlX2Vycm9yX2RlZmF1bHQgPSBBZ2dyZWdhdGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFnZ3JlZ2F0ZS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/aggregate-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/association-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/association-error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => association_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass AssociationError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAssociationError\";\n  }\n}\nvar association_error_default = AssociationError;\n//# sourceMappingURL=association-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYXNzb2NpYXRpb24tZXJyb3IuanM/NjlmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gYXNzb2NpYXRpb25fZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgQXNzb2NpYXRpb25FcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVBc3NvY2lhdGlvbkVycm9yXCI7XG4gIH1cbn1cbnZhciBhc3NvY2lhdGlvbl9lcnJvcl9kZWZhdWx0ID0gQXNzb2NpYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc29jaWF0aW9uLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/association-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/base-error.js":
/*!*********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/base-error.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  default: () => base_error_default\n});\nclass BaseError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeBaseError\";\n  }\n}\nvar base_error_default = BaseError;\n//# sourceMappingURL=base-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYmFzZS1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9iYXNlLWVycm9yLmpzPzdiNTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBiYXNlX2Vycm9yX2RlZmF1bHRcbn0pO1xuY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVCYXNlRXJyb3JcIjtcbiAgfVxufVxudmFyIGJhc2VfZXJyb3JfZGVmYXVsdCA9IEJhc2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/base-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/bulk-record-error.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/bulk-record-error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => bulk_record_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass BulkRecordError extends import_base_error.default {\n  constructor(error, record) {\n    super(error.message);\n    __publicField(this, \"errors\");\n    __publicField(this, \"record\");\n    this.name = \"SequelizeBulkRecordError\";\n    this.errors = error;\n    this.record = record;\n  }\n}\nvar bulk_record_error_default = BulkRecordError;\n//# sourceMappingURL=bulk-record-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYnVsay1yZWNvcmQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvYnVsay1yZWNvcmQtZXJyb3IuanM/NmMyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBidWxrX3JlY29yZF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBCdWxrUmVjb3JkRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IoZXJyb3IsIHJlY29yZCkge1xuICAgIHN1cGVyKGVycm9yLm1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlcnJvcnNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY29yZFwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUJ1bGtSZWNvcmRFcnJvclwiO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3I7XG4gICAgdGhpcy5yZWNvcmQgPSByZWNvcmQ7XG4gIH1cbn1cbnZhciBidWxrX3JlY29yZF9lcnJvcl9kZWZhdWx0ID0gQnVsa1JlY29yZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVsay1yZWNvcmQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/bulk-record-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection-error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => connection_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass ConnectionError extends import_base_error.default {\n  constructor(parent) {\n    super(parent ? parent.message : \"\");\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    this.name = \"SequelizeConnectionError\";\n    this.parent = parent;\n    this.original = parent;\n  }\n}\nvar connection_error_default = ConnectionError;\n//# sourceMappingURL=connection-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uLWVycm9yLmpzP2NmN2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gY29ubmVjdGlvbl9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50ID8gcGFyZW50Lm1lc3NhZ2UgOiBcIlwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFyZW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvcmlnaW5hbFwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUNvbm5lY3Rpb25FcnJvclwiO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMub3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH1cbn1cbnZhciBjb25uZWN0aW9uX2Vycm9yX2RlZmF1bHQgPSBDb25uZWN0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/access-denied-error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/access-denied-error.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => access_denied_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass AccessDeniedError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeAccessDeniedError\";\n  }\n}\nvar access_denied_error_default = AccessDeniedError;\n//# sourceMappingURL=access-denied-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9hY2Nlc3MtZGVuaWVkLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUNBQXlDLG1CQUFPLENBQUMsMEZBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9jb25uZWN0aW9uL2FjY2Vzcy1kZW5pZWQtZXJyb3IuanM/ODNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gYWNjZXNzX2RlbmllZF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgQWNjZXNzRGVuaWVkRXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUFjY2Vzc0RlbmllZEVycm9yXCI7XG4gIH1cbn1cbnZhciBhY2Nlc3NfZGVuaWVkX2Vycm9yX2RlZmF1bHQgPSBBY2Nlc3NEZW5pZWRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFjY2Vzcy1kZW5pZWQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/access-denied-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_acquire_timeout_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionAcquireTimeoutError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionAcquireTimeoutError\";\n  }\n}\nvar connection_acquire_timeout_error_default = ConnectionAcquireTimeoutError;\n//# sourceMappingURL=connection-acquire-timeout-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLDBGQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvci5qcz9lYTczIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBjb25uZWN0aW9uX2FjcXVpcmVfdGltZW91dF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUNvbm5lY3Rpb25BY3F1aXJlVGltZW91dEVycm9yXCI7XG4gIH1cbn1cbnZhciBjb25uZWN0aW9uX2FjcXVpcmVfdGltZW91dF9lcnJvcl9kZWZhdWx0ID0gQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/connection-refused-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-refused-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_refused_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionRefusedError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionRefusedError\";\n  }\n}\nvar connection_refused_error_default = ConnectionRefusedError;\n//# sourceMappingURL=connection-refused-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yLmpzP2FhOWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGNvbm5lY3Rpb25fcmVmdXNlZF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgQ29ubmVjdGlvblJlZnVzZWRFcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplQ29ubmVjdGlvblJlZnVzZWRFcnJvclwiO1xuICB9XG59XG52YXIgY29ubmVjdGlvbl9yZWZ1c2VkX2Vycm9yX2RlZmF1bHQgPSBDb25uZWN0aW9uUmVmdXNlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGlvbi1yZWZ1c2VkLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/connection-refused-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => connection_timed_out_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass ConnectionTimedOutError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeConnectionTimedOutError\";\n  }\n}\nvar connection_timed_out_error_default = ConnectionTimedOutError;\n//# sourceMappingURL=connection-timed-out-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLDBGQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvci5qcz9hMzA1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBjb25uZWN0aW9uX3RpbWVkX291dF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgQ29ubmVjdGlvblRpbWVkT3V0RXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUNvbm5lY3Rpb25UaW1lZE91dEVycm9yXCI7XG4gIH1cbn1cbnZhciBjb25uZWN0aW9uX3RpbWVkX291dF9lcnJvcl9kZWZhdWx0ID0gQ29ubmVjdGlvblRpbWVkT3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-found-error.js":
/*!******************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-found-error.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => host_not_found_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass HostNotFoundError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeHostNotFoundError\";\n  }\n}\nvar host_not_found_error_default = HostNotFoundError;\n//# sourceMappingURL=host-not-found-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHlDQUF5QyxtQkFBTyxDQUFDLDBGQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1mb3VuZC1lcnJvci5qcz80ZWEyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBob3N0X25vdF9mb3VuZF9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgSG9zdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBpbXBvcnRfY29ubmVjdGlvbl9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIocGFyZW50KTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZUhvc3ROb3RGb3VuZEVycm9yXCI7XG4gIH1cbn1cbnZhciBob3N0X25vdF9mb3VuZF9lcnJvcl9kZWZhdWx0ID0gSG9zdE5vdEZvdW5kRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob3N0LW5vdC1mb3VuZC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-found-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => host_not_reachable_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass HostNotReachableError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeHostNotReachableError\";\n  }\n}\nvar host_not_reachable_error_default = HostNotReachableError;\n//# sourceMappingURL=host-not-reachable-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9ob3N0LW5vdC1yZWFjaGFibGUtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vaG9zdC1ub3QtcmVhY2hhYmxlLWVycm9yLmpzPzcwMGYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGhvc3Rfbm90X3JlYWNoYWJsZV9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgSG9zdE5vdFJlYWNoYWJsZUVycm9yIGV4dGVuZHMgaW1wb3J0X2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKHBhcmVudCk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVIb3N0Tm90UmVhY2hhYmxlRXJyb3JcIjtcbiAgfVxufVxudmFyIGhvc3Rfbm90X3JlYWNoYWJsZV9lcnJvcl9kZWZhdWx0ID0gSG9zdE5vdFJlYWNoYWJsZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9zdC1ub3QtcmVhY2hhYmxlLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => invalid_connection_error_default\n});\nvar import_connection_error = __toModule(__webpack_require__(/*! ../connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nclass InvalidConnectionError extends import_connection_error.default {\n  constructor(parent) {\n    super(parent);\n    this.name = \"SequelizeInvalidConnectionError\";\n  }\n}\nvar invalid_connection_error_default = InvalidConnectionError;\n//# sourceMappingURL=invalid-connection-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvY29ubmVjdGlvbi9pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2Nvbm5lY3Rpb24vaW52YWxpZC1jb25uZWN0aW9uLWVycm9yLmpzPzVjMTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGludmFsaWRfY29ubmVjdGlvbl9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2Nvbm5lY3Rpb24tZXJyb3JcIikpO1xuY2xhc3MgSW52YWxpZENvbm5lY3Rpb25FcnJvciBleHRlbmRzIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplSW52YWxpZENvbm5lY3Rpb25FcnJvclwiO1xuICB9XG59XG52YXIgaW52YWxpZF9jb25uZWN0aW9uX2Vycm9yX2RlZmF1bHQgPSBJbnZhbGlkQ29ubmVjdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52YWxpZC1jb25uZWN0aW9uLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database-error.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => database_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass DatabaseError extends import_base_error.default {\n  constructor(parent, options = {}) {\n    super(parent.message);\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    __publicField(this, \"sql\");\n    __publicField(this, \"parameters\");\n    var _a;\n    this.name = \"SequelizeDatabaseError\";\n    this.parent = parent;\n    this.original = parent;\n    this.sql = parent.sql;\n    this.parameters = (_a = parent.parameters) != null ? _a : {};\n    if (options.stack) {\n      this.stack = options.stack;\n    }\n  }\n}\nvar database_error_default = DatabaseError;\n//# sourceMappingURL=database-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UtZXJyb3IuanM/YTljMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBkYXRhYmFzZV9lcnJvcl9kZWZhdWx0XG59KTtcbnZhciBpbXBvcnRfYmFzZV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYmFzZS1lcnJvclwiKSk7XG5jbGFzcyBEYXRhYmFzZUVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIocGFyZW50Lm1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXJlbnRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9yaWdpbmFsXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzcWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhcmFtZXRlcnNcIik7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplRGF0YWJhc2VFcnJvclwiO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMub3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgdGhpcy5zcWwgPSBwYXJlbnQuc3FsO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IChfYSA9IHBhcmVudC5wYXJhbWV0ZXJzKSAhPSBudWxsID8gX2EgOiB7fTtcbiAgICBpZiAob3B0aW9ucy5zdGFjaykge1xuICAgICAgdGhpcy5zdGFjayA9IG9wdGlvbnMuc3RhY2s7XG4gICAgfVxuICB9XG59XG52YXIgZGF0YWJhc2VfZXJyb3JfZGVmYXVsdCA9IERhdGFiYXNlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhYmFzZS1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => exclusion_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nclass ExclusionConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"constraint\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"table\");\n    this.name = \"SequelizeExclusionConstraintError\";\n    this.message = options.message || options.parent.message || \"\";\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n  }\n}\nvar exclusion_constraint_error_default = ExclusionConstraintError;\n//# sourceMappingURL=exclusion-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUNBQXVDLG1CQUFPLENBQUMsc0ZBQW1CO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2RhdGFiYXNlL2V4Y2x1c2lvbi1jb25zdHJhaW50LWVycm9yLmpzP2ZhY2IiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gZXhjbHVzaW9uX2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2RhdGFiYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vZGF0YWJhc2UtZXJyb3JcIikpO1xuY2xhc3MgRXhjbHVzaW9uQ29uc3RyYWludEVycm9yIGV4dGVuZHMgaW1wb3J0X2RhdGFiYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudCB8fCB7IHNxbDogXCJcIiwgbmFtZTogXCJcIiwgbWVzc2FnZTogXCJcIiB9O1xuICAgIHN1cGVyKG9wdGlvbnMucGFyZW50LCB7IHN0YWNrOiBvcHRpb25zLnN0YWNrIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25zdHJhaW50XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmaWVsZHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhYmxlXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplRXhjbHVzaW9uQ29uc3RyYWludEVycm9yXCI7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlIHx8IG9wdGlvbnMucGFyZW50Lm1lc3NhZ2UgfHwgXCJcIjtcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSBvcHRpb25zLmNvbnN0cmFpbnQ7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnRhYmxlID0gb3B0aW9ucy50YWJsZTtcbiAgfVxufVxudmFyIGV4Y2x1c2lvbl9jb25zdHJhaW50X2Vycm9yX2RlZmF1bHQgPSBFeGNsdXNpb25Db25zdHJhaW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNsdXNpb24tY29uc3RyYWludC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js":
/*!************************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  RelationshipType: () => RelationshipType,\n  default: () => foreign_key_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nvar RelationshipType = /* @__PURE__ */ ((RelationshipType2) => {\n  RelationshipType2[\"parent\"] = \"parent\";\n  RelationshipType2[\"child\"] = \"child\";\n  return RelationshipType2;\n})(RelationshipType || {});\nclass ForeignKeyConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"table\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"value\");\n    __publicField(this, \"index\");\n    __publicField(this, \"reltype\");\n    this.name = \"SequelizeForeignKeyConstraintError\";\n    this.message = options.message || options.parent.message || \"Database Error\";\n    this.fields = options.fields;\n    this.table = options.table;\n    this.value = options.value;\n    this.index = options.index;\n    this.reltype = options.reltype;\n  }\n}\nvar foreign_key_constraint_error_default = ForeignKeyConstraintError;\n//# sourceMappingURL=foreign-key-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLHNGQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvZm9yZWlnbi1rZXktY29uc3RyYWludC1lcnJvci5qcz8zZGI4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIFJlbGF0aW9uc2hpcFR5cGU6ICgpID0+IFJlbGF0aW9uc2hpcFR5cGUsXG4gIGRlZmF1bHQ6ICgpID0+IGZvcmVpZ25fa2V5X2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2RhdGFiYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vZGF0YWJhc2UtZXJyb3JcIikpO1xudmFyIFJlbGF0aW9uc2hpcFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWxhdGlvbnNoaXBUeXBlMikgPT4ge1xuICBSZWxhdGlvbnNoaXBUeXBlMltcInBhcmVudFwiXSA9IFwicGFyZW50XCI7XG4gIFJlbGF0aW9uc2hpcFR5cGUyW1wiY2hpbGRcIl0gPSBcImNoaWxkXCI7XG4gIHJldHVybiBSZWxhdGlvbnNoaXBUeXBlMjtcbn0pKFJlbGF0aW9uc2hpcFR5cGUgfHwge30pO1xuY2xhc3MgRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvciBleHRlbmRzIGltcG9ydF9kYXRhYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6IFwiXCIsIG5hbWU6IFwiXCIsIG1lc3NhZ2U6IFwiXCIgfTtcbiAgICBzdXBlcihvcHRpb25zLnBhcmVudCwgeyBzdGFjazogb3B0aW9ucy5zdGFjayB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFibGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpZWxkc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImluZGV4XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZWx0eXBlXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLnBhcmVudC5tZXNzYWdlIHx8IFwiRGF0YWJhc2UgRXJyb3JcIjtcbiAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIHRoaXMudGFibGUgPSBvcHRpb25zLnRhYmxlO1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuICAgIHRoaXMucmVsdHlwZSA9IG9wdGlvbnMucmVsdHlwZTtcbiAgfVxufVxudmFyIGZvcmVpZ25fa2V5X2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdCA9IEZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/timeout-error.js":
/*!*********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/timeout-error.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => timeout_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nclass TimeoutError extends import_database_error.default {\n  constructor(parent, options = {}) {\n    super(parent, options);\n    this.name = \"SequelizeTimeoutError\";\n  }\n}\nvar timeout_error_default = TimeoutError;\n//# sourceMappingURL=timeout-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdGltZW91dC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLHNGQUFtQjtBQUNsRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS90aW1lb3V0LWVycm9yLmpzPzU2YjciXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IHRpbWVvdXRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2RhdGFiYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vZGF0YWJhc2UtZXJyb3JcIikpO1xuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgaW1wb3J0X2RhdGFiYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHBhcmVudCwgb3B0aW9ucyk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVUaW1lb3V0RXJyb3JcIjtcbiAgfVxufVxudmFyIHRpbWVvdXRfZXJyb3JfZGVmYXVsdCA9IFRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVvdXQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/timeout-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js":
/*!********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => unknown_constraint_error_default\n});\nvar import_database_error = __toModule(__webpack_require__(/*! ../database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nclass UnknownConstraintError extends import_database_error.default {\n  constructor(options) {\n    options = options || {};\n    options.parent = options.parent || { sql: \"\", name: \"\", message: \"\" };\n    super(options.parent, { stack: options.stack });\n    __publicField(this, \"constraint\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"table\");\n    this.name = \"SequelizeUnknownConstraintError\";\n    this.message = options.message || \"The specified constraint does not exist\";\n    this.constraint = options.constraint;\n    this.fields = options.fields;\n    this.table = options.table;\n  }\n}\nvar unknown_constraint_error_default = UnknownConstraintError;\n//# sourceMappingURL=unknown-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVDQUF1QyxtQkFBTyxDQUFDLHNGQUFtQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9kYXRhYmFzZS91bmtub3duLWNvbnN0cmFpbnQtZXJyb3IuanM/NTFjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiB1bmtub3duX2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2RhdGFiYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi4vZGF0YWJhc2UtZXJyb3JcIikpO1xuY2xhc3MgVW5rbm93bkNvbnN0cmFpbnRFcnJvciBleHRlbmRzIGltcG9ydF9kYXRhYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQgfHwgeyBzcWw6IFwiXCIsIG5hbWU6IFwiXCIsIG1lc3NhZ2U6IFwiXCIgfTtcbiAgICBzdXBlcihvcHRpb25zLnBhcmVudCwgeyBzdGFjazogb3B0aW9ucy5zdGFjayB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29uc3RyYWludFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZmllbGRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YWJsZVwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZVVua25vd25Db25zdHJhaW50RXJyb3JcIjtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgXCJUaGUgc3BlY2lmaWVkIGNvbnN0cmFpbnQgZG9lcyBub3QgZXhpc3RcIjtcbiAgICB0aGlzLmNvbnN0cmFpbnQgPSBvcHRpb25zLmNvbnN0cmFpbnQ7XG4gICAgdGhpcy5maWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnRhYmxlID0gb3B0aW9ucy50YWJsZTtcbiAgfVxufVxudmFyIHVua25vd25fY29uc3RyYWludF9lcnJvcl9kZWZhdWx0ID0gVW5rbm93bkNvbnN0cmFpbnRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVua25vd24tY29uc3RyYWludC1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/eager-loading-error.js":
/*!******************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/eager-loading-error.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => eager_loading_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass EagerLoadingError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeEagerLoadingError\";\n  }\n}\nvar eager_loading_error_default = EagerLoadingError;\n//# sourceMappingURL=eager-loading-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZWFnZXItbG9hZGluZy1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0dBQWtHO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HLHVFQUF1RSwrQ0FBK0MsSUFBSSxrQ0FBa0M7QUFDL1A7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy9lYWdlci1sb2FkaW5nLWVycm9yLmpzPzQ0NDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IGVhZ2VyX2xvYWRpbmdfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgRWFnZXJMb2FkaW5nRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplRWFnZXJMb2FkaW5nRXJyb3JcIjtcbiAgfVxufVxudmFyIGVhZ2VyX2xvYWRpbmdfZXJyb3JfZGVmYXVsdCA9IEVhZ2VyTG9hZGluZ0Vycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWFnZXItbG9hZGluZy1lcnJvci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/eager-loading-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/empty-result-error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/empty-result-error.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => empty_result_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass EmptyResultError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeEmptyResultError\";\n  }\n}\nvar empty_result_error_default = EmptyResultError;\n//# sourceMappingURL=empty-result-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvZW1wdHktcmVzdWx0LWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL2VtcHR5LXJlc3VsdC1lcnJvci5qcz9hOWRmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBlbXB0eV9yZXN1bHRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgRW1wdHlSZXN1bHRFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVFbXB0eVJlc3VsdEVycm9yXCI7XG4gIH1cbn1cbnZhciBlbXB0eV9yZXN1bHRfZXJyb3JfZGVmYXVsdCA9IEVtcHR5UmVzdWx0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS1yZXN1bHQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/empty-result-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/index.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  AccessDeniedError: () => import_access_denied_error.default,\n  AggregateError: () => import_aggregate_error.default,\n  AssociationError: () => import_association_error.default,\n  AsyncQueueError: () => import_async_queue.AsyncQueueError,\n  BaseError: () => import_base_error.default,\n  BulkRecordError: () => import_bulk_record_error.default,\n  ConnectionAcquireTimeoutError: () => import_connection_acquire_timeout_error.default,\n  ConnectionError: () => import_connection_error.default,\n  ConnectionRefusedError: () => import_connection_refused_error.default,\n  ConnectionTimedOutError: () => import_connection_timed_out_error.default,\n  DatabaseError: () => import_database_error.default,\n  EagerLoadingError: () => import_eager_loading_error.default,\n  EmptyResultError: () => import_empty_result_error.default,\n  ExclusionConstraintError: () => import_exclusion_constraint_error.default,\n  ForeignKeyConstraintError: () => import_foreign_key_constraint_error.default,\n  HostNotFoundError: () => import_host_not_found_error.default,\n  HostNotReachableError: () => import_host_not_reachable_error.default,\n  InstanceError: () => import_instance_error.default,\n  InvalidConnectionError: () => import_invalid_connection_error.default,\n  OptimisticLockError: () => import_optimistic_lock_error.default,\n  QueryError: () => import_query_error.default,\n  SequelizeScopeError: () => import_sequelize_scope_error.default,\n  TimeoutError: () => import_timeout_error.default,\n  UniqueConstraintError: () => import_unique_constraint_error.default,\n  UnknownConstraintError: () => import_unknown_constraint_error.default,\n  ValidationError: () => import_validation_error.default,\n  ValidationErrorItem: () => import_validation_error.ValidationErrorItem,\n  ValidationErrorItemOrigin: () => import_validation_error.ValidationErrorItemOrigin,\n  ValidationErrorItemType: () => import_validation_error.ValidationErrorItemType\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nvar import_database_error = __toModule(__webpack_require__(/*! ./database-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database-error.js\"));\nvar import_aggregate_error = __toModule(__webpack_require__(/*! ./aggregate-error */ \"(rsc)/./node_modules/sequelize/lib/errors/aggregate-error.js\"));\nvar import_association_error = __toModule(__webpack_require__(/*! ./association-error */ \"(rsc)/./node_modules/sequelize/lib/errors/association-error.js\"));\nvar import_bulk_record_error = __toModule(__webpack_require__(/*! ./bulk-record-error */ \"(rsc)/./node_modules/sequelize/lib/errors/bulk-record-error.js\"));\nvar import_connection_error = __toModule(__webpack_require__(/*! ./connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection-error.js\"));\nvar import_eager_loading_error = __toModule(__webpack_require__(/*! ./eager-loading-error */ \"(rsc)/./node_modules/sequelize/lib/errors/eager-loading-error.js\"));\nvar import_empty_result_error = __toModule(__webpack_require__(/*! ./empty-result-error */ \"(rsc)/./node_modules/sequelize/lib/errors/empty-result-error.js\"));\nvar import_instance_error = __toModule(__webpack_require__(/*! ./instance-error */ \"(rsc)/./node_modules/sequelize/lib/errors/instance-error.js\"));\nvar import_optimistic_lock_error = __toModule(__webpack_require__(/*! ./optimistic-lock-error */ \"(rsc)/./node_modules/sequelize/lib/errors/optimistic-lock-error.js\"));\nvar import_query_error = __toModule(__webpack_require__(/*! ./query-error */ \"(rsc)/./node_modules/sequelize/lib/errors/query-error.js\"));\nvar import_sequelize_scope_error = __toModule(__webpack_require__(/*! ./sequelize-scope-error */ \"(rsc)/./node_modules/sequelize/lib/errors/sequelize-scope-error.js\"));\nvar import_validation_error = __toModule(__webpack_require__(/*! ./validation-error */ \"(rsc)/./node_modules/sequelize/lib/errors/validation-error.js\"));\nvar import_access_denied_error = __toModule(__webpack_require__(/*! ./connection/access-denied-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/access-denied-error.js\"));\nvar import_connection_acquire_timeout_error = __toModule(__webpack_require__(/*! ./connection/connection-acquire-timeout-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/connection-acquire-timeout-error.js\"));\nvar import_connection_refused_error = __toModule(__webpack_require__(/*! ./connection/connection-refused-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/connection-refused-error.js\"));\nvar import_connection_timed_out_error = __toModule(__webpack_require__(/*! ./connection/connection-timed-out-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/connection-timed-out-error.js\"));\nvar import_host_not_found_error = __toModule(__webpack_require__(/*! ./connection/host-not-found-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-found-error.js\"));\nvar import_host_not_reachable_error = __toModule(__webpack_require__(/*! ./connection/host-not-reachable-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/host-not-reachable-error.js\"));\nvar import_invalid_connection_error = __toModule(__webpack_require__(/*! ./connection/invalid-connection-error */ \"(rsc)/./node_modules/sequelize/lib/errors/connection/invalid-connection-error.js\"));\nvar import_exclusion_constraint_error = __toModule(__webpack_require__(/*! ./database/exclusion-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/exclusion-constraint-error.js\"));\nvar import_foreign_key_constraint_error = __toModule(__webpack_require__(/*! ./database/foreign-key-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/foreign-key-constraint-error.js\"));\nvar import_timeout_error = __toModule(__webpack_require__(/*! ./database/timeout-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/timeout-error.js\"));\nvar import_unknown_constraint_error = __toModule(__webpack_require__(/*! ./database/unknown-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/database/unknown-constraint-error.js\"));\nvar import_unique_constraint_error = __toModule(__webpack_require__(/*! ./validation/unique-constraint-error */ \"(rsc)/./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js\"));\nvar import_async_queue = __toModule(__webpack_require__(/*! ../dialects/mssql/async-queue */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/async-queue.js\"));\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pELHVDQUF1QyxtQkFBTyxDQUFDLHFGQUFrQjtBQUNqRSx3Q0FBd0MsbUJBQU8sQ0FBQyx1RkFBbUI7QUFDbkUsMENBQTBDLG1CQUFPLENBQUMsMkZBQXFCO0FBQ3ZFLDBDQUEwQyxtQkFBTyxDQUFDLDJGQUFxQjtBQUN2RSx5Q0FBeUMsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDckUsNENBQTRDLG1CQUFPLENBQUMsK0ZBQXVCO0FBQzNFLDJDQUEyQyxtQkFBTyxDQUFDLDZGQUFzQjtBQUN6RSx1Q0FBdUMsbUJBQU8sQ0FBQyxxRkFBa0I7QUFDakUsOENBQThDLG1CQUFPLENBQUMsbUdBQXlCO0FBQy9FLG9DQUFvQyxtQkFBTyxDQUFDLCtFQUFlO0FBQzNELDhDQUE4QyxtQkFBTyxDQUFDLG1HQUF5QjtBQUMvRSx5Q0FBeUMsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDckUsNENBQTRDLG1CQUFPLENBQUMscUhBQWtDO0FBQ3RGLHlEQUF5RCxtQkFBTyxDQUFDLCtJQUErQztBQUNoSCxpREFBaUQsbUJBQU8sQ0FBQywrSEFBdUM7QUFDaEcsbURBQW1ELG1CQUFPLENBQUMsbUlBQXlDO0FBQ3BHLDZDQUE2QyxtQkFBTyxDQUFDLHVIQUFtQztBQUN4RixpREFBaUQsbUJBQU8sQ0FBQywrSEFBdUM7QUFDaEcsaURBQWlELG1CQUFPLENBQUMsK0hBQXVDO0FBQ2hHLG1EQUFtRCxtQkFBTyxDQUFDLCtIQUF1QztBQUNsRyxxREFBcUQsbUJBQU8sQ0FBQyxtSUFBeUM7QUFDdEcsc0NBQXNDLG1CQUFPLENBQUMscUdBQTBCO0FBQ3hFLGlEQUFpRCxtQkFBTyxDQUFDLDJIQUFxQztBQUM5RixnREFBZ0QsbUJBQU8sQ0FBQyw2SEFBc0M7QUFDOUYsb0NBQW9DLG1CQUFPLENBQUMsdUdBQStCO0FBQzNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5kZXguanM/M2RkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgQWNjZXNzRGVuaWVkRXJyb3I6ICgpID0+IGltcG9ydF9hY2Nlc3NfZGVuaWVkX2Vycm9yLmRlZmF1bHQsXG4gIEFnZ3JlZ2F0ZUVycm9yOiAoKSA9PiBpbXBvcnRfYWdncmVnYXRlX2Vycm9yLmRlZmF1bHQsXG4gIEFzc29jaWF0aW9uRXJyb3I6ICgpID0+IGltcG9ydF9hc3NvY2lhdGlvbl9lcnJvci5kZWZhdWx0LFxuICBBc3luY1F1ZXVlRXJyb3I6ICgpID0+IGltcG9ydF9hc3luY19xdWV1ZS5Bc3luY1F1ZXVlRXJyb3IsXG4gIEJhc2VFcnJvcjogKCkgPT4gaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCxcbiAgQnVsa1JlY29yZEVycm9yOiAoKSA9PiBpbXBvcnRfYnVsa19yZWNvcmRfZXJyb3IuZGVmYXVsdCxcbiAgQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3I6ICgpID0+IGltcG9ydF9jb25uZWN0aW9uX2FjcXVpcmVfdGltZW91dF9lcnJvci5kZWZhdWx0LFxuICBDb25uZWN0aW9uRXJyb3I6ICgpID0+IGltcG9ydF9jb25uZWN0aW9uX2Vycm9yLmRlZmF1bHQsXG4gIENvbm5lY3Rpb25SZWZ1c2VkRXJyb3I6ICgpID0+IGltcG9ydF9jb25uZWN0aW9uX3JlZnVzZWRfZXJyb3IuZGVmYXVsdCxcbiAgQ29ubmVjdGlvblRpbWVkT3V0RXJyb3I6ICgpID0+IGltcG9ydF9jb25uZWN0aW9uX3RpbWVkX291dF9lcnJvci5kZWZhdWx0LFxuICBEYXRhYmFzZUVycm9yOiAoKSA9PiBpbXBvcnRfZGF0YWJhc2VfZXJyb3IuZGVmYXVsdCxcbiAgRWFnZXJMb2FkaW5nRXJyb3I6ICgpID0+IGltcG9ydF9lYWdlcl9sb2FkaW5nX2Vycm9yLmRlZmF1bHQsXG4gIEVtcHR5UmVzdWx0RXJyb3I6ICgpID0+IGltcG9ydF9lbXB0eV9yZXN1bHRfZXJyb3IuZGVmYXVsdCxcbiAgRXhjbHVzaW9uQ29uc3RyYWludEVycm9yOiAoKSA9PiBpbXBvcnRfZXhjbHVzaW9uX2NvbnN0cmFpbnRfZXJyb3IuZGVmYXVsdCxcbiAgRm9yZWlnbktleUNvbnN0cmFpbnRFcnJvcjogKCkgPT4gaW1wb3J0X2ZvcmVpZ25fa2V5X2NvbnN0cmFpbnRfZXJyb3IuZGVmYXVsdCxcbiAgSG9zdE5vdEZvdW5kRXJyb3I6ICgpID0+IGltcG9ydF9ob3N0X25vdF9mb3VuZF9lcnJvci5kZWZhdWx0LFxuICBIb3N0Tm90UmVhY2hhYmxlRXJyb3I6ICgpID0+IGltcG9ydF9ob3N0X25vdF9yZWFjaGFibGVfZXJyb3IuZGVmYXVsdCxcbiAgSW5zdGFuY2VFcnJvcjogKCkgPT4gaW1wb3J0X2luc3RhbmNlX2Vycm9yLmRlZmF1bHQsXG4gIEludmFsaWRDb25uZWN0aW9uRXJyb3I6ICgpID0+IGltcG9ydF9pbnZhbGlkX2Nvbm5lY3Rpb25fZXJyb3IuZGVmYXVsdCxcbiAgT3B0aW1pc3RpY0xvY2tFcnJvcjogKCkgPT4gaW1wb3J0X29wdGltaXN0aWNfbG9ja19lcnJvci5kZWZhdWx0LFxuICBRdWVyeUVycm9yOiAoKSA9PiBpbXBvcnRfcXVlcnlfZXJyb3IuZGVmYXVsdCxcbiAgU2VxdWVsaXplU2NvcGVFcnJvcjogKCkgPT4gaW1wb3J0X3NlcXVlbGl6ZV9zY29wZV9lcnJvci5kZWZhdWx0LFxuICBUaW1lb3V0RXJyb3I6ICgpID0+IGltcG9ydF90aW1lb3V0X2Vycm9yLmRlZmF1bHQsXG4gIFVuaXF1ZUNvbnN0cmFpbnRFcnJvcjogKCkgPT4gaW1wb3J0X3VuaXF1ZV9jb25zdHJhaW50X2Vycm9yLmRlZmF1bHQsXG4gIFVua25vd25Db25zdHJhaW50RXJyb3I6ICgpID0+IGltcG9ydF91bmtub3duX2NvbnN0cmFpbnRfZXJyb3IuZGVmYXVsdCxcbiAgVmFsaWRhdGlvbkVycm9yOiAoKSA9PiBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvci5kZWZhdWx0LFxuICBWYWxpZGF0aW9uRXJyb3JJdGVtOiAoKSA9PiBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtLFxuICBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luOiAoKSA9PiBpbXBvcnRfdmFsaWRhdGlvbl9lcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luLFxuICBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTogKCkgPT4gaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbVR5cGVcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfZGF0YWJhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2RhdGFiYXNlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfYWdncmVnYXRlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9hZ2dyZWdhdGUtZXJyb3JcIikpO1xudmFyIGltcG9ydF9hc3NvY2lhdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYXNzb2NpYXRpb24tZXJyb3JcIikpO1xudmFyIGltcG9ydF9idWxrX3JlY29yZF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vYnVsay1yZWNvcmQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfZWFnZXJfbG9hZGluZ19lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZWFnZXItbG9hZGluZy1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2VtcHR5X3Jlc3VsdF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZW1wdHktcmVzdWx0LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfaW5zdGFuY2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2luc3RhbmNlLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfb3B0aW1pc3RpY19sb2NrX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9vcHRpbWlzdGljLWxvY2stZXJyb3JcIikpO1xudmFyIGltcG9ydF9xdWVyeV9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vcXVlcnktZXJyb3JcIikpO1xudmFyIGltcG9ydF9zZXF1ZWxpemVfc2NvcGVfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL3NlcXVlbGl6ZS1zY29wZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24tZXJyb3JcIikpO1xudmFyIGltcG9ydF9hY2Nlc3NfZGVuaWVkX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2FjY2Vzcy1kZW5pZWQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX2FjcXVpcmVfdGltZW91dF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9jb25uZWN0aW9uLWFjcXVpcmUtdGltZW91dC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2Nvbm5lY3Rpb25fcmVmdXNlZF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9jb25uZWN0aW9uLXJlZnVzZWQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9jb25uZWN0aW9uX3RpbWVkX291dF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9jb25uZWN0aW9uLXRpbWVkLW91dC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2hvc3Rfbm90X2ZvdW5kX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2hvc3Qtbm90LWZvdW5kLWVycm9yXCIpKTtcbnZhciBpbXBvcnRfaG9zdF9ub3RfcmVhY2hhYmxlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9jb25uZWN0aW9uL2hvc3Qtbm90LXJlYWNoYWJsZS1lcnJvclwiKSk7XG52YXIgaW1wb3J0X2ludmFsaWRfY29ubmVjdGlvbl9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vY29ubmVjdGlvbi9pbnZhbGlkLWNvbm5lY3Rpb24tZXJyb3JcIikpO1xudmFyIGltcG9ydF9leGNsdXNpb25fY29uc3RyYWludF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZGF0YWJhc2UvZXhjbHVzaW9uLWNvbnN0cmFpbnQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9mb3JlaWduX2tleV9jb25zdHJhaW50X2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9kYXRhYmFzZS9mb3JlaWduLWtleS1jb25zdHJhaW50LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfdGltZW91dF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZGF0YWJhc2UvdGltZW91dC1lcnJvclwiKSk7XG52YXIgaW1wb3J0X3Vua25vd25fY29uc3RyYWludF9lcnJvciA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4vZGF0YWJhc2UvdW5rbm93bi1jb25zdHJhaW50LWVycm9yXCIpKTtcbnZhciBpbXBvcnRfdW5pcXVlX2NvbnN0cmFpbnRfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24vdW5pcXVlLWNvbnN0cmFpbnQtZXJyb3JcIikpO1xudmFyIGltcG9ydF9hc3luY19xdWV1ZSA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL2RpYWxlY3RzL21zc3FsL2FzeW5jLXF1ZXVlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/instance-error.js":
/*!*************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/instance-error.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => instance_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass InstanceError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeInstanceError\";\n  }\n}\nvar instance_error_default = InstanceError;\n//# sourceMappingURL=instance-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5zdGFuY2UtZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvaW5zdGFuY2UtZXJyb3IuanM/NWJmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gaW5zdGFuY2VfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgSW5zdGFuY2VFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVJbnN0YW5jZUVycm9yXCI7XG4gIH1cbn1cbnZhciBpbnN0YW5jZV9lcnJvcl9kZWZhdWx0ID0gSW5zdGFuY2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3RhbmNlLWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/instance-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/optimistic-lock-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/optimistic-lock-error.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => optimistic_lock_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass OptimisticLockError extends import_base_error.default {\n  constructor(options) {\n    options = options || {};\n    options.message = options.message || `Attempting to update a stale model instance: ${options.modelName}`;\n    super(options.message);\n    __publicField(this, \"modelName\");\n    __publicField(this, \"values\");\n    __publicField(this, \"where\");\n    this.name = \"SequelizeOptimisticLockError\";\n    this.modelName = options.modelName;\n    this.values = options.values;\n    this.where = options.where;\n  }\n}\nvar optimistic_lock_error_default = OptimisticLockError;\n//# sourceMappingURL=optimistic-lock-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvb3B0aW1pc3RpYy1sb2NrLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0ksbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyxtQkFBTyxDQUFDLDZFQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RixrQkFBa0I7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvb3B0aW1pc3RpYy1sb2NrLWVycm9yLmpzP2FhMGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gb3B0aW1pc3RpY19sb2NrX2Vycm9yX2RlZmF1bHRcbn0pO1xudmFyIGltcG9ydF9iYXNlX2Vycm9yID0gX190b01vZHVsZShyZXF1aXJlKFwiLi9iYXNlLWVycm9yXCIpKTtcbmNsYXNzIE9wdGltaXN0aWNMb2NrRXJyb3IgZXh0ZW5kcyBpbXBvcnRfYmFzZV9lcnJvci5kZWZhdWx0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBgQXR0ZW1wdGluZyB0byB1cGRhdGUgYSBzdGFsZSBtb2RlbCBpbnN0YW5jZTogJHtvcHRpb25zLm1vZGVsTmFtZX1gO1xuICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vZGVsTmFtZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsdWVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3aGVyZVwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZU9wdGltaXN0aWNMb2NrRXJyb3JcIjtcbiAgICB0aGlzLm1vZGVsTmFtZSA9IG9wdGlvbnMubW9kZWxOYW1lO1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy53aGVyZSA9IG9wdGlvbnMud2hlcmU7XG4gIH1cbn1cbnZhciBvcHRpbWlzdGljX2xvY2tfZXJyb3JfZGVmYXVsdCA9IE9wdGltaXN0aWNMb2NrRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcHRpbWlzdGljLWxvY2stZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/optimistic-lock-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/query-error.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/query-error.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => query_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass QueryError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeQueryError\";\n  }\n}\nvar query_error_default = QueryError;\n//# sourceMappingURL=query-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvcXVlcnktZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvcXVlcnktZXJyb3IuanM/MDU1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gcXVlcnlfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgUXVlcnlFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVRdWVyeUVycm9yXCI7XG4gIH1cbn1cbnZhciBxdWVyeV9lcnJvcl9kZWZhdWx0ID0gUXVlcnlFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LWVycm9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/query-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/sequelize-scope-error.js":
/*!********************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/sequelize-scope-error.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  default: () => sequelize_scope_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nclass SequelizeScopeError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeScopeError\";\n  }\n}\nvar sequelize_scope_error_default = SequelizeScopeError;\n//# sourceMappingURL=sequelize-scope-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvc2VxdWVsaXplLXNjb3BlLWVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLG1CQUFPLENBQUMsNkVBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL3NlcXVlbGl6ZS1zY29wZS1lcnJvci5qcz9lYzc4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBzZXF1ZWxpemVfc2NvcGVfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xuY2xhc3MgU2VxdWVsaXplU2NvcGVFcnJvciBleHRlbmRzIGltcG9ydF9iYXNlX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTZXF1ZWxpemVTY29wZUVycm9yXCI7XG4gIH1cbn1cbnZhciBzZXF1ZWxpemVfc2NvcGVfZXJyb3JfZGVmYXVsdCA9IFNlcXVlbGl6ZVNjb3BlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZWxpemUtc2NvcGUtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/sequelize-scope-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/validation-error.js":
/*!***************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation-error.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  ValidationErrorItem: () => ValidationErrorItem,\n  ValidationErrorItemOrigin: () => ValidationErrorItemOrigin,\n  ValidationErrorItemType: () => ValidationErrorItemType,\n  default: () => validation_error_default\n});\nvar import_base_error = __toModule(__webpack_require__(/*! ./base-error */ \"(rsc)/./node_modules/sequelize/lib/errors/base-error.js\"));\nvar ValidationErrorItemType = /* @__PURE__ */ ((ValidationErrorItemType2) => {\n  ValidationErrorItemType2[\"notnull violation\"] = \"CORE\";\n  ValidationErrorItemType2[\"string violation\"] = \"CORE\";\n  ValidationErrorItemType2[\"unique violation\"] = \"DB\";\n  ValidationErrorItemType2[\"validation error\"] = \"FUNCTION\";\n  return ValidationErrorItemType2;\n})(ValidationErrorItemType || {});\nvar ValidationErrorItemOrigin = /* @__PURE__ */ ((ValidationErrorItemOrigin2) => {\n  ValidationErrorItemOrigin2[\"CORE\"] = \"CORE\";\n  ValidationErrorItemOrigin2[\"DB\"] = \"DB\";\n  ValidationErrorItemOrigin2[\"FUNCTION\"] = \"FUNCTION\";\n  return ValidationErrorItemOrigin2;\n})(ValidationErrorItemOrigin || {});\nclass ValidationErrorItem {\n  constructor(message, type, path, value, instance, validatorKey, fnName, fnArgs) {\n    __publicField(this, \"message\");\n    __publicField(this, \"type\");\n    __publicField(this, \"path\");\n    __publicField(this, \"value\");\n    __publicField(this, \"origin\");\n    __publicField(this, \"instance\");\n    __publicField(this, \"validatorKey\");\n    __publicField(this, \"validatorName\");\n    __publicField(this, \"validatorArgs\");\n    this.message = message || \"\";\n    this.type = null;\n    this.path = path || null;\n    this.value = value !== void 0 ? value : null;\n    this.origin = null;\n    this.instance = instance || null;\n    this.validatorKey = validatorKey || null;\n    this.validatorName = fnName || null;\n    this.validatorArgs = fnArgs || [];\n    if (type) {\n      if (this.isValidationErrorItemOrigin(type)) {\n        this.origin = type;\n      } else {\n        const lowercaseType = this.normalizeString(type);\n        const realType = ValidationErrorItemType[lowercaseType];\n        if (realType && ValidationErrorItemOrigin[realType]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    }\n  }\n  isValidationErrorItemOrigin(origin) {\n    return ValidationErrorItemOrigin[origin] !== void 0;\n  }\n  normalizeString(str) {\n    return str.toLowerCase().trim();\n  }\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === void 0 || !!useTypeAsNS;\n    const NSSep = NSSeparator === void 0 ? \".\" : NSSeparator;\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItemOrigin[type];\n    if (useNS && (typeof NSSep !== \"string\" || !NSSep.length)) {\n      throw new Error(\"Invalid namespace separator given, must be a non-empty string\");\n    }\n    if (!(typeof key === \"string\" && key.length)) {\n      return \"\";\n    }\n    return (useNS ? [this.origin, key].join(NSSep) : key).toLowerCase().trim();\n  }\n}\n__publicField(ValidationErrorItem, \"TypeStringMap\", ValidationErrorItemType);\n__publicField(ValidationErrorItem, \"Origins\", ValidationErrorItemOrigin);\nclass ValidationError extends import_base_error.default {\n  constructor(message, errors, options = {}) {\n    super(message);\n    __publicField(this, \"errors\");\n    this.name = \"SequelizeValidationError\";\n    this.message = \"Validation Error\";\n    this.errors = errors || [];\n    if (message) {\n      this.message = message;\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map((err) => `${err.type || err.origin}: ${err.message}`).join(\",\\n\");\n    }\n    if (options.stack) {\n      this.stack = options.stack;\n    }\n  }\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\nvar validation_error_default = ValidationError;\n//# sourceMappingURL=validation-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsbUJBQU8sQ0FBQyw2RUFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQ0FBaUM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saURBQWlELHVCQUF1QixJQUFJLFlBQVk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvZXJyb3JzL3ZhbGlkYXRpb24tZXJyb3IuanM/NzM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgX19tYXJrQXNNb2R1bGUodGFyZ2V0KTtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZHVsZTIsIGRlc2MpID0+IHtcbiAgaWYgKG1vZHVsZTIgJiYgdHlwZW9mIG1vZHVsZTIgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG1vZHVsZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhtb2R1bGUyKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodGFyZ2V0LCBrZXkpICYmIGtleSAhPT0gXCJkZWZhdWx0XCIpXG4gICAgICAgIF9fZGVmUHJvcCh0YXJnZXQsIGtleSwgeyBnZXQ6ICgpID0+IG1vZHVsZTJba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhtb2R1bGUyLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG52YXIgX190b01vZHVsZSA9IChtb2R1bGUyKSA9PiB7XG4gIHJldHVybiBfX3JlRXhwb3J0KF9fbWFya0FzTW9kdWxlKF9fZGVmUHJvcChtb2R1bGUyICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kdWxlMikpIDoge30sIFwiZGVmYXVsdFwiLCBtb2R1bGUyICYmIG1vZHVsZTIuX19lc01vZHVsZSAmJiBcImRlZmF1bHRcIiBpbiBtb2R1bGUyID8geyBnZXQ6ICgpID0+IG1vZHVsZTIuZGVmYXVsdCwgZW51bWVyYWJsZTogdHJ1ZSB9IDogeyB2YWx1ZTogbW9kdWxlMiwgZW51bWVyYWJsZTogdHJ1ZSB9KSksIG1vZHVsZTIpO1xufTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBWYWxpZGF0aW9uRXJyb3JJdGVtOiAoKSA9PiBWYWxpZGF0aW9uRXJyb3JJdGVtLFxuICBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luOiAoKSA9PiBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luLFxuICBWYWxpZGF0aW9uRXJyb3JJdGVtVHlwZTogKCkgPT4gVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUsXG4gIGRlZmF1bHQ6ICgpID0+IHZhbGlkYXRpb25fZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X2Jhc2VfZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuL2Jhc2UtZXJyb3JcIikpO1xudmFyIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlID0gLyogQF9fUFVSRV9fICovICgoVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUyKSA9PiB7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlMltcIm5vdG51bGwgdmlvbGF0aW9uXCJdID0gXCJDT1JFXCI7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlMltcInN0cmluZyB2aW9sYXRpb25cIl0gPSBcIkNPUkVcIjtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUyW1widW5pcXVlIHZpb2xhdGlvblwiXSA9IFwiREJcIjtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUyW1widmFsaWRhdGlvbiBlcnJvclwiXSA9IFwiRlVOQ1RJT05cIjtcbiAgcmV0dXJuIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlMjtcbn0pKFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlIHx8IHt9KTtcbnZhciBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luID0gLyogQF9fUFVSRV9fICovICgoVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjIpID0+IHtcbiAgVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbjJbXCJDT1JFXCJdID0gXCJDT1JFXCI7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4yW1wiREJcIl0gPSBcIkRCXCI7XG4gIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4yW1wiRlVOQ1RJT05cIl0gPSBcIkZVTkNUSU9OXCI7XG4gIHJldHVybiBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luMjtcbn0pKFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4gfHwge30pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9ySXRlbSB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHR5cGUsIHBhdGgsIHZhbHVlLCBpbnN0YW5jZSwgdmFsaWRhdG9yS2V5LCBmbk5hbWUsIGZuQXJncykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtZXNzYWdlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0eXBlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwYXRoXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2YWx1ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3JpZ2luXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbnN0YW5jZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidmFsaWRhdG9yS2V5XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2YWxpZGF0b3JOYW1lXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2YWxpZGF0b3JBcmdzXCIpO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgXCJcIjtcbiAgICB0aGlzLnR5cGUgPSBudWxsO1xuICAgIHRoaXMucGF0aCA9IHBhdGggfHwgbnVsbDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogbnVsbDtcbiAgICB0aGlzLm9yaWdpbiA9IG51bGw7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgdGhpcy52YWxpZGF0b3JLZXkgPSB2YWxpZGF0b3JLZXkgfHwgbnVsbDtcbiAgICB0aGlzLnZhbGlkYXRvck5hbWUgPSBmbk5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLnZhbGlkYXRvckFyZ3MgPSBmbkFyZ3MgfHwgW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRhdGlvbkVycm9ySXRlbU9yaWdpbih0eXBlKSkge1xuICAgICAgICB0aGlzLm9yaWdpbiA9IHR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VUeXBlID0gdGhpcy5ub3JtYWxpemVTdHJpbmcodHlwZSk7XG4gICAgICAgIGNvbnN0IHJlYWxUeXBlID0gVmFsaWRhdGlvbkVycm9ySXRlbVR5cGVbbG93ZXJjYXNlVHlwZV07XG4gICAgICAgIGlmIChyZWFsVHlwZSAmJiBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luW3JlYWxUeXBlXSkge1xuICAgICAgICAgIHRoaXMub3JpZ2luID0gcmVhbFR5cGU7XG4gICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc1ZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4ob3JpZ2luKSB7XG4gICAgcmV0dXJuIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW5bb3JpZ2luXSAhPT0gdm9pZCAwO1xuICB9XG4gIG5vcm1hbGl6ZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICB9XG4gIGdldFZhbGlkYXRvcktleSh1c2VUeXBlQXNOUywgTlNTZXBhcmF0b3IpIHtcbiAgICBjb25zdCB1c2VUQU5TID0gdXNlVHlwZUFzTlMgPT09IHZvaWQgMCB8fCAhIXVzZVR5cGVBc05TO1xuICAgIGNvbnN0IE5TU2VwID0gTlNTZXBhcmF0b3IgPT09IHZvaWQgMCA/IFwiLlwiIDogTlNTZXBhcmF0b3I7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMub3JpZ2luO1xuICAgIGNvbnN0IGtleSA9IHRoaXMudmFsaWRhdG9yS2V5IHx8IHRoaXMudmFsaWRhdG9yTmFtZTtcbiAgICBjb25zdCB1c2VOUyA9IHVzZVRBTlMgJiYgdHlwZSAmJiBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luW3R5cGVdO1xuICAgIGlmICh1c2VOUyAmJiAodHlwZW9mIE5TU2VwICE9PSBcInN0cmluZ1wiIHx8ICFOU1NlcC5sZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5hbWVzcGFjZSBzZXBhcmF0b3IgZ2l2ZW4sIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAoISh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmV0dXJuICh1c2VOUyA/IFt0aGlzLm9yaWdpbiwga2V5XS5qb2luKE5TU2VwKSA6IGtleSkudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIH1cbn1cbl9fcHVibGljRmllbGQoVmFsaWRhdGlvbkVycm9ySXRlbSwgXCJUeXBlU3RyaW5nTWFwXCIsIFZhbGlkYXRpb25FcnJvckl0ZW1UeXBlKTtcbl9fcHVibGljRmllbGQoVmFsaWRhdGlvbkVycm9ySXRlbSwgXCJPcmlnaW5zXCIsIFZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW4pO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgaW1wb3J0X2Jhc2VfZXJyb3IuZGVmYXVsdCB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9ycywgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVycm9yc1wiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNlcXVlbGl6ZVZhbGlkYXRpb25FcnJvclwiO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiVmFsaWRhdGlvbiBFcnJvclwiO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMCAmJiB0aGlzLmVycm9yc1swXS5tZXNzYWdlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmVycm9ycy5tYXAoKGVycikgPT4gYCR7ZXJyLnR5cGUgfHwgZXJyLm9yaWdpbn06ICR7ZXJyLm1lc3NhZ2V9YCkuam9pbihcIixcXG5cIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnN0YWNrKSB7XG4gICAgICB0aGlzLnN0YWNrID0gb3B0aW9ucy5zdGFjaztcbiAgICB9XG4gIH1cbiAgZ2V0KHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvcnMucmVkdWNlKChyZWR1Y2VkLCBlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yLnBhdGggPT09IHBhdGgpIHtcbiAgICAgICAgcmVkdWNlZC5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWR1Y2VkO1xuICAgIH0sIFtdKTtcbiAgfVxufVxudmFyIHZhbGlkYXRpb25fZXJyb3JfZGVmYXVsdCA9IFZhbGlkYXRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb24tZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/validation-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  default: () => unique_constraint_error_default\n});\nvar import_validation_error = __toModule(__webpack_require__(/*! ../validation-error */ \"(rsc)/./node_modules/sequelize/lib/errors/validation-error.js\"));\nclass UniqueConstraintError extends import_validation_error.default {\n  constructor(options) {\n    var _a, _b, _c;\n    options = options != null ? options : {};\n    options.parent = (_a = options.parent) != null ? _a : { sql: \"\", name: \"\", message: \"\" };\n    options.message = options.message || options.parent.message || \"Validation Error\";\n    options.errors = (_b = options.errors) != null ? _b : [];\n    super(options.message, options.errors, { stack: options.stack });\n    __publicField(this, \"parent\");\n    __publicField(this, \"original\");\n    __publicField(this, \"fields\");\n    __publicField(this, \"sql\");\n    this.name = \"SequelizeUniqueConstraintError\";\n    this.fields = (_c = options.fields) != null ? _c : {};\n    this.parent = options.parent;\n    this.original = options.parent;\n    this.sql = options.parent.sql;\n  }\n}\nvar unique_constraint_error_default = UniqueConstraintError;\n//# sourceMappingURL=unique-constraint-error.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9lcnJvcnMvdmFsaWRhdGlvbi91bmlxdWUtY29uc3RyYWludC1lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrR0FBa0c7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsdUVBQXVFLCtDQUErQyxJQUFJLGtDQUFrQztBQUMvUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDZDQUE2QyxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL2Vycm9ycy92YWxpZGF0aW9uL3VuaXF1ZS1jb25zdHJhaW50LWVycm9yLmpzP2Y0MDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbl9fZXhwb3J0KGV4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gdW5pcXVlX2NvbnN0cmFpbnRfZXJyb3JfZGVmYXVsdFxufSk7XG52YXIgaW1wb3J0X3ZhbGlkYXRpb25fZXJyb3IgPSBfX3RvTW9kdWxlKHJlcXVpcmUoXCIuLi92YWxpZGF0aW9uLWVycm9yXCIpKTtcbmNsYXNzIFVuaXF1ZUNvbnN0cmFpbnRFcnJvciBleHRlbmRzIGltcG9ydF92YWxpZGF0aW9uX2Vycm9yLmRlZmF1bHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fTtcbiAgICBvcHRpb25zLnBhcmVudCA9IChfYSA9IG9wdGlvbnMucGFyZW50KSAhPSBudWxsID8gX2EgOiB7IHNxbDogXCJcIiwgbmFtZTogXCJcIiwgbWVzc2FnZTogXCJcIiB9O1xuICAgIG9wdGlvbnMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLnBhcmVudC5tZXNzYWdlIHx8IFwiVmFsaWRhdGlvbiBFcnJvclwiO1xuICAgIG9wdGlvbnMuZXJyb3JzID0gKF9iID0gb3B0aW9ucy5lcnJvcnMpICE9IG51bGwgPyBfYiA6IFtdO1xuICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSwgb3B0aW9ucy5lcnJvcnMsIHsgc3RhY2s6IG9wdGlvbnMuc3RhY2sgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBhcmVudFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib3JpZ2luYWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZpZWxkc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3FsXCIpO1xuICAgIHRoaXMubmFtZSA9IFwiU2VxdWVsaXplVW5pcXVlQ29uc3RyYWludEVycm9yXCI7XG4gICAgdGhpcy5maWVsZHMgPSAoX2MgPSBvcHRpb25zLmZpZWxkcykgIT0gbnVsbCA/IF9jIDoge307XG4gICAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICB0aGlzLm9yaWdpbmFsID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgdGhpcy5zcWwgPSBvcHRpb25zLnBhcmVudC5zcWw7XG4gIH1cbn1cbnZhciB1bmlxdWVfY29uc3RyYWludF9lcnJvcl9kZWZhdWx0ID0gVW5pcXVlQ29uc3RyYWludEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pcXVlLWNvbnN0cmFpbnQtZXJyb3IuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/errors/validation/unique-constraint-error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/hooks.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/hooks.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst debug = logger.debugContext(\"hooks\");\nconst hookTypes = {\n  beforeValidate: { params: 2 },\n  afterValidate: { params: 2 },\n  validationFailed: { params: 3 },\n  beforeCreate: { params: 2 },\n  afterCreate: { params: 2 },\n  beforeDestroy: { params: 2 },\n  afterDestroy: { params: 2 },\n  beforeRestore: { params: 2 },\n  afterRestore: { params: 2 },\n  beforeUpdate: { params: 2 },\n  afterUpdate: { params: 2 },\n  beforeSave: { params: 2, proxies: [\"beforeUpdate\", \"beforeCreate\"] },\n  afterSave: { params: 2, proxies: [\"afterUpdate\", \"afterCreate\"] },\n  beforeUpsert: { params: 2 },\n  afterUpsert: { params: 2 },\n  beforeBulkCreate: { params: 2 },\n  afterBulkCreate: { params: 2 },\n  beforeBulkDestroy: { params: 1 },\n  afterBulkDestroy: { params: 1 },\n  beforeBulkRestore: { params: 1 },\n  afterBulkRestore: { params: 1 },\n  beforeBulkUpdate: { params: 1 },\n  afterBulkUpdate: { params: 1 },\n  beforeFind: { params: 1 },\n  beforeFindAfterExpandIncludeAll: { params: 1 },\n  beforeFindAfterOptions: { params: 1 },\n  afterFind: { params: 2 },\n  beforeCount: { params: 1 },\n  beforeDefine: { params: 2, sync: true, noModel: true },\n  afterDefine: { params: 1, sync: true, noModel: true },\n  beforeInit: { params: 2, sync: true, noModel: true },\n  afterInit: { params: 1, sync: true, noModel: true },\n  beforeAssociate: { params: 2, sync: true },\n  afterAssociate: { params: 2, sync: true },\n  beforeConnect: { params: 1, noModel: true },\n  afterConnect: { params: 2, noModel: true },\n  beforeDisconnect: { params: 1, noModel: true },\n  afterDisconnect: { params: 1, noModel: true },\n  beforePoolAcquire: { params: 1, noModel: true },\n  afterPoolAcquire: { params: 2, noModel: true },\n  beforeSync: { params: 1 },\n  afterSync: { params: 1 },\n  beforeBulkSync: { params: 1 },\n  afterBulkSync: { params: 1 },\n  beforeQuery: { params: 2 },\n  afterQuery: { params: 2 }\n};\nexports.hooks = hookTypes;\nconst getProxiedHooks = (hookType) => hookTypes[hookType].proxies ? hookTypes[hookType].proxies.concat(hookType) : [hookType];\nfunction getHooks(hooked, hookType) {\n  return (hooked.options.hooks || {})[hookType] || [];\n}\nconst Hooks = {\n  _setupHooks(hooks) {\n    this.options.hooks = {};\n    _.map(hooks || {}, (hooksArray, hookName) => {\n      if (!Array.isArray(hooksArray))\n        hooksArray = [hooksArray];\n      hooksArray.forEach((hookFn) => this.addHook(hookName, hookFn));\n    });\n  },\n  async runHooks(hooks, ...hookArgs) {\n    if (!hooks)\n      throw new Error(\"runHooks requires at least 1 argument\");\n    let hookType;\n    if (typeof hooks === \"string\") {\n      hookType = hooks;\n      hooks = getHooks(this, hookType);\n      if (this.sequelize) {\n        hooks = hooks.concat(getHooks(this.sequelize, hookType));\n      }\n    }\n    if (!Array.isArray(hooks)) {\n      hooks = [hooks];\n    }\n    if (hookTypes[hookType] && hookTypes[hookType].sync) {\n      for (let hook of hooks) {\n        if (typeof hook === \"object\") {\n          hook = hook.fn;\n        }\n        debug(`running hook(sync) ${hookType}`);\n        hook.apply(this, hookArgs);\n      }\n      return;\n    }\n    for (let hook of hooks) {\n      if (typeof hook === \"object\") {\n        hook = hook.fn;\n      }\n      debug(`running hook ${hookType}`);\n      await hook.apply(this, hookArgs);\n    }\n  },\n  addHook(hookType, name, fn) {\n    if (typeof name === \"function\") {\n      fn = name;\n      name = null;\n    }\n    debug(`adding hook ${hookType}`);\n    hookType = getProxiedHooks(hookType);\n    hookType.forEach((type) => {\n      const hooks = getHooks(this, type);\n      hooks.push(name ? { name, fn } : fn);\n      this.options.hooks[type] = hooks;\n    });\n    return this;\n  },\n  removeHook(hookType, name) {\n    const isReference = typeof name === \"function\" ? true : false;\n    if (!this.hasHook(hookType)) {\n      return this;\n    }\n    debug(`removing hook ${hookType}`);\n    hookType = getProxiedHooks(hookType);\n    for (const type of hookType) {\n      this.options.hooks[type] = this.options.hooks[type].filter((hook) => {\n        if (isReference && typeof hook === \"function\") {\n          return hook !== name;\n        }\n        if (!isReference && typeof hook === \"object\") {\n          return hook.name !== name;\n        }\n        return true;\n      });\n    }\n    return this;\n  },\n  hasHook(hookType) {\n    return this.options.hooks[hookType] && !!this.options.hooks[hookType].length;\n  }\n};\nHooks.hasHooks = Hooks.hasHook;\nfunction applyTo(target, isModel = false) {\n  _.mixin(target, Hooks);\n  for (const hook of Object.keys(hookTypes)) {\n    if (isModel && hookTypes[hook].noModel) {\n      continue;\n    }\n    target[hook] = function(name, callback) {\n      return this.addHook(hook, name, callback);\n    };\n  }\n}\nexports.applyTo = applyTo;\n//# sourceMappingURL=hooks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9ob29rcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDBFQUFnQjtBQUMzQztBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0IsbUJBQW1CLFdBQVc7QUFDOUIsc0JBQXNCLFdBQVc7QUFDakMsa0JBQWtCLFdBQVc7QUFDN0IsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLFdBQVc7QUFDOUIsa0JBQWtCLFdBQVc7QUFDN0IsbUJBQW1CLFdBQVc7QUFDOUIsa0JBQWtCLFdBQVc7QUFDN0Isa0JBQWtCLFdBQVc7QUFDN0IsaUJBQWlCLFdBQVc7QUFDNUIsZ0JBQWdCLHNEQUFzRDtBQUN0RSxlQUFlLG9EQUFvRDtBQUNuRSxrQkFBa0IsV0FBVztBQUM3QixpQkFBaUIsV0FBVztBQUM1QixzQkFBc0IsV0FBVztBQUNqQyxxQkFBcUIsV0FBVztBQUNoQyx1QkFBdUIsV0FBVztBQUNsQyxzQkFBc0IsV0FBVztBQUNqQyx1QkFBdUIsV0FBVztBQUNsQyxzQkFBc0IsV0FBVztBQUNqQyxzQkFBc0IsV0FBVztBQUNqQyxxQkFBcUIsV0FBVztBQUNoQyxnQkFBZ0IsV0FBVztBQUMzQixxQ0FBcUMsV0FBVztBQUNoRCw0QkFBNEIsV0FBVztBQUN2QyxlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFdBQVc7QUFDNUIsa0JBQWtCLHNDQUFzQztBQUN4RCxpQkFBaUIsc0NBQXNDO0FBQ3ZELGdCQUFnQixzQ0FBc0M7QUFDdEQsZUFBZSxzQ0FBc0M7QUFDckQscUJBQXFCLHVCQUF1QjtBQUM1QyxvQkFBb0IsdUJBQXVCO0FBQzNDLG1CQUFtQiwwQkFBMEI7QUFDN0Msa0JBQWtCLDBCQUEwQjtBQUM1QyxzQkFBc0IsMEJBQTBCO0FBQ2hELHFCQUFxQiwwQkFBMEI7QUFDL0MsdUJBQXVCLDBCQUEwQjtBQUNqRCxzQkFBc0IsMEJBQTBCO0FBQ2hELGdCQUFnQixXQUFXO0FBQzNCLGVBQWUsV0FBVztBQUMxQixvQkFBb0IsV0FBVztBQUMvQixtQkFBbUIsV0FBVztBQUM5QixpQkFBaUIsV0FBVztBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9ob29rcy5qcz8zNGNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4vdXRpbHMvbG9nZ2VyXCIpO1xuY29uc3QgZGVidWcgPSBsb2dnZXIuZGVidWdDb250ZXh0KFwiaG9va3NcIik7XG5jb25zdCBob29rVHlwZXMgPSB7XG4gIGJlZm9yZVZhbGlkYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlclZhbGlkYXRlOiB7IHBhcmFtczogMiB9LFxuICB2YWxpZGF0aW9uRmFpbGVkOiB7IHBhcmFtczogMyB9LFxuICBiZWZvcmVDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyQ3JlYXRlOiB7IHBhcmFtczogMiB9LFxuICBiZWZvcmVEZXN0cm95OiB7IHBhcmFtczogMiB9LFxuICBhZnRlckRlc3Ryb3k6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZVJlc3RvcmU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyUmVzdG9yZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlVXBkYXRlOiB7IHBhcmFtczogMiB9LFxuICBhZnRlclVwZGF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlU2F2ZTogeyBwYXJhbXM6IDIsIHByb3hpZXM6IFtcImJlZm9yZVVwZGF0ZVwiLCBcImJlZm9yZUNyZWF0ZVwiXSB9LFxuICBhZnRlclNhdmU6IHsgcGFyYW1zOiAyLCBwcm94aWVzOiBbXCJhZnRlclVwZGF0ZVwiLCBcImFmdGVyQ3JlYXRlXCJdIH0sXG4gIGJlZm9yZVVwc2VydDogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJVcHNlcnQ6IHsgcGFyYW1zOiAyIH0sXG4gIGJlZm9yZUJ1bGtDcmVhdGU6IHsgcGFyYW1zOiAyIH0sXG4gIGFmdGVyQnVsa0NyZWF0ZTogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlQnVsa0Rlc3Ryb3k6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyQnVsa0Rlc3Ryb3k6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUJ1bGtSZXN0b3JlOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtSZXN0b3JlOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVCdWxrVXBkYXRlOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtVcGRhdGU6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUZpbmQ6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUZpbmRBZnRlckV4cGFuZEluY2x1ZGVBbGw6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUZpbmRBZnRlck9wdGlvbnM6IHsgcGFyYW1zOiAxIH0sXG4gIGFmdGVyRmluZDogeyBwYXJhbXM6IDIgfSxcbiAgYmVmb3JlQ291bnQ6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZURlZmluZTogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJEZWZpbmU6IHsgcGFyYW1zOiAxLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZUluaXQ6IHsgcGFyYW1zOiAyLCBzeW5jOiB0cnVlLCBub01vZGVsOiB0cnVlIH0sXG4gIGFmdGVySW5pdDogeyBwYXJhbXM6IDEsIHN5bmM6IHRydWUsIG5vTW9kZWw6IHRydWUgfSxcbiAgYmVmb3JlQXNzb2NpYXRlOiB7IHBhcmFtczogMiwgc3luYzogdHJ1ZSB9LFxuICBhZnRlckFzc29jaWF0ZTogeyBwYXJhbXM6IDIsIHN5bmM6IHRydWUgfSxcbiAgYmVmb3JlQ29ubmVjdDogeyBwYXJhbXM6IDEsIG5vTW9kZWw6IHRydWUgfSxcbiAgYWZ0ZXJDb25uZWN0OiB7IHBhcmFtczogMiwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVEaXNjb25uZWN0OiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlckRpc2Nvbm5lY3Q6IHsgcGFyYW1zOiAxLCBub01vZGVsOiB0cnVlIH0sXG4gIGJlZm9yZVBvb2xBY3F1aXJlOiB7IHBhcmFtczogMSwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBhZnRlclBvb2xBY3F1aXJlOiB7IHBhcmFtczogMiwgbm9Nb2RlbDogdHJ1ZSB9LFxuICBiZWZvcmVTeW5jOiB7IHBhcmFtczogMSB9LFxuICBhZnRlclN5bmM6IHsgcGFyYW1zOiAxIH0sXG4gIGJlZm9yZUJ1bGtTeW5jOiB7IHBhcmFtczogMSB9LFxuICBhZnRlckJ1bGtTeW5jOiB7IHBhcmFtczogMSB9LFxuICBiZWZvcmVRdWVyeTogeyBwYXJhbXM6IDIgfSxcbiAgYWZ0ZXJRdWVyeTogeyBwYXJhbXM6IDIgfVxufTtcbmV4cG9ydHMuaG9va3MgPSBob29rVHlwZXM7XG5jb25zdCBnZXRQcm94aWVkSG9va3MgPSAoaG9va1R5cGUpID0+IGhvb2tUeXBlc1tob29rVHlwZV0ucHJveGllcyA/IGhvb2tUeXBlc1tob29rVHlwZV0ucHJveGllcy5jb25jYXQoaG9va1R5cGUpIDogW2hvb2tUeXBlXTtcbmZ1bmN0aW9uIGdldEhvb2tzKGhvb2tlZCwgaG9va1R5cGUpIHtcbiAgcmV0dXJuIChob29rZWQub3B0aW9ucy5ob29rcyB8fCB7fSlbaG9va1R5cGVdIHx8IFtdO1xufVxuY29uc3QgSG9va3MgPSB7XG4gIF9zZXR1cEhvb2tzKGhvb2tzKSB7XG4gICAgdGhpcy5vcHRpb25zLmhvb2tzID0ge307XG4gICAgXy5tYXAoaG9va3MgfHwge30sIChob29rc0FycmF5LCBob29rTmFtZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhvb2tzQXJyYXkpKVxuICAgICAgICBob29rc0FycmF5ID0gW2hvb2tzQXJyYXldO1xuICAgICAgaG9va3NBcnJheS5mb3JFYWNoKChob29rRm4pID0+IHRoaXMuYWRkSG9vayhob29rTmFtZSwgaG9va0ZuKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFzeW5jIHJ1bkhvb2tzKGhvb2tzLCAuLi5ob29rQXJncykge1xuICAgIGlmICghaG9va3MpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJydW5Ib29rcyByZXF1aXJlcyBhdCBsZWFzdCAxIGFyZ3VtZW50XCIpO1xuICAgIGxldCBob29rVHlwZTtcbiAgICBpZiAodHlwZW9mIGhvb2tzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBob29rVHlwZSA9IGhvb2tzO1xuICAgICAgaG9va3MgPSBnZXRIb29rcyh0aGlzLCBob29rVHlwZSk7XG4gICAgICBpZiAodGhpcy5zZXF1ZWxpemUpIHtcbiAgICAgICAgaG9va3MgPSBob29rcy5jb25jYXQoZ2V0SG9va3ModGhpcy5zZXF1ZWxpemUsIGhvb2tUeXBlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShob29rcykpIHtcbiAgICAgIGhvb2tzID0gW2hvb2tzXTtcbiAgICB9XG4gICAgaWYgKGhvb2tUeXBlc1tob29rVHlwZV0gJiYgaG9va1R5cGVzW2hvb2tUeXBlXS5zeW5jKSB7XG4gICAgICBmb3IgKGxldCBob29rIG9mIGhvb2tzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaG9vayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGhvb2sgPSBob29rLmZuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKGBydW5uaW5nIGhvb2soc3luYykgJHtob29rVHlwZX1gKTtcbiAgICAgICAgaG9vay5hcHBseSh0aGlzLCBob29rQXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGhvb2sgb2YgaG9va3MpIHtcbiAgICAgIGlmICh0eXBlb2YgaG9vayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBob29rID0gaG9vay5mbjtcbiAgICAgIH1cbiAgICAgIGRlYnVnKGBydW5uaW5nIGhvb2sgJHtob29rVHlwZX1gKTtcbiAgICAgIGF3YWl0IGhvb2suYXBwbHkodGhpcywgaG9va0FyZ3MpO1xuICAgIH1cbiAgfSxcbiAgYWRkSG9vayhob29rVHlwZSwgbmFtZSwgZm4pIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm4gPSBuYW1lO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuICAgIGRlYnVnKGBhZGRpbmcgaG9vayAke2hvb2tUeXBlfWApO1xuICAgIGhvb2tUeXBlID0gZ2V0UHJveGllZEhvb2tzKGhvb2tUeXBlKTtcbiAgICBob29rVHlwZS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICBjb25zdCBob29rcyA9IGdldEhvb2tzKHRoaXMsIHR5cGUpO1xuICAgICAgaG9va3MucHVzaChuYW1lID8geyBuYW1lLCBmbiB9IDogZm4pO1xuICAgICAgdGhpcy5vcHRpb25zLmhvb2tzW3R5cGVdID0gaG9va3M7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUhvb2soaG9va1R5cGUsIG5hbWUpIHtcbiAgICBjb25zdCBpc1JlZmVyZW5jZSA9IHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgaWYgKCF0aGlzLmhhc0hvb2soaG9va1R5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVidWcoYHJlbW92aW5nIGhvb2sgJHtob29rVHlwZX1gKTtcbiAgICBob29rVHlwZSA9IGdldFByb3hpZWRIb29rcyhob29rVHlwZSk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGhvb2tUeXBlKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaG9va3NbdHlwZV0gPSB0aGlzLm9wdGlvbnMuaG9va3NbdHlwZV0uZmlsdGVyKChob29rKSA9PiB7XG4gICAgICAgIGlmIChpc1JlZmVyZW5jZSAmJiB0eXBlb2YgaG9vayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGhvb2sgIT09IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZmVyZW5jZSAmJiB0eXBlb2YgaG9vayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiBob29rLm5hbWUgIT09IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGhhc0hvb2soaG9va1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhvb2tzW2hvb2tUeXBlXSAmJiAhIXRoaXMub3B0aW9ucy5ob29rc1tob29rVHlwZV0ubGVuZ3RoO1xuICB9XG59O1xuSG9va3MuaGFzSG9va3MgPSBIb29rcy5oYXNIb29rO1xuZnVuY3Rpb24gYXBwbHlUbyh0YXJnZXQsIGlzTW9kZWwgPSBmYWxzZSkge1xuICBfLm1peGluKHRhcmdldCwgSG9va3MpO1xuICBmb3IgKGNvbnN0IGhvb2sgb2YgT2JqZWN0LmtleXMoaG9va1R5cGVzKSkge1xuICAgIGlmIChpc01vZGVsICYmIGhvb2tUeXBlc1tob29rXS5ub01vZGVsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGFyZ2V0W2hvb2tdID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEhvb2soaG9vaywgbmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG4gIH1cbn1cbmV4cG9ydHMuYXBwbHlUbyA9IGFwcGx5VG87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/hooks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/index-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/index-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst IndexHints = module.exports = {\n  USE: \"USE\",\n  FORCE: \"FORCE\",\n  IGNORE: \"IGNORE\"\n};\n//# sourceMappingURL=index-hints.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC1oaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaW5kZXgtaGludHMuanM/NTdiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IEluZGV4SGludHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgVVNFOiBcIlVTRVwiLFxuICBGT1JDRTogXCJGT1JDRVwiLFxuICBJR05PUkU6IFwiSUdOT1JFXCJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1oaW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/index-hints.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = __webpack_require__(/*! ./sequelize */ \"(rsc)/./node_modules/sequelize/lib/sequelize.js\");\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDBHQUF1QztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaW5kZXguanM/ZGI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc2VxdWVsaXplXCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/instance-validator.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/instance-validator.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst sequelizeError = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst { promisify } = __webpack_require__(/*! util */ \"util\");\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = __spreadValues({\n      hooks: true\n    }, options);\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n    this.options = options;\n    this.modelInstance = modelInstance;\n    this.validator = validator;\n    this.errors = [];\n    this.inProgress = false;\n  }\n  async _validate() {\n    if (this.inProgress)\n      throw new Error(\"Validations already in progress.\");\n    this.inProgress = true;\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks(\"beforeValidate\", this.modelInstance, this.options);\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks(\"validationFailed\", this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n    await runHooks(\"afterValidate\", this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n  async _perAttributeValidators() {\n    const validators = [];\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n      const value = this.modelInstance.dataValues[field];\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        this._validateSchema(rawAttribute, field, value);\n      }\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n    return await Promise.all(validators);\n  }\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator2, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n      const valprom = this._invokeCustomValidator(validator2, validatorType).catch(() => {\n      });\n      validators.push(valprom);\n    });\n    return await Promise.all(validators);\n  }\n  async _singleAttrValidate(value, field, allowNull) {\n    if ((value === null || value === void 0) && !allowNull) {\n      return;\n    }\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n      if ([\"isUrl\", \"isURL\", \"isEmail\"].includes(validatorType)) {\n        if (typeof test === \"object\" && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n      if (typeof test === \"function\") {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n      if (value === null || value === void 0) {\n        return;\n      }\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      validatorPromise.catch(() => {\n      });\n      validators.push(validatorPromise);\n    });\n    return Promise.all(validators.map((validator2) => validator2.catch((rejection) => {\n      const isBuiltIn = !!rejection.validatorName;\n      this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n    })));\n  }\n  async _invokeCustomValidator(validator2, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n    const validatorArity = validator2.length;\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator2.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator2.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n    try {\n      return await validator2.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    const valueString = String(value);\n    if (typeof validator[validatorType] !== \"function\") {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== \"string\" && [\"isAlpha\", \"isAlphanumeric\", \"isMobilePhone\"].includes(validatorType);\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === \"isImmutable\") {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === \"isIP\") {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === void 0)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find((association2) => association2 instanceof BelongsTo && association2.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, \"notNull.msg\", `${this.modelInstance.constructor.name}.${field} cannot be null`);\n        this.errors.push(new sequelizeError.ValidationErrorItem(errMsg, \"notNull Violation\", field, value, this.modelInstance, \"is_null\"));\n      }\n    }\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(`${field} cannot be an array or an object`, \"string violation\", field, value, this.modelInstance, \"not_a_string\"));\n      }\n    }\n  }\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || \"Validation error\";\n    const error = new sequelizeError.ValidationErrorItem(message, \"Validation error\", errorKey, value, this.modelInstance, fnName, isBuiltin ? fnName : void 0, isBuiltin ? fnArgs : void 0);\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n    this.errors.push(error);\n  }\n}\nInstanceValidator.RAW_KEY_NAME = \"original\";\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports[\"default\"] = InstanceValidator;\n//# sourceMappingURL=instance-validator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbnN0YW5jZS12YWxpZGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxvRUFBVTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDckQsa0JBQWtCLCtIQUE2QztBQUMvRCxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOERBQThELGVBQWUsS0FBSyxPQUFPLFlBQVksNkNBQTZDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsb0NBQW9DLEdBQUcsT0FBTztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaW5zdGFuY2UtdmFsaWRhdG9yLmpzPzFlNjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jb25zdCBfID0gcmVxdWlyZShcImxvZGFzaFwiKTtcbmNvbnN0IFV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvciA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuL2RhdGEtdHlwZXNcIik7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10b1wiKTtcbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoXCIuL3V0aWxzL3ZhbGlkYXRvci1leHRyYXNcIikudmFsaWRhdG9yO1xuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY2xhc3MgSW5zdGFuY2VWYWxpZGF0b3Ige1xuICBjb25zdHJ1Y3Rvcihtb2RlbEluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvb2tzOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZmllbGRzICYmICFvcHRpb25zLnNraXApIHtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IF8uZGlmZmVyZW5jZShPYmplY3Qua2V5cyhtb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpLCBvcHRpb25zLmZpZWxkcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IG9wdGlvbnMuc2tpcCB8fCBbXTtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm1vZGVsSW5zdGFuY2UgPSBtb2RlbEluc3RhbmNlO1xuICAgIHRoaXMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pblByb2dyZXNzID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgX3ZhbGlkYXRlKCkge1xuICAgIGlmICh0aGlzLmluUHJvZ3Jlc3MpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9ucyBhbHJlYWR5IGluIHByb2dyZXNzLlwiKTtcbiAgICB0aGlzLmluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX3BlckF0dHJpYnV0ZVZhbGlkYXRvcnMoKSxcbiAgICAgIHRoaXMuX2N1c3RvbVZhbGlkYXRvcnMoKVxuICAgIF0pO1xuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3IobnVsbCwgdGhpcy5lcnJvcnMpO1xuICAgIH1cbiAgfVxuICBhc3luYyB2YWxpZGF0ZSgpIHtcbiAgICByZXR1cm4gYXdhaXQgKHRoaXMub3B0aW9ucy5ob29rcyA/IHRoaXMuX3ZhbGlkYXRlQW5kUnVuSG9va3MoKSA6IHRoaXMuX3ZhbGlkYXRlKCkpO1xuICB9XG4gIGFzeW5jIF92YWxpZGF0ZUFuZFJ1bkhvb2tzKCkge1xuICAgIGNvbnN0IHJ1bkhvb2tzID0gdGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yLnJ1bkhvb2tzLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICBhd2FpdCBydW5Ib29rcyhcImJlZm9yZVZhbGlkYXRlXCIsIHRoaXMubW9kZWxJbnN0YW5jZSwgdGhpcy5vcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fdmFsaWRhdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgbmV3RXJyb3IgPSBhd2FpdCBydW5Ib29rcyhcInZhbGlkYXRpb25GYWlsZWRcIiwgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMsIGVycm9yKTtcbiAgICAgIHRocm93IG5ld0Vycm9yIHx8IGVycm9yO1xuICAgIH1cbiAgICBhd2FpdCBydW5Ib29rcyhcImFmdGVyVmFsaWRhdGVcIiwgdGhpcy5tb2RlbEluc3RhbmNlLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm1vZGVsSW5zdGFuY2U7XG4gIH1cbiAgYXN5bmMgX3BlckF0dHJpYnV0ZVZhbGlkYXRvcnMoKSB7XG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgIF8uZm9ySW4odGhpcy5tb2RlbEluc3RhbmNlLnJhd0F0dHJpYnV0ZXMsIChyYXdBdHRyaWJ1dGUsIGZpZWxkKSA9PiB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNraXAuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tb2RlbEluc3RhbmNlLmRhdGFWYWx1ZXNbZmllbGRdO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghcmF3QXR0cmlidXRlLl9hdXRvR2VuZXJhdGVkICYmICFyYXdBdHRyaWJ1dGUuYXV0b0luY3JlbWVudCkge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZVNjaGVtYShyYXdBdHRyaWJ1dGUsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzLCBmaWVsZCkpIHtcbiAgICAgICAgdmFsaWRhdG9ycy5wdXNoKHRoaXMuX3NpbmdsZUF0dHJWYWxpZGF0ZSh2YWx1ZSwgZmllbGQsIHJhd0F0dHJpYnV0ZS5hbGxvd051bGwpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwodmFsaWRhdG9ycyk7XG4gIH1cbiAgYXN5bmMgX2N1c3RvbVZhbGlkYXRvcnMoKSB7XG4gICAgY29uc3QgdmFsaWRhdG9ycyA9IFtdO1xuICAgIF8uZWFjaCh0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucy52YWxpZGF0ZSwgKHZhbGlkYXRvcjIsIHZhbGlkYXRvclR5cGUpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2tpcC5pbmNsdWRlcyh2YWxpZGF0b3JUeXBlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxwcm9tID0gdGhpcy5faW52b2tlQ3VzdG9tVmFsaWRhdG9yKHZhbGlkYXRvcjIsIHZhbGlkYXRvclR5cGUpLmNhdGNoKCgpID0+IHtcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdG9ycy5wdXNoKHZhbHByb20pO1xuICAgIH0pO1xuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbCh2YWxpZGF0b3JzKTtcbiAgfVxuICBhc3luYyBfc2luZ2xlQXR0clZhbGlkYXRlKHZhbHVlLCBmaWVsZCwgYWxsb3dOdWxsKSB7XG4gICAgaWYgKCh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSAmJiAhYWxsb3dOdWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBbXTtcbiAgICBfLmZvckluKHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzW2ZpZWxkXSwgKHRlc3QsIHZhbGlkYXRvclR5cGUpID0+IHtcbiAgICAgIGlmIChbXCJpc1VybFwiLCBcImlzVVJMXCIsIFwiaXNFbWFpbFwiXS5pbmNsdWRlcyh2YWxpZGF0b3JUeXBlKSkge1xuICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09IFwib2JqZWN0XCIgJiYgdGVzdCAhPT0gbnVsbCAmJiB0ZXN0Lm1zZykge1xuICAgICAgICAgIHRlc3QgPSB7XG4gICAgICAgICAgICBtc2c6IHRlc3QubXNnXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGVzdCA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0b3JzLnB1c2godGhpcy5faW52b2tlQ3VzdG9tVmFsaWRhdG9yKHRlc3QsIHZhbGlkYXRvclR5cGUsIHRydWUsIHZhbHVlLCBmaWVsZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZGF0b3JQcm9taXNlID0gdGhpcy5faW52b2tlQnVpbHRpblZhbGlkYXRvcih2YWx1ZSwgdGVzdCwgdmFsaWRhdG9yVHlwZSwgZmllbGQpO1xuICAgICAgdmFsaWRhdG9yUHJvbWlzZS5jYXRjaCgoKSA9PiB7XG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRvcnMucHVzaCh2YWxpZGF0b3JQcm9taXNlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsaWRhdG9ycy5tYXAoKHZhbGlkYXRvcjIpID0+IHZhbGlkYXRvcjIuY2F0Y2goKHJlamVjdGlvbikgPT4ge1xuICAgICAgY29uc3QgaXNCdWlsdEluID0gISFyZWplY3Rpb24udmFsaWRhdG9yTmFtZTtcbiAgICAgIHRoaXMuX3B1c2hFcnJvcihpc0J1aWx0SW4sIGZpZWxkLCByZWplY3Rpb24sIHZhbHVlLCByZWplY3Rpb24udmFsaWRhdG9yTmFtZSwgcmVqZWN0aW9uLnZhbGlkYXRvckFyZ3MpO1xuICAgIH0pKSk7XG4gIH1cbiAgYXN5bmMgX2ludm9rZUN1c3RvbVZhbGlkYXRvcih2YWxpZGF0b3IyLCB2YWxpZGF0b3JUeXBlLCBvcHRBdHRyRGVmaW5lZCwgb3B0VmFsdWUsIG9wdEZpZWxkKSB7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcbiAgICBjb25zdCB2YWxpZGF0b3JBcml0eSA9IHZhbGlkYXRvcjIubGVuZ3RoO1xuICAgIGxldCBhc3luY0FyaXR5ID0gMTtcbiAgICBsZXQgZXJyb3JLZXkgPSB2YWxpZGF0b3JUeXBlO1xuICAgIGxldCBpbnZva2VBcmdzO1xuICAgIGlmIChvcHRBdHRyRGVmaW5lZCkge1xuICAgICAgYXN5bmNBcml0eSA9IDI7XG4gICAgICBpbnZva2VBcmdzID0gb3B0VmFsdWU7XG4gICAgICBlcnJvcktleSA9IG9wdEZpZWxkO1xuICAgIH1cbiAgICBpZiAodmFsaWRhdG9yQXJpdHkgPT09IGFzeW5jQXJpdHkpIHtcbiAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdEF0dHJEZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHByb21pc2lmeSh2YWxpZGF0b3IyLmJpbmQodGhpcy5tb2RlbEluc3RhbmNlLCBpbnZva2VBcmdzKSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgcHJvbWlzaWZ5KHZhbGlkYXRvcjIuYmluZCh0aGlzLm1vZGVsSW5zdGFuY2UpKSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaEVycm9yKGZhbHNlLCBlcnJvcktleSwgZSwgb3B0VmFsdWUsIHZhbGlkYXRvclR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHZhbGlkYXRvcjIuY2FsbCh0aGlzLm1vZGVsSW5zdGFuY2UsIGludm9rZUFyZ3MpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoRXJyb3IoZmFsc2UsIGVycm9yS2V5LCBlLCBvcHRWYWx1ZSwgdmFsaWRhdG9yVHlwZSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9pbnZva2VCdWlsdGluVmFsaWRhdG9yKHZhbHVlLCB0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCkge1xuICAgIGNvbnN0IHZhbHVlU3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvclt2YWxpZGF0b3JUeXBlXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uOiAke3ZhbGlkYXRvclR5cGV9YCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRvckFyZ3MgPSB0aGlzLl9leHRyYWN0VmFsaWRhdG9yQXJncyh0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCk7XG4gICAgaWYgKCF2YWxpZGF0b3JbdmFsaWRhdG9yVHlwZV0odmFsdWVTdHJpbmcsIC4uLnZhbGlkYXRvckFyZ3MpKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcih0ZXN0Lm1zZyB8fCBgVmFsaWRhdGlvbiAke3ZhbGlkYXRvclR5cGV9IG9uICR7ZmllbGR9IGZhaWxlZGApLCB7IHZhbGlkYXRvck5hbWU6IHZhbGlkYXRvclR5cGUsIHZhbGlkYXRvckFyZ3MgfSk7XG4gICAgfVxuICB9XG4gIF9leHRyYWN0VmFsaWRhdG9yQXJncyh0ZXN0LCB2YWxpZGF0b3JUeXBlLCBmaWVsZCkge1xuICAgIGxldCB2YWxpZGF0b3JBcmdzID0gdGVzdC5hcmdzIHx8IHRlc3Q7XG4gICAgY29uc3QgaXNMb2NhbGl6ZWRWYWxpZGF0b3IgPSB0eXBlb2YgdmFsaWRhdG9yQXJncyAhPT0gXCJzdHJpbmdcIiAmJiBbXCJpc0FscGhhXCIsIFwiaXNBbHBoYW51bWVyaWNcIiwgXCJpc01vYmlsZVBob25lXCJdLmluY2x1ZGVzKHZhbGlkYXRvclR5cGUpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JBcmdzKSkge1xuICAgICAgaWYgKHZhbGlkYXRvclR5cGUgPT09IFwiaXNJbW11dGFibGVcIikge1xuICAgICAgICB2YWxpZGF0b3JBcmdzID0gW3ZhbGlkYXRvckFyZ3MsIGZpZWxkLCB0aGlzLm1vZGVsSW5zdGFuY2VdO1xuICAgICAgfSBlbHNlIGlmIChpc0xvY2FsaXplZFZhbGlkYXRvciB8fCB2YWxpZGF0b3JUeXBlID09PSBcImlzSVBcIikge1xuICAgICAgICB2YWxpZGF0b3JBcmdzID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0b3JBcmdzID0gW3ZhbGlkYXRvckFyZ3NdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0b3JBcmdzID0gdmFsaWRhdG9yQXJncy5zbGljZSgwKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRvckFyZ3M7XG4gIH1cbiAgX3ZhbGlkYXRlU2NoZW1hKHJhd0F0dHJpYnV0ZSwgZmllbGQsIHZhbHVlKSB7XG4gICAgaWYgKHJhd0F0dHJpYnV0ZS5hbGxvd051bGwgPT09IGZhbHNlICYmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwKSkge1xuICAgICAgY29uc3QgYXNzb2NpYXRpb24gPSBPYmplY3QudmFsdWVzKHRoaXMubW9kZWxJbnN0YW5jZS5jb25zdHJ1Y3Rvci5hc3NvY2lhdGlvbnMpLmZpbmQoKGFzc29jaWF0aW9uMikgPT4gYXNzb2NpYXRpb24yIGluc3RhbmNlb2YgQmVsb25nc1RvICYmIGFzc29jaWF0aW9uMi5mb3JlaWduS2V5ID09PSByYXdBdHRyaWJ1dGUuZmllbGROYW1lKTtcbiAgICAgIGlmICghYXNzb2NpYXRpb24gfHwgIXRoaXMubW9kZWxJbnN0YW5jZS5nZXQoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25BY2Nlc3NvcikpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IHRoaXMubW9kZWxJbnN0YW5jZS52YWxpZGF0b3JzW2ZpZWxkXTtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gXy5nZXQodmFsaWRhdG9ycywgXCJub3ROdWxsLm1zZ1wiLCBgJHt0aGlzLm1vZGVsSW5zdGFuY2UuY29uc3RydWN0b3IubmFtZX0uJHtmaWVsZH0gY2Fubm90IGJlIG51bGxgKTtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgc2VxdWVsaXplRXJyb3IuVmFsaWRhdGlvbkVycm9ySXRlbShlcnJNc2csIFwibm90TnVsbCBWaW9sYXRpb25cIiwgZmllbGQsIHZhbHVlLCB0aGlzLm1vZGVsSW5zdGFuY2UsIFwiaXNfbnVsbFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5TVFJJTkcgfHwgcmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVEVYVCB8fCByYXdBdHRyaWJ1dGUudHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5DSVRFWFQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBfLmlzT2JqZWN0KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSAmJiAhQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBzZXF1ZWxpemVFcnJvci5WYWxpZGF0aW9uRXJyb3JJdGVtKGAke2ZpZWxkfSBjYW5ub3QgYmUgYW4gYXJyYXkgb3IgYW4gb2JqZWN0YCwgXCJzdHJpbmcgdmlvbGF0aW9uXCIsIGZpZWxkLCB2YWx1ZSwgdGhpcy5tb2RlbEluc3RhbmNlLCBcIm5vdF9hX3N0cmluZ1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9wdXNoRXJyb3IoaXNCdWlsdGluLCBlcnJvcktleSwgcmF3RXJyb3IsIHZhbHVlLCBmbk5hbWUsIGZuQXJncykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSByYXdFcnJvci5tZXNzYWdlIHx8IHJhd0Vycm9yIHx8IFwiVmFsaWRhdGlvbiBlcnJvclwiO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IHNlcXVlbGl6ZUVycm9yLlZhbGlkYXRpb25FcnJvckl0ZW0obWVzc2FnZSwgXCJWYWxpZGF0aW9uIGVycm9yXCIsIGVycm9yS2V5LCB2YWx1ZSwgdGhpcy5tb2RlbEluc3RhbmNlLCBmbk5hbWUsIGlzQnVpbHRpbiA/IGZuTmFtZSA6IHZvaWQgMCwgaXNCdWlsdGluID8gZm5BcmdzIDogdm9pZCAwKTtcbiAgICBlcnJvcltJbnN0YW5jZVZhbGlkYXRvci5SQVdfS0VZX05BTUVdID0gcmF3RXJyb3I7XG4gICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn1cbkluc3RhbmNlVmFsaWRhdG9yLlJBV19LRVlfTkFNRSA9IFwib3JpZ2luYWxcIjtcbm1vZHVsZS5leHBvcnRzID0gSW5zdGFuY2VWYWxpZGF0b3I7XG5tb2R1bGUuZXhwb3J0cy5JbnN0YW5jZVZhbGlkYXRvciA9IEluc3RhbmNlVmFsaWRhdG9yO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IEluc3RhbmNlVmFsaWRhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFuY2UtdmFsaWRhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/instance-validator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/model-manager.js":
/*!*****************************************************!*\
  !*** ./node_modules/sequelize/lib/model-manager.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Toposort = __webpack_require__(/*! toposort-class */ \"(rsc)/./node_modules/toposort-class/index.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nclass ModelManager {\n  constructor(sequelize) {\n    this.models = [];\n    this.sequelize = sequelize;\n  }\n  addModel(model) {\n    this.models.push(model);\n    this.sequelize.models[model.name] = model;\n    return model;\n  }\n  removeModel(modelToRemove) {\n    this.models = this.models.filter((model) => model.name !== modelToRemove.name);\n    delete this.sequelize.models[modelToRemove.name];\n  }\n  getModel(against, options) {\n    options = _.defaults(options || {}, {\n      attribute: \"name\"\n    });\n    return this.models.find((model) => model[options.attribute] === against);\n  }\n  findModel(callback) {\n    return this.models.find(callback);\n  }\n  get all() {\n    return this.models;\n  }\n  getModelsTopoSortedByForeignKey() {\n    const models = /* @__PURE__ */ new Map();\n    const sorter = new Toposort();\n    for (const model of this.models) {\n      let deps = [];\n      let tableName = model.getTableName();\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      models.set(tableName, model);\n      for (const attrName in model.rawAttributes) {\n        if (Object.prototype.hasOwnProperty.call(model.rawAttributes, attrName)) {\n          const attribute = model.rawAttributes[attrName];\n          if (attribute.references) {\n            let dep = attribute.references.model;\n            if (_.isObject(dep)) {\n              dep = `${dep.schema}.${dep.tableName}`;\n            }\n            deps.push(dep);\n          }\n        }\n      }\n      deps = deps.filter((dep) => tableName !== dep);\n      sorter.add(tableName, deps);\n    }\n    let sorted;\n    try {\n      sorted = sorter.sort();\n    } catch (e) {\n      if (!e.message.startsWith(\"Cyclic dependency found.\")) {\n        throw e;\n      }\n      return null;\n    }\n    return sorted.map((modelName) => {\n      return models.get(modelName);\n    }).filter(Boolean);\n  }\n  forEachModel(iterator, options) {\n    const sortedModels = this.getModelsTopoSortedByForeignKey();\n    if (sortedModels == null) {\n      throw new Error(\"Cyclic dependency found.\");\n    }\n    options = _.defaults(options || {}, {\n      reverse: true\n    });\n    if (options.reverse) {\n      sortedModels.reverse();\n    }\n    for (const model of sortedModels) {\n      iterator(model);\n    }\n  }\n}\nmodule.exports = ModelManager;\nmodule.exports.ModelManager = ModelManager;\nmodule.exports[\"default\"] = ModelManager;\n//# sourceMappingURL=model-manager.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3pDLFVBQVUsbUJBQU8sQ0FBQyxxREFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQixHQUFHLG9CQUFvQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVcsR0FBRyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL21vZGVsLW1hbmFnZXIuanM/MjVhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFRvcG9zb3J0ID0gcmVxdWlyZShcInRvcG9zb3J0LWNsYXNzXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jbGFzcyBNb2RlbE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihzZXF1ZWxpemUpIHtcbiAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICB9XG4gIGFkZE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5tb2RlbHMucHVzaChtb2RlbCk7XG4gICAgdGhpcy5zZXF1ZWxpemUubW9kZWxzW21vZGVsLm5hbWVdID0gbW9kZWw7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJlbW92ZU1vZGVsKG1vZGVsVG9SZW1vdmUpIHtcbiAgICB0aGlzLm1vZGVscyA9IHRoaXMubW9kZWxzLmZpbHRlcigobW9kZWwpID0+IG1vZGVsLm5hbWUgIT09IG1vZGVsVG9SZW1vdmUubmFtZSk7XG4gICAgZGVsZXRlIHRoaXMuc2VxdWVsaXplLm1vZGVsc1ttb2RlbFRvUmVtb3ZlLm5hbWVdO1xuICB9XG4gIGdldE1vZGVsKGFnYWluc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgICBhdHRyaWJ1dGU6IFwibmFtZVwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzLmZpbmQoKG1vZGVsKSA9PiBtb2RlbFtvcHRpb25zLmF0dHJpYnV0ZV0gPT09IGFnYWluc3QpO1xuICB9XG4gIGZpbmRNb2RlbChjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLm1vZGVscy5maW5kKGNhbGxiYWNrKTtcbiAgfVxuICBnZXQgYWxsKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVscztcbiAgfVxuICBnZXRNb2RlbHNUb3BvU29ydGVkQnlGb3JlaWduS2V5KCkge1xuICAgIGNvbnN0IG1vZGVscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc29ydGVyID0gbmV3IFRvcG9zb3J0KCk7XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVscykge1xuICAgICAgbGV0IGRlcHMgPSBbXTtcbiAgICAgIGxldCB0YWJsZU5hbWUgPSBtb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICAgIGlmIChfLmlzT2JqZWN0KHRhYmxlTmFtZSkpIHtcbiAgICAgICAgdGFibGVOYW1lID0gYCR7dGFibGVOYW1lLnNjaGVtYX0uJHt0YWJsZU5hbWUudGFibGVOYW1lfWA7XG4gICAgICB9XG4gICAgICBtb2RlbHMuc2V0KHRhYmxlTmFtZSwgbW9kZWwpO1xuICAgICAgZm9yIChjb25zdCBhdHRyTmFtZSBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kZWwucmF3QXR0cmlidXRlcywgYXR0ck5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbW9kZWwucmF3QXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBsZXQgZGVwID0gYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWw7XG4gICAgICAgICAgICBpZiAoXy5pc09iamVjdChkZXApKSB7XG4gICAgICAgICAgICAgIGRlcCA9IGAke2RlcC5zY2hlbWF9LiR7ZGVwLnRhYmxlTmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVwcy5wdXNoKGRlcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZXBzID0gZGVwcy5maWx0ZXIoKGRlcCkgPT4gdGFibGVOYW1lICE9PSBkZXApO1xuICAgICAgc29ydGVyLmFkZCh0YWJsZU5hbWUsIGRlcHMpO1xuICAgIH1cbiAgICBsZXQgc29ydGVkO1xuICAgIHRyeSB7XG4gICAgICBzb3J0ZWQgPSBzb3J0ZXIuc29ydCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghZS5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDeWNsaWMgZGVwZW5kZW5jeSBmb3VuZC5cIikpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc29ydGVkLm1hcCgobW9kZWxOYW1lKSA9PiB7XG4gICAgICByZXR1cm4gbW9kZWxzLmdldChtb2RlbE5hbWUpO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgfVxuICBmb3JFYWNoTW9kZWwoaXRlcmF0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3J0ZWRNb2RlbHMgPSB0aGlzLmdldE1vZGVsc1RvcG9Tb3J0ZWRCeUZvcmVpZ25LZXkoKTtcbiAgICBpZiAoc29ydGVkTW9kZWxzID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xpYyBkZXBlbmRlbmN5IGZvdW5kLlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwge1xuICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHNvcnRlZE1vZGVscy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kZWwgb2Ygc29ydGVkTW9kZWxzKSB7XG4gICAgICBpdGVyYXRvcihtb2RlbCk7XG4gICAgfVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLk1vZGVsTWFuYWdlciA9IE1vZGVsTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBNb2RlbE1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC1tYW5hZ2VyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/model-manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/model.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/model.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst assert = __webpack_require__(/*! assert */ \"assert\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Dottie = __webpack_require__(/*! dottie */ \"(rsc)/./node_modules/dottie/dottie.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nconst BelongsTo = __webpack_require__(/*! ./associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst BelongsToMany = __webpack_require__(/*! ./associations/belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst InstanceValidator = __webpack_require__(/*! ./instance-validator */ \"(rsc)/./node_modules/sequelize/lib/instance-validator.js\");\nconst QueryTypes = __webpack_require__(/*! ./query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst Association = __webpack_require__(/*! ./associations/base */ \"(rsc)/./node_modules/sequelize/lib/associations/base.js\");\nconst HasMany = __webpack_require__(/*! ./associations/has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Hooks = __webpack_require__(/*! ./hooks */ \"(rsc)/./node_modules/sequelize/lib/hooks.js\");\nconst associationsMixin = __webpack_require__(/*! ./associations/mixin */ \"(rsc)/./node_modules/sequelize/lib/associations/mixin.js\");\nconst Op = __webpack_require__(/*! ./operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst { noDoubleNestedGroup } = __webpack_require__(/*! ./utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst validQueryKeywords = /* @__PURE__ */ new Set([\n  \"where\",\n  \"attributes\",\n  \"paranoid\",\n  \"include\",\n  \"order\",\n  \"limit\",\n  \"offset\",\n  \"transaction\",\n  \"lock\",\n  \"raw\",\n  \"logging\",\n  \"benchmark\",\n  \"having\",\n  \"searchPath\",\n  \"rejectOnEmpty\",\n  \"plain\",\n  \"scope\",\n  \"group\",\n  \"through\",\n  \"defaults\",\n  \"distinct\",\n  \"primary\",\n  \"exception\",\n  \"type\",\n  \"hooks\",\n  \"force\",\n  \"name\"\n]);\nconst nonCascadingOptions = [\"include\", \"attributes\", \"originalAttributes\", \"order\", \"where\", \"limit\", \"offset\", \"plain\", \"group\", \"having\"];\nclass Model {\n  static get queryInterface() {\n    return this.sequelize.getQueryInterface();\n  }\n  static get queryGenerator() {\n    return this.queryInterface.queryGenerator;\n  }\n  get sequelize() {\n    return this.constructor.sequelize;\n  }\n  constructor(values = {}, options = {}) {\n    if (!this.constructor._overwrittenAttributesChecked) {\n      this.constructor._overwrittenAttributesChecked = true;\n      setTimeout(() => {\n        const overwrittenAttributes = [];\n        for (const key of Object.keys(this.constructor._attributeManipulation)) {\n          if (Object.prototype.hasOwnProperty.call(this, key)) {\n            overwrittenAttributes.push(key);\n          }\n        }\n        if (overwrittenAttributes.length > 0) {\n          logger.warn(`Model ${JSON.stringify(this.constructor.name)} is declaring public class fields for attribute(s): ${overwrittenAttributes.map((attr) => JSON.stringify(attr)).join(\", \")}.\nThese class fields are shadowing Sequelize's attribute getters & setters.\nSee https://sequelize.org/main/manual/model-basics.html#caveat-with-public-class-fields`);\n        }\n      }, 0);\n    }\n    options = __spreadValues({\n      isNewRecord: true,\n      _schema: this.constructor._schema,\n      _schemaDelimiter: this.constructor._schemaDelimiter\n    }, options);\n    if (options.attributes) {\n      options.attributes = options.attributes.map((attribute) => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n    if (!options.includeValidated) {\n      this.constructor._conformIncludes(options, this.constructor);\n      if (options.include) {\n        this.constructor._expandIncludeAll(options);\n        this.constructor._validateIncludedElements(options);\n      }\n    }\n    this.dataValues = {};\n    this._previousDataValues = {};\n    this.uniqno = 1;\n    this._changed = /* @__PURE__ */ new Set();\n    this._options = options;\n    this.isNewRecord = options.isNewRecord;\n    this._initValues(values, options);\n  }\n  _initValues(values, options) {\n    let defaults;\n    let key;\n    values = __spreadValues({}, values);\n    if (options.isNewRecord) {\n      defaults = {};\n      if (this.constructor._hasDefaultValues) {\n        defaults = _.mapValues(this.constructor._defaultValues, (valueFn) => {\n          const value = valueFn();\n          return value && value instanceof Utils.SequelizeMethod ? value : _.cloneDeep(value);\n        });\n      }\n      if (this.constructor.primaryKeyAttributes.length) {\n        this.constructor.primaryKeyAttributes.forEach((primaryKeyAttribute) => {\n          if (!Object.prototype.hasOwnProperty.call(defaults, primaryKeyAttribute)) {\n            defaults[primaryKeyAttribute] = null;\n          }\n        });\n      }\n      if (this.constructor._timestampAttributes.createdAt && defaults[this.constructor._timestampAttributes.createdAt]) {\n        this.dataValues[this.constructor._timestampAttributes.createdAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.createdAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.createdAt];\n      }\n      if (this.constructor._timestampAttributes.updatedAt && defaults[this.constructor._timestampAttributes.updatedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.updatedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.updatedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.updatedAt];\n      }\n      if (this.constructor._timestampAttributes.deletedAt && defaults[this.constructor._timestampAttributes.deletedAt]) {\n        this.dataValues[this.constructor._timestampAttributes.deletedAt] = Utils.toDefaultValue(defaults[this.constructor._timestampAttributes.deletedAt], this.sequelize.options.dialect);\n        delete defaults[this.constructor._timestampAttributes.deletedAt];\n      }\n      for (key in defaults) {\n        if (values[key] === void 0) {\n          this.set(key, Utils.toDefaultValue(defaults[key], this.sequelize.options.dialect), { raw: true });\n          delete values[key];\n        }\n      }\n    }\n    this.set(values, options);\n  }\n  static _paranoidClause(model, options = {}) {\n    if (options.include) {\n      for (const include of options.include) {\n        this._paranoidClause(include.model, include);\n      }\n    }\n    if (_.get(options, \"groupedLimit.on.options.paranoid\")) {\n      const throughModel = _.get(options, \"groupedLimit.on.through.model\");\n      if (throughModel) {\n        options.groupedLimit.through = this._paranoidClause(throughModel, options.groupedLimit.through);\n      }\n    }\n    if (!model.options.timestamps || !model.options.paranoid || options.paranoid === false) {\n      return options;\n    }\n    const deletedAtCol = model._timestampAttributes.deletedAt;\n    const deletedAtAttribute = model.rawAttributes[deletedAtCol];\n    const deletedAtObject = {};\n    let deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    deletedAtDefaultValue = deletedAtDefaultValue || {\n      [Op.eq]: null\n    };\n    deletedAtObject[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    if (Utils.isWhereEmpty(options.where)) {\n      options.where = deletedAtObject;\n    } else {\n      options.where = { [Op.and]: [deletedAtObject, options.where] };\n    }\n    return options;\n  }\n  static _addDefaultAttributes() {\n    const tail = {};\n    let head = {};\n    if (!_.some(this.rawAttributes, \"primaryKey\")) {\n      if (\"id\" in this.rawAttributes) {\n        throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);\n      }\n      head = {\n        id: {\n          type: new DataTypes.INTEGER(),\n          allowNull: false,\n          primaryKey: true,\n          autoIncrement: true,\n          _autoGenerated: true\n        }\n      };\n    }\n    if (this._timestampAttributes.createdAt) {\n      tail[this._timestampAttributes.createdAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n    if (this._timestampAttributes.updatedAt) {\n      tail[this._timestampAttributes.updatedAt] = {\n        type: DataTypes.DATE,\n        allowNull: false,\n        _autoGenerated: true\n      };\n    }\n    if (this._timestampAttributes.deletedAt) {\n      tail[this._timestampAttributes.deletedAt] = {\n        type: DataTypes.DATE,\n        _autoGenerated: true\n      };\n    }\n    if (this._versionAttribute) {\n      tail[this._versionAttribute] = {\n        type: DataTypes.INTEGER,\n        allowNull: false,\n        defaultValue: 0,\n        _autoGenerated: true\n      };\n    }\n    const newRawAttributes = __spreadValues(__spreadValues({}, head), this.rawAttributes);\n    _.each(tail, (value, attr) => {\n      if (newRawAttributes[attr] === void 0) {\n        newRawAttributes[attr] = value;\n      }\n    });\n    this.rawAttributes = newRawAttributes;\n    if (!Object.keys(this.primaryKeys).length) {\n      this.primaryKeys.id = this.rawAttributes.id;\n    }\n  }\n  static getAttributes() {\n    return this.rawAttributes;\n  }\n  static _findAutoIncrementAttribute() {\n    this.autoIncrementAttribute = null;\n    for (const name in this.rawAttributes) {\n      if (Object.prototype.hasOwnProperty.call(this.rawAttributes, name)) {\n        const definition = this.rawAttributes[name];\n        if (definition && definition.autoIncrement) {\n          if (this.autoIncrementAttribute) {\n            throw new Error(\"Invalid Instance definition. Only one autoincrement field allowed.\");\n          }\n          this.autoIncrementAttribute = name;\n        }\n      }\n    }\n  }\n  static _conformIncludes(options, self) {\n    if (!options.include)\n      return;\n    if (!Array.isArray(options.include)) {\n      options.include = [options.include];\n    } else if (!options.include.length) {\n      delete options.include;\n      return;\n    }\n    options.include = options.include.map((include) => this._conformInclude(include, self));\n  }\n  static _transformStringAssociation(include, self) {\n    if (self && typeof include === \"string\") {\n      if (!Object.prototype.hasOwnProperty.call(self.associations, include)) {\n        throw new Error(`Association with alias \"${include}\" does not exist on ${self.name}`);\n      }\n      return self.associations[include];\n    }\n    return include;\n  }\n  static _conformInclude(include, self) {\n    if (include) {\n      let model;\n      if (include._pseudo)\n        return include;\n      include = this._transformStringAssociation(include, self);\n      if (include instanceof Association) {\n        if (self && include.target.name === self.name) {\n          model = include.source;\n        } else {\n          model = include.target;\n        }\n        return { model, association: include, as: include.as };\n      }\n      if (include.prototype && include.prototype instanceof Model) {\n        return { model: include };\n      }\n      if (_.isPlainObject(include)) {\n        if (include.association) {\n          include.association = this._transformStringAssociation(include.association, self);\n          if (self && include.association.target.name === self.name) {\n            model = include.association.source;\n          } else {\n            model = include.association.target;\n          }\n          if (!include.model)\n            include.model = model;\n          if (!include.as)\n            include.as = include.association.as;\n          this._conformIncludes(include, model);\n          return include;\n        }\n        if (include.model) {\n          this._conformIncludes(include, include.model);\n          return include;\n        }\n        if (include.all) {\n          this._conformIncludes(include);\n          return include;\n        }\n      }\n    }\n    throw new Error(\"Include unexpected. Element has to be either a Model, an Association or an object.\");\n  }\n  static _expandIncludeAllElement(includes, include) {\n    let all = include.all;\n    delete include.all;\n    if (all !== true) {\n      if (!Array.isArray(all)) {\n        all = [all];\n      }\n      const validTypes = {\n        BelongsTo: true,\n        HasOne: true,\n        HasMany: true,\n        One: [\"BelongsTo\", \"HasOne\"],\n        Has: [\"HasOne\", \"HasMany\"],\n        Many: [\"HasMany\"]\n      };\n      for (let i = 0; i < all.length; i++) {\n        const type = all[i];\n        if (type === \"All\") {\n          all = true;\n          break;\n        }\n        const types = validTypes[type];\n        if (!types) {\n          throw new sequelizeErrors.EagerLoadingError(`include all '${type}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);\n        }\n        if (types !== true) {\n          all.splice(i, 1);\n          i--;\n          for (let j = 0; j < types.length; j++) {\n            if (!all.includes(types[j])) {\n              all.unshift(types[j]);\n              i++;\n            }\n          }\n        }\n      }\n    }\n    const nested = include.nested;\n    if (nested) {\n      delete include.nested;\n      if (!include.include) {\n        include.include = [];\n      } else if (!Array.isArray(include.include)) {\n        include.include = [include.include];\n      }\n    }\n    const used = [];\n    (function addAllIncludes(parent, includes2) {\n      _.forEach(parent.associations, (association) => {\n        if (all !== true && !all.includes(association.associationType)) {\n          return;\n        }\n        const model = association.target;\n        const as = association.options.as;\n        const predicate = { model };\n        if (as) {\n          predicate.as = as;\n        }\n        if (_.some(includes2, predicate)) {\n          return;\n        }\n        if (nested && used.includes(model)) {\n          return;\n        }\n        used.push(parent);\n        const thisInclude = Utils.cloneDeep(include);\n        thisInclude.model = model;\n        if (as) {\n          thisInclude.as = as;\n        }\n        includes2.push(thisInclude);\n        if (nested) {\n          addAllIncludes(model, thisInclude.include);\n          if (thisInclude.include.length === 0)\n            delete thisInclude.include;\n        }\n      });\n      used.pop();\n    })(this, includes);\n  }\n  static _validateIncludedElements(options, tableNames) {\n    if (!options.model)\n      options.model = this;\n    tableNames = tableNames || {};\n    options.includeNames = [];\n    options.includeMap = {};\n    options.hasSingleAssociation = false;\n    options.hasMultiAssociation = false;\n    if (!options.parent) {\n      options.topModel = options.model;\n      options.topLimit = options.limit;\n    }\n    options.include = options.include.map((include) => {\n      include = this._conformInclude(include);\n      include.parent = options;\n      include.topLimit = options.topLimit;\n      this._validateIncludedElement.call(options.model, include, tableNames, options);\n      if (include.duplicating === void 0) {\n        include.duplicating = include.association.isMultiAssociation;\n      }\n      include.hasDuplicating = include.hasDuplicating || include.duplicating;\n      include.hasRequired = include.hasRequired || include.required;\n      options.hasDuplicating = options.hasDuplicating || include.hasDuplicating;\n      options.hasRequired = options.hasRequired || include.required;\n      options.hasWhere = options.hasWhere || include.hasWhere || !!include.where;\n      return include;\n    });\n    for (const include of options.include) {\n      include.hasParentWhere = options.hasParentWhere || !!options.where;\n      include.hasParentRequired = options.hasParentRequired || !!options.required;\n      if (include.subQuery !== false && options.hasDuplicating && options.topLimit) {\n        if (include.duplicating) {\n          include.subQuery = include.subQuery || false;\n          include.subQueryFilter = include.hasRequired;\n        } else {\n          include.subQuery = include.hasRequired;\n          include.subQueryFilter = false;\n        }\n      } else {\n        include.subQuery = include.subQuery || false;\n        if (include.duplicating) {\n          include.subQueryFilter = include.subQuery;\n        } else {\n          include.subQueryFilter = false;\n          include.subQuery = include.subQuery || include.hasParentRequired && include.hasRequired && !include.separate;\n        }\n      }\n      options.includeMap[include.as] = include;\n      options.includeNames.push(include.as);\n      if (options.topModel === options.model && options.subQuery === void 0 && options.topLimit) {\n        if (include.subQuery) {\n          options.subQuery = include.subQuery;\n        } else if (include.hasDuplicating) {\n          options.subQuery = true;\n        }\n      }\n      options.hasIncludeWhere = options.hasIncludeWhere || include.hasIncludeWhere || !!include.where;\n      options.hasIncludeRequired = options.hasIncludeRequired || include.hasIncludeRequired || !!include.required;\n      if (include.association.isMultiAssociation || include.hasMultiAssociation) {\n        options.hasMultiAssociation = true;\n      }\n      if (include.association.isSingleAssociation || include.hasSingleAssociation) {\n        options.hasSingleAssociation = true;\n      }\n    }\n    if (options.topModel === options.model && options.subQuery === void 0) {\n      options.subQuery = false;\n    }\n    return options;\n  }\n  static _validateIncludedElement(include, tableNames, options) {\n    tableNames[include.model.getTableName()] = true;\n    if (include.attributes && !options.raw) {\n      include.model._expandAttributes(include);\n      include.originalAttributes = include.model._injectDependentVirtualAttributes(include.attributes);\n      include = Utils.mapFinderOptions(include, include.model);\n      if (include.attributes.length) {\n        _.each(include.model.primaryKeys, (attr, key) => {\n          if (!include.attributes.some((includeAttr) => {\n            if (attr.field !== key) {\n              return Array.isArray(includeAttr) && includeAttr[0] === attr.field && includeAttr[1] === key;\n            }\n            return includeAttr === key;\n          })) {\n            include.attributes.unshift(key);\n          }\n        });\n      }\n    } else {\n      include = Utils.mapFinderOptions(include, include.model);\n    }\n    if (include._pseudo) {\n      if (!include.attributes) {\n        include.attributes = Object.keys(include.model.tableAttributes);\n      }\n      return Utils.mapFinderOptions(include, include.model);\n    }\n    const association = include.association || this._getIncludedAssociation(include.model, include.as);\n    include.association = association;\n    include.as = association.as;\n    if (include.association.through && Object(include.association.through.model) === include.association.through.model) {\n      if (!include.include)\n        include.include = [];\n      const through = include.association.through;\n      include.through = _.defaults(include.through || {}, {\n        model: through.model,\n        as: through.model.name,\n        association: {\n          isSingleAssociation: true\n        },\n        _pseudo: true,\n        parent: include\n      });\n      if (through.scope) {\n        include.through.where = include.through.where ? { [Op.and]: [include.through.where, through.scope] } : through.scope;\n      }\n      include.include.push(include.through);\n      tableNames[through.tableName] = true;\n    }\n    let model;\n    if (include.model.scoped === true) {\n      model = include.model;\n    } else {\n      model = include.association.target.name === include.model.name ? include.association.target : include.association.source;\n    }\n    model._injectScope(include);\n    if (!include.attributes) {\n      include.attributes = Object.keys(include.model.tableAttributes);\n    }\n    include = Utils.mapFinderOptions(include, include.model);\n    if (include.required === void 0) {\n      include.required = !!include.where;\n    }\n    if (include.association.scope) {\n      include.where = include.where ? { [Op.and]: [include.where, include.association.scope] } : include.association.scope;\n    }\n    if (include.limit && include.separate === void 0) {\n      include.separate = true;\n    }\n    if (include.separate === true) {\n      if (!(include.association instanceof HasMany)) {\n        throw new Error(\"Only HasMany associations support include.separate\");\n      }\n      include.duplicating = false;\n      if (options.attributes && options.attributes.length && !_.flattenDepth(options.attributes, 2).includes(association.sourceKey)) {\n        options.attributes.push(association.sourceKey);\n      }\n      if (include.attributes && include.attributes.length && !_.flattenDepth(include.attributes, 2).includes(association.foreignKey)) {\n        include.attributes.push(association.foreignKey);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(include, \"include\")) {\n      this._validateIncludedElements.call(include.model, include, tableNames);\n    }\n    return include;\n  }\n  static _getIncludedAssociation(targetModel, targetAlias) {\n    const associations = this.getAssociations(targetModel);\n    let association = null;\n    if (associations.length === 0) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is not associated to ${this.name}!`);\n    }\n    if (associations.length === 1) {\n      association = this.getAssociationForAlias(targetModel, targetAlias);\n      if (association) {\n        return association;\n      }\n      if (targetAlias) {\n        const existingAliases = this.getAssociations(targetModel).map((association2) => association2.as);\n        throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You've included an alias (${targetAlias}), but it does not match the alias(es) defined in your association (${existingAliases.join(\", \")}).`);\n      }\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} using an alias. You must use the 'as' keyword to specify the alias within your include statement.`);\n    }\n    association = this.getAssociationForAlias(targetModel, targetAlias);\n    if (!association) {\n      throw new sequelizeErrors.EagerLoadingError(`${targetModel.name} is associated to ${this.name} multiple times. To identify the correct association, you must use the 'as' keyword to specify the alias of the association you want to include.`);\n    }\n    return association;\n  }\n  static _expandIncludeAll(options) {\n    const includes = options.include;\n    if (!includes) {\n      return;\n    }\n    for (let index = 0; index < includes.length; index++) {\n      const include = includes[index];\n      if (include.all) {\n        includes.splice(index, 1);\n        index--;\n        this._expandIncludeAllElement(includes, include);\n      }\n    }\n    includes.forEach((include) => {\n      this._expandIncludeAll.call(include.model, include);\n    });\n  }\n  static _conformIndex(index) {\n    if (!index.fields) {\n      throw new Error('Missing \"fields\" property for index definition');\n    }\n    index = _.defaults(index, {\n      type: \"\",\n      parser: null\n    });\n    if (index.type && index.type.toLowerCase() === \"unique\") {\n      index.unique = true;\n      delete index.type;\n    }\n    return index;\n  }\n  static _uniqIncludes(options) {\n    if (!options.include)\n      return;\n    options.include = _(options.include).groupBy((include) => `${include.model && include.model.name}-${include.as}`).map((includes) => this._assignOptions(...includes)).value();\n  }\n  static _baseMerge(...args) {\n    _.assignWith(...args);\n    this._conformIncludes(args[0], this);\n    this._uniqIncludes(args[0]);\n    return args[0];\n  }\n  static _mergeFunction(objValue, srcValue, key) {\n    if (Array.isArray(objValue) && Array.isArray(srcValue)) {\n      return _.union(objValue, srcValue);\n    }\n    if ([\"where\", \"having\"].includes(key)) {\n      if (this.options && this.options.whereMergeStrategy === \"and\") {\n        return combineWheresWithAnd(objValue, srcValue);\n      }\n      if (srcValue instanceof Utils.SequelizeMethod) {\n        srcValue = { [Op.and]: srcValue };\n      }\n      if (_.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n        return Object.assign(objValue, srcValue);\n      }\n    } else if (key === \"attributes\" && _.isPlainObject(objValue) && _.isPlainObject(srcValue)) {\n      return _.assignWith(objValue, srcValue, (objValue2, srcValue2) => {\n        if (Array.isArray(objValue2) && Array.isArray(srcValue2)) {\n          return _.union(objValue2, srcValue2);\n        }\n      });\n    }\n    if (srcValue) {\n      return Utils.cloneDeep(srcValue, true);\n    }\n    return srcValue === void 0 ? objValue : srcValue;\n  }\n  static _assignOptions(...args) {\n    return this._baseMerge(...args, this._mergeFunction.bind(this));\n  }\n  static _defaultsOptions(target, opts) {\n    return this._baseMerge(target, opts, (srcValue, objValue, key) => {\n      return this._mergeFunction(objValue, srcValue, key);\n    });\n  }\n  static init(attributes, options = {}) {\n    if (!options.sequelize) {\n      throw new Error(\"No Sequelize instance passed\");\n    }\n    this.sequelize = options.sequelize;\n    const globalOptions = this.sequelize.options;\n    options = Utils.merge(_.cloneDeep(globalOptions.define), options);\n    if (!options.modelName) {\n      options.modelName = this.name;\n    }\n    options = Utils.merge({\n      name: {\n        plural: Utils.pluralize(options.modelName),\n        singular: Utils.singularize(options.modelName)\n      },\n      indexes: [],\n      omitNull: globalOptions.omitNull,\n      schema: globalOptions.schema\n    }, options);\n    this.sequelize.runHooks(\"beforeDefine\", attributes, options);\n    if (options.modelName !== this.name) {\n      Object.defineProperty(this, \"name\", { value: options.modelName });\n    }\n    delete options.modelName;\n    this.options = __spreadValues({\n      timestamps: true,\n      validate: {},\n      freezeTableName: false,\n      underscored: false,\n      paranoid: false,\n      rejectOnEmpty: false,\n      whereCollection: null,\n      schema: null,\n      schemaDelimiter: \"\",\n      defaultScope: {},\n      scopes: {},\n      indexes: [],\n      whereMergeStrategy: \"overwrite\"\n    }, options);\n    if (this.sequelize.isDefined(this.name)) {\n      this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name));\n    }\n    this.associations = {};\n    this._setupHooks(options.hooks);\n    this.underscored = this.options.underscored;\n    if (!this.options.tableName) {\n      this.tableName = this.options.freezeTableName ? this.name : Utils.underscoredIf(Utils.pluralize(this.name), this.underscored);\n    } else {\n      this.tableName = this.options.tableName;\n    }\n    this._schema = this.options.schema;\n    this._schemaDelimiter = this.options.schemaDelimiter;\n    _.each(options.validate, (validator, validatorType) => {\n      if (Object.prototype.hasOwnProperty.call(attributes, validatorType)) {\n        throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${validatorType}`);\n      }\n      if (typeof validator !== \"function\") {\n        throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${validatorType}`);\n      }\n    });\n    if (!_.includes([\"and\", \"overwrite\"], this.options && this.options.whereMergeStrategy)) {\n      throw new Error(`Invalid value ${this.options && this.options.whereMergeStrategy} for whereMergeStrategy. Allowed values are 'and' and 'overwrite'.`);\n    }\n    this.rawAttributes = _.mapValues(attributes, (attribute, name) => {\n      attribute = this.sequelize.normalizeAttribute(attribute);\n      if (attribute.type === void 0) {\n        throw new Error(`Unrecognized datatype for attribute \"${this.name}.${name}\"`);\n      }\n      if (attribute.allowNull !== false && _.get(attribute, \"validate.notNull\")) {\n        throw new Error(`Invalid definition for \"${this.name}.${name}\", \"notNull\" validator is only allowed with \"allowNull:false\"`);\n      }\n      if (_.get(attribute, \"references.model.prototype\") instanceof Model) {\n        attribute.references.model = attribute.references.model.getTableName();\n      }\n      return attribute;\n    });\n    const tableName = this.getTableName();\n    this._indexes = this.options.indexes.map((index) => Utils.nameIndex(this._conformIndex(index), tableName));\n    this.primaryKeys = {};\n    this._readOnlyAttributes = /* @__PURE__ */ new Set();\n    this._timestampAttributes = {};\n    if (this.options.timestamps) {\n      for (const key of [\"createdAt\", \"updatedAt\", \"deletedAt\"]) {\n        if (![\"undefined\", \"string\", \"boolean\"].includes(typeof this.options[key])) {\n          throw new Error(`Value for \"${key}\" option must be a string or a boolean, got ${typeof this.options[key]}`);\n        }\n        if (this.options[key] === \"\") {\n          throw new Error(`Value for \"${key}\" option cannot be an empty string`);\n        }\n      }\n      if (this.options.createdAt !== false) {\n        this._timestampAttributes.createdAt = typeof this.options.createdAt === \"string\" ? this.options.createdAt : \"createdAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.createdAt);\n      }\n      if (this.options.updatedAt !== false) {\n        this._timestampAttributes.updatedAt = typeof this.options.updatedAt === \"string\" ? this.options.updatedAt : \"updatedAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.updatedAt);\n      }\n      if (this.options.paranoid && this.options.deletedAt !== false) {\n        this._timestampAttributes.deletedAt = typeof this.options.deletedAt === \"string\" ? this.options.deletedAt : \"deletedAt\";\n        this._readOnlyAttributes.add(this._timestampAttributes.deletedAt);\n      }\n    }\n    if (this.options.version) {\n      this._versionAttribute = typeof this.options.version === \"string\" ? this.options.version : \"version\";\n      this._readOnlyAttributes.add(this._versionAttribute);\n    }\n    this._hasReadOnlyAttributes = this._readOnlyAttributes.size > 0;\n    this._addDefaultAttributes();\n    this.refreshAttributes();\n    this._findAutoIncrementAttribute();\n    this._scope = this.options.defaultScope;\n    this._scopeNames = [\"defaultScope\"];\n    this.sequelize.modelManager.addModel(this);\n    this.sequelize.runHooks(\"afterDefine\", this);\n    return this;\n  }\n  static refreshAttributes() {\n    const attributeManipulation = {};\n    this.prototype._customGetters = {};\n    this.prototype._customSetters = {};\n    [\"get\", \"set\"].forEach((type) => {\n      const opt = `${type}terMethods`;\n      const funcs = __spreadValues({}, this.options[opt]);\n      const _custom = type === \"get\" ? this.prototype._customGetters : this.prototype._customSetters;\n      _.each(funcs, (method, attribute) => {\n        _custom[attribute] = method;\n        if (type === \"get\") {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === \"set\") {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n      _.each(this.rawAttributes, (options, attribute) => {\n        if (Object.prototype.hasOwnProperty.call(options, type)) {\n          _custom[attribute] = options[type];\n        }\n        if (type === \"get\") {\n          funcs[attribute] = function() {\n            return this.get(attribute);\n          };\n        }\n        if (type === \"set\") {\n          funcs[attribute] = function(value) {\n            return this.set(attribute, value);\n          };\n        }\n      });\n      _.each(funcs, (fct, name) => {\n        if (!attributeManipulation[name]) {\n          attributeManipulation[name] = {\n            configurable: true\n          };\n        }\n        attributeManipulation[name][type] = fct;\n      });\n    });\n    this._dataTypeChanges = {};\n    this._dataTypeSanitizers = {};\n    this._hasBooleanAttributes = false;\n    this._hasDateAttributes = false;\n    this._jsonAttributes = /* @__PURE__ */ new Set();\n    this._virtualAttributes = /* @__PURE__ */ new Set();\n    this._defaultValues = {};\n    this.prototype.validators = {};\n    this.fieldRawAttributesMap = {};\n    this.primaryKeys = {};\n    this.uniqueKeys = {};\n    _.each(this.rawAttributes, (definition, name) => {\n      definition.type = this.sequelize.normalizeDataType(definition.type);\n      definition.Model = this;\n      definition.fieldName = name;\n      definition._modelAttribute = true;\n      if (definition.field === void 0) {\n        definition.field = Utils.underscoredIf(name, this.underscored);\n      }\n      if (definition.primaryKey === true) {\n        this.primaryKeys[name] = definition;\n      }\n      this.fieldRawAttributesMap[definition.field] = definition;\n      if (definition.type._sanitize) {\n        this._dataTypeSanitizers[name] = definition.type._sanitize;\n      }\n      if (definition.type._isChanged) {\n        this._dataTypeChanges[name] = definition.type._isChanged;\n      }\n      if (definition.type instanceof DataTypes.BOOLEAN) {\n        this._hasBooleanAttributes = true;\n      } else if (definition.type instanceof DataTypes.DATE || definition.type instanceof DataTypes.DATEONLY) {\n        this._hasDateAttributes = true;\n      } else if (definition.type instanceof DataTypes.JSON) {\n        this._jsonAttributes.add(name);\n      } else if (definition.type instanceof DataTypes.VIRTUAL) {\n        this._virtualAttributes.add(name);\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"defaultValue\")) {\n        this._defaultValues[name] = () => Utils.toDefaultValue(definition.defaultValue, this.sequelize.options.dialect);\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"unique\") && definition.unique) {\n        let idxName;\n        if (typeof definition.unique === \"object\" && Object.prototype.hasOwnProperty.call(definition.unique, \"name\")) {\n          idxName = definition.unique.name;\n        } else if (typeof definition.unique === \"string\") {\n          idxName = definition.unique;\n        } else {\n          idxName = `${this.tableName}_${name}_unique`;\n        }\n        const idx = this.uniqueKeys[idxName] || { fields: [] };\n        idx.fields.push(definition.field);\n        idx.msg = idx.msg || definition.unique.msg || null;\n        idx.name = idxName || false;\n        idx.column = name;\n        idx.customIndex = definition.unique !== true;\n        this.uniqueKeys[idxName] = idx;\n      }\n      if (Object.prototype.hasOwnProperty.call(definition, \"validate\")) {\n        this.prototype.validators[name] = definition.validate;\n      }\n      if (definition.index === true && definition.type instanceof DataTypes.JSONB) {\n        this._indexes.push(Utils.nameIndex(this._conformIndex({\n          fields: [definition.field || name],\n          using: \"gin\"\n        }), this.getTableName()));\n        delete definition.index;\n      }\n    });\n    this.fieldAttributeMap = _.reduce(this.fieldRawAttributesMap, (map, value, key) => {\n      if (key !== value.fieldName) {\n        map[key] = value.fieldName;\n      }\n      return map;\n    }, {});\n    this._hasJsonAttributes = !!this._jsonAttributes.size;\n    this._hasVirtualAttributes = !!this._virtualAttributes.size;\n    this._hasDefaultValues = !_.isEmpty(this._defaultValues);\n    this.tableAttributes = _.omitBy(this.rawAttributes, (_a, key) => this._virtualAttributes.has(key));\n    this.prototype._hasCustomGetters = Object.keys(this.prototype._customGetters).length;\n    this.prototype._hasCustomSetters = Object.keys(this.prototype._customSetters).length;\n    for (const key of Object.keys(attributeManipulation)) {\n      if (Object.prototype.hasOwnProperty.call(Model.prototype, key)) {\n        this.sequelize.log(`Not overriding built-in method from model attribute: ${key}`);\n        continue;\n      }\n      Object.defineProperty(this.prototype, key, attributeManipulation[key]);\n    }\n    this.prototype.rawAttributes = this.rawAttributes;\n    this.prototype._isAttribute = (key) => Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes, key);\n    this.primaryKeyAttributes = Object.keys(this.primaryKeys);\n    this.primaryKeyAttribute = this.primaryKeyAttributes[0];\n    if (this.primaryKeyAttribute) {\n      this.primaryKeyField = this.rawAttributes[this.primaryKeyAttribute].field || this.primaryKeyAttribute;\n    }\n    this._hasPrimaryKeys = this.primaryKeyAttributes.length > 0;\n    this._isPrimaryKey = (key) => this.primaryKeyAttributes.includes(key);\n    this._attributeManipulation = attributeManipulation;\n  }\n  static removeAttribute(attribute) {\n    delete this.rawAttributes[attribute];\n    this.refreshAttributes();\n  }\n  static async sync(options) {\n    options = __spreadValues(__spreadValues({}, this.options), options);\n    options.hooks = options.hooks === void 0 ? true : !!options.hooks;\n    const attributes = this.tableAttributes;\n    const rawAttributes = this.fieldRawAttributesMap;\n    if (options.hooks) {\n      await this.runHooks(\"beforeSync\", options);\n    }\n    const tableName = this.getTableName(options);\n    let tableExists;\n    if (options.force) {\n      await this.drop(options);\n      tableExists = false;\n    } else {\n      tableExists = await this.queryInterface.tableExists(tableName, options);\n    }\n    if (!tableExists) {\n      await this.queryInterface.createTable(tableName, attributes, options, this);\n    } else {\n      await this.queryInterface.ensureEnums(tableName, attributes, options, this);\n    }\n    if (tableExists && options.alter) {\n      const tableInfos = await Promise.all([\n        this.queryInterface.describeTable(tableName, options),\n        this.queryInterface.getForeignKeyReferencesForTable(tableName, options)\n      ]);\n      const columns = tableInfos[0];\n      const foreignKeyReferences = tableInfos[1];\n      const removedConstraints = {};\n      for (const columnName in attributes) {\n        if (!Object.prototype.hasOwnProperty.call(attributes, columnName))\n          continue;\n        if (!columns[columnName] && !columns[attributes[columnName].field]) {\n          await this.queryInterface.addColumn(tableName, attributes[columnName].field || columnName, attributes[columnName], options);\n        }\n      }\n      if (options.alter === true || typeof options.alter === \"object\" && options.alter.drop !== false) {\n        for (const columnName in columns) {\n          if (!Object.prototype.hasOwnProperty.call(columns, columnName))\n            continue;\n          const currentAttribute = rawAttributes[columnName];\n          if (!currentAttribute) {\n            await this.queryInterface.removeColumn(tableName, columnName, options);\n            continue;\n          }\n          if (currentAttribute.primaryKey)\n            continue;\n          const references = currentAttribute.references;\n          if (currentAttribute.references) {\n            const database = this.sequelize.config.database;\n            const schema = this.sequelize.config.schema;\n            for (const foreignKeyReference of foreignKeyReferences) {\n              const constraintName = foreignKeyReference.constraintName;\n              if (!!constraintName && foreignKeyReference.tableCatalog === database && (schema ? foreignKeyReference.tableSchema === schema : true) && foreignKeyReference.referencedTableName === references.model && foreignKeyReference.referencedColumnName === references.key && (schema ? foreignKeyReference.referencedTableSchema === schema : true) && !removedConstraints[constraintName]) {\n                await this.queryInterface.removeConstraint(tableName, constraintName, options);\n                removedConstraints[constraintName] = true;\n              }\n            }\n          }\n          await this.queryInterface.changeColumn(tableName, columnName, currentAttribute, options);\n        }\n      }\n    }\n    const existingIndexes = await this.queryInterface.showIndex(tableName, options);\n    const missingIndexes = this._indexes.filter((item1) => !existingIndexes.some((item2) => item1.name === item2.name)).sort((index1, index2) => {\n      if (this.sequelize.options.dialect === \"postgres\") {\n        if (index1.concurrently === true)\n          return 1;\n        if (index2.concurrently === true)\n          return -1;\n      }\n      return 0;\n    });\n    for (const index of missingIndexes) {\n      await this.queryInterface.addIndex(tableName, __spreadValues(__spreadValues({}, options), index));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterSync\", options);\n    }\n    return this;\n  }\n  static async drop(options) {\n    return await this.queryInterface.dropTable(this.getTableName(options), options);\n  }\n  static async dropSchema(schema) {\n    return await this.queryInterface.dropSchema(schema);\n  }\n  static schema(schema, options) {\n    const clone = class extends this {\n    };\n    Object.defineProperty(clone, \"name\", { value: this.name });\n    clone._schema = schema;\n    if (options) {\n      if (typeof options === \"string\") {\n        clone._schemaDelimiter = options;\n      } else if (options.schemaDelimiter) {\n        clone._schemaDelimiter = options.schemaDelimiter;\n      }\n    }\n    return clone;\n  }\n  static getTableName() {\n    return this.queryGenerator.addSchema(this);\n  }\n  static unscoped() {\n    return this.scope();\n  }\n  static addScope(name, scope, options) {\n    options = __spreadValues({ override: false }, options);\n    if ((name === \"defaultScope\" && Object.keys(this.options.defaultScope).length > 0 || name in this.options.scopes) && options.override === false) {\n      throw new Error(`The scope ${name} already exists. Pass { override: true } as options to silence this error`);\n    }\n    if (name === \"defaultScope\") {\n      this.options.defaultScope = this._scope = scope;\n    } else {\n      this.options.scopes[name] = scope;\n    }\n  }\n  static scope(option) {\n    const self = class extends this {\n    };\n    let scope;\n    let scopeName;\n    Object.defineProperty(self, \"name\", { value: this.name });\n    self._scope = {};\n    self._scopeNames = [];\n    self.scoped = true;\n    if (!option) {\n      return self;\n    }\n    const options = _.flatten(arguments);\n    for (const option2 of options) {\n      scope = null;\n      scopeName = null;\n      if (_.isPlainObject(option2)) {\n        if (option2.method) {\n          if (Array.isArray(option2.method) && !!self.options.scopes[option2.method[0]]) {\n            scopeName = option2.method[0];\n            scope = self.options.scopes[scopeName].apply(self, option2.method.slice(1));\n          } else if (self.options.scopes[option2.method]) {\n            scopeName = option2.method;\n            scope = self.options.scopes[scopeName].apply(self);\n          }\n        } else {\n          scope = option2;\n        }\n      } else if (option2 === \"defaultScope\" && _.isPlainObject(self.options.defaultScope)) {\n        scope = self.options.defaultScope;\n      } else {\n        scopeName = option2;\n        scope = self.options.scopes[scopeName];\n        if (typeof scope === \"function\") {\n          scope = scope();\n        }\n      }\n      if (scope) {\n        this._conformIncludes(scope, this);\n        this._assignOptions(self._scope, Utils.cloneDeep(scope));\n        self._scopeNames.push(scopeName ? scopeName : \"defaultScope\");\n      } else {\n        throw new sequelizeErrors.SequelizeScopeError(`Invalid scope ${scopeName} called.`);\n      }\n    }\n    return self;\n  }\n  static async findAll(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new sequelizeErrors.QueryError(\"The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    if (options !== void 0 && options.attributes) {\n      if (!Array.isArray(options.attributes) && !_.isPlainObject(options.attributes)) {\n        throw new sequelizeErrors.QueryError(\"The attributes option must be an array of column names or an object\");\n      }\n    }\n    this.warnOnInvalidOptions(options, Object.keys(this.rawAttributes));\n    const tableNames = {};\n    tableNames[this.getTableName(options)] = true;\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    _.defaults(options, { hooks: true });\n    options.rejectOnEmpty = Object.prototype.hasOwnProperty.call(options, \"rejectOnEmpty\") ? options.rejectOnEmpty : this.options.rejectOnEmpty;\n    this._injectScope(options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFind\", options);\n    }\n    this._conformIncludes(options, this);\n    this._expandAttributes(options);\n    this._expandIncludeAll(options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFindAfterExpandIncludeAll\", options);\n    }\n    options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    if (options.include) {\n      options.hasJoin = true;\n      this._validateIncludedElements(options, tableNames);\n      if (options.attributes && !options.raw && this.primaryKeyAttribute && !options.attributes.includes(this.primaryKeyAttribute) && (!options.group || !options.hasSingleAssociation || options.hasMultiAssociation)) {\n        options.attributes = [this.primaryKeyAttribute].concat(options.attributes);\n      }\n    }\n    if (!options.attributes) {\n      options.attributes = Object.keys(this.rawAttributes);\n      options.originalAttributes = this._injectDependentVirtualAttributes(options.attributes);\n    }\n    this.options.whereCollection = options.where || null;\n    Utils.mapFinderOptions(options, this);\n    options = this._paranoidClause(this, options);\n    if (options.hooks) {\n      await this.runHooks(\"beforeFindAfterOptions\", options);\n    }\n    const selectOptions = __spreadProps(__spreadValues({}, options), { tableNames: Object.keys(tableNames) });\n    const results = await this.queryInterface.select(this, this.getTableName(selectOptions), selectOptions);\n    if (options.hooks) {\n      await this.runHooks(\"afterFind\", results, options);\n    }\n    if (_.isEmpty(results) && options.rejectOnEmpty) {\n      if (typeof options.rejectOnEmpty === \"function\") {\n        throw new options.rejectOnEmpty();\n      }\n      if (typeof options.rejectOnEmpty === \"object\") {\n        throw options.rejectOnEmpty;\n      }\n      throw new sequelizeErrors.EmptyResultError();\n    }\n    return await Model._findSeparate(results, options);\n  }\n  static warnOnInvalidOptions(options, validColumnNames) {\n    if (!_.isPlainObject(options)) {\n      return;\n    }\n    const unrecognizedOptions = Object.keys(options).filter((k) => !validQueryKeywords.has(k));\n    const unexpectedModelAttributes = _.intersection(unrecognizedOptions, validColumnNames);\n    if (!options.where && unexpectedModelAttributes.length > 0) {\n      logger.warn(`Model attributes (${unexpectedModelAttributes.join(\", \")}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`);\n    }\n  }\n  static _injectDependentVirtualAttributes(attributes) {\n    if (!this._hasVirtualAttributes)\n      return attributes;\n    if (!attributes || !Array.isArray(attributes))\n      return attributes;\n    for (const attribute of attributes) {\n      if (this._virtualAttributes.has(attribute) && this.rawAttributes[attribute].type.fields) {\n        attributes = attributes.concat(this.rawAttributes[attribute].type.fields);\n      }\n    }\n    attributes = _.uniq(attributes);\n    return attributes;\n  }\n  static async _findSeparate(results, options) {\n    if (!options.include || options.raw || !results)\n      return results;\n    const original = results;\n    if (options.plain)\n      results = [results];\n    if (!results.length)\n      return original;\n    await Promise.all(options.include.map(async (include) => {\n      if (!include.separate) {\n        return await Model._findSeparate(results.reduce((memo, result) => {\n          let associations = result.get(include.association.as);\n          if (!associations)\n            return memo;\n          if (!Array.isArray(associations))\n            associations = [associations];\n          for (let i = 0, len = associations.length; i !== len; ++i) {\n            memo.push(associations[i]);\n          }\n          return memo;\n        }, []), __spreadProps(__spreadValues({}, _.omit(options, \"include\", \"attributes\", \"order\", \"where\", \"limit\", \"offset\", \"plain\", \"scope\")), {\n          include: include.include || []\n        }));\n      }\n      const map = await include.association.get(results, __spreadValues(__spreadValues({}, _.omit(options, nonCascadingOptions)), _.omit(include, [\"parent\", \"association\", \"as\", \"originalAttributes\"])));\n      for (const result of results) {\n        result.set(include.association.as, map[result.get(include.association.sourceKey)], { raw: true });\n      }\n    }));\n    return original;\n  }\n  static async findByPk(param, options) {\n    if ([null, void 0].includes(param)) {\n      return null;\n    }\n    options = Utils.cloneDeep(options) || {};\n    if (typeof param === \"number\" || typeof param === \"bigint\" || typeof param === \"string\" || Buffer.isBuffer(param)) {\n      options.where = {\n        [this.primaryKeyAttribute]: param\n      };\n    } else {\n      throw new Error(`Argument passed to findByPk is invalid: ${param}`);\n    }\n    return await this.findOne(options);\n  }\n  static async findOne(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new Error(\"The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.limit === void 0) {\n      const uniqueSingleColumns = _.chain(this.uniqueKeys).values().filter((c) => c.fields.length === 1).map(\"column\").value();\n      if (!options.where || !_.some(options.where, (value, key) => (key === this.primaryKeyAttribute || uniqueSingleColumns.includes(key)) && (Utils.isPrimitive(value) || Buffer.isBuffer(value)))) {\n        options.limit = 1;\n      }\n    }\n    return await this.findAll(_.defaults(options, {\n      plain: true\n    }));\n  }\n  static async aggregate(attribute, aggregateFunction, options) {\n    options = Utils.cloneDeep(options);\n    const prevAttributes = options.attributes;\n    this._injectScope(options);\n    options.attributes = prevAttributes;\n    this._conformIncludes(options, this);\n    if (options.include) {\n      this._expandIncludeAll(options);\n      this._validateIncludedElements(options);\n    }\n    const attrOptions = this.rawAttributes[attribute];\n    const field = attrOptions && attrOptions.field || attribute;\n    let aggregateColumn = this.sequelize.col(field);\n    if (options.distinct) {\n      aggregateColumn = this.sequelize.fn(\"DISTINCT\", aggregateColumn);\n    }\n    let { group } = options;\n    if (Array.isArray(group) && Array.isArray(group[0])) {\n      noDoubleNestedGroup();\n      group = _.flatten(group);\n    }\n    options.attributes = _.unionBy(options.attributes, group, [[this.sequelize.fn(aggregateFunction, aggregateColumn), aggregateFunction]], (a) => Array.isArray(a) ? a[1] : a);\n    if (!options.dataType) {\n      if (attrOptions) {\n        options.dataType = attrOptions.type;\n      } else {\n        options.dataType = new DataTypes.FLOAT();\n      }\n    } else {\n      options.dataType = this.sequelize.normalizeDataType(options.dataType);\n    }\n    Utils.mapOptionFieldNames(options, this);\n    options = this._paranoidClause(this, options);\n    const value = await this.queryInterface.rawSelect(this.getTableName(options), options, aggregateFunction, this);\n    return value;\n  }\n  static async count(options) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { hooks: true });\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.raw = true;\n    if (options.hooks) {\n      await this.runHooks(\"beforeCount\", options);\n    }\n    let col = options.col || \"*\";\n    if (options.include) {\n      col = `${this.name}.${options.col || this.primaryKeyField}`;\n    }\n    if (options.distinct && col === \"*\") {\n      col = this.primaryKeyField;\n    }\n    options.plain = !options.group;\n    options.dataType = new DataTypes.INTEGER();\n    options.includeIgnoreAttributes = false;\n    options.limit = null;\n    options.offset = null;\n    options.order = null;\n    const result = await this.aggregate(col, \"count\", options);\n    if (Array.isArray(result)) {\n      return result.map((item) => __spreadProps(__spreadValues({}, item), {\n        count: Number(item.count)\n      }));\n    }\n    return result;\n  }\n  static async findAndCountAll(options) {\n    if (options !== void 0 && !_.isPlainObject(options)) {\n      throw new Error(\"The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value\");\n    }\n    const countOptions = Utils.cloneDeep(options);\n    if (countOptions.attributes) {\n      countOptions.attributes = void 0;\n    }\n    const [count, rows] = await Promise.all([\n      this.count(countOptions),\n      this.findAll(options)\n    ]);\n    return {\n      count,\n      rows: count === 0 ? [] : rows\n    };\n  }\n  static async max(field, options) {\n    return await this.aggregate(field, \"max\", options);\n  }\n  static async min(field, options) {\n    return await this.aggregate(field, \"min\", options);\n  }\n  static async sum(field, options) {\n    return await this.aggregate(field, \"sum\", options);\n  }\n  static build(values, options) {\n    if (Array.isArray(values)) {\n      return this.bulkBuild(values, options);\n    }\n    return new this(values, options);\n  }\n  static bulkBuild(valueSets, options) {\n    options = __spreadValues({ isNewRecord: true }, options);\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n    if (options.attributes) {\n      options.attributes = options.attributes.map((attribute) => Array.isArray(attribute) ? attribute[1] : attribute);\n    }\n    return valueSets.map((values) => this.build(values, options));\n  }\n  static async create(values, options) {\n    options = Utils.cloneDeep(options || {});\n    return await this.build(values, {\n      isNewRecord: true,\n      attributes: options.fields,\n      include: options.include,\n      raw: options.raw,\n      silent: options.silent\n    }).save(options);\n  }\n  static async findOrBuild(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findOrBuild. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)\");\n    }\n    let values;\n    let instance = await this.findOne(options);\n    if (instance === null) {\n      values = __spreadValues({}, options.defaults);\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n      instance = this.build(values, options);\n      return [instance, true];\n    }\n    return [instance, false];\n  }\n  static async findOrCreate(options) {\n    if (!options || !options.where || arguments.length > 1) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findOrCreate. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)\");\n    }\n    options = __spreadValues({}, options);\n    if (options.defaults) {\n      const defaults = Object.keys(options.defaults);\n      const unknownDefaults = defaults.filter((name) => !this.rawAttributes[name]);\n      if (unknownDefaults.length) {\n        logger.warn(`Unknown attributes (${unknownDefaults}) passed to defaults option of findOrCreate`);\n      }\n    }\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const internalTransaction = !options.transaction;\n    let values;\n    let transaction;\n    try {\n      const t = await this.sequelize.transaction(options);\n      transaction = t;\n      options.transaction = t;\n      const found = await this.findOne(Utils.defaults({ transaction }, options));\n      if (found !== null) {\n        return [found, false];\n      }\n      values = __spreadValues({}, options.defaults);\n      if (_.isPlainObject(options.where)) {\n        values = Utils.defaults(values, options.where);\n      }\n      options.exception = true;\n      options.returning = true;\n      try {\n        const created = await this.create(values, options);\n        if (created.get(this.primaryKeyAttribute, { raw: true }) === null) {\n          throw new sequelizeErrors.UniqueConstraintError();\n        }\n        return [created, true];\n      } catch (err) {\n        if (!(err instanceof sequelizeErrors.UniqueConstraintError))\n          throw err;\n        const flattenedWhere = Utils.flattenObjectDeep(options.where);\n        const flattenedWhereKeys = Object.keys(flattenedWhere).map((name) => _.last(name.split(\".\")));\n        const whereFields = flattenedWhereKeys.map((name) => _.get(this.rawAttributes, `${name}.field`, name));\n        const defaultFields = options.defaults && Object.keys(options.defaults).filter((name) => this.rawAttributes[name]).map((name) => this.rawAttributes[name].field || name);\n        const errFieldKeys = Object.keys(err.fields);\n        const errFieldsWhereIntersects = Utils.intersects(errFieldKeys, whereFields);\n        if (defaultFields && !errFieldsWhereIntersects && Utils.intersects(errFieldKeys, defaultFields)) {\n          throw err;\n        }\n        if (errFieldsWhereIntersects) {\n          _.each(err.fields, (value, key) => {\n            const name = this.fieldRawAttributesMap[key].fieldName;\n            if (value.toString() !== options.where[name].toString()) {\n              throw new Error(`${this.name}#findOrCreate: value used for ${name} was not equal for both the find and the create calls, '${options.where[name]}' vs '${value}'`);\n            }\n          });\n        }\n        const otherCreated = await this.findOne(Utils.defaults({\n          transaction: internalTransaction ? null : transaction\n        }, options));\n        if (otherCreated === null)\n          throw err;\n        return [otherCreated, false];\n      }\n    } finally {\n      if (internalTransaction && transaction) {\n        await transaction.commit();\n      }\n    }\n  }\n  static async findCreateFind(options) {\n    if (!options || !options.where) {\n      throw new Error(\"Missing where attribute in the options parameter passed to findCreateFind.\");\n    }\n    let values = __spreadValues({}, options.defaults);\n    if (_.isPlainObject(options.where)) {\n      values = Utils.defaults(values, options.where);\n    }\n    const found = await this.findOne(options);\n    if (found)\n      return [found, false];\n    try {\n      const createOptions = __spreadValues({}, options);\n      if (this.sequelize.options.dialect === \"postgres\" && options.transaction) {\n        createOptions.ignoreDuplicates = true;\n      }\n      const created = await this.create(values, createOptions);\n      return [created, true];\n    } catch (err) {\n      if (!(err instanceof sequelizeErrors.UniqueConstraintError || err instanceof sequelizeErrors.EmptyResultError)) {\n        throw err;\n      }\n      const foundAgain = await this.findOne(options);\n      return [foundAgain, false];\n    }\n  }\n  static async upsert(values, options) {\n    options = __spreadValues({\n      hooks: true,\n      returning: true,\n      validate: true\n    }, Utils.cloneDeep(options));\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const createdAtAttr = this._timestampAttributes.createdAt;\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    const hasPrimary = this.primaryKeyField in values || this.primaryKeyAttribute in values;\n    const instance = this.build(values);\n    options.model = this;\n    options.instance = instance;\n    const changed = Array.from(instance._changed);\n    if (!options.fields) {\n      options.fields = changed;\n    }\n    if (options.validate) {\n      await instance.validate(options);\n    }\n    const updatedDataValues = _.pick(instance.dataValues, changed);\n    const insertValues = Utils.mapValueFieldNames(instance.dataValues, Object.keys(instance.rawAttributes), this);\n    const updateValues = Utils.mapValueFieldNames(updatedDataValues, options.fields, this);\n    const now = Utils.now(this.sequelize.options.dialect);\n    if (createdAtAttr && !insertValues[createdAtAttr]) {\n      const field = this.rawAttributes[createdAtAttr].field || createdAtAttr;\n      insertValues[field] = this._getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (updatedAtAttr && !insertValues[updatedAtAttr]) {\n      const field = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n      insertValues[field] = updateValues[field] = this._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n    if (this.sequelize.options.dialect === \"db2\") {\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(insertValues, this.rawAttributes, this.uniqno);\n    }\n    if (!hasPrimary && this.primaryKeyAttribute && !this.rawAttributes[this.primaryKeyAttribute].defaultValue) {\n      delete insertValues[this.primaryKeyField];\n      delete updateValues[this.primaryKeyField];\n    }\n    if (options.hooks) {\n      await this.runHooks(\"beforeUpsert\", values, options);\n    }\n    const result = await this.queryInterface.upsert(this.getTableName(options), insertValues, updateValues, instance.where(), options);\n    const [record] = result;\n    record.isNewRecord = false;\n    if (options.hooks) {\n      await this.runHooks(\"afterUpsert\", result, options);\n      return result;\n    }\n    return result;\n  }\n  static async bulkCreate(records, options = {}) {\n    if (!records.length) {\n      return [];\n    }\n    const dialect = this.sequelize.options.dialect;\n    const now = Utils.now(this.sequelize.options.dialect);\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.model = this;\n    if (!options.includeValidated) {\n      this._conformIncludes(options, this);\n      if (options.include) {\n        this._expandIncludeAll(options);\n        this._validateIncludedElements(options);\n      }\n    }\n    const instances = records.map((values) => this.build(values, { isNewRecord: true, include: options.include }));\n    const recursiveBulkCreate = async (instances2, options2) => {\n      options2 = __spreadValues({\n        validate: false,\n        hooks: true,\n        individualHooks: false,\n        ignoreDuplicates: false\n      }, options2);\n      if (options2.returning === void 0) {\n        if (options2.association) {\n          options2.returning = false;\n        } else {\n          options2.returning = true;\n        }\n      }\n      if (options2.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.ignoreDuplicates && !this.sequelize.dialect.supports.inserts.onConflictDoNothing) {\n        throw new Error(`${dialect} does not support the ignoreDuplicates option.`);\n      }\n      if (options2.updateOnDuplicate && (dialect !== \"mysql\" && dialect !== \"mariadb\" && dialect !== \"sqlite\" && dialect !== \"postgres\")) {\n        throw new Error(`${dialect} does not support the updateOnDuplicate option.`);\n      }\n      const model = options2.model;\n      options2.fields = options2.fields || Object.keys(model.rawAttributes);\n      const createdAtAttr = model._timestampAttributes.createdAt;\n      const updatedAtAttr = model._timestampAttributes.updatedAt;\n      if (options2.updateOnDuplicate !== void 0) {\n        if (Array.isArray(options2.updateOnDuplicate) && options2.updateOnDuplicate.length) {\n          options2.updateOnDuplicate = _.intersection(_.without(Object.keys(model.tableAttributes), createdAtAttr), options2.updateOnDuplicate);\n        } else {\n          throw new Error(\"updateOnDuplicate option only supports non-empty array.\");\n        }\n      }\n      if (options2.hooks) {\n        await model.runHooks(\"beforeBulkCreate\", instances2, options2);\n      }\n      if (options2.validate) {\n        const errors = [];\n        const validateOptions = __spreadValues({}, options2);\n        validateOptions.hooks = options2.individualHooks;\n        await Promise.all(instances2.map(async (instance) => {\n          try {\n            await instance.validate(validateOptions);\n          } catch (err) {\n            errors.push(new sequelizeErrors.BulkRecordError(err, instance));\n          }\n        }));\n        delete options2.skip;\n        if (errors.length) {\n          throw new sequelizeErrors.AggregateError(errors);\n        }\n      }\n      if (options2.individualHooks) {\n        await Promise.all(instances2.map(async (instance) => {\n          const individualOptions = __spreadProps(__spreadValues({}, options2), {\n            validate: false,\n            hooks: true\n          });\n          delete individualOptions.fields;\n          delete individualOptions.individualHooks;\n          delete individualOptions.ignoreDuplicates;\n          await instance.save(individualOptions);\n        }));\n      } else {\n        if (options2.include && options2.include.length) {\n          await Promise.all(options2.include.filter((include) => include.association instanceof BelongsTo).map(async (include) => {\n            const associationInstances = [];\n            const associationInstanceIndexToInstanceMap = [];\n            for (const instance of instances2) {\n              const associationInstance = instance.get(include.as);\n              if (associationInstance) {\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n            if (!associationInstances.length) {\n              return;\n            }\n            const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n              transaction: options2.transaction,\n              logging: options2.logging\n            }).value();\n            const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);\n            for (const idx in createdAssociationInstances) {\n              const associationInstance = createdAssociationInstances[idx];\n              const instance = associationInstanceIndexToInstanceMap[idx];\n              await include.association.set(instance, associationInstance, { save: false, logging: options2.logging });\n            }\n          }));\n        }\n        records = instances2.map((instance) => {\n          const values = instance.dataValues;\n          if (createdAtAttr && !values[createdAtAttr]) {\n            values[createdAtAttr] = now;\n            if (!options2.fields.includes(createdAtAttr)) {\n              options2.fields.push(createdAtAttr);\n            }\n          }\n          if (updatedAtAttr && !values[updatedAtAttr]) {\n            values[updatedAtAttr] = now;\n            if (!options2.fields.includes(updatedAtAttr)) {\n              options2.fields.push(updatedAtAttr);\n            }\n          }\n          const out = Utils.mapValueFieldNames(values, options2.fields, model);\n          for (const key of model._virtualAttributes) {\n            delete out[key];\n          }\n          return out;\n        });\n        const fieldMappedAttributes = {};\n        for (const attr in model.tableAttributes) {\n          fieldMappedAttributes[model.rawAttributes[attr].field || attr] = model.rawAttributes[attr];\n        }\n        if (options2.updateOnDuplicate) {\n          options2.updateOnDuplicate = options2.updateOnDuplicate.map((attr) => model.rawAttributes[attr].field || attr);\n          if (options2.conflictAttributes) {\n            options2.upsertKeys = options2.conflictAttributes.map((attrName) => model.rawAttributes[attrName].field || attrName);\n          } else {\n            const upsertKeys = [];\n            for (const i of model._indexes) {\n              if (i.unique && !i.where) {\n                upsertKeys.push(...i.fields);\n              }\n            }\n            const firstUniqueKey = Object.values(model.uniqueKeys).find((c) => c.fields.length > 0);\n            if (firstUniqueKey && firstUniqueKey.fields) {\n              upsertKeys.push(...firstUniqueKey.fields);\n            }\n            options2.upsertKeys = upsertKeys.length > 0 ? upsertKeys : Object.values(model.primaryKeys).map((x) => x.field);\n          }\n        }\n        if (options2.returning && Array.isArray(options2.returning)) {\n          options2.returning = options2.returning.map((attr) => _.get(model.rawAttributes[attr], \"field\", attr));\n        }\n        const results = await model.queryInterface.bulkInsert(model.getTableName(options2), records, options2, fieldMappedAttributes);\n        if (Array.isArray(results)) {\n          results.forEach((result, i) => {\n            const instance = instances2[i];\n            for (const key in result) {\n              if (!instance || key === model.primaryKeyAttribute && instance.get(model.primaryKeyAttribute) && [\"mysql\", \"mariadb\", \"sqlite\"].includes(dialect)) {\n                continue;\n              }\n              if (Object.prototype.hasOwnProperty.call(result, key)) {\n                const record = result[key];\n                const attr = _.find(model.rawAttributes, (attribute) => attribute.fieldName === key || attribute.field === key);\n                instance.dataValues[attr && attr.fieldName || key] = record;\n              }\n            }\n          });\n        }\n      }\n      if (options2.include && options2.include.length) {\n        await Promise.all(options2.include.filter((include) => !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include) => {\n          const associationInstances = [];\n          const associationInstanceIndexToInstanceMap = [];\n          for (const instance of instances2) {\n            let associated = instance.get(include.as);\n            if (!Array.isArray(associated))\n              associated = [associated];\n            for (const associationInstance of associated) {\n              if (associationInstance) {\n                if (!(include.association instanceof BelongsToMany)) {\n                  associationInstance.set(include.association.foreignKey, instance.get(include.association.sourceKey || instance.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n                  Object.assign(associationInstance, include.association.scope);\n                }\n                associationInstances.push(associationInstance);\n                associationInstanceIndexToInstanceMap.push(instance);\n              }\n            }\n          }\n          if (!associationInstances.length) {\n            return;\n          }\n          const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n            transaction: options2.transaction,\n            logging: options2.logging\n          }).value();\n          const createdAssociationInstances = await recursiveBulkCreate(associationInstances, includeOptions);\n          if (include.association instanceof BelongsToMany) {\n            const valueSets = [];\n            for (const idx in createdAssociationInstances) {\n              const associationInstance = createdAssociationInstances[idx];\n              const instance = associationInstanceIndexToInstanceMap[idx];\n              const values = __spreadValues({\n                [include.association.foreignKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true }),\n                [include.association.otherKey]: associationInstance.get(associationInstance.constructor.primaryKeyAttribute, { raw: true })\n              }, include.association.through.scope);\n              if (associationInstance[include.association.through.model.name]) {\n                for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                  if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof associationInstance[include.association.through.model.name][attr] === \"undefined\") {\n                    continue;\n                  }\n                  values[attr] = associationInstance[include.association.through.model.name][attr];\n                }\n              }\n              valueSets.push(values);\n            }\n            const throughOptions = _(Utils.cloneDeep(include)).omit([\"association\", \"attributes\"]).defaults({\n              transaction: options2.transaction,\n              logging: options2.logging\n            }).value();\n            throughOptions.model = include.association.throughModel;\n            const throughInstances = include.association.throughModel.bulkBuild(valueSets, throughOptions);\n            await recursiveBulkCreate(throughInstances, throughOptions);\n          }\n        }));\n      }\n      instances2.forEach((instance) => {\n        for (const attr in model.rawAttributes) {\n          if (model.rawAttributes[attr].field && instance.dataValues[model.rawAttributes[attr].field] !== void 0 && model.rawAttributes[attr].field !== attr) {\n            instance.dataValues[attr] = instance.dataValues[model.rawAttributes[attr].field];\n            delete instance.dataValues[model.rawAttributes[attr].field];\n          }\n          instance._previousDataValues[attr] = instance.dataValues[attr];\n          instance.changed(attr, false);\n        }\n        instance.isNewRecord = false;\n      });\n      if (options2.hooks) {\n        await model.runHooks(\"afterBulkCreate\", instances2, options2);\n      }\n      return instances2;\n    };\n    return await recursiveBulkCreate(instances, options);\n  }\n  static async truncate(options) {\n    options = Utils.cloneDeep(options) || {};\n    options.truncate = true;\n    return await this.destroy(options);\n  }\n  static async destroy(options) {\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    this._injectScope(options);\n    if (!options || !(options.where || options.truncate)) {\n      throw new Error(\"Missing where or truncate attribute in the options parameter of model.destroy.\");\n    }\n    if (!options.truncate && !_.isPlainObject(options.where) && !Array.isArray(options.where) && !(options.where instanceof Utils.SequelizeMethod)) {\n      throw new Error(\"Expected plain object, array or sequelize method in the options.where parameter of model.destroy.\");\n    }\n    options = _.defaults(options, {\n      hooks: true,\n      individualHooks: false,\n      force: false,\n      cascade: false,\n      restartIdentity: false\n    });\n    options.type = QueryTypes.BULKDELETE;\n    Utils.mapOptionFieldNames(options, this);\n    options.model = this;\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkDestroy\", options);\n    }\n    let instances;\n    if (options.individualHooks) {\n      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark });\n      await Promise.all(instances.map((instance) => this.runHooks(\"beforeDestroy\", instance, options)));\n    }\n    let result;\n    if (this._timestampAttributes.deletedAt && !options.force) {\n      options.type = QueryTypes.BULKUPDATE;\n      const attrValueHash = {};\n      const deletedAtAttribute = this.rawAttributes[this._timestampAttributes.deletedAt];\n      const field = this.rawAttributes[this._timestampAttributes.deletedAt].field;\n      const where = {\n        [field]: Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null\n      };\n      attrValueHash[field] = Utils.now(this.sequelize.options.dialect);\n      result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, Object.assign(where, options.where), options, this.rawAttributes);\n    } else {\n      result = await this.queryInterface.bulkDelete(this.getTableName(options), options.where, options, this);\n    }\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterDestroy\", instance, options)));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkDestroy\", options);\n    }\n    return result;\n  }\n  static async restore(options) {\n    if (!this._timestampAttributes.deletedAt)\n      throw new Error(\"Model is not paranoid\");\n    options = __spreadValues({\n      hooks: true,\n      individualHooks: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options.type = QueryTypes.RAW;\n    options.model = this;\n    Utils.mapOptionFieldNames(options, this);\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkRestore\", options);\n    }\n    let instances;\n    if (options.individualHooks) {\n      instances = await this.findAll({ where: options.where, transaction: options.transaction, logging: options.logging, benchmark: options.benchmark, paranoid: false });\n      await Promise.all(instances.map((instance) => this.runHooks(\"beforeRestore\", instance, options)));\n    }\n    const attrValueHash = {};\n    const deletedAtCol = this._timestampAttributes.deletedAt;\n    const deletedAtAttribute = this.rawAttributes[deletedAtCol];\n    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    attrValueHash[deletedAtAttribute.field || deletedAtCol] = deletedAtDefaultValue;\n    options.omitNull = false;\n    const result = await this.queryInterface.bulkUpdate(this.getTableName(options), attrValueHash, options.where, options, this.rawAttributes);\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterRestore\", instance, options)));\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkRestore\", options);\n    }\n    return result;\n  }\n  static async update(values, options) {\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n    options = this._paranoidClause(this, _.defaults(options, {\n      validate: true,\n      hooks: true,\n      individualHooks: false,\n      returning: false,\n      force: false,\n      sideEffects: true\n    }));\n    options.type = QueryTypes.BULKUPDATE;\n    values = _.omitBy(values, (value) => value === void 0);\n    if (options.fields && options.fields instanceof Array) {\n      for (const key of Object.keys(values)) {\n        if (!options.fields.includes(key)) {\n          delete values[key];\n        }\n      }\n    } else {\n      const updatedAtAttr = this._timestampAttributes.updatedAt;\n      options.fields = _.intersection(Object.keys(values), Object.keys(this.tableAttributes));\n      if (updatedAtAttr && !options.fields.includes(updatedAtAttr)) {\n        options.fields.push(updatedAtAttr);\n      }\n    }\n    if (this._timestampAttributes.updatedAt && !options.silent) {\n      values[this._timestampAttributes.updatedAt] = this._getDefaultTimestamp(this._timestampAttributes.updatedAt) || Utils.now(this.sequelize.options.dialect);\n    }\n    options.model = this;\n    let valuesUse;\n    if (options.validate) {\n      const build = this.build(values);\n      build.set(this._timestampAttributes.updatedAt, values[this._timestampAttributes.updatedAt], { raw: true });\n      if (options.sideEffects) {\n        Object.assign(values, _.pick(build.get(), build.changed()));\n        options.fields = _.union(options.fields, Object.keys(values));\n      }\n      options.skip = _.difference(Object.keys(this.rawAttributes), Object.keys(values));\n      const attributes = await build.validate(options);\n      options.skip = void 0;\n      if (attributes && attributes.dataValues) {\n        values = _.pick(attributes.dataValues, Object.keys(values));\n      }\n    }\n    if (options.hooks) {\n      options.attributes = values;\n      await this.runHooks(\"beforeBulkUpdate\", options);\n      values = options.attributes;\n      delete options.attributes;\n    }\n    valuesUse = values;\n    let instances;\n    let updateDoneRowByRow = false;\n    if (options.individualHooks) {\n      instances = await this.findAll({\n        where: options.where,\n        transaction: options.transaction,\n        logging: options.logging,\n        benchmark: options.benchmark,\n        paranoid: options.paranoid\n      });\n      if (instances.length) {\n        let changedValues;\n        let different = false;\n        instances = await Promise.all(instances.map(async (instance) => {\n          Object.assign(instance.dataValues, values);\n          _.forIn(valuesUse, (newValue, attr) => {\n            if (newValue !== instance._previousDataValues[attr]) {\n              instance.setDataValue(attr, newValue);\n            }\n          });\n          await this.runHooks(\"beforeUpdate\", instance, options);\n          if (!different) {\n            const thisChangedValues = {};\n            _.forIn(instance.dataValues, (newValue, attr) => {\n              if (newValue !== instance._previousDataValues[attr]) {\n                thisChangedValues[attr] = newValue;\n              }\n            });\n            if (!changedValues) {\n              changedValues = thisChangedValues;\n            } else {\n              different = !_.isEqual(changedValues, thisChangedValues);\n            }\n          }\n          return instance;\n        }));\n        if (!different) {\n          const keys = Object.keys(changedValues);\n          if (keys.length) {\n            valuesUse = changedValues;\n            options.fields = _.union(options.fields, keys);\n          }\n        } else {\n          instances = await Promise.all(instances.map(async (instance) => {\n            const individualOptions = __spreadProps(__spreadValues({}, options), {\n              hooks: false,\n              validate: false\n            });\n            delete individualOptions.individualHooks;\n            return instance.save(individualOptions);\n          }));\n          updateDoneRowByRow = true;\n        }\n      }\n    }\n    let result;\n    if (updateDoneRowByRow) {\n      result = [instances.length, instances];\n    } else if (_.isEmpty(valuesUse) || Object.keys(valuesUse).length === 1 && valuesUse[this._timestampAttributes.updatedAt]) {\n      result = [0];\n    } else {\n      valuesUse = Utils.mapValueFieldNames(valuesUse, options.fields, this);\n      options = Utils.mapOptionFieldNames(options, this);\n      options.hasTrigger = this.options ? this.options.hasTrigger : false;\n      const affectedRows = await this.queryInterface.bulkUpdate(this.getTableName(options), valuesUse, options.where, options, this.tableAttributes);\n      if (options.returning) {\n        result = [affectedRows.length, affectedRows];\n        instances = affectedRows;\n      } else {\n        result = [affectedRows];\n      }\n    }\n    if (options.individualHooks) {\n      await Promise.all(instances.map((instance) => this.runHooks(\"afterUpdate\", instance, options)));\n      result[1] = instances;\n    }\n    if (options.hooks) {\n      options.attributes = values;\n      await this.runHooks(\"afterBulkUpdate\", options);\n      delete options.attributes;\n    }\n    return result;\n  }\n  static async describe(schema, options) {\n    return await this.queryInterface.describeTable(this.tableName, __spreadValues({ schema: schema || this._schema || void 0 }, options));\n  }\n  static _getDefaultTimestamp(attr) {\n    if (!!this.rawAttributes[attr] && !!this.rawAttributes[attr].defaultValue) {\n      return Utils.toDefaultValue(this.rawAttributes[attr].defaultValue, this.sequelize.options.dialect);\n    }\n    return void 0;\n  }\n  static _expandAttributes(options) {\n    if (!_.isPlainObject(options.attributes)) {\n      return;\n    }\n    let attributes = Object.keys(this.rawAttributes);\n    if (options.attributes.exclude) {\n      attributes = attributes.filter((elem) => !options.attributes.exclude.includes(elem));\n    }\n    if (options.attributes.include) {\n      attributes = attributes.concat(options.attributes.include);\n    }\n    options.attributes = attributes;\n  }\n  static _injectScope(options) {\n    const scope = Utils.cloneDeep(this._scope);\n    this._defaultsOptions(options, scope);\n  }\n  static [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.name;\n  }\n  static hasAlias(alias) {\n    return Object.prototype.hasOwnProperty.call(this.associations, alias);\n  }\n  static async increment(fields, options) {\n    options = options || {};\n    if (typeof fields === \"string\")\n      fields = [fields];\n    if (Array.isArray(fields)) {\n      fields = fields.map((f) => {\n        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {\n          return this.rawAttributes[f].field;\n        }\n        return f;\n      });\n    } else if (fields && typeof fields === \"object\") {\n      fields = Object.keys(fields).reduce((rawFields, f) => {\n        if (this.rawAttributes[f] && this.rawAttributes[f].field && this.rawAttributes[f].field !== f) {\n          rawFields[this.rawAttributes[f].field] = fields[f];\n        } else {\n          rawFields[f] = fields[f];\n        }\n        return rawFields;\n      }, {});\n    }\n    this._injectScope(options);\n    this._optionsMustContainWhere(options);\n    options = Utils.defaults({}, options, {\n      by: 1,\n      where: {},\n      increment: true\n    });\n    const isSubtraction = !options.increment;\n    Utils.mapOptionFieldNames(options, this);\n    const where = __spreadValues({}, options.where);\n    let incrementAmountsByField = {};\n    if (Array.isArray(fields)) {\n      incrementAmountsByField = {};\n      for (const field of fields) {\n        incrementAmountsByField[field] = options.by;\n      }\n    } else {\n      incrementAmountsByField = fields;\n    }\n    if (this._versionAttribute) {\n      incrementAmountsByField[this._versionAttribute] = isSubtraction ? -1 : 1;\n    }\n    const extraAttributesToBeUpdated = {};\n    const updatedAtAttr = this._timestampAttributes.updatedAt;\n    if (!options.silent && updatedAtAttr && !incrementAmountsByField[updatedAtAttr]) {\n      const attrName = this.rawAttributes[updatedAtAttr].field || updatedAtAttr;\n      extraAttributesToBeUpdated[attrName] = this._getDefaultTimestamp(updatedAtAttr) || Utils.now(this.sequelize.options.dialect);\n    }\n    const tableName = this.getTableName(options);\n    let affectedRows;\n    if (isSubtraction) {\n      affectedRows = await this.queryInterface.decrement(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    } else {\n      affectedRows = await this.queryInterface.increment(this, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    }\n    if (options.returning) {\n      return [affectedRows, affectedRows.length];\n    }\n    return [affectedRows];\n  }\n  static async decrement(fields, options) {\n    return this.increment(fields, __spreadProps(__spreadValues({\n      by: 1\n    }, options), {\n      increment: false\n    }));\n  }\n  static _optionsMustContainWhere(options) {\n    assert(options && options.where, \"Missing where attribute in the options parameter\");\n    assert(_.isPlainObject(options.where) || Array.isArray(options.where) || options.where instanceof Utils.SequelizeMethod, \"Expected plain object, array or sequelize method in the options.where parameter\");\n  }\n  where(checkVersion) {\n    const where = this.constructor.primaryKeyAttributes.reduce((result, attribute) => {\n      result[attribute] = this.get(attribute, { raw: true });\n      return result;\n    }, {});\n    if (_.size(where) === 0) {\n      return this.constructor.options.whereCollection;\n    }\n    const versionAttr = this.constructor._versionAttribute;\n    if (checkVersion && versionAttr) {\n      where[versionAttr] = this.get(versionAttr, { raw: true });\n    }\n    return Utils.mapWhereFieldNames(where, this.constructor);\n  }\n  toString() {\n    return `[object SequelizeInstance:${this.constructor.name}]`;\n  }\n  getDataValue(key) {\n    return this.dataValues[key];\n  }\n  setDataValue(key, value) {\n    const originalValue = this._previousDataValues[key];\n    if (!_.isEqual(value, originalValue)) {\n      this.changed(key, true);\n    }\n    this.dataValues[key] = value;\n  }\n  get(key, options) {\n    if (options === void 0 && typeof key === \"object\") {\n      options = key;\n      key = void 0;\n    }\n    options = options || {};\n    if (key) {\n      if (Object.prototype.hasOwnProperty.call(this._customGetters, key) && !options.raw) {\n        return this._customGetters[key].call(this, key, options);\n      }\n      if (options.plain && this._options.include && this._options.includeNames.includes(key)) {\n        if (Array.isArray(this.dataValues[key])) {\n          return this.dataValues[key].map((instance) => instance.get(options));\n        }\n        if (this.dataValues[key] instanceof Model) {\n          return this.dataValues[key].get(options);\n        }\n        return this.dataValues[key];\n      }\n      return this.dataValues[key];\n    }\n    if (this._hasCustomGetters || options.plain && this._options.include || options.clone) {\n      const values = {};\n      let _key;\n      if (this._hasCustomGetters) {\n        for (_key in this._customGetters) {\n          if (this._options.attributes && !this._options.attributes.includes(_key)) {\n            continue;\n          }\n          if (Object.prototype.hasOwnProperty.call(this._customGetters, _key)) {\n            values[_key] = this.get(_key, options);\n          }\n        }\n      }\n      for (_key in this.dataValues) {\n        if (!Object.prototype.hasOwnProperty.call(values, _key) && Object.prototype.hasOwnProperty.call(this.dataValues, _key)) {\n          values[_key] = this.get(_key, options);\n        }\n      }\n      return values;\n    }\n    return this.dataValues;\n  }\n  set(key, value, options) {\n    let values;\n    let originalValue;\n    if (typeof key === \"object\" && key !== null) {\n      values = key;\n      options = value || {};\n      if (options.reset) {\n        this.dataValues = {};\n        for (const key2 in values) {\n          this.changed(key2, false);\n        }\n      }\n      if (options.raw && !(this._options && this._options.include) && !(options && options.attributes) && !this.constructor._hasDateAttributes && !this.constructor._hasBooleanAttributes) {\n        if (Object.keys(this.dataValues).length) {\n          Object.assign(this.dataValues, values);\n        } else {\n          this.dataValues = values;\n        }\n        this._previousDataValues = __spreadValues({}, this.dataValues);\n      } else {\n        if (options.attributes) {\n          const setKeys = (data) => {\n            for (const k of data) {\n              if (values[k] === void 0) {\n                continue;\n              }\n              this.set(k, values[k], options);\n            }\n          };\n          setKeys(options.attributes);\n          if (this.constructor._hasVirtualAttributes) {\n            setKeys(this.constructor._virtualAttributes);\n          }\n          if (this._options.includeNames) {\n            setKeys(this._options.includeNames);\n          }\n        } else {\n          for (const key2 in values) {\n            this.set(key2, values[key2], options);\n          }\n        }\n        if (options.raw) {\n          this._previousDataValues = __spreadValues({}, this.dataValues);\n        }\n      }\n      return this;\n    }\n    if (!options)\n      options = {};\n    if (!options.raw) {\n      originalValue = this.dataValues[key];\n    }\n    if (!options.raw && this._customSetters[key]) {\n      this._customSetters[key].call(this, value, key);\n      const newValue = this.dataValues[key];\n      if (!_.isEqual(newValue, originalValue)) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n    } else {\n      if (this._options && this._options.include && this._options.includeNames.includes(key)) {\n        this._setInclude(key, value, options);\n        return this;\n      }\n      if (!options.raw) {\n        if (!this._isAttribute(key)) {\n          if (key.includes(\".\") && this.constructor._jsonAttributes.has(key.split(\".\")[0])) {\n            const previousNestedValue = Dottie.get(this.dataValues, key);\n            if (!_.isEqual(previousNestedValue, value)) {\n              Dottie.set(this.dataValues, key, value);\n              this.changed(key.split(\".\")[0], true);\n            }\n          }\n          return this;\n        }\n        if (this.constructor._hasPrimaryKeys && originalValue && this.constructor._isPrimaryKey(key)) {\n          return this;\n        }\n        if (!this.isNewRecord && this.constructor._hasReadOnlyAttributes && this.constructor._readOnlyAttributes.has(key)) {\n          return this;\n        }\n      }\n      if (!(value instanceof Utils.SequelizeMethod) && Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers, key)) {\n        value = this.constructor._dataTypeSanitizers[key].call(this, value, options);\n      }\n      if (!options.raw && (value instanceof Utils.SequelizeMethod || !(value instanceof Utils.SequelizeMethod) && this.constructor._dataTypeChanges[key] && this.constructor._dataTypeChanges[key].call(this, value, originalValue, options) || !this.constructor._dataTypeChanges[key] && !_.isEqual(value, originalValue))) {\n        this._previousDataValues[key] = originalValue;\n        this.changed(key, true);\n      }\n      this.dataValues[key] = value;\n    }\n    return this;\n  }\n  setAttributes(updates) {\n    return this.set(updates);\n  }\n  changed(key, value) {\n    if (key === void 0) {\n      if (this._changed.size > 0) {\n        return Array.from(this._changed);\n      }\n      return false;\n    }\n    if (value === true) {\n      this._changed.add(key);\n      return this;\n    }\n    if (value === false) {\n      this._changed.delete(key);\n      return this;\n    }\n    return this._changed.has(key);\n  }\n  previous(key) {\n    if (key) {\n      return this._previousDataValues[key];\n    }\n    return _.pickBy(this._previousDataValues, (value, key2) => this.changed(key2));\n  }\n  _setInclude(key, value, options) {\n    if (!Array.isArray(value))\n      value = [value];\n    if (value[0] instanceof Model) {\n      value = value.map((instance) => instance.dataValues);\n    }\n    const include = this._options.includeMap[key];\n    const association = include.association;\n    const accessor = key;\n    const primaryKeyAttribute = include.model.primaryKeyAttribute;\n    const childOptions = {\n      isNewRecord: this.isNewRecord,\n      include: include.include,\n      includeNames: include.includeNames,\n      includeMap: include.includeMap,\n      includeValidated: true,\n      raw: options.raw,\n      attributes: include.originalAttributes\n    };\n    let isEmpty;\n    if (include.originalAttributes === void 0 || include.originalAttributes.length) {\n      if (association.isSingleAssociation) {\n        if (Array.isArray(value)) {\n          value = value[0];\n        }\n        isEmpty = value && value[primaryKeyAttribute] === null || value === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? null : include.model.build(value, childOptions);\n      } else {\n        isEmpty = value[0] && value[0][primaryKeyAttribute] === null;\n        this[accessor] = this.dataValues[accessor] = isEmpty ? [] : include.model.bulkBuild(value, childOptions);\n      }\n    }\n  }\n  async save(options) {\n    if (arguments.length > 1) {\n      throw new Error(\"The second argument was removed in favor of the options object.\");\n    }\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    options = _.defaults(options, {\n      hooks: true,\n      validate: true\n    });\n    if (!options.fields) {\n      if (this.isNewRecord) {\n        options.fields = Object.keys(this.constructor.rawAttributes);\n      } else {\n        options.fields = _.intersection(this.changed(), Object.keys(this.constructor.rawAttributes));\n      }\n      options.defaultFields = options.fields;\n    }\n    if (options.returning === void 0) {\n      if (options.association) {\n        options.returning = false;\n      } else if (this.isNewRecord) {\n        options.returning = true;\n      }\n    }\n    const primaryKeyName = this.constructor.primaryKeyAttribute;\n    const primaryKeyAttribute = primaryKeyName && this.constructor.rawAttributes[primaryKeyName];\n    const createdAtAttr = this.constructor._timestampAttributes.createdAt;\n    const versionAttr = this.constructor._versionAttribute;\n    const hook = this.isNewRecord ? \"Create\" : \"Update\";\n    const wasNewRecord = this.isNewRecord;\n    const now = Utils.now(this.sequelize.options.dialect);\n    let updatedAtAttr = this.constructor._timestampAttributes.updatedAt;\n    if (updatedAtAttr && options.fields.length > 0 && !options.fields.includes(updatedAtAttr)) {\n      options.fields.push(updatedAtAttr);\n    }\n    if (versionAttr && options.fields.length > 0 && !options.fields.includes(versionAttr)) {\n      options.fields.push(versionAttr);\n    }\n    if (options.silent === true && !(this.isNewRecord && this.get(updatedAtAttr, { raw: true }))) {\n      _.remove(options.fields, (val) => val === updatedAtAttr);\n      updatedAtAttr = false;\n    }\n    if (this.isNewRecord === true) {\n      if (createdAtAttr && !options.fields.includes(createdAtAttr)) {\n        options.fields.push(createdAtAttr);\n      }\n      if (primaryKeyAttribute && primaryKeyAttribute.defaultValue && !options.fields.includes(primaryKeyName)) {\n        options.fields.unshift(primaryKeyName);\n      }\n    }\n    if (this.isNewRecord === false) {\n      if (primaryKeyName && this.get(primaryKeyName, { raw: true }) === void 0) {\n        throw new Error(\"You attempted to save an instance with no primary key, this is not allowed since it would result in a global update\");\n      }\n    }\n    if (updatedAtAttr && !options.silent && options.fields.includes(updatedAtAttr)) {\n      this.dataValues[updatedAtAttr] = this.constructor._getDefaultTimestamp(updatedAtAttr) || now;\n    }\n    if (this.isNewRecord && createdAtAttr && !this.dataValues[createdAtAttr]) {\n      this.dataValues[createdAtAttr] = this.constructor._getDefaultTimestamp(createdAtAttr) || now;\n    }\n    if (this.sequelize.options.dialect === \"db2\" && this.isNewRecord) {\n      this.uniqno = this.sequelize.dialect.queryGenerator.addUniqueFields(this.dataValues, this.constructor.rawAttributes, this.uniqno);\n    }\n    if (options.validate) {\n      await this.validate(options);\n    }\n    if (options.hooks) {\n      const beforeHookValues = _.pick(this.dataValues, options.fields);\n      let ignoreChanged = _.difference(this.changed(), options.fields);\n      let hookChanged;\n      let afterHookValues;\n      if (updatedAtAttr && options.fields.includes(updatedAtAttr)) {\n        ignoreChanged = _.without(ignoreChanged, updatedAtAttr);\n      }\n      await this.constructor.runHooks(`before${hook}`, this, options);\n      if (options.defaultFields && !this.isNewRecord) {\n        afterHookValues = _.pick(this.dataValues, _.difference(this.changed(), ignoreChanged));\n        hookChanged = [];\n        for (const key of Object.keys(afterHookValues)) {\n          if (afterHookValues[key] !== beforeHookValues[key]) {\n            hookChanged.push(key);\n          }\n        }\n        options.fields = _.uniq(options.fields.concat(hookChanged));\n      }\n      if (hookChanged) {\n        if (options.validate) {\n          options.skip = _.difference(Object.keys(this.constructor.rawAttributes), hookChanged);\n          await this.validate(options);\n          delete options.skip;\n        }\n      }\n    }\n    if (options.fields.length && this.isNewRecord && this._options.include && this._options.include.length) {\n      await Promise.all(this._options.include.filter((include) => include.association instanceof BelongsTo).map(async (include) => {\n        const instance = this.get(include.as);\n        if (!instance)\n          return;\n        const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n          transaction: options.transaction,\n          logging: options.logging,\n          parentRecord: this\n        }).value();\n        await instance.save(includeOptions);\n        await this[include.association.accessors.set](instance, { save: false, logging: options.logging });\n      }));\n    }\n    const realFields = options.fields.filter((field) => !this.constructor._virtualAttributes.has(field));\n    if (!realFields.length)\n      return this;\n    if (!this.changed() && !this.isNewRecord)\n      return this;\n    const versionFieldName = _.get(this.constructor.rawAttributes[versionAttr], \"field\") || versionAttr;\n    const values = Utils.mapValueFieldNames(this.dataValues, options.fields, this.constructor);\n    let query = null;\n    let args = [];\n    let where;\n    if (this.isNewRecord) {\n      query = \"insert\";\n      args = [this, this.constructor.getTableName(options), values, options];\n    } else {\n      where = this.where(true);\n      if (versionAttr) {\n        values[versionFieldName] = parseInt(values[versionFieldName], 10) + 1;\n      }\n      query = \"update\";\n      args = [this, this.constructor.getTableName(options), values, where, options];\n    }\n    const [result, rowsUpdated] = await this.constructor.queryInterface[query](...args);\n    if (versionAttr) {\n      if (rowsUpdated < 1) {\n        throw new sequelizeErrors.OptimisticLockError({\n          modelName: this.constructor.name,\n          values,\n          where\n        });\n      } else {\n        result.dataValues[versionAttr] = values[versionFieldName];\n      }\n    }\n    for (const attr of Object.keys(this.constructor.rawAttributes)) {\n      if (this.constructor.rawAttributes[attr].field && values[this.constructor.rawAttributes[attr].field] !== void 0 && this.constructor.rawAttributes[attr].field !== attr) {\n        values[attr] = values[this.constructor.rawAttributes[attr].field];\n        delete values[this.constructor.rawAttributes[attr].field];\n      }\n    }\n    Object.assign(values, result.dataValues);\n    Object.assign(result.dataValues, values);\n    if (wasNewRecord && this._options.include && this._options.include.length) {\n      await Promise.all(this._options.include.filter((include) => !(include.association instanceof BelongsTo || include.parent && include.parent.association instanceof BelongsToMany)).map(async (include) => {\n        let instances = this.get(include.as);\n        if (!instances)\n          return;\n        if (!Array.isArray(instances))\n          instances = [instances];\n        const includeOptions = _(Utils.cloneDeep(include)).omit([\"association\"]).defaults({\n          transaction: options.transaction,\n          logging: options.logging,\n          parentRecord: this\n        }).value();\n        await Promise.all(instances.map(async (instance) => {\n          if (include.association instanceof BelongsToMany) {\n            await instance.save(includeOptions);\n            const values0 = __spreadValues({\n              [include.association.foreignKey]: this.get(this.constructor.primaryKeyAttribute, { raw: true }),\n              [include.association.otherKey]: instance.get(instance.constructor.primaryKeyAttribute, { raw: true })\n            }, include.association.through.scope);\n            if (instance[include.association.through.model.name]) {\n              for (const attr of Object.keys(include.association.through.model.rawAttributes)) {\n                if (include.association.through.model.rawAttributes[attr]._autoGenerated || attr === include.association.foreignKey || attr === include.association.otherKey || typeof instance[include.association.through.model.name][attr] === \"undefined\") {\n                  continue;\n                }\n                values0[attr] = instance[include.association.through.model.name][attr];\n              }\n            }\n            await include.association.throughModel.create(values0, includeOptions);\n          } else {\n            instance.set(include.association.foreignKey, this.get(include.association.sourceKey || this.constructor.primaryKeyAttribute, { raw: true }), { raw: true });\n            Object.assign(instance, include.association.scope);\n            await instance.save(includeOptions);\n          }\n        }));\n      }));\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(`after${hook}`, result, options);\n    }\n    for (const field of options.fields) {\n      result._previousDataValues[field] = result.dataValues[field];\n      this.changed(field, false);\n    }\n    this.isNewRecord = false;\n    return result;\n  }\n  async reload(options) {\n    options = Utils.defaults({\n      where: this.where()\n    }, options, {\n      include: this._options.include || void 0\n    });\n    const reloaded = await this.constructor.findOne(options);\n    if (!reloaded) {\n      throw new sequelizeErrors.InstanceError(\"Instance could not be reloaded because it does not exist anymore (find call returned null)\");\n    }\n    this._options = reloaded._options;\n    this.set(reloaded.dataValues, {\n      raw: true,\n      reset: !options.attributes\n    });\n    return this;\n  }\n  async validate(options) {\n    return new InstanceValidator(this, options).validate();\n  }\n  async update(values, options) {\n    values = _.omitBy(values, (value) => value === void 0);\n    const changedBefore = this.changed() || [];\n    options = options || {};\n    if (Array.isArray(options))\n      options = { fields: options };\n    options = Utils.cloneDeep(options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    const setOptions = Utils.cloneDeep(options);\n    setOptions.attributes = options.fields;\n    this.set(values, setOptions);\n    const sideEffects = _.without(this.changed(), ...changedBefore);\n    const fields = _.union(Object.keys(values), sideEffects);\n    if (!options.fields) {\n      options.fields = _.intersection(fields, this.changed());\n      options.defaultFields = options.fields;\n    }\n    return await this.save(options);\n  }\n  async destroy(options) {\n    options = __spreadValues({\n      hooks: true,\n      force: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"beforeDestroy\", this, options);\n    }\n    const where = this.where(true);\n    let result;\n    if (this.constructor._timestampAttributes.deletedAt && options.force === false) {\n      const attributeName = this.constructor._timestampAttributes.deletedAt;\n      const attribute = this.constructor.rawAttributes[attributeName];\n      const defaultValue = Object.prototype.hasOwnProperty.call(attribute, \"defaultValue\") ? attribute.defaultValue : null;\n      const currentValue = this.getDataValue(attributeName);\n      const undefinedOrNull = currentValue == null && defaultValue == null;\n      if (undefinedOrNull || _.isEqual(currentValue, defaultValue)) {\n        this.setDataValue(attributeName, new Date());\n      }\n      result = await this.save(__spreadProps(__spreadValues({}, options), { hooks: false }));\n    } else {\n      result = await this.constructor.queryInterface.delete(this, this.constructor.getTableName(options), where, __spreadValues({ type: QueryTypes.DELETE, limit: null }, options));\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"afterDestroy\", this, options);\n    }\n    return result;\n  }\n  isSoftDeleted() {\n    if (!this.constructor._timestampAttributes.deletedAt) {\n      throw new Error(\"Model is not paranoid\");\n    }\n    const deletedAtAttribute = this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt];\n    const defaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    const deletedAt = this.get(this.constructor._timestampAttributes.deletedAt) || null;\n    const isSet = deletedAt !== defaultValue;\n    return isSet;\n  }\n  async restore(options) {\n    if (!this.constructor._timestampAttributes.deletedAt)\n      throw new Error(\"Model is not paranoid\");\n    options = __spreadValues({\n      hooks: true,\n      force: false\n    }, options);\n    if (options.transaction === void 0 && this.sequelize.constructor._cls) {\n      const t = this.sequelize.constructor._cls.get(\"transaction\");\n      if (t) {\n        options.transaction = t;\n      }\n    }\n    if (options.hooks) {\n      await this.constructor.runHooks(\"beforeRestore\", this, options);\n    }\n    const deletedAtCol = this.constructor._timestampAttributes.deletedAt;\n    const deletedAtAttribute = this.constructor.rawAttributes[deletedAtCol];\n    const deletedAtDefaultValue = Object.prototype.hasOwnProperty.call(deletedAtAttribute, \"defaultValue\") ? deletedAtAttribute.defaultValue : null;\n    this.setDataValue(deletedAtCol, deletedAtDefaultValue);\n    const result = await this.save(__spreadProps(__spreadValues({}, options), { hooks: false, omitNull: false }));\n    if (options.hooks) {\n      await this.constructor.runHooks(\"afterRestore\", this, options);\n      return result;\n    }\n    return result;\n  }\n  async increment(fields, options) {\n    const identifier = this.where();\n    options = Utils.cloneDeep(options);\n    options.where = __spreadValues(__spreadValues({}, options.where), identifier);\n    options.instance = this;\n    await this.constructor.increment(fields, options);\n    return this;\n  }\n  async decrement(fields, options) {\n    return this.increment(fields, __spreadProps(__spreadValues({\n      by: 1\n    }, options), {\n      increment: false\n    }));\n  }\n  equals(other) {\n    if (!other || !other.constructor) {\n      return false;\n    }\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n    return this.constructor.primaryKeyAttributes.every((attribute) => this.get(attribute, { raw: true }) === other.get(attribute, { raw: true }));\n  }\n  equalsOneOf(others) {\n    return others.some((other) => this.equals(other));\n  }\n  setValidators(attribute, validators) {\n    this.validators[attribute] = validators;\n  }\n  toJSON() {\n    return _.cloneDeep(this.get({\n      plain: true\n    }));\n  }\n  static hasMany(target, options) {\n  }\n  static belongsToMany(target, options) {\n  }\n  static hasOne(target, options) {\n  }\n  static belongsTo(target, options) {\n  }\n}\nfunction unpackAnd(where) {\n  if (!_.isObject(where)) {\n    return where;\n  }\n  const keys = Utils.getComplexKeys(where);\n  if (keys.length === 0) {\n    return;\n  }\n  if (keys.length !== 1 || keys[0] !== Op.and) {\n    return where;\n  }\n  const andParts = where[Op.and];\n  return andParts;\n}\nfunction combineWheresWithAnd(whereA, whereB) {\n  const unpackedA = unpackAnd(whereA);\n  if (unpackedA === void 0) {\n    return whereB;\n  }\n  const unpackedB = unpackAnd(whereB);\n  if (unpackedB === void 0) {\n    return whereA;\n  }\n  return {\n    [Op.and]: _.flatten([unpackedA, unpackedB])\n  };\n}\nObject.assign(Model, associationsMixin);\nHooks.applyTo(Model, true);\nmodule.exports = Model;\n//# sourceMappingURL=model.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDM0Msa0JBQWtCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCwwQkFBMEIsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDeEQsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWU7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsb0VBQVU7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDRGQUF5QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IsMEJBQTBCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ3hELFdBQVcsbUJBQU8sQ0FBQyxvRUFBYTtBQUNoQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUNBQXVDLHFEQUFxRCxxRUFBcUU7QUFDaE07QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFdBQVc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixlQUFlO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRLHNCQUFzQixVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBEQUEwRCxtREFBbUQ7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBdUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLHVCQUF1QixVQUFVO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCLG1CQUFtQixXQUFXLDRDQUE0QyxZQUFZLHNFQUFzRSwyQkFBMkI7QUFDaFE7QUFDQSxxREFBcUQsa0JBQWtCLG1CQUFtQixXQUFXO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsbUJBQW1CLFdBQVc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9DQUFvQyxHQUFHLFdBQVc7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVLDJCQUEyQixjQUFjO0FBQ3hKO0FBQ0E7QUFDQSxvRkFBb0YsVUFBVSwrQkFBK0IsY0FBYztBQUMzSTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVSxHQUFHLEtBQUs7QUFDbEY7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLEdBQUcsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSSw4Q0FBOEMseUJBQXlCO0FBQ25IO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCLGVBQWUsR0FBRyxLQUFLO0FBQzlDO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixJQUFJO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBLG1DQUFtQyxNQUFNLHVCQUF1QixpQkFBaUI7QUFDakY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix1RUFBdUUsV0FBVztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjLHFDQUFxQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUMsK0NBQStDLFVBQVU7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNDQUFzQztBQUMvQztBQUNBLFNBQVM7QUFDVDtBQUNBLHlGQUF5RjtBQUN6RjtBQUNBLDZGQUE2RixXQUFXO0FBQ3hHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUVBQWlFLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVLEdBQUcsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLEtBQUs7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxnQ0FBZ0MsTUFBTSx5REFBeUQsb0JBQW9CLFFBQVEsTUFBTTtBQUM1SztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw2Q0FBNkM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHdDQUF3QztBQUNySDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0tBQW9LLFdBQVcsS0FBSyxXQUFXO0FBQy9MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLFdBQVc7QUFDdEgsK0hBQStILFdBQVc7QUFDMUksZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0hBQWdIO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUlBQWlJO0FBQ3hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csV0FBVztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsMENBQTBDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFdBQVc7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtFQUFrRSx1Q0FBdUM7QUFDekcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsV0FBVztBQUM1Ryx1R0FBdUcsV0FBVztBQUNsSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDJJQUEySSxXQUFXLEtBQUssV0FBVztBQUN0SztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjLGNBQWM7QUFDMUYsTUFBTTtBQUNOLGtJQUFrSSxzQ0FBc0M7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYywrQkFBK0I7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsV0FBVyw2QkFBNkIsV0FBVztBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9tb2RlbC5qcz9lNTlkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fc3ByZWFkUHJvcHMgPSAoYSwgYikgPT4gX19kZWZQcm9wcyhhLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBEb3R0aWUgPSByZXF1aXJlKFwiZG90dGllXCIpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHsgbG9nZ2VyIH0gPSByZXF1aXJlKFwiLi91dGlscy9sb2dnZXJcIik7XG5jb25zdCBCZWxvbmdzVG8gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10b1wiKTtcbmNvbnN0IEJlbG9uZ3NUb01hbnkgPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55XCIpO1xuY29uc3QgSW5zdGFuY2VWYWxpZGF0b3IgPSByZXF1aXJlKFwiLi9pbnN0YW5jZS12YWxpZGF0b3JcIik7XG5jb25zdCBRdWVyeVR5cGVzID0gcmVxdWlyZShcIi4vcXVlcnktdHlwZXNcIik7XG5jb25zdCBzZXF1ZWxpemVFcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBBc3NvY2lhdGlvbiA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9iYXNlXCIpO1xuY29uc3QgSGFzTWFueSA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9oYXMtbWFueVwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuL2RhdGEtdHlwZXNcIik7XG5jb25zdCBIb29rcyA9IHJlcXVpcmUoXCIuL2hvb2tzXCIpO1xuY29uc3QgYXNzb2NpYXRpb25zTWl4aW4gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvbWl4aW5cIik7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuL29wZXJhdG9yc1wiKTtcbmNvbnN0IHsgbm9Eb3VibGVOZXN0ZWRHcm91cCB9ID0gcmVxdWlyZShcIi4vdXRpbHMvZGVwcmVjYXRpb25zXCIpO1xuY29uc3QgdmFsaWRRdWVyeUtleXdvcmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIndoZXJlXCIsXG4gIFwiYXR0cmlidXRlc1wiLFxuICBcInBhcmFub2lkXCIsXG4gIFwiaW5jbHVkZVwiLFxuICBcIm9yZGVyXCIsXG4gIFwibGltaXRcIixcbiAgXCJvZmZzZXRcIixcbiAgXCJ0cmFuc2FjdGlvblwiLFxuICBcImxvY2tcIixcbiAgXCJyYXdcIixcbiAgXCJsb2dnaW5nXCIsXG4gIFwiYmVuY2htYXJrXCIsXG4gIFwiaGF2aW5nXCIsXG4gIFwic2VhcmNoUGF0aFwiLFxuICBcInJlamVjdE9uRW1wdHlcIixcbiAgXCJwbGFpblwiLFxuICBcInNjb3BlXCIsXG4gIFwiZ3JvdXBcIixcbiAgXCJ0aHJvdWdoXCIsXG4gIFwiZGVmYXVsdHNcIixcbiAgXCJkaXN0aW5jdFwiLFxuICBcInByaW1hcnlcIixcbiAgXCJleGNlcHRpb25cIixcbiAgXCJ0eXBlXCIsXG4gIFwiaG9va3NcIixcbiAgXCJmb3JjZVwiLFxuICBcIm5hbWVcIlxuXSk7XG5jb25zdCBub25DYXNjYWRpbmdPcHRpb25zID0gW1wiaW5jbHVkZVwiLCBcImF0dHJpYnV0ZXNcIiwgXCJvcmlnaW5hbEF0dHJpYnV0ZXNcIiwgXCJvcmRlclwiLCBcIndoZXJlXCIsIFwibGltaXRcIiwgXCJvZmZzZXRcIiwgXCJwbGFpblwiLCBcImdyb3VwXCIsIFwiaGF2aW5nXCJdO1xuY2xhc3MgTW9kZWwge1xuICBzdGF0aWMgZ2V0IHF1ZXJ5SW50ZXJmYWNlKCkge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbGl6ZS5nZXRRdWVyeUludGVyZmFjZSgpO1xuICB9XG4gIHN0YXRpYyBnZXQgcXVlcnlHZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlJbnRlcmZhY2UucXVlcnlHZW5lcmF0b3I7XG4gIH1cbiAgZ2V0IHNlcXVlbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5zZXF1ZWxpemU7XG4gIH1cbiAgY29uc3RydWN0b3IodmFsdWVzID0ge30sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5fb3ZlcndyaXR0ZW5BdHRyaWJ1dGVzQ2hlY2tlZCkge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fb3ZlcndyaXR0ZW5BdHRyaWJ1dGVzQ2hlY2tlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3ZlcndyaXR0ZW5BdHRyaWJ1dGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IuX2F0dHJpYnV0ZU1hbmlwdWxhdGlvbikpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIGtleSkpIHtcbiAgICAgICAgICAgIG92ZXJ3cml0dGVuQXR0cmlidXRlcy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVyd3JpdHRlbkF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKGBNb2RlbCAke0pTT04uc3RyaW5naWZ5KHRoaXMuY29uc3RydWN0b3IubmFtZSl9IGlzIGRlY2xhcmluZyBwdWJsaWMgY2xhc3MgZmllbGRzIGZvciBhdHRyaWJ1dGUocyk6ICR7b3ZlcndyaXR0ZW5BdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gSlNPTi5zdHJpbmdpZnkoYXR0cikpLmpvaW4oXCIsIFwiKX0uXG5UaGVzZSBjbGFzcyBmaWVsZHMgYXJlIHNoYWRvd2luZyBTZXF1ZWxpemUncyBhdHRyaWJ1dGUgZ2V0dGVycyAmIHNldHRlcnMuXG5TZWUgaHR0cHM6Ly9zZXF1ZWxpemUub3JnL21haW4vbWFudWFsL21vZGVsLWJhc2ljcy5odG1sI2NhdmVhdC13aXRoLXB1YmxpYy1jbGFzcy1maWVsZHNgKTtcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBpc05ld1JlY29yZDogdHJ1ZSxcbiAgICAgIF9zY2hlbWE6IHRoaXMuY29uc3RydWN0b3IuX3NjaGVtYSxcbiAgICAgIF9zY2hlbWFEZWxpbWl0ZXI6IHRoaXMuY29uc3RydWN0b3IuX3NjaGVtYURlbGltaXRlclxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4gQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpID8gYXR0cmlidXRlWzFdIDogYXR0cmlidXRlKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLmluY2x1ZGVWYWxpZGF0ZWQpIHtcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fZXhwYW5kSW5jbHVkZUFsbChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRhdGFWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMgPSB7fTtcbiAgICB0aGlzLnVuaXFubyA9IDE7XG4gICAgdGhpcy5fY2hhbmdlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pc05ld1JlY29yZCA9IG9wdGlvbnMuaXNOZXdSZWNvcmQ7XG4gICAgdGhpcy5faW5pdFZhbHVlcyh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG4gIF9pbml0VmFsdWVzKHZhbHVlcywgb3B0aW9ucykge1xuICAgIGxldCBkZWZhdWx0cztcbiAgICBsZXQga2V5O1xuICAgIHZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB2YWx1ZXMpO1xuICAgIGlmIChvcHRpb25zLmlzTmV3UmVjb3JkKSB7XG4gICAgICBkZWZhdWx0cyA9IHt9O1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX2hhc0RlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgZGVmYXVsdHMgPSBfLm1hcFZhbHVlcyh0aGlzLmNvbnN0cnVjdG9yLl9kZWZhdWx0VmFsdWVzLCAodmFsdWVGbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVGbigpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCA/IHZhbHVlIDogXy5jbG9uZURlZXAodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmZvckVhY2goKHByaW1hcnlLZXlBdHRyaWJ1dGUpID0+IHtcbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0cywgcHJpbWFyeUtleUF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzW3ByaW1hcnlLZXlBdHRyaWJ1dGVdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0ICYmIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdID0gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgICBkZWxldGUgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5jcmVhdGVkQXRdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0ICYmIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdID0gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgICBkZWxldGUgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0ICYmIGRlZmF1bHRzW3RoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0XSkge1xuICAgICAgICB0aGlzLmRhdGFWYWx1ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdID0gVXRpbHMudG9EZWZhdWx0VmFsdWUoZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgICAgICBkZWxldGUgZGVmYXVsdHNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdO1xuICAgICAgfVxuICAgICAgZm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKHZhbHVlc1trZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLnNldChrZXksIFV0aWxzLnRvRGVmYXVsdFZhbHVlKGRlZmF1bHRzW2tleV0sIHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCksIHsgcmF3OiB0cnVlIH0pO1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldCh2YWx1ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBfcGFyYW5vaWRDbGF1c2UobW9kZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGZvciAoY29uc3QgaW5jbHVkZSBvZiBvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgICAgdGhpcy5fcGFyYW5vaWRDbGF1c2UoaW5jbHVkZS5tb2RlbCwgaW5jbHVkZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfLmdldChvcHRpb25zLCBcImdyb3VwZWRMaW1pdC5vbi5vcHRpb25zLnBhcmFub2lkXCIpKSB7XG4gICAgICBjb25zdCB0aHJvdWdoTW9kZWwgPSBfLmdldChvcHRpb25zLCBcImdyb3VwZWRMaW1pdC5vbi50aHJvdWdoLm1vZGVsXCIpO1xuICAgICAgaWYgKHRocm91Z2hNb2RlbCkge1xuICAgICAgICBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhyb3VnaE1vZGVsLCBvcHRpb25zLmdyb3VwZWRMaW1pdC50aHJvdWdoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtb2RlbC5vcHRpb25zLnRpbWVzdGFtcHMgfHwgIW1vZGVsLm9wdGlvbnMucGFyYW5vaWQgfHwgb3B0aW9ucy5wYXJhbm9pZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkQXRDb2wgPSBtb2RlbC5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gbW9kZWwucmF3QXR0cmlidXRlc1tkZWxldGVkQXRDb2xdO1xuICAgIGNvbnN0IGRlbGV0ZWRBdE9iamVjdCA9IHt9O1xuICAgIGxldCBkZWxldGVkQXREZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVsZXRlZEF0QXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSA/IGRlbGV0ZWRBdEF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgOiBudWxsO1xuICAgIGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSB8fCB7XG4gICAgICBbT3AuZXFdOiBudWxsXG4gICAgfTtcbiAgICBkZWxldGVkQXRPYmplY3RbZGVsZXRlZEF0QXR0cmlidXRlLmZpZWxkIHx8IGRlbGV0ZWRBdENvbF0gPSBkZWxldGVkQXREZWZhdWx0VmFsdWU7XG4gICAgaWYgKFV0aWxzLmlzV2hlcmVFbXB0eShvcHRpb25zLndoZXJlKSkge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IGRlbGV0ZWRBdE9iamVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy53aGVyZSA9IHsgW09wLmFuZF06IFtkZWxldGVkQXRPYmplY3QsIG9wdGlvbnMud2hlcmVdIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIHN0YXRpYyBfYWRkRGVmYXVsdEF0dHJpYnV0ZXMoKSB7XG4gICAgY29uc3QgdGFpbCA9IHt9O1xuICAgIGxldCBoZWFkID0ge307XG4gICAgaWYgKCFfLnNvbWUodGhpcy5yYXdBdHRyaWJ1dGVzLCBcInByaW1hcnlLZXlcIikpIHtcbiAgICAgIGlmIChcImlkXCIgaW4gdGhpcy5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBjb2x1bW4gY2FsbGVkICdpZCcgd2FzIGFkZGVkIHRvIHRoZSBhdHRyaWJ1dGVzIG9mICcke3RoaXMudGFibGVOYW1lfScgYnV0IG5vdCBtYXJrZWQgd2l0aCAncHJpbWFyeUtleTogdHJ1ZSdgKTtcbiAgICAgIH1cbiAgICAgIGhlYWQgPSB7XG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgdHlwZTogbmV3IERhdGFUeXBlcy5JTlRFR0VSKCksXG4gICAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgICBwcmltYXJ5S2V5OiB0cnVlLFxuICAgICAgICAgIGF1dG9JbmNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0KSB7XG4gICAgICB0YWlsW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0XSA9IHtcbiAgICAgICAgdHlwZTogRGF0YVR5cGVzLkRBVEUsXG4gICAgICAgIGFsbG93TnVsbDogZmFsc2UsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQpIHtcbiAgICAgIHRhaWxbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdID0ge1xuICAgICAgICB0eXBlOiBEYXRhVHlwZXMuREFURSxcbiAgICAgICAgYWxsb3dOdWxsOiBmYWxzZSxcbiAgICAgICAgX2F1dG9HZW5lcmF0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkge1xuICAgICAgdGFpbFt0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5EQVRFLFxuICAgICAgICBfYXV0b0dlbmVyYXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZlcnNpb25BdHRyaWJ1dGUpIHtcbiAgICAgIHRhaWxbdGhpcy5fdmVyc2lvbkF0dHJpYnV0ZV0gPSB7XG4gICAgICAgIHR5cGU6IERhdGFUeXBlcy5JTlRFR0VSLFxuICAgICAgICBhbGxvd051bGw6IGZhbHNlLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IDAsXG4gICAgICAgIF9hdXRvR2VuZXJhdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBuZXdSYXdBdHRyaWJ1dGVzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIGhlYWQpLCB0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgIF8uZWFjaCh0YWlsLCAodmFsdWUsIGF0dHIpID0+IHtcbiAgICAgIGlmIChuZXdSYXdBdHRyaWJ1dGVzW2F0dHJdID09PSB2b2lkIDApIHtcbiAgICAgICAgbmV3UmF3QXR0cmlidXRlc1thdHRyXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmF3QXR0cmlidXRlcyA9IG5ld1Jhd0F0dHJpYnV0ZXM7XG4gICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLnByaW1hcnlLZXlzKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucHJpbWFyeUtleXMuaWQgPSB0aGlzLnJhd0F0dHJpYnV0ZXMuaWQ7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLnJhd0F0dHJpYnV0ZXM7XG4gIH1cbiAgc3RhdGljIF9maW5kQXV0b0luY3JlbWVudEF0dHJpYnV0ZSgpIHtcbiAgICB0aGlzLmF1dG9JbmNyZW1lbnRBdHRyaWJ1dGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLnJhd0F0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5yYXdBdHRyaWJ1dGVzLCBuYW1lKSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbiAmJiBkZWZpbml0aW9uLmF1dG9JbmNyZW1lbnQpIHtcbiAgICAgICAgICBpZiAodGhpcy5hdXRvSW5jcmVtZW50QXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEluc3RhbmNlIGRlZmluaXRpb24uIE9ubHkgb25lIGF1dG9pbmNyZW1lbnQgZmllbGQgYWxsb3dlZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXV0b0luY3JlbWVudEF0dHJpYnV0ZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIF9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgc2VsZikge1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGUpKSB7XG4gICAgICBvcHRpb25zLmluY2x1ZGUgPSBbb3B0aW9ucy5pbmNsdWRlXTtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgb3B0aW9ucy5pbmNsdWRlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvcHRpb25zLmluY2x1ZGUgPSBvcHRpb25zLmluY2x1ZGUubWFwKChpbmNsdWRlKSA9PiB0aGlzLl9jb25mb3JtSW5jbHVkZShpbmNsdWRlLCBzZWxmKSk7XG4gIH1cbiAgc3RhdGljIF90cmFuc2Zvcm1TdHJpbmdBc3NvY2lhdGlvbihpbmNsdWRlLCBzZWxmKSB7XG4gICAgaWYgKHNlbGYgJiYgdHlwZW9mIGluY2x1ZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGYuYXNzb2NpYXRpb25zLCBpbmNsdWRlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc29jaWF0aW9uIHdpdGggYWxpYXMgXCIke2luY2x1ZGV9XCIgZG9lcyBub3QgZXhpc3Qgb24gJHtzZWxmLm5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5hc3NvY2lhdGlvbnNbaW5jbHVkZV07XG4gICAgfVxuICAgIHJldHVybiBpbmNsdWRlO1xuICB9XG4gIHN0YXRpYyBfY29uZm9ybUluY2x1ZGUoaW5jbHVkZSwgc2VsZikge1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBsZXQgbW9kZWw7XG4gICAgICBpZiAoaW5jbHVkZS5fcHNldWRvKVxuICAgICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICAgIGluY2x1ZGUgPSB0aGlzLl90cmFuc2Zvcm1TdHJpbmdBc3NvY2lhdGlvbihpbmNsdWRlLCBzZWxmKTtcbiAgICAgIGlmIChpbmNsdWRlIGluc3RhbmNlb2YgQXNzb2NpYXRpb24pIHtcbiAgICAgICAgaWYgKHNlbGYgJiYgaW5jbHVkZS50YXJnZXQubmFtZSA9PT0gc2VsZi5uYW1lKSB7XG4gICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLnNvdXJjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbCA9IGluY2x1ZGUudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1vZGVsLCBhc3NvY2lhdGlvbjogaW5jbHVkZSwgYXM6IGluY2x1ZGUuYXMgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlLnByb3RvdHlwZSAmJiBpbmNsdWRlLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIHJldHVybiB7IG1vZGVsOiBpbmNsdWRlIH07XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KGluY2x1ZGUpKSB7XG4gICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgaW5jbHVkZS5hc3NvY2lhdGlvbiA9IHRoaXMuX3RyYW5zZm9ybVN0cmluZ0Fzc29jaWF0aW9uKGluY2x1ZGUuYXNzb2NpYXRpb24sIHNlbGYpO1xuICAgICAgICAgIGlmIChzZWxmICYmIGluY2x1ZGUuYXNzb2NpYXRpb24udGFyZ2V0Lm5hbWUgPT09IHNlbGYubmFtZSkge1xuICAgICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWwgPSBpbmNsdWRlLmFzc29jaWF0aW9uLnRhcmdldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpbmNsdWRlLm1vZGVsKVxuICAgICAgICAgICAgaW5jbHVkZS5tb2RlbCA9IG1vZGVsO1xuICAgICAgICAgIGlmICghaW5jbHVkZS5hcylcbiAgICAgICAgICAgIGluY2x1ZGUuYXMgPSBpbmNsdWRlLmFzc29jaWF0aW9uLmFzO1xuICAgICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhpbmNsdWRlLCBtb2RlbCk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGUubW9kZWwpIHtcbiAgICAgICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGUuYWxsKSB7XG4gICAgICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKGluY2x1ZGUpO1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkluY2x1ZGUgdW5leHBlY3RlZC4gRWxlbWVudCBoYXMgdG8gYmUgZWl0aGVyIGEgTW9kZWwsIGFuIEFzc29jaWF0aW9uIG9yIGFuIG9iamVjdC5cIik7XG4gIH1cbiAgc3RhdGljIF9leHBhbmRJbmNsdWRlQWxsRWxlbWVudChpbmNsdWRlcywgaW5jbHVkZSkge1xuICAgIGxldCBhbGwgPSBpbmNsdWRlLmFsbDtcbiAgICBkZWxldGUgaW5jbHVkZS5hbGw7XG4gICAgaWYgKGFsbCAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFsbCkpIHtcbiAgICAgICAgYWxsID0gW2FsbF07XG4gICAgICB9XG4gICAgICBjb25zdCB2YWxpZFR5cGVzID0ge1xuICAgICAgICBCZWxvbmdzVG86IHRydWUsXG4gICAgICAgIEhhc09uZTogdHJ1ZSxcbiAgICAgICAgSGFzTWFueTogdHJ1ZSxcbiAgICAgICAgT25lOiBbXCJCZWxvbmdzVG9cIiwgXCJIYXNPbmVcIl0sXG4gICAgICAgIEhhczogW1wiSGFzT25lXCIsIFwiSGFzTWFueVwiXSxcbiAgICAgICAgTWFueTogW1wiSGFzTWFueVwiXVxuICAgICAgfTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBhbGxbaV07XG4gICAgICAgIGlmICh0eXBlID09PSBcIkFsbFwiKSB7XG4gICAgICAgICAgYWxsID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlcyA9IHZhbGlkVHlwZXNbdHlwZV07XG4gICAgICAgIGlmICghdHlwZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGBpbmNsdWRlIGFsbCAnJHt0eXBlfScgaXMgbm90IHZhbGlkIC0gbXVzdCBiZSBCZWxvbmdzVG8sIEhhc09uZSwgSGFzTWFueSwgT25lLCBIYXMsIE1hbnkgb3IgQWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVzICE9PSB0cnVlKSB7XG4gICAgICAgICAgYWxsLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpLS07XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0eXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKCFhbGwuaW5jbHVkZXModHlwZXNbal0pKSB7XG4gICAgICAgICAgICAgIGFsbC51bnNoaWZ0KHR5cGVzW2pdKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXN0ZWQgPSBpbmNsdWRlLm5lc3RlZDtcbiAgICBpZiAobmVzdGVkKSB7XG4gICAgICBkZWxldGUgaW5jbHVkZS5uZXN0ZWQ7XG4gICAgICBpZiAoIWluY2x1ZGUuaW5jbHVkZSkge1xuICAgICAgICBpbmNsdWRlLmluY2x1ZGUgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaW5jbHVkZS5pbmNsdWRlKSkge1xuICAgICAgICBpbmNsdWRlLmluY2x1ZGUgPSBbaW5jbHVkZS5pbmNsdWRlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXNlZCA9IFtdO1xuICAgIChmdW5jdGlvbiBhZGRBbGxJbmNsdWRlcyhwYXJlbnQsIGluY2x1ZGVzMikge1xuICAgICAgXy5mb3JFYWNoKHBhcmVudC5hc3NvY2lhdGlvbnMsIChhc3NvY2lhdGlvbikgPT4ge1xuICAgICAgICBpZiAoYWxsICE9PSB0cnVlICYmICFhbGwuaW5jbHVkZXMoYXNzb2NpYXRpb24uYXNzb2NpYXRpb25UeXBlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbCA9IGFzc29jaWF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgYXMgPSBhc3NvY2lhdGlvbi5vcHRpb25zLmFzO1xuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB7IG1vZGVsIH07XG4gICAgICAgIGlmIChhcykge1xuICAgICAgICAgIHByZWRpY2F0ZS5hcyA9IGFzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfLnNvbWUoaW5jbHVkZXMyLCBwcmVkaWNhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXN0ZWQgJiYgdXNlZC5pbmNsdWRlcyhtb2RlbCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXNlZC5wdXNoKHBhcmVudCk7XG4gICAgICAgIGNvbnN0IHRoaXNJbmNsdWRlID0gVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpO1xuICAgICAgICB0aGlzSW5jbHVkZS5tb2RlbCA9IG1vZGVsO1xuICAgICAgICBpZiAoYXMpIHtcbiAgICAgICAgICB0aGlzSW5jbHVkZS5hcyA9IGFzO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1ZGVzMi5wdXNoKHRoaXNJbmNsdWRlKTtcbiAgICAgICAgaWYgKG5lc3RlZCkge1xuICAgICAgICAgIGFkZEFsbEluY2x1ZGVzKG1vZGVsLCB0aGlzSW5jbHVkZS5pbmNsdWRlKTtcbiAgICAgICAgICBpZiAodGhpc0luY2x1ZGUuaW5jbHVkZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICBkZWxldGUgdGhpc0luY2x1ZGUuaW5jbHVkZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1c2VkLnBvcCgpO1xuICAgIH0pKHRoaXMsIGluY2x1ZGVzKTtcbiAgfVxuICBzdGF0aWMgX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zLCB0YWJsZU5hbWVzKSB7XG4gICAgaWYgKCFvcHRpb25zLm1vZGVsKVxuICAgICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgdGFibGVOYW1lcyA9IHRhYmxlTmFtZXMgfHwge307XG4gICAgb3B0aW9ucy5pbmNsdWRlTmFtZXMgPSBbXTtcbiAgICBvcHRpb25zLmluY2x1ZGVNYXAgPSB7fTtcbiAgICBvcHRpb25zLmhhc1NpbmdsZUFzc29jaWF0aW9uID0gZmFsc2U7XG4gICAgb3B0aW9ucy5oYXNNdWx0aUFzc29jaWF0aW9uID0gZmFsc2U7XG4gICAgaWYgKCFvcHRpb25zLnBhcmVudCkge1xuICAgICAgb3B0aW9ucy50b3BNb2RlbCA9IG9wdGlvbnMubW9kZWw7XG4gICAgICBvcHRpb25zLnRvcExpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICB9XG4gICAgb3B0aW9ucy5pbmNsdWRlID0gb3B0aW9ucy5pbmNsdWRlLm1hcCgoaW5jbHVkZSkgPT4ge1xuICAgICAgaW5jbHVkZSA9IHRoaXMuX2NvbmZvcm1JbmNsdWRlKGluY2x1ZGUpO1xuICAgICAgaW5jbHVkZS5wYXJlbnQgPSBvcHRpb25zO1xuICAgICAgaW5jbHVkZS50b3BMaW1pdCA9IG9wdGlvbnMudG9wTGltaXQ7XG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudC5jYWxsKG9wdGlvbnMubW9kZWwsIGluY2x1ZGUsIHRhYmxlTmFtZXMsIG9wdGlvbnMpO1xuICAgICAgaWYgKGluY2x1ZGUuZHVwbGljYXRpbmcgPT09IHZvaWQgMCkge1xuICAgICAgICBpbmNsdWRlLmR1cGxpY2F0aW5nID0gaW5jbHVkZS5hc3NvY2lhdGlvbi5pc011bHRpQXNzb2NpYXRpb247XG4gICAgICB9XG4gICAgICBpbmNsdWRlLmhhc0R1cGxpY2F0aW5nID0gaW5jbHVkZS5oYXNEdXBsaWNhdGluZyB8fCBpbmNsdWRlLmR1cGxpY2F0aW5nO1xuICAgICAgaW5jbHVkZS5oYXNSZXF1aXJlZCA9IGluY2x1ZGUuaGFzUmVxdWlyZWQgfHwgaW5jbHVkZS5yZXF1aXJlZDtcbiAgICAgIG9wdGlvbnMuaGFzRHVwbGljYXRpbmcgPSBvcHRpb25zLmhhc0R1cGxpY2F0aW5nIHx8IGluY2x1ZGUuaGFzRHVwbGljYXRpbmc7XG4gICAgICBvcHRpb25zLmhhc1JlcXVpcmVkID0gb3B0aW9ucy5oYXNSZXF1aXJlZCB8fCBpbmNsdWRlLnJlcXVpcmVkO1xuICAgICAgb3B0aW9ucy5oYXNXaGVyZSA9IG9wdGlvbnMuaGFzV2hlcmUgfHwgaW5jbHVkZS5oYXNXaGVyZSB8fCAhIWluY2x1ZGUud2hlcmU7XG4gICAgICByZXR1cm4gaW5jbHVkZTtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGluY2x1ZGUgb2Ygb3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICBpbmNsdWRlLmhhc1BhcmVudFdoZXJlID0gb3B0aW9ucy5oYXNQYXJlbnRXaGVyZSB8fCAhIW9wdGlvbnMud2hlcmU7XG4gICAgICBpbmNsdWRlLmhhc1BhcmVudFJlcXVpcmVkID0gb3B0aW9ucy5oYXNQYXJlbnRSZXF1aXJlZCB8fCAhIW9wdGlvbnMucmVxdWlyZWQ7XG4gICAgICBpZiAoaW5jbHVkZS5zdWJRdWVyeSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5oYXNEdXBsaWNhdGluZyAmJiBvcHRpb25zLnRvcExpbWl0KSB7XG4gICAgICAgIGlmIChpbmNsdWRlLmR1cGxpY2F0aW5nKSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnkgfHwgZmFsc2U7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGluY2x1ZGUuaGFzUmVxdWlyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuaGFzUmVxdWlyZWQ7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeUZpbHRlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5ID0gaW5jbHVkZS5zdWJRdWVyeSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKGluY2x1ZGUuZHVwbGljYXRpbmcpIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gaW5jbHVkZS5zdWJRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmNsdWRlLnN1YlF1ZXJ5RmlsdGVyID0gZmFsc2U7XG4gICAgICAgICAgaW5jbHVkZS5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnkgfHwgaW5jbHVkZS5oYXNQYXJlbnRSZXF1aXJlZCAmJiBpbmNsdWRlLmhhc1JlcXVpcmVkICYmICFpbmNsdWRlLnNlcGFyYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLmluY2x1ZGVNYXBbaW5jbHVkZS5hc10gPSBpbmNsdWRlO1xuICAgICAgb3B0aW9ucy5pbmNsdWRlTmFtZXMucHVzaChpbmNsdWRlLmFzKTtcbiAgICAgIGlmIChvcHRpb25zLnRvcE1vZGVsID09PSBvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMuc3ViUXVlcnkgPT09IHZvaWQgMCAmJiBvcHRpb25zLnRvcExpbWl0KSB7XG4gICAgICAgIGlmIChpbmNsdWRlLnN1YlF1ZXJ5KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdWJRdWVyeSA9IGluY2x1ZGUuc3ViUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZS5oYXNEdXBsaWNhdGluZykge1xuICAgICAgICAgIG9wdGlvbnMuc3ViUXVlcnkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcHRpb25zLmhhc0luY2x1ZGVXaGVyZSA9IG9wdGlvbnMuaGFzSW5jbHVkZVdoZXJlIHx8IGluY2x1ZGUuaGFzSW5jbHVkZVdoZXJlIHx8ICEhaW5jbHVkZS53aGVyZTtcbiAgICAgIG9wdGlvbnMuaGFzSW5jbHVkZVJlcXVpcmVkID0gb3B0aW9ucy5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgaW5jbHVkZS5oYXNJbmNsdWRlUmVxdWlyZWQgfHwgISFpbmNsdWRlLnJlcXVpcmVkO1xuICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24uaXNNdWx0aUFzc29jaWF0aW9uIHx8IGluY2x1ZGUuaGFzTXVsdGlBc3NvY2lhdGlvbikge1xuICAgICAgICBvcHRpb25zLmhhc011bHRpQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24uaXNTaW5nbGVBc3NvY2lhdGlvbiB8fCBpbmNsdWRlLmhhc1NpbmdsZUFzc29jaWF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMuaGFzU2luZ2xlQXNzb2NpYXRpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy50b3BNb2RlbCA9PT0gb3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLnN1YlF1ZXJ5ID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMuc3ViUXVlcnkgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgc3RhdGljIF92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudChpbmNsdWRlLCB0YWJsZU5hbWVzLCBvcHRpb25zKSB7XG4gICAgdGFibGVOYW1lc1tpbmNsdWRlLm1vZGVsLmdldFRhYmxlTmFtZSgpXSA9IHRydWU7XG4gICAgaWYgKGluY2x1ZGUuYXR0cmlidXRlcyAmJiAhb3B0aW9ucy5yYXcpIHtcbiAgICAgIGluY2x1ZGUubW9kZWwuX2V4cGFuZEF0dHJpYnV0ZXMoaW5jbHVkZSk7XG4gICAgICBpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlcyA9IGluY2x1ZGUubW9kZWwuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKGluY2x1ZGUuYXR0cmlidXRlcyk7XG4gICAgICBpbmNsdWRlID0gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICAgIGlmIChpbmNsdWRlLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIF8uZWFjaChpbmNsdWRlLm1vZGVsLnByaW1hcnlLZXlzLCAoYXR0ciwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKCFpbmNsdWRlLmF0dHJpYnV0ZXMuc29tZSgoaW5jbHVkZUF0dHIpID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRyLmZpZWxkICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5jbHVkZUF0dHIpICYmIGluY2x1ZGVBdHRyWzBdID09PSBhdHRyLmZpZWxkICYmIGluY2x1ZGVBdHRyWzFdID09PSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZUF0dHIgPT09IGtleTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzLnVuc2hpZnQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmNsdWRlID0gVXRpbHMubWFwRmluZGVyT3B0aW9ucyhpbmNsdWRlLCBpbmNsdWRlLm1vZGVsKTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGUuX3BzZXVkbykge1xuICAgICAgaWYgKCFpbmNsdWRlLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMoaW5jbHVkZS5tb2RlbC50YWJsZUF0dHJpYnV0ZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFV0aWxzLm1hcEZpbmRlck9wdGlvbnMoaW5jbHVkZSwgaW5jbHVkZS5tb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbiB8fCB0aGlzLl9nZXRJbmNsdWRlZEFzc29jaWF0aW9uKGluY2x1ZGUubW9kZWwsIGluY2x1ZGUuYXMpO1xuICAgIGluY2x1ZGUuYXNzb2NpYXRpb24gPSBhc3NvY2lhdGlvbjtcbiAgICBpbmNsdWRlLmFzID0gYXNzb2NpYXRpb24uYXM7XG4gICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaCAmJiBPYmplY3QoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsKSA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsKSB7XG4gICAgICBpZiAoIWluY2x1ZGUuaW5jbHVkZSlcbiAgICAgICAgaW5jbHVkZS5pbmNsdWRlID0gW107XG4gICAgICBjb25zdCB0aHJvdWdoID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoO1xuICAgICAgaW5jbHVkZS50aHJvdWdoID0gXy5kZWZhdWx0cyhpbmNsdWRlLnRocm91Z2ggfHwge30sIHtcbiAgICAgICAgbW9kZWw6IHRocm91Z2gubW9kZWwsXG4gICAgICAgIGFzOiB0aHJvdWdoLm1vZGVsLm5hbWUsXG4gICAgICAgIGFzc29jaWF0aW9uOiB7XG4gICAgICAgICAgaXNTaW5nbGVBc3NvY2lhdGlvbjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBfcHNldWRvOiB0cnVlLFxuICAgICAgICBwYXJlbnQ6IGluY2x1ZGVcbiAgICAgIH0pO1xuICAgICAgaWYgKHRocm91Z2guc2NvcGUpIHtcbiAgICAgICAgaW5jbHVkZS50aHJvdWdoLndoZXJlID0gaW5jbHVkZS50aHJvdWdoLndoZXJlID8geyBbT3AuYW5kXTogW2luY2x1ZGUudGhyb3VnaC53aGVyZSwgdGhyb3VnaC5zY29wZV0gfSA6IHRocm91Z2guc2NvcGU7XG4gICAgICB9XG4gICAgICBpbmNsdWRlLmluY2x1ZGUucHVzaChpbmNsdWRlLnRocm91Z2gpO1xuICAgICAgdGFibGVOYW1lc1t0aHJvdWdoLnRhYmxlTmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbW9kZWw7XG4gICAgaWYgKGluY2x1ZGUubW9kZWwuc2NvcGVkID09PSB0cnVlKSB7XG4gICAgICBtb2RlbCA9IGluY2x1ZGUubW9kZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQubmFtZSA9PT0gaW5jbHVkZS5tb2RlbC5uYW1lID8gaW5jbHVkZS5hc3NvY2lhdGlvbi50YXJnZXQgOiBpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZTtcbiAgICB9XG4gICAgbW9kZWwuX2luamVjdFNjb3BlKGluY2x1ZGUpO1xuICAgIGlmICghaW5jbHVkZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpbmNsdWRlLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhpbmNsdWRlLm1vZGVsLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGluY2x1ZGUgPSBVdGlscy5tYXBGaW5kZXJPcHRpb25zKGluY2x1ZGUsIGluY2x1ZGUubW9kZWwpO1xuICAgIGlmIChpbmNsdWRlLnJlcXVpcmVkID09PSB2b2lkIDApIHtcbiAgICAgIGluY2x1ZGUucmVxdWlyZWQgPSAhIWluY2x1ZGUud2hlcmU7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlKSB7XG4gICAgICBpbmNsdWRlLndoZXJlID0gaW5jbHVkZS53aGVyZSA/IHsgW09wLmFuZF06IFtpbmNsdWRlLndoZXJlLCBpbmNsdWRlLmFzc29jaWF0aW9uLnNjb3BlXSB9IDogaW5jbHVkZS5hc3NvY2lhdGlvbi5zY29wZTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGUubGltaXQgJiYgaW5jbHVkZS5zZXBhcmF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdWRlLnNlcGFyYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGUuc2VwYXJhdGUgPT09IHRydWUpIHtcbiAgICAgIGlmICghKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBIYXNNYW55KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IEhhc01hbnkgYXNzb2NpYXRpb25zIHN1cHBvcnQgaW5jbHVkZS5zZXBhcmF0ZVwiKTtcbiAgICAgIH1cbiAgICAgIGluY2x1ZGUuZHVwbGljYXRpbmcgPSBmYWxzZTtcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMgJiYgb3B0aW9ucy5hdHRyaWJ1dGVzLmxlbmd0aCAmJiAhXy5mbGF0dGVuRGVwdGgob3B0aW9ucy5hdHRyaWJ1dGVzLCAyKS5pbmNsdWRlcyhhc3NvY2lhdGlvbi5zb3VyY2VLZXkpKSB7XG4gICAgICAgIG9wdGlvbnMuYXR0cmlidXRlcy5wdXNoKGFzc29jaWF0aW9uLnNvdXJjZUtleSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZS5hdHRyaWJ1dGVzICYmIGluY2x1ZGUuYXR0cmlidXRlcy5sZW5ndGggJiYgIV8uZmxhdHRlbkRlcHRoKGluY2x1ZGUuYXR0cmlidXRlcywgMikuaW5jbHVkZXMoYXNzb2NpYXRpb24uZm9yZWlnbktleSkpIHtcbiAgICAgICAgaW5jbHVkZS5hdHRyaWJ1dGVzLnB1c2goYXNzb2NpYXRpb24uZm9yZWlnbktleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5jbHVkZSwgXCJpbmNsdWRlXCIpKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMuY2FsbChpbmNsdWRlLm1vZGVsLCBpbmNsdWRlLCB0YWJsZU5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGluY2x1ZGU7XG4gIH1cbiAgc3RhdGljIF9nZXRJbmNsdWRlZEFzc29jaWF0aW9uKHRhcmdldE1vZGVsLCB0YXJnZXRBbGlhcykge1xuICAgIGNvbnN0IGFzc29jaWF0aW9ucyA9IHRoaXMuZ2V0QXNzb2NpYXRpb25zKHRhcmdldE1vZGVsKTtcbiAgICBsZXQgYXNzb2NpYXRpb24gPSBudWxsO1xuICAgIGlmIChhc3NvY2lhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIG5vdCBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSFgKTtcbiAgICB9XG4gICAgaWYgKGFzc29jaWF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGFzc29jaWF0aW9uID0gdGhpcy5nZXRBc3NvY2lhdGlvbkZvckFsaWFzKHRhcmdldE1vZGVsLCB0YXJnZXRBbGlhcyk7XG4gICAgICBpZiAoYXNzb2NpYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFzc29jaWF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEFsaWFzKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQWxpYXNlcyA9IHRoaXMuZ2V0QXNzb2NpYXRpb25zKHRhcmdldE1vZGVsKS5tYXAoKGFzc29jaWF0aW9uMikgPT4gYXNzb2NpYXRpb24yLmFzKTtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5FYWdlckxvYWRpbmdFcnJvcihgJHt0YXJnZXRNb2RlbC5uYW1lfSBpcyBhc3NvY2lhdGVkIHRvICR7dGhpcy5uYW1lfSB1c2luZyBhbiBhbGlhcy4gWW91J3ZlIGluY2x1ZGVkIGFuIGFsaWFzICgke3RhcmdldEFsaWFzfSksIGJ1dCBpdCBkb2VzIG5vdCBtYXRjaCB0aGUgYWxpYXMoZXMpIGRlZmluZWQgaW4geW91ciBhc3NvY2lhdGlvbiAoJHtleGlzdGluZ0FsaWFzZXMuam9pbihcIiwgXCIpfSkuYCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IHVzaW5nIGFuIGFsaWFzLiBZb3UgbXVzdCB1c2UgdGhlICdhcycga2V5d29yZCB0byBzcGVjaWZ5IHRoZSBhbGlhcyB3aXRoaW4geW91ciBpbmNsdWRlIHN0YXRlbWVudC5gKTtcbiAgICB9XG4gICAgYXNzb2NpYXRpb24gPSB0aGlzLmdldEFzc29jaWF0aW9uRm9yQWxpYXModGFyZ2V0TW9kZWwsIHRhcmdldEFsaWFzKTtcbiAgICBpZiAoIWFzc29jaWF0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkVhZ2VyTG9hZGluZ0Vycm9yKGAke3RhcmdldE1vZGVsLm5hbWV9IGlzIGFzc29jaWF0ZWQgdG8gJHt0aGlzLm5hbWV9IG11bHRpcGxlIHRpbWVzLiBUbyBpZGVudGlmeSB0aGUgY29ycmVjdCBhc3NvY2lhdGlvbiwgeW91IG11c3QgdXNlIHRoZSAnYXMnIGtleXdvcmQgdG8gc3BlY2lmeSB0aGUgYWxpYXMgb2YgdGhlIGFzc29jaWF0aW9uIHlvdSB3YW50IHRvIGluY2x1ZGUuYCk7XG4gICAgfVxuICAgIHJldHVybiBhc3NvY2lhdGlvbjtcbiAgfVxuICBzdGF0aWMgX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucykge1xuICAgIGNvbnN0IGluY2x1ZGVzID0gb3B0aW9ucy5pbmNsdWRlO1xuICAgIGlmICghaW5jbHVkZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGluY2x1ZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgaW5jbHVkZSA9IGluY2x1ZGVzW2luZGV4XTtcbiAgICAgIGlmIChpbmNsdWRlLmFsbCkge1xuICAgICAgICBpbmNsdWRlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsRWxlbWVudChpbmNsdWRlcywgaW5jbHVkZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGluY2x1ZGVzLmZvckVhY2goKGluY2x1ZGUpID0+IHtcbiAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwuY2FsbChpbmNsdWRlLm1vZGVsLCBpbmNsdWRlKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX2NvbmZvcm1JbmRleChpbmRleCkge1xuICAgIGlmICghaW5kZXguZmllbGRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJmaWVsZHNcIiBwcm9wZXJ0eSBmb3IgaW5kZXggZGVmaW5pdGlvbicpO1xuICAgIH1cbiAgICBpbmRleCA9IF8uZGVmYXVsdHMoaW5kZXgsIHtcbiAgICAgIHR5cGU6IFwiXCIsXG4gICAgICBwYXJzZXI6IG51bGxcbiAgICB9KTtcbiAgICBpZiAoaW5kZXgudHlwZSAmJiBpbmRleC50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwidW5pcXVlXCIpIHtcbiAgICAgIGluZGV4LnVuaXF1ZSA9IHRydWU7XG4gICAgICBkZWxldGUgaW5kZXgudHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG4gIHN0YXRpYyBfdW5pcUluY2x1ZGVzKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSlcbiAgICAgIHJldHVybjtcbiAgICBvcHRpb25zLmluY2x1ZGUgPSBfKG9wdGlvbnMuaW5jbHVkZSkuZ3JvdXBCeSgoaW5jbHVkZSkgPT4gYCR7aW5jbHVkZS5tb2RlbCAmJiBpbmNsdWRlLm1vZGVsLm5hbWV9LSR7aW5jbHVkZS5hc31gKS5tYXAoKGluY2x1ZGVzKSA9PiB0aGlzLl9hc3NpZ25PcHRpb25zKC4uLmluY2x1ZGVzKSkudmFsdWUoKTtcbiAgfVxuICBzdGF0aWMgX2Jhc2VNZXJnZSguLi5hcmdzKSB7XG4gICAgXy5hc3NpZ25XaXRoKC4uLmFyZ3MpO1xuICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhhcmdzWzBdLCB0aGlzKTtcbiAgICB0aGlzLl91bmlxSW5jbHVkZXMoYXJnc1swXSk7XG4gICAgcmV0dXJuIGFyZ3NbMF07XG4gIH1cbiAgc3RhdGljIF9tZXJnZUZ1bmN0aW9uKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqVmFsdWUpICYmIEFycmF5LmlzQXJyYXkoc3JjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gXy51bmlvbihvYmpWYWx1ZSwgc3JjVmFsdWUpO1xuICAgIH1cbiAgICBpZiAoW1wid2hlcmVcIiwgXCJoYXZpbmdcIl0uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMud2hlcmVNZXJnZVN0cmF0ZWd5ID09PSBcImFuZFwiKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lV2hlcmVzV2l0aEFuZChvYmpWYWx1ZSwgc3JjVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHNyY1ZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kKSB7XG4gICAgICAgIHNyY1ZhbHVlID0geyBbT3AuYW5kXTogc3JjVmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob2JqVmFsdWUpICYmIF8uaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqVmFsdWUsIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgXy5pc1BsYWluT2JqZWN0KG9ialZhbHVlKSAmJiBfLmlzUGxhaW5PYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICByZXR1cm4gXy5hc3NpZ25XaXRoKG9ialZhbHVlLCBzcmNWYWx1ZSwgKG9ialZhbHVlMiwgc3JjVmFsdWUyKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialZhbHVlMikgJiYgQXJyYXkuaXNBcnJheShzcmNWYWx1ZTIpKSB7XG4gICAgICAgICAgcmV0dXJuIF8udW5pb24ob2JqVmFsdWUyLCBzcmNWYWx1ZTIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gVXRpbHMuY2xvbmVEZWVwKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNyY1ZhbHVlID09PSB2b2lkIDAgPyBvYmpWYWx1ZSA6IHNyY1ZhbHVlO1xuICB9XG4gIHN0YXRpYyBfYXNzaWduT3B0aW9ucyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jhc2VNZXJnZSguLi5hcmdzLCB0aGlzLl9tZXJnZUZ1bmN0aW9uLmJpbmQodGhpcykpO1xuICB9XG4gIHN0YXRpYyBfZGVmYXVsdHNPcHRpb25zKHRhcmdldCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLl9iYXNlTWVyZ2UodGFyZ2V0LCBvcHRzLCAoc3JjVmFsdWUsIG9ialZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXJnZUZ1bmN0aW9uKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgaW5pdChhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIW9wdGlvbnMuc2VxdWVsaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBTZXF1ZWxpemUgaW5zdGFuY2UgcGFzc2VkXCIpO1xuICAgIH1cbiAgICB0aGlzLnNlcXVlbGl6ZSA9IG9wdGlvbnMuc2VxdWVsaXplO1xuICAgIGNvbnN0IGdsb2JhbE9wdGlvbnMgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zO1xuICAgIG9wdGlvbnMgPSBVdGlscy5tZXJnZShfLmNsb25lRGVlcChnbG9iYWxPcHRpb25zLmRlZmluZSksIG9wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucy5tb2RlbE5hbWUpIHtcbiAgICAgIG9wdGlvbnMubW9kZWxOYW1lID0gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMubWVyZ2Uoe1xuICAgICAgbmFtZToge1xuICAgICAgICBwbHVyYWw6IFV0aWxzLnBsdXJhbGl6ZShvcHRpb25zLm1vZGVsTmFtZSksXG4gICAgICAgIHNpbmd1bGFyOiBVdGlscy5zaW5ndWxhcml6ZShvcHRpb25zLm1vZGVsTmFtZSlcbiAgICAgIH0sXG4gICAgICBpbmRleGVzOiBbXSxcbiAgICAgIG9taXROdWxsOiBnbG9iYWxPcHRpb25zLm9taXROdWxsLFxuICAgICAgc2NoZW1hOiBnbG9iYWxPcHRpb25zLnNjaGVtYVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIHRoaXMuc2VxdWVsaXplLnJ1bkhvb2tzKFwiYmVmb3JlRGVmaW5lXCIsIGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm1vZGVsTmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHsgdmFsdWU6IG9wdGlvbnMubW9kZWxOYW1lIH0pO1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5tb2RlbE5hbWU7XG4gICAgdGhpcy5vcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgdGltZXN0YW1wczogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiB7fSxcbiAgICAgIGZyZWV6ZVRhYmxlTmFtZTogZmFsc2UsXG4gICAgICB1bmRlcnNjb3JlZDogZmFsc2UsXG4gICAgICBwYXJhbm9pZDogZmFsc2UsXG4gICAgICByZWplY3RPbkVtcHR5OiBmYWxzZSxcbiAgICAgIHdoZXJlQ29sbGVjdGlvbjogbnVsbCxcbiAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgIHNjaGVtYURlbGltaXRlcjogXCJcIixcbiAgICAgIGRlZmF1bHRTY29wZToge30sXG4gICAgICBzY29wZXM6IHt9LFxuICAgICAgaW5kZXhlczogW10sXG4gICAgICB3aGVyZU1lcmdlU3RyYXRlZ3k6IFwib3ZlcndyaXRlXCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUuaXNEZWZpbmVkKHRoaXMubmFtZSkpIHtcbiAgICAgIHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5yZW1vdmVNb2RlbCh0aGlzLnNlcXVlbGl6ZS5tb2RlbE1hbmFnZXIuZ2V0TW9kZWwodGhpcy5uYW1lKSk7XG4gICAgfVxuICAgIHRoaXMuYXNzb2NpYXRpb25zID0ge307XG4gICAgdGhpcy5fc2V0dXBIb29rcyhvcHRpb25zLmhvb2tzKTtcbiAgICB0aGlzLnVuZGVyc2NvcmVkID0gdGhpcy5vcHRpb25zLnVuZGVyc2NvcmVkO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnRhYmxlTmFtZSkge1xuICAgICAgdGhpcy50YWJsZU5hbWUgPSB0aGlzLm9wdGlvbnMuZnJlZXplVGFibGVOYW1lID8gdGhpcy5uYW1lIDogVXRpbHMudW5kZXJzY29yZWRJZihVdGlscy5wbHVyYWxpemUodGhpcy5uYW1lKSwgdGhpcy51bmRlcnNjb3JlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFibGVOYW1lID0gdGhpcy5vcHRpb25zLnRhYmxlTmFtZTtcbiAgICB9XG4gICAgdGhpcy5fc2NoZW1hID0gdGhpcy5vcHRpb25zLnNjaGVtYTtcbiAgICB0aGlzLl9zY2hlbWFEZWxpbWl0ZXIgPSB0aGlzLm9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyO1xuICAgIF8uZWFjaChvcHRpb25zLnZhbGlkYXRlLCAodmFsaWRhdG9yLCB2YWxpZGF0b3JUeXBlKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsIHZhbGlkYXRvclR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBtb2RlbCB2YWxpZGF0b3IgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSB0aGUgc2FtZSBuYW1lIGFzIGEgZmllbGQuIE1vZGVsOiAke3RoaXMubmFtZX0sIGZpZWxkL3ZhbGlkYXRpb24gbmFtZTogJHt2YWxpZGF0b3JUeXBlfWApO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0b3IgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1lbWJlcnMgb2YgdGhlIHZhbGlkYXRlIG9wdGlvbiBtdXN0IGJlIGZ1bmN0aW9ucy4gTW9kZWw6ICR7dGhpcy5uYW1lfSwgZXJyb3Igd2l0aCB2YWxpZGF0ZSBtZW1iZXIgJHt2YWxpZGF0b3JUeXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghXy5pbmNsdWRlcyhbXCJhbmRcIiwgXCJvdmVyd3JpdGVcIl0sIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMud2hlcmVNZXJnZVN0cmF0ZWd5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlICR7dGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy53aGVyZU1lcmdlU3RyYXRlZ3l9IGZvciB3aGVyZU1lcmdlU3RyYXRlZ3kuIEFsbG93ZWQgdmFsdWVzIGFyZSAnYW5kJyBhbmQgJ292ZXJ3cml0ZScuYCk7XG4gICAgfVxuICAgIHRoaXMucmF3QXR0cmlidXRlcyA9IF8ubWFwVmFsdWVzKGF0dHJpYnV0ZXMsIChhdHRyaWJ1dGUsIG5hbWUpID0+IHtcbiAgICAgIGF0dHJpYnV0ZSA9IHRoaXMuc2VxdWVsaXplLm5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZGF0YXR5cGUgZm9yIGF0dHJpYnV0ZSBcIiR7dGhpcy5uYW1lfS4ke25hbWV9XCJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRyaWJ1dGUuYWxsb3dOdWxsICE9PSBmYWxzZSAmJiBfLmdldChhdHRyaWJ1dGUsIFwidmFsaWRhdGUubm90TnVsbFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGVmaW5pdGlvbiBmb3IgXCIke3RoaXMubmFtZX0uJHtuYW1lfVwiLCBcIm5vdE51bGxcIiB2YWxpZGF0b3IgaXMgb25seSBhbGxvd2VkIHdpdGggXCJhbGxvd051bGw6ZmFsc2VcImApO1xuICAgICAgfVxuICAgICAgaWYgKF8uZ2V0KGF0dHJpYnV0ZSwgXCJyZWZlcmVuY2VzLm1vZGVsLnByb3RvdHlwZVwiKSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5yZWZlcmVuY2VzLm1vZGVsID0gYXR0cmlidXRlLnJlZmVyZW5jZXMubW9kZWwuZ2V0VGFibGVOYW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlO1xuICAgIH0pO1xuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKCk7XG4gICAgdGhpcy5faW5kZXhlcyA9IHRoaXMub3B0aW9ucy5pbmRleGVzLm1hcCgoaW5kZXgpID0+IFV0aWxzLm5hbWVJbmRleCh0aGlzLl9jb25mb3JtSW5kZXgoaW5kZXgpLCB0YWJsZU5hbWUpKTtcbiAgICB0aGlzLnByaW1hcnlLZXlzID0ge307XG4gICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aW1lc3RhbXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBbXCJjcmVhdGVkQXRcIiwgXCJ1cGRhdGVkQXRcIiwgXCJkZWxldGVkQXRcIl0pIHtcbiAgICAgICAgaWYgKCFbXCJ1bmRlZmluZWRcIiwgXCJzdHJpbmdcIiwgXCJib29sZWFuXCJdLmluY2x1ZGVzKHR5cGVvZiB0aGlzLm9wdGlvbnNba2V5XSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGZvciBcIiR7a2V5fVwiIG9wdGlvbiBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYm9vbGVhbiwgZ290ICR7dHlwZW9mIHRoaXMub3B0aW9uc1trZXldfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNba2V5XSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgZm9yIFwiJHtrZXl9XCIgb3B0aW9uIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jcmVhdGVkQXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0ID0gdHlwZW9mIHRoaXMub3B0aW9ucy5jcmVhdGVkQXQgPT09IFwic3RyaW5nXCIgPyB0aGlzLm9wdGlvbnMuY3JlYXRlZEF0IDogXCJjcmVhdGVkQXRcIjtcbiAgICAgICAgdGhpcy5fcmVhZE9ubHlBdHRyaWJ1dGVzLmFkZCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmNyZWF0ZWRBdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwZGF0ZWRBdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnVwZGF0ZWRBdCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMub3B0aW9ucy51cGRhdGVkQXQgOiBcInVwZGF0ZWRBdFwiO1xuICAgICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyYW5vaWQgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZWRBdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgPSB0eXBlb2YgdGhpcy5vcHRpb25zLmRlbGV0ZWRBdCA9PT0gXCJzdHJpbmdcIiA/IHRoaXMub3B0aW9ucy5kZWxldGVkQXQgOiBcImRlbGV0ZWRBdFwiO1xuICAgICAgICB0aGlzLl9yZWFkT25seUF0dHJpYnV0ZXMuYWRkKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICB0aGlzLl92ZXJzaW9uQXR0cmlidXRlID0gdHlwZW9mIHRoaXMub3B0aW9ucy52ZXJzaW9uID09PSBcInN0cmluZ1wiID8gdGhpcy5vcHRpb25zLnZlcnNpb24gOiBcInZlcnNpb25cIjtcbiAgICAgIHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5hZGQodGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHRoaXMuX2hhc1JlYWRPbmx5QXR0cmlidXRlcyA9IHRoaXMuX3JlYWRPbmx5QXR0cmlidXRlcy5zaXplID4gMDtcbiAgICB0aGlzLl9hZGREZWZhdWx0QXR0cmlidXRlcygpO1xuICAgIHRoaXMucmVmcmVzaEF0dHJpYnV0ZXMoKTtcbiAgICB0aGlzLl9maW5kQXV0b0luY3JlbWVudEF0dHJpYnV0ZSgpO1xuICAgIHRoaXMuX3Njb3BlID0gdGhpcy5vcHRpb25zLmRlZmF1bHRTY29wZTtcbiAgICB0aGlzLl9zY29wZU5hbWVzID0gW1wiZGVmYXVsdFNjb3BlXCJdO1xuICAgIHRoaXMuc2VxdWVsaXplLm1vZGVsTWFuYWdlci5hZGRNb2RlbCh0aGlzKTtcbiAgICB0aGlzLnNlcXVlbGl6ZS5ydW5Ib29rcyhcImFmdGVyRGVmaW5lXCIsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyByZWZyZXNoQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVNYW5pcHVsYXRpb24gPSB7fTtcbiAgICB0aGlzLnByb3RvdHlwZS5fY3VzdG9tR2V0dGVycyA9IHt9O1xuICAgIHRoaXMucHJvdG90eXBlLl9jdXN0b21TZXR0ZXJzID0ge307XG4gICAgW1wiZ2V0XCIsIFwic2V0XCJdLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIGNvbnN0IG9wdCA9IGAke3R5cGV9dGVyTWV0aG9kc2A7XG4gICAgICBjb25zdCBmdW5jcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnNbb3B0XSk7XG4gICAgICBjb25zdCBfY3VzdG9tID0gdHlwZSA9PT0gXCJnZXRcIiA/IHRoaXMucHJvdG90eXBlLl9jdXN0b21HZXR0ZXJzIDogdGhpcy5wcm90b3R5cGUuX2N1c3RvbVNldHRlcnM7XG4gICAgICBfLmVhY2goZnVuY3MsIChtZXRob2QsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBfY3VzdG9tW2F0dHJpYnV0ZV0gPSBtZXRob2Q7XG4gICAgICAgIGlmICh0eXBlID09PSBcImdldFwiKSB7XG4gICAgICAgICAgZnVuY3NbYXR0cmlidXRlXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXy5lYWNoKHRoaXMucmF3QXR0cmlidXRlcywgKG9wdGlvbnMsIGF0dHJpYnV0ZSkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIHR5cGUpKSB7XG4gICAgICAgICAgX2N1c3RvbVthdHRyaWJ1dGVdID0gb3B0aW9uc1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJnZXRcIikge1xuICAgICAgICAgIGZ1bmNzW2F0dHJpYnV0ZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyaWJ1dGUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICBmdW5jc1thdHRyaWJ1dGVdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldChhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF8uZWFjaChmdW5jcywgKGZjdCwgbmFtZSkgPT4ge1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZU1hbmlwdWxhdGlvbltuYW1lXSkge1xuICAgICAgICAgIGF0dHJpYnV0ZU1hbmlwdWxhdGlvbltuYW1lXSA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlTWFuaXB1bGF0aW9uW25hbWVdW3R5cGVdID0gZmN0O1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZGF0YVR5cGVDaGFuZ2VzID0ge307XG4gICAgdGhpcy5fZGF0YVR5cGVTYW5pdGl6ZXJzID0ge307XG4gICAgdGhpcy5faGFzQm9vbGVhbkF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLl9oYXNEYXRlQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIHRoaXMuX2pzb25BdHRyaWJ1dGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGVmYXVsdFZhbHVlcyA9IHt9O1xuICAgIHRoaXMucHJvdG90eXBlLnZhbGlkYXRvcnMgPSB7fTtcbiAgICB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcCA9IHt9O1xuICAgIHRoaXMucHJpbWFyeUtleXMgPSB7fTtcbiAgICB0aGlzLnVuaXF1ZUtleXMgPSB7fTtcbiAgICBfLmVhY2godGhpcy5yYXdBdHRyaWJ1dGVzLCAoZGVmaW5pdGlvbiwgbmFtZSkgPT4ge1xuICAgICAgZGVmaW5pdGlvbi50eXBlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplRGF0YVR5cGUoZGVmaW5pdGlvbi50eXBlKTtcbiAgICAgIGRlZmluaXRpb24uTW9kZWwgPSB0aGlzO1xuICAgICAgZGVmaW5pdGlvbi5maWVsZE5hbWUgPSBuYW1lO1xuICAgICAgZGVmaW5pdGlvbi5fbW9kZWxBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgaWYgKGRlZmluaXRpb24uZmllbGQgPT09IHZvaWQgMCkge1xuICAgICAgICBkZWZpbml0aW9uLmZpZWxkID0gVXRpbHMudW5kZXJzY29yZWRJZihuYW1lLCB0aGlzLnVuZGVyc2NvcmVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbml0aW9uLnByaW1hcnlLZXkgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5S2V5c1tuYW1lXSA9IGRlZmluaXRpb247XG4gICAgICB9XG4gICAgICB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcFtkZWZpbml0aW9uLmZpZWxkXSA9IGRlZmluaXRpb247XG4gICAgICBpZiAoZGVmaW5pdGlvbi50eXBlLl9zYW5pdGl6ZSkge1xuICAgICAgICB0aGlzLl9kYXRhVHlwZVNhbml0aXplcnNbbmFtZV0gPSBkZWZpbml0aW9uLnR5cGUuX3Nhbml0aXplO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZS5faXNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX2RhdGFUeXBlQ2hhbmdlc1tuYW1lXSA9IGRlZmluaXRpb24udHlwZS5faXNDaGFuZ2VkO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24udHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5CT09MRUFOKSB7XG4gICAgICAgIHRoaXMuX2hhc0Jvb2xlYW5BdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEUgfHwgZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkRBVEVPTkxZKSB7XG4gICAgICAgIHRoaXMuX2hhc0RhdGVBdHRyaWJ1dGVzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pIHtcbiAgICAgICAgdGhpcy5fanNvbkF0dHJpYnV0ZXMuYWRkKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChkZWZpbml0aW9uLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVklSVFVBTCkge1xuICAgICAgICB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5hZGQobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24sIFwiZGVmYXVsdFZhbHVlXCIpKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZXNbbmFtZV0gPSAoKSA9PiBVdGlscy50b0RlZmF1bHRWYWx1ZShkZWZpbml0aW9uLmRlZmF1bHRWYWx1ZSwgdGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGVmaW5pdGlvbiwgXCJ1bmlxdWVcIikgJiYgZGVmaW5pdGlvbi51bmlxdWUpIHtcbiAgICAgICAgbGV0IGlkeE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbi51bmlxdWUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmluaXRpb24udW5pcXVlLCBcIm5hbWVcIikpIHtcbiAgICAgICAgICBpZHhOYW1lID0gZGVmaW5pdGlvbi51bmlxdWUubmFtZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbi51bmlxdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZHhOYW1lID0gZGVmaW5pdGlvbi51bmlxdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWR4TmFtZSA9IGAke3RoaXMudGFibGVOYW1lfV8ke25hbWV9X3VuaXF1ZWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy51bmlxdWVLZXlzW2lkeE5hbWVdIHx8IHsgZmllbGRzOiBbXSB9O1xuICAgICAgICBpZHguZmllbGRzLnB1c2goZGVmaW5pdGlvbi5maWVsZCk7XG4gICAgICAgIGlkeC5tc2cgPSBpZHgubXNnIHx8IGRlZmluaXRpb24udW5pcXVlLm1zZyB8fCBudWxsO1xuICAgICAgICBpZHgubmFtZSA9IGlkeE5hbWUgfHwgZmFsc2U7XG4gICAgICAgIGlkeC5jb2x1bW4gPSBuYW1lO1xuICAgICAgICBpZHguY3VzdG9tSW5kZXggPSBkZWZpbml0aW9uLnVuaXF1ZSAhPT0gdHJ1ZTtcbiAgICAgICAgdGhpcy51bmlxdWVLZXlzW2lkeE5hbWVdID0gaWR4O1xuICAgICAgfVxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZpbml0aW9uLCBcInZhbGlkYXRlXCIpKSB7XG4gICAgICAgIHRoaXMucHJvdG90eXBlLnZhbGlkYXRvcnNbbmFtZV0gPSBkZWZpbml0aW9uLnZhbGlkYXRlO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmluaXRpb24uaW5kZXggPT09IHRydWUgJiYgZGVmaW5pdGlvbi50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT05CKSB7XG4gICAgICAgIHRoaXMuX2luZGV4ZXMucHVzaChVdGlscy5uYW1lSW5kZXgodGhpcy5fY29uZm9ybUluZGV4KHtcbiAgICAgICAgICBmaWVsZHM6IFtkZWZpbml0aW9uLmZpZWxkIHx8IG5hbWVdLFxuICAgICAgICAgIHVzaW5nOiBcImdpblwiXG4gICAgICAgIH0pLCB0aGlzLmdldFRhYmxlTmFtZSgpKSk7XG4gICAgICAgIGRlbGV0ZSBkZWZpbml0aW9uLmluZGV4O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmllbGRBdHRyaWJ1dGVNYXAgPSBfLnJlZHVjZSh0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcCwgKG1hcCwgdmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKGtleSAhPT0gdmFsdWUuZmllbGROYW1lKSB7XG4gICAgICAgIG1hcFtrZXldID0gdmFsdWUuZmllbGROYW1lO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSk7XG4gICAgdGhpcy5faGFzSnNvbkF0dHJpYnV0ZXMgPSAhIXRoaXMuX2pzb25BdHRyaWJ1dGVzLnNpemU7XG4gICAgdGhpcy5faGFzVmlydHVhbEF0dHJpYnV0ZXMgPSAhIXRoaXMuX3ZpcnR1YWxBdHRyaWJ1dGVzLnNpemU7XG4gICAgdGhpcy5faGFzRGVmYXVsdFZhbHVlcyA9ICFfLmlzRW1wdHkodGhpcy5fZGVmYXVsdFZhbHVlcyk7XG4gICAgdGhpcy50YWJsZUF0dHJpYnV0ZXMgPSBfLm9taXRCeSh0aGlzLnJhd0F0dHJpYnV0ZXMsIChfYSwga2V5KSA9PiB0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoa2V5KSk7XG4gICAgdGhpcy5wcm90b3R5cGUuX2hhc0N1c3RvbUdldHRlcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3RvdHlwZS5fY3VzdG9tR2V0dGVycykubGVuZ3RoO1xuICAgIHRoaXMucHJvdG90eXBlLl9oYXNDdXN0b21TZXR0ZXJzID0gT2JqZWN0LmtleXModGhpcy5wcm90b3R5cGUuX2N1c3RvbVNldHRlcnMpLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhhdHRyaWJ1dGVNYW5pcHVsYXRpb24pKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1vZGVsLnByb3RvdHlwZSwga2V5KSkge1xuICAgICAgICB0aGlzLnNlcXVlbGl6ZS5sb2coYE5vdCBvdmVycmlkaW5nIGJ1aWx0LWluIG1ldGhvZCBmcm9tIG1vZGVsIGF0dHJpYnV0ZTogJHtrZXl9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucHJvdG90eXBlLCBrZXksIGF0dHJpYnV0ZU1hbmlwdWxhdGlvbltrZXldKTtcbiAgICB9XG4gICAgdGhpcy5wcm90b3R5cGUucmF3QXR0cmlidXRlcyA9IHRoaXMucmF3QXR0cmlidXRlcztcbiAgICB0aGlzLnByb3RvdHlwZS5faXNBdHRyaWJ1dGUgPSAoa2V5KSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm90b3R5cGUucmF3QXR0cmlidXRlcywga2V5KTtcbiAgICB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzID0gT2JqZWN0LmtleXModGhpcy5wcmltYXJ5S2V5cyk7XG4gICAgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlID0gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlc1swXTtcbiAgICBpZiAodGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlKSB7XG4gICAgICB0aGlzLnByaW1hcnlLZXlGaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1t0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVdLmZpZWxkIHx8IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZTtcbiAgICB9XG4gICAgdGhpcy5faGFzUHJpbWFyeUtleXMgPSB0aGlzLnByaW1hcnlLZXlBdHRyaWJ1dGVzLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5faXNQcmltYXJ5S2V5ID0gKGtleSkgPT4gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlcy5pbmNsdWRlcyhrZXkpO1xuICAgIHRoaXMuX2F0dHJpYnV0ZU1hbmlwdWxhdGlvbiA9IGF0dHJpYnV0ZU1hbmlwdWxhdGlvbjtcbiAgfVxuICBzdGF0aWMgcmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSkge1xuICAgIGRlbGV0ZSB0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGVzKCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHN5bmMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgb3B0aW9ucy5ob29rcyA9IG9wdGlvbnMuaG9va3MgPT09IHZvaWQgMCA/IHRydWUgOiAhIW9wdGlvbnMuaG9va3M7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHRoaXMudGFibGVBdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHJhd0F0dHJpYnV0ZXMgPSB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcDtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZVN5bmNcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpO1xuICAgIGxldCB0YWJsZUV4aXN0cztcbiAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgYXdhaXQgdGhpcy5kcm9wKG9wdGlvbnMpO1xuICAgICAgdGFibGVFeGlzdHMgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFibGVFeGlzdHMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnRhYmxlRXhpc3RzKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICghdGFibGVFeGlzdHMpIHtcbiAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuY3JlYXRlVGFibGUodGFibGVOYW1lLCBhdHRyaWJ1dGVzLCBvcHRpb25zLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5lbnN1cmVFbnVtcyh0YWJsZU5hbWUsIGF0dHJpYnV0ZXMsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGFibGVFeGlzdHMgJiYgb3B0aW9ucy5hbHRlcikge1xuICAgICAgY29uc3QgdGFibGVJbmZvcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5xdWVyeUludGVyZmFjZS5kZXNjcmliZVRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyksXG4gICAgICAgIHRoaXMucXVlcnlJbnRlcmZhY2UuZ2V0Rm9yZWlnbktleVJlZmVyZW5jZXNGb3JUYWJsZSh0YWJsZU5hbWUsIG9wdGlvbnMpXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSB0YWJsZUluZm9zWzBdO1xuICAgICAgY29uc3QgZm9yZWlnbktleVJlZmVyZW5jZXMgPSB0YWJsZUluZm9zWzFdO1xuICAgICAgY29uc3QgcmVtb3ZlZENvbnN0cmFpbnRzID0ge307XG4gICAgICBmb3IgKGNvbnN0IGNvbHVtbk5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRyaWJ1dGVzLCBjb2x1bW5OYW1lKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCFjb2x1bW5zW2NvbHVtbk5hbWVdICYmICFjb2x1bW5zW2F0dHJpYnV0ZXNbY29sdW1uTmFtZV0uZmllbGRdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5hZGRDb2x1bW4odGFibGVOYW1lLCBhdHRyaWJ1dGVzW2NvbHVtbk5hbWVdLmZpZWxkIHx8IGNvbHVtbk5hbWUsIGF0dHJpYnV0ZXNbY29sdW1uTmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbHRlciA9PT0gdHJ1ZSB8fCB0eXBlb2Ygb3B0aW9ucy5hbHRlciA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmFsdGVyLmRyb3AgIT09IGZhbHNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29sdW1uTmFtZSBpbiBjb2x1bW5zKSB7XG4gICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29sdW1ucywgY29sdW1uTmFtZSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlID0gcmF3QXR0cmlidXRlc1tjb2x1bW5OYW1lXTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UucmVtb3ZlQ29sdW1uKHRhYmxlTmFtZSwgY29sdW1uTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGUucHJpbWFyeUtleSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBjdXJyZW50QXR0cmlidXRlLnJlZmVyZW5jZXM7XG4gICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGUucmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3QgZGF0YWJhc2UgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuZGF0YWJhc2U7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLnNlcXVlbGl6ZS5jb25maWcuc2NoZW1hO1xuICAgICAgICAgICAgZm9yIChjb25zdCBmb3JlaWduS2V5UmVmZXJlbmNlIG9mIGZvcmVpZ25LZXlSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnROYW1lID0gZm9yZWlnbktleVJlZmVyZW5jZS5jb25zdHJhaW50TmFtZTtcbiAgICAgICAgICAgICAgaWYgKCEhY29uc3RyYWludE5hbWUgJiYgZm9yZWlnbktleVJlZmVyZW5jZS50YWJsZUNhdGFsb2cgPT09IGRhdGFiYXNlICYmIChzY2hlbWEgPyBmb3JlaWduS2V5UmVmZXJlbmNlLnRhYmxlU2NoZW1hID09PSBzY2hlbWEgOiB0cnVlKSAmJiBmb3JlaWduS2V5UmVmZXJlbmNlLnJlZmVyZW5jZWRUYWJsZU5hbWUgPT09IHJlZmVyZW5jZXMubW9kZWwgJiYgZm9yZWlnbktleVJlZmVyZW5jZS5yZWZlcmVuY2VkQ29sdW1uTmFtZSA9PT0gcmVmZXJlbmNlcy5rZXkgJiYgKHNjaGVtYSA/IGZvcmVpZ25LZXlSZWZlcmVuY2UucmVmZXJlbmNlZFRhYmxlU2NoZW1hID09PSBzY2hlbWEgOiB0cnVlKSAmJiAhcmVtb3ZlZENvbnN0cmFpbnRzW2NvbnN0cmFpbnROYW1lXSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UucmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGNvbnN0cmFpbnROYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZW1vdmVkQ29uc3RyYWludHNbY29uc3RyYWludE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmNoYW5nZUNvbHVtbih0YWJsZU5hbWUsIGNvbHVtbk5hbWUsIGN1cnJlbnRBdHRyaWJ1dGUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSW5kZXhlcyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2Uuc2hvd0luZGV4KHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgbWlzc2luZ0luZGV4ZXMgPSB0aGlzLl9pbmRleGVzLmZpbHRlcigoaXRlbTEpID0+ICFleGlzdGluZ0luZGV4ZXMuc29tZSgoaXRlbTIpID0+IGl0ZW0xLm5hbWUgPT09IGl0ZW0yLm5hbWUpKS5zb3J0KChpbmRleDEsIGluZGV4MikgPT4ge1xuICAgICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJwb3N0Z3Jlc1wiKSB7XG4gICAgICAgIGlmIChpbmRleDEuY29uY3VycmVudGx5ID09PSB0cnVlKVxuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoaW5kZXgyLmNvbmN1cnJlbnRseSA9PT0gdHJ1ZSlcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG1pc3NpbmdJbmRleGVzKSB7XG4gICAgICBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmFkZEluZGV4KHRhYmxlTmFtZSwgX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCBpbmRleCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyU3luY1wiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRyb3Aob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmRyb3BUYWJsZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRyb3BTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZHJvcFNjaGVtYShzY2hlbWEpO1xuICB9XG4gIHN0YXRpYyBzY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2xvbmUgPSBjbGFzcyBleHRlbmRzIHRoaXMge1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCBcIm5hbWVcIiwgeyB2YWx1ZTogdGhpcy5uYW1lIH0pO1xuICAgIGNsb25lLl9zY2hlbWEgPSBzY2hlbWE7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjbG9uZS5fc2NoZW1hRGVsaW1pdGVyID0gb3B0aW9ucztcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zY2hlbWFEZWxpbWl0ZXIpIHtcbiAgICAgICAgY2xvbmUuX3NjaGVtYURlbGltaXRlciA9IG9wdGlvbnMuc2NoZW1hRGVsaW1pdGVyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldFRhYmxlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeUdlbmVyYXRvci5hZGRTY2hlbWEodGhpcyk7XG4gIH1cbiAgc3RhdGljIHVuc2NvcGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlKCk7XG4gIH1cbiAgc3RhdGljIGFkZFNjb3BlKG5hbWUsIHNjb3BlLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHsgb3ZlcnJpZGU6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgIGlmICgobmFtZSA9PT0gXCJkZWZhdWx0U2NvcGVcIiAmJiBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuZGVmYXVsdFNjb3BlKS5sZW5ndGggPiAwIHx8IG5hbWUgaW4gdGhpcy5vcHRpb25zLnNjb3BlcykgJiYgb3B0aW9ucy5vdmVycmlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNjb3BlICR7bmFtZX0gYWxyZWFkeSBleGlzdHMuIFBhc3MgeyBvdmVycmlkZTogdHJ1ZSB9IGFzIG9wdGlvbnMgdG8gc2lsZW5jZSB0aGlzIGVycm9yYCk7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSBcImRlZmF1bHRTY29wZVwiKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZGVmYXVsdFNjb3BlID0gdGhpcy5fc2NvcGUgPSBzY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLnNjb3Blc1tuYW1lXSA9IHNjb3BlO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgc2NvcGUob3B0aW9uKSB7XG4gICAgY29uc3Qgc2VsZiA9IGNsYXNzIGV4dGVuZHMgdGhpcyB7XG4gICAgfTtcbiAgICBsZXQgc2NvcGU7XG4gICAgbGV0IHNjb3BlTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgXCJuYW1lXCIsIHsgdmFsdWU6IHRoaXMubmFtZSB9KTtcbiAgICBzZWxmLl9zY29wZSA9IHt9O1xuICAgIHNlbGYuX3Njb3BlTmFtZXMgPSBbXTtcbiAgICBzZWxmLnNjb3BlZCA9IHRydWU7XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gXy5mbGF0dGVuKGFyZ3VtZW50cyk7XG4gICAgZm9yIChjb25zdCBvcHRpb24yIG9mIG9wdGlvbnMpIHtcbiAgICAgIHNjb3BlID0gbnVsbDtcbiAgICAgIHNjb3BlTmFtZSA9IG51bGw7XG4gICAgICBpZiAoXy5pc1BsYWluT2JqZWN0KG9wdGlvbjIpKSB7XG4gICAgICAgIGlmIChvcHRpb24yLm1ldGhvZCkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbjIubWV0aG9kKSAmJiAhIXNlbGYub3B0aW9ucy5zY29wZXNbb3B0aW9uMi5tZXRob2RbMF1dKSB7XG4gICAgICAgICAgICBzY29wZU5hbWUgPSBvcHRpb24yLm1ldGhvZFswXTtcbiAgICAgICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLnNjb3Blc1tzY29wZU5hbWVdLmFwcGx5KHNlbGYsIG9wdGlvbjIubWV0aG9kLnNsaWNlKDEpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYub3B0aW9ucy5zY29wZXNbb3B0aW9uMi5tZXRob2RdKSB7XG4gICAgICAgICAgICBzY29wZU5hbWUgPSBvcHRpb24yLm1ldGhvZDtcbiAgICAgICAgICAgIHNjb3BlID0gc2VsZi5vcHRpb25zLnNjb3Blc1tzY29wZU5hbWVdLmFwcGx5KHNlbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZSA9IG9wdGlvbjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3B0aW9uMiA9PT0gXCJkZWZhdWx0U2NvcGVcIiAmJiBfLmlzUGxhaW5PYmplY3Qoc2VsZi5vcHRpb25zLmRlZmF1bHRTY29wZSkpIHtcbiAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuZGVmYXVsdFNjb3BlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVOYW1lID0gb3B0aW9uMjtcbiAgICAgICAgc2NvcGUgPSBzZWxmLm9wdGlvbnMuc2NvcGVzW3Njb3BlTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHNjb3BlID0gc2NvcGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhzY29wZSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2Fzc2lnbk9wdGlvbnMoc2VsZi5fc2NvcGUsIFV0aWxzLmNsb25lRGVlcChzY29wZSkpO1xuICAgICAgICBzZWxmLl9zY29wZU5hbWVzLnB1c2goc2NvcGVOYW1lID8gc2NvcGVOYW1lIDogXCJkZWZhdWx0U2NvcGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLlNlcXVlbGl6ZVNjb3BlRXJyb3IoYEludmFsaWQgc2NvcGUgJHtzY29wZU5hbWV9IGNhbGxlZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRBbGwob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5RdWVyeUVycm9yKFwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBmaW5kQWxsIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QsIHVzZSBmaW5kQnlQayBpZiB5b3Ugd2lzaCB0byBwYXNzIGEgc2luZ2xlIHByaW1hcnkga2V5IHZhbHVlXCIpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAhPT0gdm9pZCAwICYmIG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0cmlidXRlcykgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuUXVlcnlFcnJvcihcIlRoZSBhdHRyaWJ1dGVzIG9wdGlvbiBtdXN0IGJlIGFuIGFycmF5IG9mIGNvbHVtbiBuYW1lcyBvciBhbiBvYmplY3RcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud2Fybk9uSW52YWxpZE9wdGlvbnMob3B0aW9ucywgT2JqZWN0LmtleXModGhpcy5yYXdBdHRyaWJ1dGVzKSk7XG4gICAgY29uc3QgdGFibGVOYW1lcyA9IHt9O1xuICAgIHRhYmxlTmFtZXNbdGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyldID0gdHJ1ZTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgXy5kZWZhdWx0cyhvcHRpb25zLCB7IGhvb2tzOiB0cnVlIH0pO1xuICAgIG9wdGlvbnMucmVqZWN0T25FbXB0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcInJlamVjdE9uRW1wdHlcIikgPyBvcHRpb25zLnJlamVjdE9uRW1wdHkgOiB0aGlzLm9wdGlvbnMucmVqZWN0T25FbXB0eTtcbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUZpbmRcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICB0aGlzLl9leHBhbmRBdHRyaWJ1dGVzKG9wdGlvbnMpO1xuICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVGaW5kQWZ0ZXJFeHBhbmRJbmNsdWRlQWxsXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb25zLm9yaWdpbmFsQXR0cmlidXRlcyA9IHRoaXMuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgb3B0aW9ucy5oYXNKb2luID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zLCB0YWJsZU5hbWVzKTtcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMucmF3ICYmIHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSAmJiAhb3B0aW9ucy5hdHRyaWJ1dGVzLmluY2x1ZGVzKHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSkgJiYgKCFvcHRpb25zLmdyb3VwIHx8ICFvcHRpb25zLmhhc1NpbmdsZUFzc29jaWF0aW9uIHx8IG9wdGlvbnMuaGFzTXVsdGlBc3NvY2lhdGlvbikpIHtcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gW3RoaXMucHJpbWFyeUtleUF0dHJpYnV0ZV0uY29uY2F0KG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgICAgb3B0aW9ucy5vcmlnaW5hbEF0dHJpYnV0ZXMgPSB0aGlzLl9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMud2hlcmVDb2xsZWN0aW9uID0gb3B0aW9ucy53aGVyZSB8fCBudWxsO1xuICAgIFV0aWxzLm1hcEZpbmRlck9wdGlvbnMob3B0aW9ucywgdGhpcyk7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRoaXMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlRmluZEFmdGVyT3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0T3B0aW9ucyA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IHRhYmxlTmFtZXM6IE9iamVjdC5rZXlzKHRhYmxlTmFtZXMpIH0pO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLnNlbGVjdCh0aGlzLCB0aGlzLmdldFRhYmxlTmFtZShzZWxlY3RPcHRpb25zKSwgc2VsZWN0T3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlckZpbmRcIiwgcmVzdWx0cywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChfLmlzRW1wdHkocmVzdWx0cykgJiYgb3B0aW9ucy5yZWplY3RPbkVtcHR5KSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVqZWN0T25FbXB0eSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBvcHRpb25zLnJlamVjdE9uRW1wdHkoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWplY3RPbkVtcHR5ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG9wdGlvbnMucmVqZWN0T25FbXB0eTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuRW1wdHlSZXN1bHRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgTW9kZWwuX2ZpbmRTZXBhcmF0ZShyZXN1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgd2Fybk9uSW52YWxpZE9wdGlvbnMob3B0aW9ucywgdmFsaWRDb2x1bW5OYW1lcykge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHVucmVjb2duaXplZE9wdGlvbnMgPSBPYmplY3Qua2V5cyhvcHRpb25zKS5maWx0ZXIoKGspID0+ICF2YWxpZFF1ZXJ5S2V5d29yZHMuaGFzKGspKTtcbiAgICBjb25zdCB1bmV4cGVjdGVkTW9kZWxBdHRyaWJ1dGVzID0gXy5pbnRlcnNlY3Rpb24odW5yZWNvZ25pemVkT3B0aW9ucywgdmFsaWRDb2x1bW5OYW1lcyk7XG4gICAgaWYgKCFvcHRpb25zLndoZXJlICYmIHVuZXhwZWN0ZWRNb2RlbEF0dHJpYnV0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgbG9nZ2VyLndhcm4oYE1vZGVsIGF0dHJpYnV0ZXMgKCR7dW5leHBlY3RlZE1vZGVsQXR0cmlidXRlcy5qb2luKFwiLCBcIil9KSBwYXNzZWQgaW50byBmaW5kZXIgbWV0aG9kIG9wdGlvbnMgb2YgbW9kZWwgJHt0aGlzLm5hbWV9LCBidXQgdGhlIG9wdGlvbnMud2hlcmUgb2JqZWN0IGlzIGVtcHR5LiBEaWQgeW91IGZvcmdldCB0byB1c2Ugb3B0aW9ucy53aGVyZT9gKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9pbmplY3REZXBlbmRlbnRWaXJ0dWFsQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNWaXJ0dWFsQXR0cmlidXRlcylcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIGlmICghYXR0cmlidXRlcyB8fCAhQXJyYXkuaXNBcnJheShhdHRyaWJ1dGVzKSlcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICh0aGlzLl92aXJ0dWFsQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlKSAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXS50eXBlLmZpZWxkcykge1xuICAgICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5jb25jYXQodGhpcy5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZV0udHlwZS5maWVsZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBhdHRyaWJ1dGVzID0gXy51bmlxKGF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICB9XG4gIHN0YXRpYyBhc3luYyBfZmluZFNlcGFyYXRlKHJlc3VsdHMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZSB8fCBvcHRpb25zLnJhdyB8fCAhcmVzdWx0cylcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIGNvbnN0IG9yaWdpbmFsID0gcmVzdWx0cztcbiAgICBpZiAob3B0aW9ucy5wbGFpbilcbiAgICAgIHJlc3VsdHMgPSBbcmVzdWx0c107XG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aClcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChvcHRpb25zLmluY2x1ZGUubWFwKGFzeW5jIChpbmNsdWRlKSA9PiB7XG4gICAgICBpZiAoIWluY2x1ZGUuc2VwYXJhdGUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IE1vZGVsLl9maW5kU2VwYXJhdGUocmVzdWx0cy5yZWR1Y2UoKG1lbW8sIHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGxldCBhc3NvY2lhdGlvbnMgPSByZXN1bHQuZ2V0KGluY2x1ZGUuYXNzb2NpYXRpb24uYXMpO1xuICAgICAgICAgIGlmICghYXNzb2NpYXRpb25zKVxuICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzc29jaWF0aW9ucykpXG4gICAgICAgICAgICBhc3NvY2lhdGlvbnMgPSBbYXNzb2NpYXRpb25zXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXNzb2NpYXRpb25zLmxlbmd0aDsgaSAhPT0gbGVuOyArK2kpIHtcbiAgICAgICAgICAgIG1lbW8ucHVzaChhc3NvY2lhdGlvbnNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVtbztcbiAgICAgICAgfSwgW10pLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBfLm9taXQob3B0aW9ucywgXCJpbmNsdWRlXCIsIFwiYXR0cmlidXRlc1wiLCBcIm9yZGVyXCIsIFwid2hlcmVcIiwgXCJsaW1pdFwiLCBcIm9mZnNldFwiLCBcInBsYWluXCIsIFwic2NvcGVcIikpLCB7XG4gICAgICAgICAgaW5jbHVkZTogaW5jbHVkZS5pbmNsdWRlIHx8IFtdXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IGluY2x1ZGUuYXNzb2NpYXRpb24uZ2V0KHJlc3VsdHMsIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBfLm9taXQob3B0aW9ucywgbm9uQ2FzY2FkaW5nT3B0aW9ucykpLCBfLm9taXQoaW5jbHVkZSwgW1wicGFyZW50XCIsIFwiYXNzb2NpYXRpb25cIiwgXCJhc1wiLCBcIm9yaWdpbmFsQXR0cmlidXRlc1wiXSkpKTtcbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgcmVzdWx0LnNldChpbmNsdWRlLmFzc29jaWF0aW9uLmFzLCBtYXBbcmVzdWx0LmdldChpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZUtleSldLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIG9yaWdpbmFsO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kQnlQayhwYXJhbSwgb3B0aW9ucykge1xuICAgIGlmIChbbnVsbCwgdm9pZCAwXS5pbmNsdWRlcyhwYXJhbSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgcGFyYW0gPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHBhcmFtID09PSBcImJpZ2ludFwiIHx8IHR5cGVvZiBwYXJhbSA9PT0gXCJzdHJpbmdcIiB8fCBCdWZmZXIuaXNCdWZmZXIocGFyYW0pKSB7XG4gICAgICBvcHRpb25zLndoZXJlID0ge1xuICAgICAgICBbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXTogcGFyYW1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQXJndW1lbnQgcGFzc2VkIHRvIGZpbmRCeVBrIGlzIGludmFsaWQ6ICR7cGFyYW19YCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbmRPbmUob3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRPbmUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBmaW5kT25lIG11c3QgYmUgYW4gb3B0aW9ucyBvYmplY3QsIHVzZSBmaW5kQnlQayBpZiB5b3Ugd2lzaCB0byBwYXNzIGEgc2luZ2xlIHByaW1hcnkga2V5IHZhbHVlXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgdW5pcXVlU2luZ2xlQ29sdW1ucyA9IF8uY2hhaW4odGhpcy51bmlxdWVLZXlzKS52YWx1ZXMoKS5maWx0ZXIoKGMpID0+IGMuZmllbGRzLmxlbmd0aCA9PT0gMSkubWFwKFwiY29sdW1uXCIpLnZhbHVlKCk7XG4gICAgICBpZiAoIW9wdGlvbnMud2hlcmUgfHwgIV8uc29tZShvcHRpb25zLndoZXJlLCAodmFsdWUsIGtleSkgPT4gKGtleSA9PT0gdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlIHx8IHVuaXF1ZVNpbmdsZUNvbHVtbnMuaW5jbHVkZXMoa2V5KSkgJiYgKFV0aWxzLmlzUHJpbWl0aXZlKHZhbHVlKSB8fCBCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSkpIHtcbiAgICAgICAgb3B0aW9ucy5saW1pdCA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmZpbmRBbGwoXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBwbGFpbjogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgYWdncmVnYXRlKGF0dHJpYnV0ZSwgYWdncmVnYXRlRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGNvbnN0IHByZXZBdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IHByZXZBdHRyaWJ1dGVzO1xuICAgIHRoaXMuX2NvbmZvcm1JbmNsdWRlcyhvcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgdGhpcy5fdmFsaWRhdGVJbmNsdWRlZEVsZW1lbnRzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBhdHRyT3B0aW9ucyA9IHRoaXMucmF3QXR0cmlidXRlc1thdHRyaWJ1dGVdO1xuICAgIGNvbnN0IGZpZWxkID0gYXR0ck9wdGlvbnMgJiYgYXR0ck9wdGlvbnMuZmllbGQgfHwgYXR0cmlidXRlO1xuICAgIGxldCBhZ2dyZWdhdGVDb2x1bW4gPSB0aGlzLnNlcXVlbGl6ZS5jb2woZmllbGQpO1xuICAgIGlmIChvcHRpb25zLmRpc3RpbmN0KSB7XG4gICAgICBhZ2dyZWdhdGVDb2x1bW4gPSB0aGlzLnNlcXVlbGl6ZS5mbihcIkRJU1RJTkNUXCIsIGFnZ3JlZ2F0ZUNvbHVtbik7XG4gICAgfVxuICAgIGxldCB7IGdyb3VwIH0gPSBvcHRpb25zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwKSAmJiBBcnJheS5pc0FycmF5KGdyb3VwWzBdKSkge1xuICAgICAgbm9Eb3VibGVOZXN0ZWRHcm91cCgpO1xuICAgICAgZ3JvdXAgPSBfLmZsYXR0ZW4oZ3JvdXApO1xuICAgIH1cbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBfLnVuaW9uQnkob3B0aW9ucy5hdHRyaWJ1dGVzLCBncm91cCwgW1t0aGlzLnNlcXVlbGl6ZS5mbihhZ2dyZWdhdGVGdW5jdGlvbiwgYWdncmVnYXRlQ29sdW1uKSwgYWdncmVnYXRlRnVuY3Rpb25dXSwgKGEpID0+IEFycmF5LmlzQXJyYXkoYSkgPyBhWzFdIDogYSk7XG4gICAgaWYgKCFvcHRpb25zLmRhdGFUeXBlKSB7XG4gICAgICBpZiAoYXR0ck9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucy5kYXRhVHlwZSA9IGF0dHJPcHRpb25zLnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLmRhdGFUeXBlID0gbmV3IERhdGFUeXBlcy5GTE9BVCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zLmRhdGFUeXBlID0gdGhpcy5zZXF1ZWxpemUubm9ybWFsaXplRGF0YVR5cGUob3B0aW9ucy5kYXRhVHlwZSk7XG4gICAgfVxuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgb3B0aW9ucyA9IHRoaXMuX3BhcmFub2lkQ2xhdXNlKHRoaXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5yYXdTZWxlY3QodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIG9wdGlvbnMsIGFnZ3JlZ2F0ZUZ1bmN0aW9uLCB0aGlzKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvdW50KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHsgaG9va3M6IHRydWUgfSk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBvcHRpb25zLnJhdyA9IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVDb3VudFwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IGNvbCA9IG9wdGlvbnMuY29sIHx8IFwiKlwiO1xuICAgIGlmIChvcHRpb25zLmluY2x1ZGUpIHtcbiAgICAgIGNvbCA9IGAke3RoaXMubmFtZX0uJHtvcHRpb25zLmNvbCB8fCB0aGlzLnByaW1hcnlLZXlGaWVsZH1gO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kaXN0aW5jdCAmJiBjb2wgPT09IFwiKlwiKSB7XG4gICAgICBjb2wgPSB0aGlzLnByaW1hcnlLZXlGaWVsZDtcbiAgICB9XG4gICAgb3B0aW9ucy5wbGFpbiA9ICFvcHRpb25zLmdyb3VwO1xuICAgIG9wdGlvbnMuZGF0YVR5cGUgPSBuZXcgRGF0YVR5cGVzLklOVEVHRVIoKTtcbiAgICBvcHRpb25zLmluY2x1ZGVJZ25vcmVBdHRyaWJ1dGVzID0gZmFsc2U7XG4gICAgb3B0aW9ucy5saW1pdCA9IG51bGw7XG4gICAgb3B0aW9ucy5vZmZzZXQgPSBudWxsO1xuICAgIG9wdGlvbnMub3JkZXIgPSBudWxsO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWdncmVnYXRlKGNvbCwgXCJjb3VudFwiLCBvcHRpb25zKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0Lm1hcCgoaXRlbSkgPT4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgaXRlbSksIHtcbiAgICAgICAgY291bnQ6IE51bWJlcihpdGVtLmNvdW50KVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kQW5kQ291bnRBbGwob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICE9PSB2b2lkIDAgJiYgIV8uaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFyZ3VtZW50IHBhc3NlZCB0byBmaW5kQW5kQ291bnRBbGwgbXVzdCBiZSBhbiBvcHRpb25zIG9iamVjdCwgdXNlIGZpbmRCeVBrIGlmIHlvdSB3aXNoIHRvIHBhc3MgYSBzaW5nbGUgcHJpbWFyeSBrZXkgdmFsdWVcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvdW50T3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAoY291bnRPcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvdW50T3B0aW9ucy5hdHRyaWJ1dGVzID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBbY291bnQsIHJvd3NdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5jb3VudChjb3VudE9wdGlvbnMpLFxuICAgICAgdGhpcy5maW5kQWxsKG9wdGlvbnMpXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvdW50LFxuICAgICAgcm93czogY291bnQgPT09IDAgPyBbXSA6IHJvd3NcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBtYXgoZmllbGQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoZmllbGQsIFwibWF4XCIsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBtaW4oZmllbGQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoZmllbGQsIFwibWluXCIsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBzdW0oZmllbGQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5hZ2dyZWdhdGUoZmllbGQsIFwic3VtXCIsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBidWlsZCh2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWxrQnVpbGQodmFsdWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKHZhbHVlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGJ1bGtCdWlsZCh2YWx1ZVNldHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoeyBpc05ld1JlY29yZDogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMuaW5jbHVkZVZhbGlkYXRlZCkge1xuICAgICAgdGhpcy5fY29uZm9ybUluY2x1ZGVzKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZSkge1xuICAgICAgICB0aGlzLl9leHBhbmRJbmNsdWRlQWxsKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUluY2x1ZGVkRWxlbWVudHMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcy5tYXAoKGF0dHJpYnV0ZSkgPT4gQXJyYXkuaXNBcnJheShhdHRyaWJ1dGUpID8gYXR0cmlidXRlWzFdIDogYXR0cmlidXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlU2V0cy5tYXAoKHZhbHVlcykgPT4gdGhpcy5idWlsZCh2YWx1ZXMsIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY3JlYXRlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyB8fCB7fSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYnVpbGQodmFsdWVzLCB7XG4gICAgICBpc05ld1JlY29yZDogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMuZmllbGRzLFxuICAgICAgaW5jbHVkZTogb3B0aW9ucy5pbmNsdWRlLFxuICAgICAgcmF3OiBvcHRpb25zLnJhdyxcbiAgICAgIHNpbGVudDogb3B0aW9ucy5zaWxlbnRcbiAgICB9KS5zYXZlKG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kT3JCdWlsZChvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLndoZXJlIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHdoZXJlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgcGFzc2VkIHRvIGZpbmRPckJ1aWxkLiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBBUEkgaGFzIGNoYW5nZWQsIGFuZCBpcyBub3cgb3B0aW9ucyBvbmx5IChhbiBvYmplY3Qgd2l0aCB3aGVyZSwgZGVmYXVsdHMga2V5cywgdHJhbnNhY3Rpb24gZXRjLilcIik7XG4gICAgfVxuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IGluc3RhbmNlID0gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgdmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMuZGVmYXVsdHMpO1xuICAgICAgaWYgKF8uaXNQbGFpbk9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgICB2YWx1ZXMgPSBVdGlscy5kZWZhdWx0cyh2YWx1ZXMsIG9wdGlvbnMud2hlcmUpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkKHZhbHVlcywgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gW2luc3RhbmNlLCB0cnVlXTtcbiAgICB9XG4gICAgcmV0dXJuIFtpbnN0YW5jZSwgZmFsc2VdO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmaW5kT3JDcmVhdGUob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy53aGVyZSB8fCBhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB3aGVyZSBhdHRyaWJ1dGUgaW4gdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHBhc3NlZCB0byBmaW5kT3JDcmVhdGUuIFBsZWFzZSBub3RlIHRoYXQgdGhlIEFQSSBoYXMgY2hhbmdlZCwgYW5kIGlzIG5vdyBvcHRpb25zIG9ubHkgKGFuIG9iamVjdCB3aXRoIHdoZXJlLCBkZWZhdWx0cyBrZXlzLCB0cmFuc2FjdGlvbiBldGMuKVwiKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgY29uc3QgZGVmYXVsdHMgPSBPYmplY3Qua2V5cyhvcHRpb25zLmRlZmF1bHRzKTtcbiAgICAgIGNvbnN0IHVua25vd25EZWZhdWx0cyA9IGRlZmF1bHRzLmZpbHRlcigobmFtZSkgPT4gIXRoaXMucmF3QXR0cmlidXRlc1tuYW1lXSk7XG4gICAgICBpZiAodW5rbm93bkRlZmF1bHRzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIud2FybihgVW5rbm93biBhdHRyaWJ1dGVzICgke3Vua25vd25EZWZhdWx0c30pIHBhc3NlZCB0byBkZWZhdWx0cyBvcHRpb24gb2YgZmluZE9yQ3JlYXRlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxUcmFuc2FjdGlvbiA9ICFvcHRpb25zLnRyYW5zYWN0aW9uO1xuICAgIGxldCB2YWx1ZXM7XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5zZXF1ZWxpemUudHJhbnNhY3Rpb24ob3B0aW9ucyk7XG4gICAgICB0cmFuc2FjdGlvbiA9IHQ7XG4gICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kT25lKFV0aWxzLmRlZmF1bHRzKHsgdHJhbnNhY3Rpb24gfSwgb3B0aW9ucykpO1xuICAgICAgaWYgKGZvdW5kICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbZm91bmQsIGZhbHNlXTtcbiAgICAgIH1cbiAgICAgIHZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zLmRlZmF1bHRzKTtcbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgICAgdmFsdWVzID0gVXRpbHMuZGVmYXVsdHModmFsdWVzLCBvcHRpb25zLndoZXJlKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuZXhjZXB0aW9uID0gdHJ1ZTtcbiAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWQgPSBhd2FpdCB0aGlzLmNyZWF0ZSh2YWx1ZXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoY3JlYXRlZC5nZXQodGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtjcmVhdGVkLCB0cnVlXTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yKSlcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZFdoZXJlID0gVXRpbHMuZmxhdHRlbk9iamVjdERlZXAob3B0aW9ucy53aGVyZSk7XG4gICAgICAgIGNvbnN0IGZsYXR0ZW5lZFdoZXJlS2V5cyA9IE9iamVjdC5rZXlzKGZsYXR0ZW5lZFdoZXJlKS5tYXAoKG5hbWUpID0+IF8ubGFzdChuYW1lLnNwbGl0KFwiLlwiKSkpO1xuICAgICAgICBjb25zdCB3aGVyZUZpZWxkcyA9IGZsYXR0ZW5lZFdoZXJlS2V5cy5tYXAoKG5hbWUpID0+IF8uZ2V0KHRoaXMucmF3QXR0cmlidXRlcywgYCR7bmFtZX0uZmllbGRgLCBuYW1lKSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRGaWVsZHMgPSBvcHRpb25zLmRlZmF1bHRzICYmIE9iamVjdC5rZXlzKG9wdGlvbnMuZGVmYXVsdHMpLmZpbHRlcigobmFtZSkgPT4gdGhpcy5yYXdBdHRyaWJ1dGVzW25hbWVdKS5tYXAoKG5hbWUpID0+IHRoaXMucmF3QXR0cmlidXRlc1tuYW1lXS5maWVsZCB8fCBuYW1lKTtcbiAgICAgICAgY29uc3QgZXJyRmllbGRLZXlzID0gT2JqZWN0LmtleXMoZXJyLmZpZWxkcyk7XG4gICAgICAgIGNvbnN0IGVyckZpZWxkc1doZXJlSW50ZXJzZWN0cyA9IFV0aWxzLmludGVyc2VjdHMoZXJyRmllbGRLZXlzLCB3aGVyZUZpZWxkcyk7XG4gICAgICAgIGlmIChkZWZhdWx0RmllbGRzICYmICFlcnJGaWVsZHNXaGVyZUludGVyc2VjdHMgJiYgVXRpbHMuaW50ZXJzZWN0cyhlcnJGaWVsZEtleXMsIGRlZmF1bHRGaWVsZHMpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJGaWVsZHNXaGVyZUludGVyc2VjdHMpIHtcbiAgICAgICAgICBfLmVhY2goZXJyLmZpZWxkcywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmZpZWxkUmF3QXR0cmlidXRlc01hcFtrZXldLmZpZWxkTmFtZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpICE9PSBvcHRpb25zLndoZXJlW25hbWVdLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMubmFtZX0jZmluZE9yQ3JlYXRlOiB2YWx1ZSB1c2VkIGZvciAke25hbWV9IHdhcyBub3QgZXF1YWwgZm9yIGJvdGggdGhlIGZpbmQgYW5kIHRoZSBjcmVhdGUgY2FsbHMsICcke29wdGlvbnMud2hlcmVbbmFtZV19JyB2cyAnJHt2YWx1ZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3RoZXJDcmVhdGVkID0gYXdhaXQgdGhpcy5maW5kT25lKFV0aWxzLmRlZmF1bHRzKHtcbiAgICAgICAgICB0cmFuc2FjdGlvbjogaW50ZXJuYWxUcmFuc2FjdGlvbiA/IG51bGwgOiB0cmFuc2FjdGlvblxuICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgIGlmIChvdGhlckNyZWF0ZWQgPT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICByZXR1cm4gW290aGVyQ3JlYXRlZCwgZmFsc2VdO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaW50ZXJuYWxUcmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbikge1xuICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZpbmRDcmVhdGVGaW5kKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMud2hlcmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlciBwYXNzZWQgdG8gZmluZENyZWF0ZUZpbmQuXCIpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMuZGVmYXVsdHMpO1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy53aGVyZSkpIHtcbiAgICAgIHZhbHVlcyA9IFV0aWxzLmRlZmF1bHRzKHZhbHVlcywgb3B0aW9ucy53aGVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZvdW5kID0gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICAgIGlmIChmb3VuZClcbiAgICAgIHJldHVybiBbZm91bmQsIGZhbHNlXTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3JlYXRlT3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKTtcbiAgICAgIGlmICh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QgPT09IFwicG9zdGdyZXNcIiAmJiBvcHRpb25zLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNyZWF0ZU9wdGlvbnMuaWdub3JlRHVwbGljYXRlcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjcmVhdGVkID0gYXdhaXQgdGhpcy5jcmVhdGUodmFsdWVzLCBjcmVhdGVPcHRpb25zKTtcbiAgICAgIHJldHVybiBbY3JlYXRlZCwgdHJ1ZV07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBzZXF1ZWxpemVFcnJvcnMuVW5pcXVlQ29uc3RyYWludEVycm9yIHx8IGVyciBpbnN0YW5jZW9mIHNlcXVlbGl6ZUVycm9ycy5FbXB0eVJlc3VsdEVycm9yKSkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3VuZEFnYWluID0gYXdhaXQgdGhpcy5maW5kT25lKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIFtmb3VuZEFnYWluLCBmYWxzZV07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBhc3luYyB1cHNlcnQodmFsdWVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgcmV0dXJuaW5nOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IHRydWVcbiAgICB9LCBVdGlscy5jbG9uZURlZXAob3B0aW9ucykpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY3JlYXRlZEF0QXR0ciA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0O1xuICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICBjb25zdCBoYXNQcmltYXJ5ID0gdGhpcy5wcmltYXJ5S2V5RmllbGQgaW4gdmFsdWVzIHx8IHRoaXMucHJpbWFyeUtleUF0dHJpYnV0ZSBpbiB2YWx1ZXM7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmJ1aWxkKHZhbHVlcyk7XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgb3B0aW9ucy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGNvbnN0IGNoYW5nZWQgPSBBcnJheS5mcm9tKGluc3RhbmNlLl9jaGFuZ2VkKTtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IGNoYW5nZWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICBhd2FpdCBpbnN0YW5jZS52YWxpZGF0ZShvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZERhdGFWYWx1ZXMgPSBfLnBpY2soaW5zdGFuY2UuZGF0YVZhbHVlcywgY2hhbmdlZCk7XG4gICAgY29uc3QgaW5zZXJ0VmFsdWVzID0gVXRpbHMubWFwVmFsdWVGaWVsZE5hbWVzKGluc3RhbmNlLmRhdGFWYWx1ZXMsIE9iamVjdC5rZXlzKGluc3RhbmNlLnJhd0F0dHJpYnV0ZXMpLCB0aGlzKTtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZXMgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModXBkYXRlZERhdGFWYWx1ZXMsIG9wdGlvbnMuZmllbGRzLCB0aGlzKTtcbiAgICBjb25zdCBub3cgPSBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICBpZiAoY3JlYXRlZEF0QXR0ciAmJiAhaW5zZXJ0VmFsdWVzW2NyZWF0ZWRBdEF0dHJdKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1tjcmVhdGVkQXRBdHRyXS5maWVsZCB8fCBjcmVhdGVkQXRBdHRyO1xuICAgICAgaW5zZXJ0VmFsdWVzW2ZpZWxkXSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAoY3JlYXRlZEF0QXR0cikgfHwgbm93O1xuICAgIH1cbiAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhaW5zZXJ0VmFsdWVzW3VwZGF0ZWRBdEF0dHJdKSB7XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1t1cGRhdGVkQXRBdHRyXS5maWVsZCB8fCB1cGRhdGVkQXRBdHRyO1xuICAgICAgaW5zZXJ0VmFsdWVzW2ZpZWxkXSA9IHVwZGF0ZVZhbHVlc1tmaWVsZF0gPSB0aGlzLl9nZXREZWZhdWx0VGltZXN0YW1wKHVwZGF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJkYjJcIikge1xuICAgICAgdGhpcy51bmlxbm8gPSB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmFkZFVuaXF1ZUZpZWxkcyhpbnNlcnRWYWx1ZXMsIHRoaXMucmF3QXR0cmlidXRlcywgdGhpcy51bmlxbm8pO1xuICAgIH1cbiAgICBpZiAoIWhhc1ByaW1hcnkgJiYgdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlICYmICF0aGlzLnJhd0F0dHJpYnV0ZXNbdGhpcy5wcmltYXJ5S2V5QXR0cmlidXRlXS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIGRlbGV0ZSBpbnNlcnRWYWx1ZXNbdGhpcy5wcmltYXJ5S2V5RmllbGRdO1xuICAgICAgZGVsZXRlIHVwZGF0ZVZhbHVlc1t0aGlzLnByaW1hcnlLZXlGaWVsZF07XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlVXBzZXJ0XCIsIHZhbHVlcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UudXBzZXJ0KHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBpbnNlcnRWYWx1ZXMsIHVwZGF0ZVZhbHVlcywgaW5zdGFuY2Uud2hlcmUoKSwgb3B0aW9ucyk7XG4gICAgY29uc3QgW3JlY29yZF0gPSByZXN1bHQ7XG4gICAgcmVjb3JkLmlzTmV3UmVjb3JkID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlclVwc2VydFwiLCByZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgYnVsa0NyZWF0ZShyZWNvcmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIXJlY29yZHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGRpYWxlY3QgPSB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3Q7XG4gICAgY29uc3Qgbm93ID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIGlmICghb3B0aW9ucy5pbmNsdWRlVmFsaWRhdGVkKSB7XG4gICAgICB0aGlzLl9jb25mb3JtSW5jbHVkZXMob3B0aW9ucywgdGhpcyk7XG4gICAgICBpZiAob3B0aW9ucy5pbmNsdWRlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZEluY2x1ZGVBbGwob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlSW5jbHVkZWRFbGVtZW50cyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5zdGFuY2VzID0gcmVjb3Jkcy5tYXAoKHZhbHVlcykgPT4gdGhpcy5idWlsZCh2YWx1ZXMsIHsgaXNOZXdSZWNvcmQ6IHRydWUsIGluY2x1ZGU6IG9wdGlvbnMuaW5jbHVkZSB9KSk7XG4gICAgY29uc3QgcmVjdXJzaXZlQnVsa0NyZWF0ZSA9IGFzeW5jIChpbnN0YW5jZXMyLCBvcHRpb25zMikgPT4ge1xuICAgICAgb3B0aW9uczIgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgaG9va3M6IHRydWUsXG4gICAgICAgIGluZGl2aWR1YWxIb29rczogZmFsc2UsXG4gICAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zMik7XG4gICAgICBpZiAob3B0aW9uczIucmV0dXJuaW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMyLmFzc29jaWF0aW9uKSB7XG4gICAgICAgICAgb3B0aW9uczIucmV0dXJuaW5nID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9uczIucmV0dXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMyLmlnbm9yZUR1cGxpY2F0ZXMgJiYgIXRoaXMuc2VxdWVsaXplLmRpYWxlY3Quc3VwcG9ydHMuaW5zZXJ0cy5pZ25vcmVEdXBsaWNhdGVzICYmICF0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnN1cHBvcnRzLmluc2VydHMub25Db25mbGljdERvTm90aGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZGlhbGVjdH0gZG9lcyBub3Qgc3VwcG9ydCB0aGUgaWdub3JlRHVwbGljYXRlcyBvcHRpb24uYCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUgJiYgKGRpYWxlY3QgIT09IFwibXlzcWxcIiAmJiBkaWFsZWN0ICE9PSBcIm1hcmlhZGJcIiAmJiBkaWFsZWN0ICE9PSBcInNxbGl0ZVwiICYmIGRpYWxlY3QgIT09IFwicG9zdGdyZXNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RpYWxlY3R9IGRvZXMgbm90IHN1cHBvcnQgdGhlIHVwZGF0ZU9uRHVwbGljYXRlIG9wdGlvbi5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vZGVsID0gb3B0aW9uczIubW9kZWw7XG4gICAgICBvcHRpb25zMi5maWVsZHMgPSBvcHRpb25zMi5maWVsZHMgfHwgT2JqZWN0LmtleXMobW9kZWwucmF3QXR0cmlidXRlcyk7XG4gICAgICBjb25zdCBjcmVhdGVkQXRBdHRyID0gbW9kZWwuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0O1xuICAgICAgY29uc3QgdXBkYXRlZEF0QXR0ciA9IG1vZGVsLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICAgIGlmIChvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlKSAmJiBvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZS5sZW5ndGgpIHtcbiAgICAgICAgICBvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZSA9IF8uaW50ZXJzZWN0aW9uKF8ud2l0aG91dChPYmplY3Qua2V5cyhtb2RlbC50YWJsZUF0dHJpYnV0ZXMpLCBjcmVhdGVkQXRBdHRyKSwgb3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVwZGF0ZU9uRHVwbGljYXRlIG9wdGlvbiBvbmx5IHN1cHBvcnRzIG5vbi1lbXB0eSBhcnJheS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zMi5ob29rcykge1xuICAgICAgICBhd2FpdCBtb2RlbC5ydW5Ib29rcyhcImJlZm9yZUJ1bGtDcmVhdGVcIiwgaW5zdGFuY2VzMiwgb3B0aW9uczIpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMyLnZhbGlkYXRlKSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBjb25zdCB2YWxpZGF0ZU9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9uczIpO1xuICAgICAgICB2YWxpZGF0ZU9wdGlvbnMuaG9va3MgPSBvcHRpb25zMi5pbmRpdmlkdWFsSG9va3M7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlczIubWFwKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBpbnN0YW5jZS52YWxpZGF0ZSh2YWxpZGF0ZU9wdGlvbnMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gobmV3IHNlcXVlbGl6ZUVycm9ycy5CdWxrUmVjb3JkRXJyb3IoZXJyLCBpbnN0YW5jZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBkZWxldGUgb3B0aW9uczIuc2tpcDtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkFnZ3JlZ2F0ZUVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zMi5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzMi5tYXAoYXN5bmMgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5kaXZpZHVhbE9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zMiksIHtcbiAgICAgICAgICAgIHZhbGlkYXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGhvb2tzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGVsZXRlIGluZGl2aWR1YWxPcHRpb25zLmZpZWxkcztcbiAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzO1xuICAgICAgICAgIGRlbGV0ZSBpbmRpdmlkdWFsT3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVzO1xuICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5kaXZpZHVhbE9wdGlvbnMpO1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9uczIuaW5jbHVkZSAmJiBvcHRpb25zMi5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMyLmluY2x1ZGUuZmlsdGVyKChpbmNsdWRlKSA9PiBpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvKS5tYXAoYXN5bmMgKGluY2x1ZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlczIpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSA9IGluc3RhbmNlLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgICAgICAgaWYgKGFzc29jaWF0aW9uSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlcy5wdXNoKGFzc29jaWF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXNzb2NpYXRpb25JbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpLm9taXQoW1wiYXNzb2NpYXRpb25cIl0pLmRlZmF1bHRzKHtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMyLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICBsb2dnaW5nOiBvcHRpb25zMi5sb2dnaW5nXG4gICAgICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzID0gYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZShhc3NvY2lhdGlvbkluc3RhbmNlcywgaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFzc29jaWF0aW9uSW5zdGFuY2UgPSBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXNbaWR4XTtcbiAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwW2lkeF07XG4gICAgICAgICAgICAgIGF3YWl0IGluY2x1ZGUuYXNzb2NpYXRpb24uc2V0KGluc3RhbmNlLCBhc3NvY2lhdGlvbkluc3RhbmNlLCB7IHNhdmU6IGZhbHNlLCBsb2dnaW5nOiBvcHRpb25zMi5sb2dnaW5nIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzID0gaW5zdGFuY2VzMi5tYXAoKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWVzID0gaW5zdGFuY2UuZGF0YVZhbHVlcztcbiAgICAgICAgICBpZiAoY3JlYXRlZEF0QXR0ciAmJiAhdmFsdWVzW2NyZWF0ZWRBdEF0dHJdKSB7XG4gICAgICAgICAgICB2YWx1ZXNbY3JlYXRlZEF0QXR0cl0gPSBub3c7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMyLmZpZWxkcy5pbmNsdWRlcyhjcmVhdGVkQXRBdHRyKSkge1xuICAgICAgICAgICAgICBvcHRpb25zMi5maWVsZHMucHVzaChjcmVhdGVkQXRBdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIXZhbHVlc1t1cGRhdGVkQXRBdHRyXSkge1xuICAgICAgICAgICAgdmFsdWVzW3VwZGF0ZWRBdEF0dHJdID0gbm93O1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zMi5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgICAgICAgICAgb3B0aW9uczIuZmllbGRzLnB1c2godXBkYXRlZEF0QXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG91dCA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh2YWx1ZXMsIG9wdGlvbnMyLmZpZWxkcywgbW9kZWwpO1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG1vZGVsLl92aXJ0dWFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgZGVsZXRlIG91dFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmllbGRNYXBwZWRBdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBpbiBtb2RlbC50YWJsZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBmaWVsZE1hcHBlZEF0dHJpYnV0ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCB8fCBhdHRyXSA9IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMyLnVwZGF0ZU9uRHVwbGljYXRlKSB7XG4gICAgICAgICAgb3B0aW9uczIudXBkYXRlT25EdXBsaWNhdGUgPSBvcHRpb25zMi51cGRhdGVPbkR1cGxpY2F0ZS5tYXAoKGF0dHIpID0+IG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgfHwgYXR0cik7XG4gICAgICAgICAgaWYgKG9wdGlvbnMyLmNvbmZsaWN0QXR0cmlidXRlcykge1xuICAgICAgICAgICAgb3B0aW9uczIudXBzZXJ0S2V5cyA9IG9wdGlvbnMyLmNvbmZsaWN0QXR0cmlidXRlcy5tYXAoKGF0dHJOYW1lKSA9PiBtb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJOYW1lXS5maWVsZCB8fCBhdHRyTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVwc2VydEtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBtb2RlbC5faW5kZXhlcykge1xuICAgICAgICAgICAgICBpZiAoaS51bmlxdWUgJiYgIWkud2hlcmUpIHtcbiAgICAgICAgICAgICAgICB1cHNlcnRLZXlzLnB1c2goLi4uaS5maWVsZHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaXJzdFVuaXF1ZUtleSA9IE9iamVjdC52YWx1ZXMobW9kZWwudW5pcXVlS2V5cykuZmluZCgoYykgPT4gYy5maWVsZHMubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBpZiAoZmlyc3RVbmlxdWVLZXkgJiYgZmlyc3RVbmlxdWVLZXkuZmllbGRzKSB7XG4gICAgICAgICAgICAgIHVwc2VydEtleXMucHVzaCguLi5maXJzdFVuaXF1ZUtleS5maWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9uczIudXBzZXJ0S2V5cyA9IHVwc2VydEtleXMubGVuZ3RoID4gMCA/IHVwc2VydEtleXMgOiBPYmplY3QudmFsdWVzKG1vZGVsLnByaW1hcnlLZXlzKS5tYXAoKHgpID0+IHguZmllbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uczIucmV0dXJuaW5nICYmIEFycmF5LmlzQXJyYXkob3B0aW9uczIucmV0dXJuaW5nKSkge1xuICAgICAgICAgIG9wdGlvbnMyLnJldHVybmluZyA9IG9wdGlvbnMyLnJldHVybmluZy5tYXAoKGF0dHIpID0+IF8uZ2V0KG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0sIFwiZmllbGRcIiwgYXR0cikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBtb2RlbC5xdWVyeUludGVyZmFjZS5idWxrSW5zZXJ0KG1vZGVsLmdldFRhYmxlTmFtZShvcHRpb25zMiksIHJlY29yZHMsIG9wdGlvbnMyLCBmaWVsZE1hcHBlZEF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHRzKSkge1xuICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaCgocmVzdWx0LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlczJbaV07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKCFpbnN0YW5jZSB8fCBrZXkgPT09IG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgaW5zdGFuY2UuZ2V0KG1vZGVsLnByaW1hcnlLZXlBdHRyaWJ1dGUpICYmIFtcIm15c3FsXCIsIFwibWFyaWFkYlwiLCBcInNxbGl0ZVwiXS5pbmNsdWRlcyhkaWFsZWN0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IF8uZmluZChtb2RlbC5yYXdBdHRyaWJ1dGVzLCAoYXR0cmlidXRlKSA9PiBhdHRyaWJ1dGUuZmllbGROYW1lID09PSBrZXkgfHwgYXR0cmlidXRlLmZpZWxkID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0ciAmJiBhdHRyLmZpZWxkTmFtZSB8fCBrZXldID0gcmVjb3JkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zMi5pbmNsdWRlICYmIG9wdGlvbnMyLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9wdGlvbnMyLmluY2x1ZGUuZmlsdGVyKChpbmNsdWRlKSA9PiAhKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gfHwgaW5jbHVkZS5wYXJlbnQgJiYgaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSkubWFwKGFzeW5jIChpbmNsdWRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICBjb25zdCBhc3NvY2lhdGlvbkluc3RhbmNlSW5kZXhUb0luc3RhbmNlTWFwID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMyKSB7XG4gICAgICAgICAgICBsZXQgYXNzb2NpYXRlZCA9IGluc3RhbmNlLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc3NvY2lhdGVkKSlcbiAgICAgICAgICAgICAgYXNzb2NpYXRlZCA9IFthc3NvY2lhdGVkXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSBvZiBhc3NvY2lhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpKSB7XG4gICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlLnNldChpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXksIGluc3RhbmNlLmdldChpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZUtleSB8fCBpbnN0YW5jZS5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSwgeyByYXc6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGFzc29jaWF0aW9uSW5zdGFuY2UsIGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbkluc3RhbmNlcy5wdXNoKGFzc29jaWF0aW9uSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXAucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhc3NvY2lhdGlvbkluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSkub21pdChbXCJhc3NvY2lhdGlvblwiXSkuZGVmYXVsdHMoe1xuICAgICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMyLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9uczIubG9nZ2luZ1xuICAgICAgICAgIH0pLnZhbHVlKCk7XG4gICAgICAgICAgY29uc3QgY3JlYXRlZEFzc29jaWF0aW9uSW5zdGFuY2VzID0gYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZShhc3NvY2lhdGlvbkluc3RhbmNlcywgaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uIGluc3RhbmNlb2YgQmVsb25nc1RvTWFueSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVTZXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkeCBpbiBjcmVhdGVkQXNzb2NpYXRpb25JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXNzb2NpYXRpb25JbnN0YW5jZSA9IGNyZWF0ZWRBc3NvY2lhdGlvbkluc3RhbmNlc1tpZHhdO1xuICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGFzc29jaWF0aW9uSW5zdGFuY2VJbmRleFRvSW5zdGFuY2VNYXBbaWR4XTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXldOiBpbnN0YW5jZS5nZXQoaW5zdGFuY2UuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24ub3RoZXJLZXldOiBhc3NvY2lhdGlvbkluc3RhbmNlLmdldChhc3NvY2lhdGlvbkluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pXG4gICAgICAgICAgICAgIH0sIGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5zY29wZSk7XG4gICAgICAgICAgICAgIGlmIChhc3NvY2lhdGlvbkluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3Qua2V5cyhpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5fYXV0b0dlbmVyYXRlZCB8fCBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLmZvcmVpZ25LZXkgfHwgYXR0ciA9PT0gaW5jbHVkZS5hc3NvY2lhdGlvbi5vdGhlcktleSB8fCB0eXBlb2YgYXNzb2NpYXRpb25JbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YWx1ZXNbYXR0cl0gPSBhc3NvY2lhdGlvbkluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXVthdHRyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWVTZXRzLnB1c2godmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRocm91Z2hPcHRpb25zID0gXyhVdGlscy5jbG9uZURlZXAoaW5jbHVkZSkpLm9taXQoW1wiYXNzb2NpYXRpb25cIiwgXCJhdHRyaWJ1dGVzXCJdKS5kZWZhdWx0cyh7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zMi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgbG9nZ2luZzogb3B0aW9uczIubG9nZ2luZ1xuICAgICAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgICAgIHRocm91Z2hPcHRpb25zLm1vZGVsID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoTW9kZWw7XG4gICAgICAgICAgICBjb25zdCB0aHJvdWdoSW5zdGFuY2VzID0gaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoTW9kZWwuYnVsa0J1aWxkKHZhbHVlU2V0cywgdGhyb3VnaE9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgcmVjdXJzaXZlQnVsa0NyZWF0ZSh0aHJvdWdoSW5zdGFuY2VzLCB0aHJvdWdoT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZXMyLmZvckVhY2goKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBpbiBtb2RlbC5yYXdBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgJiYgaW5zdGFuY2UuZGF0YVZhbHVlc1ttb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkXSAhPT0gdm9pZCAwICYmIG1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgIT09IGF0dHIpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmRhdGFWYWx1ZXNbYXR0cl0gPSBpbnN0YW5jZS5kYXRhVmFsdWVzW21vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgICAgICAgZGVsZXRlIGluc3RhbmNlLmRhdGFWYWx1ZXNbbW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlLl9wcmV2aW91c0RhdGFWYWx1ZXNbYXR0cl0gPSBpbnN0YW5jZS5kYXRhVmFsdWVzW2F0dHJdO1xuICAgICAgICAgIGluc3RhbmNlLmNoYW5nZWQoYXR0ciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLmlzTmV3UmVjb3JkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmIChvcHRpb25zMi5ob29rcykge1xuICAgICAgICBhd2FpdCBtb2RlbC5ydW5Ib29rcyhcImFmdGVyQnVsa0NyZWF0ZVwiLCBpbnN0YW5jZXMyLCBvcHRpb25zMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2VzMjtcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCByZWN1cnNpdmVCdWxrQ3JlYXRlKGluc3RhbmNlcywgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHRydW5jYXRlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpIHx8IHt9O1xuICAgIG9wdGlvbnMudHJ1bmNhdGUgPSB0cnVlO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc3Ryb3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIShvcHRpb25zLndoZXJlIHx8IG9wdGlvbnMudHJ1bmNhdGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHdoZXJlIG9yIHRydW5jYXRlIGF0dHJpYnV0ZSBpbiB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgb2YgbW9kZWwuZGVzdHJveS5cIik7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy50cnVuY2F0ZSAmJiAhXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpICYmICFBcnJheS5pc0FycmF5KG9wdGlvbnMud2hlcmUpICYmICEob3B0aW9ucy53aGVyZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHBsYWluIG9iamVjdCwgYXJyYXkgb3Igc2VxdWVsaXplIG1ldGhvZCBpbiB0aGUgb3B0aW9ucy53aGVyZSBwYXJhbWV0ZXIgb2YgbW9kZWwuZGVzdHJveS5cIik7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgIGZvcmNlOiBmYWxzZSxcbiAgICAgIGNhc2NhZGU6IGZhbHNlLFxuICAgICAgcmVzdGFydElkZW50aXR5OiBmYWxzZVxuICAgIH0pO1xuICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS0RFTEVURTtcbiAgICBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzO1xuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlQnVsa0Rlc3Ryb3lcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGxldCBpbnN0YW5jZXM7XG4gICAgaWYgKG9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzKSB7XG4gICAgICBpbnN0YW5jZXMgPSBhd2FpdCB0aGlzLmZpbmRBbGwoeyB3aGVyZTogb3B0aW9ucy53aGVyZSwgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZywgYmVuY2htYXJrOiBvcHRpb25zLmJlbmNobWFyayB9KTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlRGVzdHJveVwiLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQgJiYgIW9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuQlVMS1VQREFURTtcbiAgICAgIGNvbnN0IGF0dHJWYWx1ZUhhc2ggPSB7fTtcbiAgICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMucmF3QXR0cmlidXRlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF07XG4gICAgICBjb25zdCBmaWVsZCA9IHRoaXMucmF3QXR0cmlidXRlc1t0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdF0uZmllbGQ7XG4gICAgICBjb25zdCB3aGVyZSA9IHtcbiAgICAgICAgW2ZpZWxkXTogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbFxuICAgICAgfTtcbiAgICAgIGF0dHJWYWx1ZUhhc2hbZmllbGRdID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtVcGRhdGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIGF0dHJWYWx1ZUhhc2gsIE9iamVjdC5hc3NpZ24od2hlcmUsIG9wdGlvbnMud2hlcmUpLCBvcHRpb25zLCB0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5SW50ZXJmYWNlLmJ1bGtEZWxldGUodGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyksIG9wdGlvbnMud2hlcmUsIG9wdGlvbnMsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJEZXN0cm95XCIsIGluc3RhbmNlLCBvcHRpb25zKSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyQnVsa0Rlc3Ryb3lcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIHJlc3RvcmUob3B0aW9ucykge1xuICAgIGlmICghdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBpcyBub3QgcGFyYW5vaWRcIik7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZVxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5SQVc7XG4gICAgb3B0aW9ucy5tb2RlbCA9IHRoaXM7XG4gICAgVXRpbHMubWFwT3B0aW9uRmllbGROYW1lcyhvcHRpb25zLCB0aGlzKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImJlZm9yZUJ1bGtSZXN0b3JlXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBsZXQgaW5zdGFuY2VzO1xuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgaW5zdGFuY2VzID0gYXdhaXQgdGhpcy5maW5kQWxsKHsgd2hlcmU6IG9wdGlvbnMud2hlcmUsIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsIGJlbmNobWFyazogb3B0aW9ucy5iZW5jaG1hcmssIHBhcmFub2lkOiBmYWxzZSB9KTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB0aGlzLnJ1bkhvb2tzKFwiYmVmb3JlUmVzdG9yZVwiLCBpbnN0YW5jZSwgb3B0aW9ucykpKTtcbiAgICB9XG4gICAgY29uc3QgYXR0clZhbHVlSGFzaCA9IHt9O1xuICAgIGNvbnN0IGRlbGV0ZWRBdENvbCA9IHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgIGNvbnN0IGRlbGV0ZWRBdEF0dHJpYnV0ZSA9IHRoaXMucmF3QXR0cmlidXRlc1tkZWxldGVkQXRDb2xdO1xuICAgIGNvbnN0IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgYXR0clZhbHVlSGFzaFtkZWxldGVkQXRBdHRyaWJ1dGUuZmllbGQgfHwgZGVsZXRlZEF0Q29sXSA9IGRlbGV0ZWRBdERlZmF1bHRWYWx1ZTtcbiAgICBvcHRpb25zLm9taXROdWxsID0gZmFsc2U7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5idWxrVXBkYXRlKHRoaXMuZ2V0VGFibGVOYW1lKG9wdGlvbnMpLCBhdHRyVmFsdWVIYXNoLCBvcHRpb25zLndoZXJlLCBvcHRpb25zLCB0aGlzLnJhd0F0dHJpYnV0ZXMpO1xuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcCgoaW5zdGFuY2UpID0+IHRoaXMucnVuSG9va3MoXCJhZnRlclJlc3RvcmVcIiwgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJCdWxrUmVzdG9yZVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgdXBkYXRlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBVdGlscy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbmplY3RTY29wZShvcHRpb25zKTtcbiAgICB0aGlzLl9vcHRpb25zTXVzdENvbnRhaW5XaGVyZShvcHRpb25zKTtcbiAgICBvcHRpb25zID0gdGhpcy5fcGFyYW5vaWRDbGF1c2UodGhpcywgXy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICB2YWxpZGF0ZTogdHJ1ZSxcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgaW5kaXZpZHVhbEhvb2tzOiBmYWxzZSxcbiAgICAgIHJldHVybmluZzogZmFsc2UsXG4gICAgICBmb3JjZTogZmFsc2UsXG4gICAgICBzaWRlRWZmZWN0czogdHJ1ZVxuICAgIH0pKTtcbiAgICBvcHRpb25zLnR5cGUgPSBRdWVyeVR5cGVzLkJVTEtVUERBVEU7XG4gICAgdmFsdWVzID0gXy5vbWl0QnkodmFsdWVzLCAodmFsdWUpID0+IHZhbHVlID09PSB2b2lkIDApO1xuICAgIGlmIChvcHRpb25zLmZpZWxkcyAmJiBvcHRpb25zLmZpZWxkcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5maWVsZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGVkQXRBdHRyID0gdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQ7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IF8uaW50ZXJzZWN0aW9uKE9iamVjdC5rZXlzKHZhbHVlcyksIE9iamVjdC5rZXlzKHRoaXMudGFibGVBdHRyaWJ1dGVzKSk7XG4gICAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiAhb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh1cGRhdGVkQXRBdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0ICYmICFvcHRpb25zLnNpbGVudCkge1xuICAgICAgdmFsdWVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSA9IHRoaXMuX2dldERlZmF1bHRUaW1lc3RhbXAodGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXQpIHx8IFV0aWxzLm5vdyh0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cbiAgICBvcHRpb25zLm1vZGVsID0gdGhpcztcbiAgICBsZXQgdmFsdWVzVXNlO1xuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICBjb25zdCBidWlsZCA9IHRoaXMuYnVpbGQodmFsdWVzKTtcbiAgICAgIGJ1aWxkLnNldCh0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdCwgdmFsdWVzW3RoaXMuX3RpbWVzdGFtcEF0dHJpYnV0ZXMudXBkYXRlZEF0XSwgeyByYXc6IHRydWUgfSk7XG4gICAgICBpZiAob3B0aW9ucy5zaWRlRWZmZWN0cykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHZhbHVlcywgXy5waWNrKGJ1aWxkLmdldCgpLCBidWlsZC5jaGFuZ2VkKCkpKTtcbiAgICAgICAgb3B0aW9ucy5maWVsZHMgPSBfLnVuaW9uKG9wdGlvbnMuZmllbGRzLCBPYmplY3Qua2V5cyh2YWx1ZXMpKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMuc2tpcCA9IF8uZGlmZmVyZW5jZShPYmplY3Qua2V5cyh0aGlzLnJhd0F0dHJpYnV0ZXMpLCBPYmplY3Qua2V5cyh2YWx1ZXMpKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhd2FpdCBidWlsZC52YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuc2tpcCA9IHZvaWQgMDtcbiAgICAgIGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMuZGF0YVZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBfLnBpY2soYXR0cmlidXRlcy5kYXRhVmFsdWVzLCBPYmplY3Qua2V5cyh2YWx1ZXMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIG9wdGlvbnMuYXR0cmlidXRlcyA9IHZhbHVlcztcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVCdWxrVXBkYXRlXCIsIG9wdGlvbnMpO1xuICAgICAgdmFsdWVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICB9XG4gICAgdmFsdWVzVXNlID0gdmFsdWVzO1xuICAgIGxldCBpbnN0YW5jZXM7XG4gICAgbGV0IHVwZGF0ZURvbmVSb3dCeVJvdyA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLmluZGl2aWR1YWxIb29rcykge1xuICAgICAgaW5zdGFuY2VzID0gYXdhaXQgdGhpcy5maW5kQWxsKHtcbiAgICAgICAgd2hlcmU6IG9wdGlvbnMud2hlcmUsXG4gICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcsXG4gICAgICAgIGJlbmNobWFyazogb3B0aW9ucy5iZW5jaG1hcmssXG4gICAgICAgIHBhcmFub2lkOiBvcHRpb25zLnBhcmFub2lkXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjaGFuZ2VkVmFsdWVzO1xuICAgICAgICBsZXQgZGlmZmVyZW50ID0gZmFsc2U7XG4gICAgICAgIGluc3RhbmNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoYXN5bmMgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZS5kYXRhVmFsdWVzLCB2YWx1ZXMpO1xuICAgICAgICAgIF8uZm9ySW4odmFsdWVzVXNlLCAobmV3VmFsdWUsIGF0dHIpID0+IHtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gaW5zdGFuY2UuX3ByZXZpb3VzRGF0YVZhbHVlc1thdHRyXSkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZXREYXRhVmFsdWUoYXR0ciwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVVcGRhdGVcIiwgaW5zdGFuY2UsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmICghZGlmZmVyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0aGlzQ2hhbmdlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgXy5mb3JJbihpbnN0YW5jZS5kYXRhVmFsdWVzLCAobmV3VmFsdWUsIGF0dHIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBpbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgdGhpc0NoYW5nZWRWYWx1ZXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYW5nZWRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZFZhbHVlcyA9IHRoaXNDaGFuZ2VkVmFsdWVzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGlmZmVyZW50ID0gIV8uaXNFcXVhbChjaGFuZ2VkVmFsdWVzLCB0aGlzQ2hhbmdlZFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAoIWRpZmZlcmVudCkge1xuICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjaGFuZ2VkVmFsdWVzKTtcbiAgICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlc1VzZSA9IGNoYW5nZWRWYWx1ZXM7XG4gICAgICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8udW5pb24ob3B0aW9ucy5maWVsZHMsIGtleXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZXMgPSBhd2FpdCBQcm9taXNlLmFsbChpbnN0YW5jZXMubWFwKGFzeW5jIChpbnN0YW5jZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kaXZpZHVhbE9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBvcHRpb25zKSwge1xuICAgICAgICAgICAgICBob29rczogZmFsc2UsXG4gICAgICAgICAgICAgIHZhbGlkYXRlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgaW5kaXZpZHVhbE9wdGlvbnMuaW5kaXZpZHVhbEhvb2tzO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnNhdmUoaW5kaXZpZHVhbE9wdGlvbnMpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB1cGRhdGVEb25lUm93QnlSb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHVwZGF0ZURvbmVSb3dCeVJvdykge1xuICAgICAgcmVzdWx0ID0gW2luc3RhbmNlcy5sZW5ndGgsIGluc3RhbmNlc107XG4gICAgfSBlbHNlIGlmIChfLmlzRW1wdHkodmFsdWVzVXNlKSB8fCBPYmplY3Qua2V5cyh2YWx1ZXNVc2UpLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZXNVc2VbdGhpcy5fdGltZXN0YW1wQXR0cmlidXRlcy51cGRhdGVkQXRdKSB7XG4gICAgICByZXN1bHQgPSBbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc1VzZSA9IFV0aWxzLm1hcFZhbHVlRmllbGROYW1lcyh2YWx1ZXNVc2UsIG9wdGlvbnMuZmllbGRzLCB0aGlzKTtcbiAgICAgIG9wdGlvbnMgPSBVdGlscy5tYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgb3B0aW9ucy5oYXNUcmlnZ2VyID0gdGhpcy5vcHRpb25zID8gdGhpcy5vcHRpb25zLmhhc1RyaWdnZXIgOiBmYWxzZTtcbiAgICAgIGNvbnN0IGFmZmVjdGVkUm93cyA9IGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuYnVsa1VwZGF0ZSh0aGlzLmdldFRhYmxlTmFtZShvcHRpb25zKSwgdmFsdWVzVXNlLCBvcHRpb25zLndoZXJlLCBvcHRpb25zLCB0aGlzLnRhYmxlQXR0cmlidXRlcyk7XG4gICAgICBpZiAob3B0aW9ucy5yZXR1cm5pbmcpIHtcbiAgICAgICAgcmVzdWx0ID0gW2FmZmVjdGVkUm93cy5sZW5ndGgsIGFmZmVjdGVkUm93c107XG4gICAgICAgIGluc3RhbmNlcyA9IGFmZmVjdGVkUm93cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IFthZmZlY3RlZFJvd3NdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmRpdmlkdWFsSG9va3MpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJVcGRhdGVcIiwgaW5zdGFuY2UsIG9wdGlvbnMpKSk7XG4gICAgICByZXN1bHRbMV0gPSBpbnN0YW5jZXM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSB2YWx1ZXM7XG4gICAgICBhd2FpdCB0aGlzLnJ1bkhvb2tzKFwiYWZ0ZXJCdWxrVXBkYXRlXCIsIG9wdGlvbnMpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMuYXR0cmlidXRlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzY3JpYmUoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnlJbnRlcmZhY2UuZGVzY3JpYmVUYWJsZSh0aGlzLnRhYmxlTmFtZSwgX19zcHJlYWRWYWx1ZXMoeyBzY2hlbWE6IHNjaGVtYSB8fCB0aGlzLl9zY2hlbWEgfHwgdm9pZCAwIH0sIG9wdGlvbnMpKTtcbiAgfVxuICBzdGF0aWMgX2dldERlZmF1bHRUaW1lc3RhbXAoYXR0cikge1xuICAgIGlmICghIXRoaXMucmF3QXR0cmlidXRlc1thdHRyXSAmJiAhIXRoaXMucmF3QXR0cmlidXRlc1thdHRyXS5kZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBVdGlscy50b0RlZmF1bHRWYWx1ZSh0aGlzLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZGVmYXVsdFZhbHVlLCB0aGlzLnNlcXVlbGl6ZS5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHN0YXRpYyBfZXhwYW5kQXR0cmlidXRlcyhvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzUGxhaW5PYmplY3Qob3B0aW9ucy5hdHRyaWJ1dGVzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYXR0cmlidXRlcyA9IE9iamVjdC5rZXlzKHRoaXMucmF3QXR0cmlidXRlcyk7XG4gICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcy5leGNsdWRlKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcy5maWx0ZXIoKGVsZW0pID0+ICFvcHRpb25zLmF0dHJpYnV0ZXMuZXhjbHVkZS5pbmNsdWRlcyhlbGVtKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMuaW5jbHVkZSkge1xuICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMuY29uY2F0KG9wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlKTtcbiAgICB9XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgfVxuICBzdGF0aWMgX2luamVjdFNjb3BlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzY29wZSA9IFV0aWxzLmNsb25lRGVlcCh0aGlzLl9zY29wZSk7XG4gICAgdGhpcy5fZGVmYXVsdHNPcHRpb25zKG9wdGlvbnMsIHNjb3BlKTtcbiAgfVxuICBzdGF0aWMgW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV0oKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICBzdGF0aWMgaGFzQWxpYXMoYWxpYXMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXNzb2NpYXRpb25zLCBhbGlhcyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGluY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGZpZWxkcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgIGZpZWxkcyA9IFtmaWVsZHNdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZpZWxkcykpIHtcbiAgICAgIGZpZWxkcyA9IGZpZWxkcy5tYXAoKGYpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucmF3QXR0cmlidXRlc1tmXSAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQgJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkICE9PSBmKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZmllbGRzICYmIHR5cGVvZiBmaWVsZHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKGZpZWxkcykucmVkdWNlKChyYXdGaWVsZHMsIGYpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucmF3QXR0cmlidXRlc1tmXSAmJiB0aGlzLnJhd0F0dHJpYnV0ZXNbZl0uZmllbGQgJiYgdGhpcy5yYXdBdHRyaWJ1dGVzW2ZdLmZpZWxkICE9PSBmKSB7XG4gICAgICAgICAgcmF3RmllbGRzW3RoaXMucmF3QXR0cmlidXRlc1tmXS5maWVsZF0gPSBmaWVsZHNbZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmF3RmllbGRzW2ZdID0gZmllbGRzW2ZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYXdGaWVsZHM7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHRoaXMuX2luamVjdFNjb3BlKG9wdGlvbnMpO1xuICAgIHRoaXMuX29wdGlvbnNNdXN0Q29udGFpbldoZXJlKG9wdGlvbnMpO1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyh7fSwgb3B0aW9ucywge1xuICAgICAgYnk6IDEsXG4gICAgICB3aGVyZToge30sXG4gICAgICBpbmNyZW1lbnQ6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpc1N1YnRyYWN0aW9uID0gIW9wdGlvbnMuaW5jcmVtZW50O1xuICAgIFV0aWxzLm1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgdGhpcyk7XG4gICAgY29uc3Qgd2hlcmUgPSBfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy53aGVyZSk7XG4gICAgbGV0IGluY3JlbWVudEFtb3VudHNCeUZpZWxkID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkW2ZpZWxkXSA9IG9wdGlvbnMuYnk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluY3JlbWVudEFtb3VudHNCeUZpZWxkID0gZmllbGRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdmVyc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgaW5jcmVtZW50QW1vdW50c0J5RmllbGRbdGhpcy5fdmVyc2lvbkF0dHJpYnV0ZV0gPSBpc1N1YnRyYWN0aW9uID8gLTEgOiAxO1xuICAgIH1cbiAgICBjb25zdCBleHRyYUF0dHJpYnV0ZXNUb0JlVXBkYXRlZCA9IHt9O1xuICAgIGNvbnN0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50ICYmIHVwZGF0ZWRBdEF0dHIgJiYgIWluY3JlbWVudEFtb3VudHNCeUZpZWxkW3VwZGF0ZWRBdEF0dHJdKSB7XG4gICAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMucmF3QXR0cmlidXRlc1t1cGRhdGVkQXRBdHRyXS5maWVsZCB8fCB1cGRhdGVkQXRBdHRyO1xuICAgICAgZXh0cmFBdHRyaWJ1dGVzVG9CZVVwZGF0ZWRbYXR0ck5hbWVdID0gdGhpcy5fZ2V0RGVmYXVsdFRpbWVzdGFtcCh1cGRhdGVkQXRBdHRyKSB8fCBVdGlscy5ub3codGhpcy5zZXF1ZWxpemUub3B0aW9ucy5kaWFsZWN0KTtcbiAgICB9XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGhpcy5nZXRUYWJsZU5hbWUob3B0aW9ucyk7XG4gICAgbGV0IGFmZmVjdGVkUm93cztcbiAgICBpZiAoaXNTdWJ0cmFjdGlvbikge1xuICAgICAgYWZmZWN0ZWRSb3dzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5kZWNyZW1lbnQodGhpcywgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZmZWN0ZWRSb3dzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5pbmNyZW1lbnQodGhpcywgdGFibGVOYW1lLCB3aGVyZSwgaW5jcmVtZW50QW1vdW50c0J5RmllbGQsIGV4dHJhQXR0cmlidXRlc1RvQmVVcGRhdGVkLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmV0dXJuaW5nKSB7XG4gICAgICByZXR1cm4gW2FmZmVjdGVkUm93cywgYWZmZWN0ZWRSb3dzLmxlbmd0aF07XG4gICAgfVxuICAgIHJldHVybiBbYWZmZWN0ZWRSb3dzXTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVjcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmluY3JlbWVudChmaWVsZHMsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgYnk6IDFcbiAgICB9LCBvcHRpb25zKSwge1xuICAgICAgaW5jcmVtZW50OiBmYWxzZVxuICAgIH0pKTtcbiAgfVxuICBzdGF0aWMgX29wdGlvbnNNdXN0Q29udGFpbldoZXJlKG9wdGlvbnMpIHtcbiAgICBhc3NlcnQob3B0aW9ucyAmJiBvcHRpb25zLndoZXJlLCBcIk1pc3Npbmcgd2hlcmUgYXR0cmlidXRlIGluIHRoZSBvcHRpb25zIHBhcmFtZXRlclwiKTtcbiAgICBhc3NlcnQoXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucy53aGVyZSkgfHwgb3B0aW9ucy53aGVyZSBpbnN0YW5jZW9mIFV0aWxzLlNlcXVlbGl6ZU1ldGhvZCwgXCJFeHBlY3RlZCBwbGFpbiBvYmplY3QsIGFycmF5IG9yIHNlcXVlbGl6ZSBtZXRob2QgaW4gdGhlIG9wdGlvbnMud2hlcmUgcGFyYW1ldGVyXCIpO1xuICB9XG4gIHdoZXJlKGNoZWNrVmVyc2lvbikge1xuICAgIGNvbnN0IHdoZXJlID0gdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5yZWR1Y2UoKHJlc3VsdCwgYXR0cmlidXRlKSA9PiB7XG4gICAgICByZXN1bHRbYXR0cmlidXRlXSA9IHRoaXMuZ2V0KGF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KTtcbiAgICBpZiAoXy5zaXplKHdoZXJlKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3Iub3B0aW9ucy53aGVyZUNvbGxlY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25BdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdmVyc2lvbkF0dHJpYnV0ZTtcbiAgICBpZiAoY2hlY2tWZXJzaW9uICYmIHZlcnNpb25BdHRyKSB7XG4gICAgICB3aGVyZVt2ZXJzaW9uQXR0cl0gPSB0aGlzLmdldCh2ZXJzaW9uQXR0ciwgeyByYXc6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiBVdGlscy5tYXBXaGVyZUZpZWxkTmFtZXMod2hlcmUsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgW29iamVjdCBTZXF1ZWxpemVJbnN0YW5jZToke3RoaXMuY29uc3RydWN0b3IubmFtZX1dYDtcbiAgfVxuICBnZXREYXRhVmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldO1xuICB9XG4gIHNldERhdGFWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlc1trZXldO1xuICAgIGlmICghXy5pc0VxdWFsKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSkge1xuICAgICAgdGhpcy5jaGFuZ2VkKGtleSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YVZhbHVlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgZ2V0KGtleSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDAgJiYgdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgb3B0aW9ucyA9IGtleTtcbiAgICAgIGtleSA9IHZvaWQgMDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9jdXN0b21HZXR0ZXJzLCBrZXkpICYmICFvcHRpb25zLnJhdykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VzdG9tR2V0dGVyc1trZXldLmNhbGwodGhpcywga2V5LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnBsYWluICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZGF0YVZhbHVlc1trZXldKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXNba2V5XS5tYXAoKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5nZXQob3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFWYWx1ZXNba2V5XSBpbnN0YW5jZW9mIE1vZGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZhbHVlc1trZXldLmdldChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5kYXRhVmFsdWVzW2tleV07XG4gICAgfVxuICAgIGlmICh0aGlzLl9oYXNDdXN0b21HZXR0ZXJzIHx8IG9wdGlvbnMucGxhaW4gJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlIHx8IG9wdGlvbnMuY2xvbmUpIHtcbiAgICAgIGNvbnN0IHZhbHVlcyA9IHt9O1xuICAgICAgbGV0IF9rZXk7XG4gICAgICBpZiAodGhpcy5faGFzQ3VzdG9tR2V0dGVycykge1xuICAgICAgICBmb3IgKF9rZXkgaW4gdGhpcy5fY3VzdG9tR2V0dGVycykge1xuICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmF0dHJpYnV0ZXMgJiYgIXRoaXMuX29wdGlvbnMuYXR0cmlidXRlcy5pbmNsdWRlcyhfa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fY3VzdG9tR2V0dGVycywgX2tleSkpIHtcbiAgICAgICAgICAgIHZhbHVlc1tfa2V5XSA9IHRoaXMuZ2V0KF9rZXksIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChfa2V5IGluIHRoaXMuZGF0YVZhbHVlcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZXMsIF9rZXkpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmRhdGFWYWx1ZXMsIF9rZXkpKSB7XG4gICAgICAgICAgdmFsdWVzW19rZXldID0gdGhpcy5nZXQoX2tleSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFWYWx1ZXM7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWVzO1xuICAgIGxldCBvcmlnaW5hbFZhbHVlO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSBcIm9iamVjdFwiICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgdmFsdWVzID0ga2V5O1xuICAgICAgb3B0aW9ucyA9IHZhbHVlIHx8IHt9O1xuICAgICAgaWYgKG9wdGlvbnMucmVzZXQpIHtcbiAgICAgICAgdGhpcy5kYXRhVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5MiBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWQoa2V5MiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5yYXcgJiYgISh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSkgJiYgIShvcHRpb25zICYmIG9wdGlvbnMuYXR0cmlidXRlcykgJiYgIXRoaXMuY29uc3RydWN0b3IuX2hhc0RhdGVBdHRyaWJ1dGVzICYmICF0aGlzLmNvbnN0cnVjdG9yLl9oYXNCb29sZWFuQXR0cmlidXRlcykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5kYXRhVmFsdWVzKS5sZW5ndGgpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuZGF0YVZhbHVlcywgdmFsdWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhdGFWYWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzID0gX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZGF0YVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgY29uc3Qgc2V0S2V5cyA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgZGF0YSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWVzW2tdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnNldChrLCB2YWx1ZXNba10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0S2V5cyhvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9oYXNWaXJ0dWFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgc2V0S2V5cyh0aGlzLmNvbnN0cnVjdG9yLl92aXJ0dWFsQXR0cmlidXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcykge1xuICAgICAgICAgICAgc2V0S2V5cyh0aGlzLl9vcHRpb25zLmluY2x1ZGVOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5MiBpbiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleTIsIHZhbHVlc1trZXkyXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJhdykge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRGF0YVZhbHVlcyA9IF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmRhdGFWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIGlmICghb3B0aW9ucy5yYXcpIHtcbiAgICAgIG9yaWdpbmFsVmFsdWUgPSB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnJhdyAmJiB0aGlzLl9jdXN0b21TZXR0ZXJzW2tleV0pIHtcbiAgICAgIHRoaXMuX2N1c3RvbVNldHRlcnNba2V5XS5jYWxsKHRoaXMsIHZhbHVlLCBrZXkpO1xuICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmRhdGFWYWx1ZXNba2V5XTtcbiAgICAgIGlmICghXy5pc0VxdWFsKG5ld1ZhbHVlLCBvcmlnaW5hbFZhbHVlKSkge1xuICAgICAgICB0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXNba2V5XSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgICAgIHRoaXMuY2hhbmdlZChrZXksIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucyAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlTmFtZXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICB0aGlzLl9zZXRJbmNsdWRlKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5yYXcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc0F0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgaWYgKGtleS5pbmNsdWRlcyhcIi5cIikgJiYgdGhpcy5jb25zdHJ1Y3Rvci5fanNvbkF0dHJpYnV0ZXMuaGFzKGtleS5zcGxpdChcIi5cIilbMF0pKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c05lc3RlZFZhbHVlID0gRG90dGllLmdldCh0aGlzLmRhdGFWYWx1ZXMsIGtleSk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFcXVhbChwcmV2aW91c05lc3RlZFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgRG90dGllLnNldCh0aGlzLmRhdGFWYWx1ZXMsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LnNwbGl0KFwiLlwiKVswXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9oYXNQcmltYXJ5S2V5cyAmJiBvcmlnaW5hbFZhbHVlICYmIHRoaXMuY29uc3RydWN0b3IuX2lzUHJpbWFyeUtleShrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTmV3UmVjb3JkICYmIHRoaXMuY29uc3RydWN0b3IuX2hhc1JlYWRPbmx5QXR0cmlidXRlcyAmJiB0aGlzLmNvbnN0cnVjdG9yLl9yZWFkT25seUF0dHJpYnV0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZVNhbml0aXplcnMsIGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZVNhbml0aXplcnNba2V5XS5jYWxsKHRoaXMsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy5yYXcgJiYgKHZhbHVlIGluc3RhbmNlb2YgVXRpbHMuU2VxdWVsaXplTWV0aG9kIHx8ICEodmFsdWUgaW5zdGFuY2VvZiBVdGlscy5TZXF1ZWxpemVNZXRob2QpICYmIHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlQ2hhbmdlc1trZXldICYmIHRoaXMuY29uc3RydWN0b3IuX2RhdGFUeXBlQ2hhbmdlc1trZXldLmNhbGwodGhpcywgdmFsdWUsIG9yaWdpbmFsVmFsdWUsIG9wdGlvbnMpIHx8ICF0aGlzLmNvbnN0cnVjdG9yLl9kYXRhVHlwZUNoYW5nZXNba2V5XSAmJiAhXy5pc0VxdWFsKHZhbHVlLCBvcmlnaW5hbFZhbHVlKSkpIHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV0gPSBvcmlnaW5hbFZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZWQoa2V5LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YVZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldEF0dHJpYnV0ZXModXBkYXRlcykge1xuICAgIHJldHVybiB0aGlzLnNldCh1cGRhdGVzKTtcbiAgfVxuICBjaGFuZ2VkKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5ID09PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLl9jaGFuZ2VkLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2NoYW5nZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuX2NoYW5nZWQuYWRkKGtleSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fY2hhbmdlZC5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlZC5oYXMoa2V5KTtcbiAgfVxuICBwcmV2aW91cyhrZXkpIHtcbiAgICBpZiAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNEYXRhVmFsdWVzW2tleV07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2tCeSh0aGlzLl9wcmV2aW91c0RhdGFWYWx1ZXMsICh2YWx1ZSwga2V5MikgPT4gdGhpcy5jaGFuZ2VkKGtleTIpKTtcbiAgfVxuICBfc2V0SW5jbHVkZShrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICBpZiAodmFsdWVbMF0gaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5kYXRhVmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgaW5jbHVkZSA9IHRoaXMuX29wdGlvbnMuaW5jbHVkZU1hcFtrZXldO1xuICAgIGNvbnN0IGFzc29jaWF0aW9uID0gaW5jbHVkZS5hc3NvY2lhdGlvbjtcbiAgICBjb25zdCBhY2Nlc3NvciA9IGtleTtcbiAgICBjb25zdCBwcmltYXJ5S2V5QXR0cmlidXRlID0gaW5jbHVkZS5tb2RlbC5wcmltYXJ5S2V5QXR0cmlidXRlO1xuICAgIGNvbnN0IGNoaWxkT3B0aW9ucyA9IHtcbiAgICAgIGlzTmV3UmVjb3JkOiB0aGlzLmlzTmV3UmVjb3JkLFxuICAgICAgaW5jbHVkZTogaW5jbHVkZS5pbmNsdWRlLFxuICAgICAgaW5jbHVkZU5hbWVzOiBpbmNsdWRlLmluY2x1ZGVOYW1lcyxcbiAgICAgIGluY2x1ZGVNYXA6IGluY2x1ZGUuaW5jbHVkZU1hcCxcbiAgICAgIGluY2x1ZGVWYWxpZGF0ZWQ6IHRydWUsXG4gICAgICByYXc6IG9wdGlvbnMucmF3LFxuICAgICAgYXR0cmlidXRlczogaW5jbHVkZS5vcmlnaW5hbEF0dHJpYnV0ZXNcbiAgICB9O1xuICAgIGxldCBpc0VtcHR5O1xuICAgIGlmIChpbmNsdWRlLm9yaWdpbmFsQXR0cmlidXRlcyA9PT0gdm9pZCAwIHx8IGluY2x1ZGUub3JpZ2luYWxBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgaWYgKGFzc29jaWF0aW9uLmlzU2luZ2xlQXNzb2NpYXRpb24pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpc0VtcHR5ID0gdmFsdWUgJiYgdmFsdWVbcHJpbWFyeUtleUF0dHJpYnV0ZV0gPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGw7XG4gICAgICAgIHRoaXNbYWNjZXNzb3JdID0gdGhpcy5kYXRhVmFsdWVzW2FjY2Vzc29yXSA9IGlzRW1wdHkgPyBudWxsIDogaW5jbHVkZS5tb2RlbC5idWlsZCh2YWx1ZSwgY2hpbGRPcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzRW1wdHkgPSB2YWx1ZVswXSAmJiB2YWx1ZVswXVtwcmltYXJ5S2V5QXR0cmlidXRlXSA9PT0gbnVsbDtcbiAgICAgICAgdGhpc1thY2Nlc3Nvcl0gPSB0aGlzLmRhdGFWYWx1ZXNbYWNjZXNzb3JdID0gaXNFbXB0eSA/IFtdIDogaW5jbHVkZS5tb2RlbC5idWxrQnVpbGQodmFsdWUsIGNoaWxkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIHNhdmUob3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBhcmd1bWVudCB3YXMgcmVtb3ZlZCBpbiBmYXZvciBvZiB0aGUgb3B0aW9ucyBvYmplY3QuXCIpO1xuICAgIH1cbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgb3B0aW9ucyA9IF8uZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGlmICghb3B0aW9ucy5maWVsZHMpIHtcbiAgICAgIGlmICh0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuZmllbGRzID0gXy5pbnRlcnNlY3Rpb24odGhpcy5jaGFuZ2VkKCksIE9iamVjdC5rZXlzKHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlcykpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5kZWZhdWx0RmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJldHVybmluZyA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAob3B0aW9ucy5hc3NvY2lhdGlvbikge1xuICAgICAgICBvcHRpb25zLnJldHVybmluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICAgIG9wdGlvbnMucmV0dXJuaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJpbWFyeUtleU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGU7XG4gICAgY29uc3QgcHJpbWFyeUtleUF0dHJpYnV0ZSA9IHByaW1hcnlLZXlOYW1lICYmIHRoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1twcmltYXJ5S2V5TmFtZV07XG4gICAgY29uc3QgY3JlYXRlZEF0QXR0ciA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuY3JlYXRlZEF0O1xuICAgIGNvbnN0IHZlcnNpb25BdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5fdmVyc2lvbkF0dHJpYnV0ZTtcbiAgICBjb25zdCBob29rID0gdGhpcy5pc05ld1JlY29yZCA/IFwiQ3JlYXRlXCIgOiBcIlVwZGF0ZVwiO1xuICAgIGNvbnN0IHdhc05ld1JlY29yZCA9IHRoaXMuaXNOZXdSZWNvcmQ7XG4gICAgY29uc3Qgbm93ID0gVXRpbHMubm93KHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCk7XG4gICAgbGV0IHVwZGF0ZWRBdEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLnVwZGF0ZWRBdDtcbiAgICBpZiAodXBkYXRlZEF0QXR0ciAmJiBvcHRpb25zLmZpZWxkcy5sZW5ndGggPiAwICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyh1cGRhdGVkQXRBdHRyKSkge1xuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh1cGRhdGVkQXRBdHRyKTtcbiAgICB9XG4gICAgaWYgKHZlcnNpb25BdHRyICYmIG9wdGlvbnMuZmllbGRzLmxlbmd0aCA+IDAgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHZlcnNpb25BdHRyKSkge1xuICAgICAgb3B0aW9ucy5maWVsZHMucHVzaCh2ZXJzaW9uQXR0cik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNpbGVudCA9PT0gdHJ1ZSAmJiAhKHRoaXMuaXNOZXdSZWNvcmQgJiYgdGhpcy5nZXQodXBkYXRlZEF0QXR0ciwgeyByYXc6IHRydWUgfSkpKSB7XG4gICAgICBfLnJlbW92ZShvcHRpb25zLmZpZWxkcywgKHZhbCkgPT4gdmFsID09PSB1cGRhdGVkQXRBdHRyKTtcbiAgICAgIHVwZGF0ZWRBdEF0dHIgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQgPT09IHRydWUpIHtcbiAgICAgIGlmIChjcmVhdGVkQXRBdHRyICYmICFvcHRpb25zLmZpZWxkcy5pbmNsdWRlcyhjcmVhdGVkQXRBdHRyKSkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcy5wdXNoKGNyZWF0ZWRBdEF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKHByaW1hcnlLZXlBdHRyaWJ1dGUgJiYgcHJpbWFyeUtleUF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgJiYgIW9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHByaW1hcnlLZXlOYW1lKSkge1xuICAgICAgICBvcHRpb25zLmZpZWxkcy51bnNoaWZ0KHByaW1hcnlLZXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQgPT09IGZhbHNlKSB7XG4gICAgICBpZiAocHJpbWFyeUtleU5hbWUgJiYgdGhpcy5nZXQocHJpbWFyeUtleU5hbWUsIHsgcmF3OiB0cnVlIH0pID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGF0dGVtcHRlZCB0byBzYXZlIGFuIGluc3RhbmNlIHdpdGggbm8gcHJpbWFyeSBrZXksIHRoaXMgaXMgbm90IGFsbG93ZWQgc2luY2UgaXQgd291bGQgcmVzdWx0IGluIGEgZ2xvYmFsIHVwZGF0ZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgIW9wdGlvbnMuc2lsZW50ICYmIG9wdGlvbnMuZmllbGRzLmluY2x1ZGVzKHVwZGF0ZWRBdEF0dHIpKSB7XG4gICAgICB0aGlzLmRhdGFWYWx1ZXNbdXBkYXRlZEF0QXR0cl0gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXREZWZhdWx0VGltZXN0YW1wKHVwZGF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNOZXdSZWNvcmQgJiYgY3JlYXRlZEF0QXR0ciAmJiAhdGhpcy5kYXRhVmFsdWVzW2NyZWF0ZWRBdEF0dHJdKSB7XG4gICAgICB0aGlzLmRhdGFWYWx1ZXNbY3JlYXRlZEF0QXR0cl0gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXREZWZhdWx0VGltZXN0YW1wKGNyZWF0ZWRBdEF0dHIpIHx8IG5vdztcbiAgICB9XG4gICAgaWYgKHRoaXMuc2VxdWVsaXplLm9wdGlvbnMuZGlhbGVjdCA9PT0gXCJkYjJcIiAmJiB0aGlzLmlzTmV3UmVjb3JkKSB7XG4gICAgICB0aGlzLnVuaXFubyA9IHRoaXMuc2VxdWVsaXplLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuYWRkVW5pcXVlRmllbGRzKHRoaXMuZGF0YVZhbHVlcywgdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzLCB0aGlzLnVuaXFubyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlKSB7XG4gICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgY29uc3QgYmVmb3JlSG9va1ZhbHVlcyA9IF8ucGljayh0aGlzLmRhdGFWYWx1ZXMsIG9wdGlvbnMuZmllbGRzKTtcbiAgICAgIGxldCBpZ25vcmVDaGFuZ2VkID0gXy5kaWZmZXJlbmNlKHRoaXMuY2hhbmdlZCgpLCBvcHRpb25zLmZpZWxkcyk7XG4gICAgICBsZXQgaG9va0NoYW5nZWQ7XG4gICAgICBsZXQgYWZ0ZXJIb29rVmFsdWVzO1xuICAgICAgaWYgKHVwZGF0ZWRBdEF0dHIgJiYgb3B0aW9ucy5maWVsZHMuaW5jbHVkZXModXBkYXRlZEF0QXR0cikpIHtcbiAgICAgICAgaWdub3JlQ2hhbmdlZCA9IF8ud2l0aG91dChpZ25vcmVDaGFuZ2VkLCB1cGRhdGVkQXRBdHRyKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuY29uc3RydWN0b3IucnVuSG9va3MoYGJlZm9yZSR7aG9va31gLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRGaWVsZHMgJiYgIXRoaXMuaXNOZXdSZWNvcmQpIHtcbiAgICAgICAgYWZ0ZXJIb29rVmFsdWVzID0gXy5waWNrKHRoaXMuZGF0YVZhbHVlcywgXy5kaWZmZXJlbmNlKHRoaXMuY2hhbmdlZCgpLCBpZ25vcmVDaGFuZ2VkKSk7XG4gICAgICAgIGhvb2tDaGFuZ2VkID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGFmdGVySG9va1ZhbHVlcykpIHtcbiAgICAgICAgICBpZiAoYWZ0ZXJIb29rVmFsdWVzW2tleV0gIT09IGJlZm9yZUhvb2tWYWx1ZXNba2V5XSkge1xuICAgICAgICAgICAgaG9va0NoYW5nZWQucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmZpZWxkcyA9IF8udW5pcShvcHRpb25zLmZpZWxkcy5jb25jYXQoaG9va0NoYW5nZWQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChob29rQ2hhbmdlZCkge1xuICAgICAgICBpZiAob3B0aW9ucy52YWxpZGF0ZSkge1xuICAgICAgICAgIG9wdGlvbnMuc2tpcCA9IF8uZGlmZmVyZW5jZShPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpLCBob29rQ2hhbmdlZCk7XG4gICAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZShvcHRpb25zKTtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5za2lwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpZWxkcy5sZW5ndGggJiYgdGhpcy5pc05ld1JlY29yZCAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUgJiYgdGhpcy5fb3B0aW9ucy5pbmNsdWRlLmxlbmd0aCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5fb3B0aW9ucy5pbmNsdWRlLmZpbHRlcigoaW5jbHVkZSkgPT4gaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUbykubWFwKGFzeW5jIChpbmNsdWRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXQoaW5jbHVkZS5hcyk7XG4gICAgICAgIGlmICghaW5zdGFuY2UpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IF8oVXRpbHMuY2xvbmVEZWVwKGluY2x1ZGUpKS5vbWl0KFtcImFzc29jaWF0aW9uXCJdKS5kZWZhdWx0cyh7XG4gICAgICAgICAgdHJhbnNhY3Rpb246IG9wdGlvbnMudHJhbnNhY3Rpb24sXG4gICAgICAgICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICAgICAgICAgIHBhcmVudFJlY29yZDogdGhpc1xuICAgICAgICB9KS52YWx1ZSgpO1xuICAgICAgICBhd2FpdCBpbnN0YW5jZS5zYXZlKGluY2x1ZGVPcHRpb25zKTtcbiAgICAgICAgYXdhaXQgdGhpc1tpbmNsdWRlLmFzc29jaWF0aW9uLmFjY2Vzc29ycy5zZXRdKGluc3RhbmNlLCB7IHNhdmU6IGZhbHNlLCBsb2dnaW5nOiBvcHRpb25zLmxvZ2dpbmcgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWxGaWVsZHMgPSBvcHRpb25zLmZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiAhdGhpcy5jb25zdHJ1Y3Rvci5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGZpZWxkKSk7XG4gICAgaWYgKCFyZWFsRmllbGRzLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICghdGhpcy5jaGFuZ2VkKCkgJiYgIXRoaXMuaXNOZXdSZWNvcmQpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCB2ZXJzaW9uRmllbGROYW1lID0gXy5nZXQodGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW3ZlcnNpb25BdHRyXSwgXCJmaWVsZFwiKSB8fCB2ZXJzaW9uQXR0cjtcbiAgICBjb25zdCB2YWx1ZXMgPSBVdGlscy5tYXBWYWx1ZUZpZWxkTmFtZXModGhpcy5kYXRhVmFsdWVzLCBvcHRpb25zLmZpZWxkcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgbGV0IHF1ZXJ5ID0gbnVsbDtcbiAgICBsZXQgYXJncyA9IFtdO1xuICAgIGxldCB3aGVyZTtcbiAgICBpZiAodGhpcy5pc05ld1JlY29yZCkge1xuICAgICAgcXVlcnkgPSBcImluc2VydFwiO1xuICAgICAgYXJncyA9IFt0aGlzLCB0aGlzLmNvbnN0cnVjdG9yLmdldFRhYmxlTmFtZShvcHRpb25zKSwgdmFsdWVzLCBvcHRpb25zXTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hlcmUgPSB0aGlzLndoZXJlKHRydWUpO1xuICAgICAgaWYgKHZlcnNpb25BdHRyKSB7XG4gICAgICAgIHZhbHVlc1t2ZXJzaW9uRmllbGROYW1lXSA9IHBhcnNlSW50KHZhbHVlc1t2ZXJzaW9uRmllbGROYW1lXSwgMTApICsgMTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5ID0gXCJ1cGRhdGVcIjtcbiAgICAgIGFyZ3MgPSBbdGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHZhbHVlcywgd2hlcmUsIG9wdGlvbnNdO1xuICAgIH1cbiAgICBjb25zdCBbcmVzdWx0LCByb3dzVXBkYXRlZF0gPSBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnF1ZXJ5SW50ZXJmYWNlW3F1ZXJ5XSguLi5hcmdzKTtcbiAgICBpZiAodmVyc2lvbkF0dHIpIHtcbiAgICAgIGlmIChyb3dzVXBkYXRlZCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IHNlcXVlbGl6ZUVycm9ycy5PcHRpbWlzdGljTG9ja0Vycm9yKHtcbiAgICAgICAgICBtb2RlbE5hbWU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgd2hlcmVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZGF0YVZhbHVlc1t2ZXJzaW9uQXR0cl0gPSB2YWx1ZXNbdmVyc2lvbkZpZWxkTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICYmIHZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdICE9PSB2b2lkIDAgJiYgdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICE9PSBhdHRyKSB7XG4gICAgICAgIHZhbHVlc1thdHRyXSA9IHZhbHVlc1t0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdO1xuICAgICAgICBkZWxldGUgdmFsdWVzW3RoaXMuY29uc3RydWN0b3IucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZF07XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odmFsdWVzLCByZXN1bHQuZGF0YVZhbHVlcyk7XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuZGF0YVZhbHVlcywgdmFsdWVzKTtcbiAgICBpZiAod2FzTmV3UmVjb3JkICYmIHRoaXMuX29wdGlvbnMuaW5jbHVkZSAmJiB0aGlzLl9vcHRpb25zLmluY2x1ZGUubGVuZ3RoKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLl9vcHRpb25zLmluY2x1ZGUuZmlsdGVyKChpbmNsdWRlKSA9PiAhKGluY2x1ZGUuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG8gfHwgaW5jbHVkZS5wYXJlbnQgJiYgaW5jbHVkZS5wYXJlbnQuYXNzb2NpYXRpb24gaW5zdGFuY2VvZiBCZWxvbmdzVG9NYW55KSkubWFwKGFzeW5jIChpbmNsdWRlKSA9PiB7XG4gICAgICAgIGxldCBpbnN0YW5jZXMgPSB0aGlzLmdldChpbmNsdWRlLmFzKTtcbiAgICAgICAgaWYgKCFpbnN0YW5jZXMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5zdGFuY2VzKSlcbiAgICAgICAgICBpbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcbiAgICAgICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSBfKFV0aWxzLmNsb25lRGVlcChpbmNsdWRlKSkub21pdChbXCJhc3NvY2lhdGlvblwiXSkuZGVmYXVsdHMoe1xuICAgICAgICAgIHRyYW5zYWN0aW9uOiBvcHRpb25zLnRyYW5zYWN0aW9uLFxuICAgICAgICAgIGxvZ2dpbmc6IG9wdGlvbnMubG9nZ2luZyxcbiAgICAgICAgICBwYXJlbnRSZWNvcmQ6IHRoaXNcbiAgICAgICAgfSkudmFsdWUoKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoaW5zdGFuY2VzLm1hcChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoaW5jbHVkZS5hc3NvY2lhdGlvbiBpbnN0YW5jZW9mIEJlbG9uZ3NUb01hbnkpIHtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNhdmUoaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzMCA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICAgICAgW2luY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleV06IHRoaXMuZ2V0KHRoaXMuY29uc3RydWN0b3IucHJpbWFyeUtleUF0dHJpYnV0ZSwgeyByYXc6IHRydWUgfSksXG4gICAgICAgICAgICAgIFtpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5XTogaW5zdGFuY2UuZ2V0KGluc3RhbmNlLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pXG4gICAgICAgICAgICB9LCBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2guc2NvcGUpO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlW2luY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5uYW1lXSkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgT2JqZWN0LmtleXMoaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLnJhd0F0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGUuYXNzb2NpYXRpb24udGhyb3VnaC5tb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLl9hdXRvR2VuZXJhdGVkIHx8IGF0dHIgPT09IGluY2x1ZGUuYXNzb2NpYXRpb24uZm9yZWlnbktleSB8fCBhdHRyID09PSBpbmNsdWRlLmFzc29jaWF0aW9uLm90aGVyS2V5IHx8IHR5cGVvZiBpbnN0YW5jZVtpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2gubW9kZWwubmFtZV1bYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZXMwW2F0dHJdID0gaW5zdGFuY2VbaW5jbHVkZS5hc3NvY2lhdGlvbi50aHJvdWdoLm1vZGVsLm5hbWVdW2F0dHJdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCBpbmNsdWRlLmFzc29jaWF0aW9uLnRocm91Z2hNb2RlbC5jcmVhdGUodmFsdWVzMCwgaW5jbHVkZU9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXQoaW5jbHVkZS5hc3NvY2lhdGlvbi5mb3JlaWduS2V5LCB0aGlzLmdldChpbmNsdWRlLmFzc29jaWF0aW9uLnNvdXJjZUtleSB8fCB0aGlzLmNvbnN0cnVjdG9yLnByaW1hcnlLZXlBdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pLCB7IHJhdzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaW5zdGFuY2UsIGluY2x1ZGUuYXNzb2NpYXRpb24uc2NvcGUpO1xuICAgICAgICAgICAgYXdhaXQgaW5zdGFuY2Uuc2F2ZShpbmNsdWRlT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKGBhZnRlciR7aG9va31gLCByZXN1bHQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICByZXN1bHQuX3ByZXZpb3VzRGF0YVZhbHVlc1tmaWVsZF0gPSByZXN1bHQuZGF0YVZhbHVlc1tmaWVsZF07XG4gICAgICB0aGlzLmNoYW5nZWQoZmllbGQsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5pc05ld1JlY29yZCA9IGZhbHNlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgcmVsb2FkKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMoe1xuICAgICAgd2hlcmU6IHRoaXMud2hlcmUoKVxuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgIGluY2x1ZGU6IHRoaXMuX29wdGlvbnMuaW5jbHVkZSB8fCB2b2lkIDBcbiAgICB9KTtcbiAgICBjb25zdCByZWxvYWRlZCA9IGF3YWl0IHRoaXMuY29uc3RydWN0b3IuZmluZE9uZShvcHRpb25zKTtcbiAgICBpZiAoIXJlbG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgc2VxdWVsaXplRXJyb3JzLkluc3RhbmNlRXJyb3IoXCJJbnN0YW5jZSBjb3VsZCBub3QgYmUgcmVsb2FkZWQgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBhbnltb3JlIChmaW5kIGNhbGwgcmV0dXJuZWQgbnVsbClcIik7XG4gICAgfVxuICAgIHRoaXMuX29wdGlvbnMgPSByZWxvYWRlZC5fb3B0aW9ucztcbiAgICB0aGlzLnNldChyZWxvYWRlZC5kYXRhVmFsdWVzLCB7XG4gICAgICByYXc6IHRydWUsXG4gICAgICByZXNldDogIW9wdGlvbnMuYXR0cmlidXRlc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEluc3RhbmNlVmFsaWRhdG9yKHRoaXMsIG9wdGlvbnMpLnZhbGlkYXRlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhbHVlcyA9IF8ub21pdEJ5KHZhbHVlcywgKHZhbHVlKSA9PiB2YWx1ZSA9PT0gdm9pZCAwKTtcbiAgICBjb25zdCBjaGFuZ2VkQmVmb3JlID0gdGhpcy5jaGFuZ2VkKCkgfHwgW107XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpXG4gICAgICBvcHRpb25zID0geyBmaWVsZHM6IG9wdGlvbnMgfTtcbiAgICBvcHRpb25zID0gVXRpbHMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRyYW5zYWN0aW9uID09PSB2b2lkIDAgJiYgdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMuZ2V0KFwidHJhbnNhY3Rpb25cIik7XG4gICAgICBpZiAodCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zYWN0aW9uID0gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2V0T3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBzZXRPcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmZpZWxkcztcbiAgICB0aGlzLnNldCh2YWx1ZXMsIHNldE9wdGlvbnMpO1xuICAgIGNvbnN0IHNpZGVFZmZlY3RzID0gXy53aXRob3V0KHRoaXMuY2hhbmdlZCgpLCAuLi5jaGFuZ2VkQmVmb3JlKTtcbiAgICBjb25zdCBmaWVsZHMgPSBfLnVuaW9uKE9iamVjdC5rZXlzKHZhbHVlcyksIHNpZGVFZmZlY3RzKTtcbiAgICBpZiAoIW9wdGlvbnMuZmllbGRzKSB7XG4gICAgICBvcHRpb25zLmZpZWxkcyA9IF8uaW50ZXJzZWN0aW9uKGZpZWxkcywgdGhpcy5jaGFuZ2VkKCkpO1xuICAgICAgb3B0aW9ucy5kZWZhdWx0RmllbGRzID0gb3B0aW9ucy5maWVsZHM7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNhdmUob3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgZGVzdHJveShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGhvb2tzOiB0cnVlLFxuICAgICAgZm9yY2U6IGZhbHNlXG4gICAgfSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gPT09IHZvaWQgMCAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSB0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhcImJlZm9yZURlc3Ryb3lcIiwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHdoZXJlID0gdGhpcy53aGVyZSh0cnVlKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCAmJiBvcHRpb25zLmZvcmNlID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuX3RpbWVzdGFtcEF0dHJpYnV0ZXMuZGVsZXRlZEF0O1xuICAgICAgY29uc3QgYXR0cmlidXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikgPyBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuZ2V0RGF0YVZhbHVlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgY29uc3QgdW5kZWZpbmVkT3JOdWxsID0gY3VycmVudFZhbHVlID09IG51bGwgJiYgZGVmYXVsdFZhbHVlID09IG51bGw7XG4gICAgICBpZiAodW5kZWZpbmVkT3JOdWxsIHx8IF8uaXNFcXVhbChjdXJyZW50VmFsdWUsIGRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgdGhpcy5zZXREYXRhVmFsdWUoYXR0cmlidXRlTmFtZSwgbmV3IERhdGUoKSk7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnNhdmUoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgaG9va3M6IGZhbHNlIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5xdWVyeUludGVyZmFjZS5kZWxldGUodGhpcywgdGhpcy5jb25zdHJ1Y3Rvci5nZXRUYWJsZU5hbWUob3B0aW9ucyksIHdoZXJlLCBfX3NwcmVhZFZhbHVlcyh7IHR5cGU6IFF1ZXJ5VHlwZXMuREVMRVRFLCBsaW1pdDogbnVsbCB9LCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKFwiYWZ0ZXJEZXN0cm95XCIsIHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlzU29mdERlbGV0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgaXMgbm90IHBhcmFub2lkXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWxldGVkQXRBdHRyaWJ1dGUgPSB0aGlzLmNvbnN0cnVjdG9yLnJhd0F0dHJpYnV0ZXNbdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXRdO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWxldGVkQXRBdHRyaWJ1dGUsIFwiZGVmYXVsdFZhbHVlXCIpID8gZGVsZXRlZEF0QXR0cmlidXRlLmRlZmF1bHRWYWx1ZSA6IG51bGw7XG4gICAgY29uc3QgZGVsZXRlZEF0ID0gdGhpcy5nZXQodGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQpIHx8IG51bGw7XG4gICAgY29uc3QgaXNTZXQgPSBkZWxldGVkQXQgIT09IGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4gaXNTZXQ7XG4gIH1cbiAgYXN5bmMgcmVzdG9yZShvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl90aW1lc3RhbXBBdHRyaWJ1dGVzLmRlbGV0ZWRBdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGlzIG5vdCBwYXJhbm9pZFwiKTtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgaG9va3M6IHRydWUsXG4gICAgICBmb3JjZTogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIHRoaXMuc2VxdWVsaXplLmNvbnN0cnVjdG9yLl9jbHMpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLmdldChcInRyYW5zYWN0aW9uXCIpO1xuICAgICAgaWYgKHQpIHtcbiAgICAgICAgb3B0aW9ucy50cmFuc2FjdGlvbiA9IHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmhvb2tzKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLnJ1bkhvb2tzKFwiYmVmb3JlUmVzdG9yZVwiLCB0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgZGVsZXRlZEF0Q29sID0gdGhpcy5jb25zdHJ1Y3Rvci5fdGltZXN0YW1wQXR0cmlidXRlcy5kZWxldGVkQXQ7XG4gICAgY29uc3QgZGVsZXRlZEF0QXR0cmlidXRlID0gdGhpcy5jb25zdHJ1Y3Rvci5yYXdBdHRyaWJ1dGVzW2RlbGV0ZWRBdENvbF07XG4gICAgY29uc3QgZGVsZXRlZEF0RGVmYXVsdFZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlbGV0ZWRBdEF0dHJpYnV0ZSwgXCJkZWZhdWx0VmFsdWVcIikgPyBkZWxldGVkQXRBdHRyaWJ1dGUuZGVmYXVsdFZhbHVlIDogbnVsbDtcbiAgICB0aGlzLnNldERhdGFWYWx1ZShkZWxldGVkQXRDb2wsIGRlbGV0ZWRBdERlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYXZlKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGhvb2tzOiBmYWxzZSwgb21pdE51bGw6IGZhbHNlIH0pKTtcbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5jb25zdHJ1Y3Rvci5ydW5Ib29rcyhcImFmdGVyUmVzdG9yZVwiLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgaW5jcmVtZW50KGZpZWxkcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLndoZXJlKCk7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmNsb25lRGVlcChvcHRpb25zKTtcbiAgICBvcHRpb25zLndoZXJlID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMud2hlcmUpLCBpZGVudGlmaWVyKTtcbiAgICBvcHRpb25zLmluc3RhbmNlID0gdGhpcztcbiAgICBhd2FpdCB0aGlzLmNvbnN0cnVjdG9yLmluY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIGRlY3JlbWVudChmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnQoZmllbGRzLCBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGJ5OiAxXG4gICAgfSwgb3B0aW9ucyksIHtcbiAgICAgIGluY3JlbWVudDogZmFsc2VcbiAgICB9KSk7XG4gIH1cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFvdGhlciB8fCAhb3RoZXIuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5wcmltYXJ5S2V5QXR0cmlidXRlcy5ldmVyeSgoYXR0cmlidXRlKSA9PiB0aGlzLmdldChhdHRyaWJ1dGUsIHsgcmF3OiB0cnVlIH0pID09PSBvdGhlci5nZXQoYXR0cmlidXRlLCB7IHJhdzogdHJ1ZSB9KSk7XG4gIH1cbiAgZXF1YWxzT25lT2Yob3RoZXJzKSB7XG4gICAgcmV0dXJuIG90aGVycy5zb21lKChvdGhlcikgPT4gdGhpcy5lcXVhbHMob3RoZXIpKTtcbiAgfVxuICBzZXRWYWxpZGF0b3JzKGF0dHJpYnV0ZSwgdmFsaWRhdG9ycykge1xuICAgIHRoaXMudmFsaWRhdG9yc1thdHRyaWJ1dGVdID0gdmFsaWRhdG9ycztcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIF8uY2xvbmVEZWVwKHRoaXMuZ2V0KHtcbiAgICAgIHBsYWluOiB0cnVlXG4gICAgfSkpO1xuICB9XG4gIHN0YXRpYyBoYXNNYW55KHRhcmdldCwgb3B0aW9ucykge1xuICB9XG4gIHN0YXRpYyBiZWxvbmdzVG9NYW55KHRhcmdldCwgb3B0aW9ucykge1xuICB9XG4gIHN0YXRpYyBoYXNPbmUodGFyZ2V0LCBvcHRpb25zKSB7XG4gIH1cbiAgc3RhdGljIGJlbG9uZ3NUbyh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgfVxufVxuZnVuY3Rpb24gdW5wYWNrQW5kKHdoZXJlKSB7XG4gIGlmICghXy5pc09iamVjdCh3aGVyZSkpIHtcbiAgICByZXR1cm4gd2hlcmU7XG4gIH1cbiAgY29uc3Qga2V5cyA9IFV0aWxzLmdldENvbXBsZXhLZXlzKHdoZXJlKTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChrZXlzLmxlbmd0aCAhPT0gMSB8fCBrZXlzWzBdICE9PSBPcC5hbmQpIHtcbiAgICByZXR1cm4gd2hlcmU7XG4gIH1cbiAgY29uc3QgYW5kUGFydHMgPSB3aGVyZVtPcC5hbmRdO1xuICByZXR1cm4gYW5kUGFydHM7XG59XG5mdW5jdGlvbiBjb21iaW5lV2hlcmVzV2l0aEFuZCh3aGVyZUEsIHdoZXJlQikge1xuICBjb25zdCB1bnBhY2tlZEEgPSB1bnBhY2tBbmQod2hlcmVBKTtcbiAgaWYgKHVucGFja2VkQSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHdoZXJlQjtcbiAgfVxuICBjb25zdCB1bnBhY2tlZEIgPSB1bnBhY2tBbmQod2hlcmVCKTtcbiAgaWYgKHVucGFja2VkQiA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHdoZXJlQTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFtPcC5hbmRdOiBfLmZsYXR0ZW4oW3VucGFja2VkQSwgdW5wYWNrZWRCXSlcbiAgfTtcbn1cbk9iamVjdC5hc3NpZ24oTW9kZWwsIGFzc29jaWF0aW9uc01peGluKTtcbkhvb2tzLmFwcGx5VG8oTW9kZWwsIHRydWUpO1xubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/model.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/operators.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/operators.js ***!
  \*************************************************/
/***/ ((module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  Op: () => Op,\n  default: () => operators_default\n});\nconst Op = {\n  eq: Symbol.for(\"eq\"),\n  ne: Symbol.for(\"ne\"),\n  gte: Symbol.for(\"gte\"),\n  gt: Symbol.for(\"gt\"),\n  lte: Symbol.for(\"lte\"),\n  lt: Symbol.for(\"lt\"),\n  not: Symbol.for(\"not\"),\n  is: Symbol.for(\"is\"),\n  in: Symbol.for(\"in\"),\n  notIn: Symbol.for(\"notIn\"),\n  like: Symbol.for(\"like\"),\n  notLike: Symbol.for(\"notLike\"),\n  iLike: Symbol.for(\"iLike\"),\n  notILike: Symbol.for(\"notILike\"),\n  startsWith: Symbol.for(\"startsWith\"),\n  endsWith: Symbol.for(\"endsWith\"),\n  substring: Symbol.for(\"substring\"),\n  regexp: Symbol.for(\"regexp\"),\n  notRegexp: Symbol.for(\"notRegexp\"),\n  iRegexp: Symbol.for(\"iRegexp\"),\n  notIRegexp: Symbol.for(\"notIRegexp\"),\n  between: Symbol.for(\"between\"),\n  notBetween: Symbol.for(\"notBetween\"),\n  overlap: Symbol.for(\"overlap\"),\n  contains: Symbol.for(\"contains\"),\n  contained: Symbol.for(\"contained\"),\n  adjacent: Symbol.for(\"adjacent\"),\n  strictLeft: Symbol.for(\"strictLeft\"),\n  strictRight: Symbol.for(\"strictRight\"),\n  noExtendRight: Symbol.for(\"noExtendRight\"),\n  noExtendLeft: Symbol.for(\"noExtendLeft\"),\n  and: Symbol.for(\"and\"),\n  or: Symbol.for(\"or\"),\n  any: Symbol.for(\"any\"),\n  all: Symbol.for(\"all\"),\n  values: Symbol.for(\"values\"),\n  col: Symbol.for(\"col\"),\n  placeholder: Symbol.for(\"placeholder\"),\n  join: Symbol.for(\"join\"),\n  match: Symbol.for(\"match\")\n};\nvar operators_default = Op;\nmodule.exports = Op;\n//# sourceMappingURL=operators.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9vcGVyYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvb3BlcmF0b3JzLmpzPzFhNTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBPcDogKCkgPT4gT3AsXG4gIGRlZmF1bHQ6ICgpID0+IG9wZXJhdG9yc19kZWZhdWx0XG59KTtcbmNvbnN0IE9wID0ge1xuICBlcTogU3ltYm9sLmZvcihcImVxXCIpLFxuICBuZTogU3ltYm9sLmZvcihcIm5lXCIpLFxuICBndGU6IFN5bWJvbC5mb3IoXCJndGVcIiksXG4gIGd0OiBTeW1ib2wuZm9yKFwiZ3RcIiksXG4gIGx0ZTogU3ltYm9sLmZvcihcImx0ZVwiKSxcbiAgbHQ6IFN5bWJvbC5mb3IoXCJsdFwiKSxcbiAgbm90OiBTeW1ib2wuZm9yKFwibm90XCIpLFxuICBpczogU3ltYm9sLmZvcihcImlzXCIpLFxuICBpbjogU3ltYm9sLmZvcihcImluXCIpLFxuICBub3RJbjogU3ltYm9sLmZvcihcIm5vdEluXCIpLFxuICBsaWtlOiBTeW1ib2wuZm9yKFwibGlrZVwiKSxcbiAgbm90TGlrZTogU3ltYm9sLmZvcihcIm5vdExpa2VcIiksXG4gIGlMaWtlOiBTeW1ib2wuZm9yKFwiaUxpa2VcIiksXG4gIG5vdElMaWtlOiBTeW1ib2wuZm9yKFwibm90SUxpa2VcIiksXG4gIHN0YXJ0c1dpdGg6IFN5bWJvbC5mb3IoXCJzdGFydHNXaXRoXCIpLFxuICBlbmRzV2l0aDogU3ltYm9sLmZvcihcImVuZHNXaXRoXCIpLFxuICBzdWJzdHJpbmc6IFN5bWJvbC5mb3IoXCJzdWJzdHJpbmdcIiksXG4gIHJlZ2V4cDogU3ltYm9sLmZvcihcInJlZ2V4cFwiKSxcbiAgbm90UmVnZXhwOiBTeW1ib2wuZm9yKFwibm90UmVnZXhwXCIpLFxuICBpUmVnZXhwOiBTeW1ib2wuZm9yKFwiaVJlZ2V4cFwiKSxcbiAgbm90SVJlZ2V4cDogU3ltYm9sLmZvcihcIm5vdElSZWdleHBcIiksXG4gIGJldHdlZW46IFN5bWJvbC5mb3IoXCJiZXR3ZWVuXCIpLFxuICBub3RCZXR3ZWVuOiBTeW1ib2wuZm9yKFwibm90QmV0d2VlblwiKSxcbiAgb3ZlcmxhcDogU3ltYm9sLmZvcihcIm92ZXJsYXBcIiksXG4gIGNvbnRhaW5zOiBTeW1ib2wuZm9yKFwiY29udGFpbnNcIiksXG4gIGNvbnRhaW5lZDogU3ltYm9sLmZvcihcImNvbnRhaW5lZFwiKSxcbiAgYWRqYWNlbnQ6IFN5bWJvbC5mb3IoXCJhZGphY2VudFwiKSxcbiAgc3RyaWN0TGVmdDogU3ltYm9sLmZvcihcInN0cmljdExlZnRcIiksXG4gIHN0cmljdFJpZ2h0OiBTeW1ib2wuZm9yKFwic3RyaWN0UmlnaHRcIiksXG4gIG5vRXh0ZW5kUmlnaHQ6IFN5bWJvbC5mb3IoXCJub0V4dGVuZFJpZ2h0XCIpLFxuICBub0V4dGVuZExlZnQ6IFN5bWJvbC5mb3IoXCJub0V4dGVuZExlZnRcIiksXG4gIGFuZDogU3ltYm9sLmZvcihcImFuZFwiKSxcbiAgb3I6IFN5bWJvbC5mb3IoXCJvclwiKSxcbiAgYW55OiBTeW1ib2wuZm9yKFwiYW55XCIpLFxuICBhbGw6IFN5bWJvbC5mb3IoXCJhbGxcIiksXG4gIHZhbHVlczogU3ltYm9sLmZvcihcInZhbHVlc1wiKSxcbiAgY29sOiBTeW1ib2wuZm9yKFwiY29sXCIpLFxuICBwbGFjZWhvbGRlcjogU3ltYm9sLmZvcihcInBsYWNlaG9sZGVyXCIpLFxuICBqb2luOiBTeW1ib2wuZm9yKFwiam9pblwiKSxcbiAgbWF0Y2g6IFN5bWJvbC5mb3IoXCJtYXRjaFwiKVxufTtcbnZhciBvcGVyYXRvcnNfZGVmYXVsdCA9IE9wO1xubW9kdWxlLmV4cG9ydHMgPSBPcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZXJhdG9ycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/operators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/query-types.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/query-types.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst QueryTypes = module.exports = {\n  SELECT: \"SELECT\",\n  INSERT: \"INSERT\",\n  UPDATE: \"UPDATE\",\n  BULKUPDATE: \"BULKUPDATE\",\n  BULKDELETE: \"BULKDELETE\",\n  DELETE: \"DELETE\",\n  UPSERT: \"UPSERT\",\n  VERSION: \"VERSION\",\n  SHOWTABLES: \"SHOWTABLES\",\n  SHOWINDEXES: \"SHOWINDEXES\",\n  DESCRIBE: \"DESCRIBE\",\n  RAW: \"RAW\",\n  FOREIGNKEYS: \"FOREIGNKEYS\",\n  SHOWCONSTRAINTS: \"SHOWCONSTRAINTS\"\n};\n//# sourceMappingURL=query-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9xdWVyeS10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3F1ZXJ5LXR5cGVzLmpzPzIwMjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBRdWVyeVR5cGVzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFNFTEVDVDogXCJTRUxFQ1RcIixcbiAgSU5TRVJUOiBcIklOU0VSVFwiLFxuICBVUERBVEU6IFwiVVBEQVRFXCIsXG4gIEJVTEtVUERBVEU6IFwiQlVMS1VQREFURVwiLFxuICBCVUxLREVMRVRFOiBcIkJVTEtERUxFVEVcIixcbiAgREVMRVRFOiBcIkRFTEVURVwiLFxuICBVUFNFUlQ6IFwiVVBTRVJUXCIsXG4gIFZFUlNJT046IFwiVkVSU0lPTlwiLFxuICBTSE9XVEFCTEVTOiBcIlNIT1dUQUJMRVNcIixcbiAgU0hPV0lOREVYRVM6IFwiU0hPV0lOREVYRVNcIixcbiAgREVTQ1JJQkU6IFwiREVTQ1JJQkVcIixcbiAgUkFXOiBcIlJBV1wiLFxuICBGT1JFSUdOS0VZUzogXCJGT1JFSUdOS0VZU1wiLFxuICBTSE9XQ09OU1RSQUlOVFM6IFwiU0hPV0NPTlNUUkFJTlRTXCJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS10eXBlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/query-types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/sequelize.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/sequelize.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst url = __webpack_require__(/*! url */ \"url\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst pgConnectionString = __webpack_require__(/*! pg-connection-string */ \"(rsc)/./node_modules/pg-connection-string/index.js\");\nconst retry = (__webpack_require__(/*! retry-as-promised */ \"(rsc)/./node_modules/retry-as-promised/dist/index.js\")[\"default\"]);\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst Utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/sequelize/lib/utils.js\");\nconst Model = __webpack_require__(/*! ./model */ \"(rsc)/./node_modules/sequelize/lib/model.js\");\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst Deferrable = __webpack_require__(/*! ./deferrable */ \"(rsc)/./node_modules/sequelize/lib/deferrable.js\");\nconst ModelManager = __webpack_require__(/*! ./model-manager */ \"(rsc)/./node_modules/sequelize/lib/model-manager.js\");\nconst Transaction = __webpack_require__(/*! ./transaction */ \"(rsc)/./node_modules/sequelize/lib/transaction.js\");\nconst QueryTypes = __webpack_require__(/*! ./query-types */ \"(rsc)/./node_modules/sequelize/lib/query-types.js\");\nconst TableHints = __webpack_require__(/*! ./table-hints */ \"(rsc)/./node_modules/sequelize/lib/table-hints.js\");\nconst IndexHints = __webpack_require__(/*! ./index-hints */ \"(rsc)/./node_modules/sequelize/lib/index-hints.js\");\nconst sequelizeErrors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/sequelize/lib/errors/index.js\");\nconst Hooks = __webpack_require__(/*! ./hooks */ \"(rsc)/./node_modules/sequelize/lib/hooks.js\");\nconst Association = __webpack_require__(/*! ./associations/index */ \"(rsc)/./node_modules/sequelize/lib/associations/index.js\");\nconst Validator = (__webpack_require__(/*! ./utils/validator-extras */ \"(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\").validator);\nconst Op = __webpack_require__(/*! ./operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst deprecations = __webpack_require__(/*! ./utils/deprecations */ \"(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\");\nconst { QueryInterface } = __webpack_require__(/*! ./dialects/abstract/query-interface */ \"(rsc)/./node_modules/sequelize/lib/dialects/abstract/query-interface.js\");\nconst { BelongsTo } = __webpack_require__(/*! ./associations/belongs-to */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to.js\");\nconst HasOne = __webpack_require__(/*! ./associations/has-one */ \"(rsc)/./node_modules/sequelize/lib/associations/has-one.js\");\nconst { BelongsToMany } = __webpack_require__(/*! ./associations/belongs-to-many */ \"(rsc)/./node_modules/sequelize/lib/associations/belongs-to-many.js\");\nconst { HasMany } = __webpack_require__(/*! ./associations/has-many */ \"(rsc)/./node_modules/sequelize/lib/associations/has-many.js\");\nconst { withSqliteForeignKeysOff } = __webpack_require__(/*! ./dialects/sqlite/sqlite-utils */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/sqlite-utils.js\");\nconst { injectReplacements } = __webpack_require__(/*! ./utils/sql */ \"(rsc)/./node_modules/sequelize/lib/utils/sql.js\");\nclass Sequelize {\n  constructor(database, username, password, options) {\n    let config;\n    if (arguments.length === 1 && typeof database === \"object\") {\n      options = database;\n      config = _.pick(options, \"host\", \"port\", \"database\", \"username\", \"password\");\n    } else if (arguments.length === 1 && typeof database === \"string\" || arguments.length === 2 && typeof username === \"object\") {\n      config = {};\n      options = username || {};\n      const urlParts = url.parse(arguments[0], true);\n      options.dialect = urlParts.protocol.replace(/:$/, \"\");\n      options.host = urlParts.hostname;\n      if (options.dialect === \"sqlite\" && urlParts.pathname && !urlParts.pathname.startsWith(\"/:memory\")) {\n        const storagePath = path.join(options.host, urlParts.pathname);\n        options.storage = path.resolve(options.storage || storagePath);\n      }\n      if (urlParts.pathname) {\n        config.database = urlParts.pathname.replace(/^\\//, \"\");\n      }\n      if (urlParts.port) {\n        options.port = urlParts.port;\n      }\n      if (urlParts.auth) {\n        const authParts = urlParts.auth.split(\":\");\n        config.username = authParts[0];\n        if (authParts.length > 1)\n          config.password = authParts.slice(1).join(\":\");\n      }\n      if (urlParts.query) {\n        if (urlParts.query.host) {\n          options.host = urlParts.query.host;\n        }\n        if (options.dialectOptions) {\n          Object.assign(options.dialectOptions, urlParts.query);\n        } else {\n          options.dialectOptions = urlParts.query;\n          if (urlParts.query.options) {\n            try {\n              const o = JSON.parse(urlParts.query.options);\n              options.dialectOptions.options = o;\n            } catch (e) {\n            }\n          }\n        }\n      }\n      if ([\"postgres\", \"postgresql\"].includes(options.dialect)) {\n        Object.assign(options.dialectOptions, pgConnectionString.parse(arguments[0]));\n      }\n    } else {\n      options = options || {};\n      config = { database, username, password };\n    }\n    Sequelize.runHooks(\"beforeInit\", config, options);\n    this.options = __spreadValues({\n      dialect: null,\n      dialectModule: null,\n      dialectModulePath: null,\n      host: \"localhost\",\n      protocol: \"tcp\",\n      define: {},\n      query: {},\n      sync: {},\n      timezone: \"+00:00\",\n      standardConformingStrings: true,\n      logging: console.log,\n      omitNull: false,\n      native: false,\n      replication: false,\n      ssl: void 0,\n      pool: {},\n      quoteIdentifiers: true,\n      hooks: {},\n      retry: {\n        max: 5,\n        match: [\n          \"SQLITE_BUSY: database is locked\"\n        ]\n      },\n      transactionType: Transaction.TYPES.DEFERRED,\n      isolationLevel: null,\n      databaseVersion: 0,\n      typeValidation: false,\n      benchmark: false,\n      minifyAliases: false,\n      logQueryParameters: false,\n      attributeBehavior: \"throw\"\n    }, options);\n    if (!this.options.dialect) {\n      throw new Error(\"Dialect needs to be explicitly supplied as of v4.0.0\");\n    }\n    if (this.options.dialect === \"postgresql\") {\n      this.options.dialect = \"postgres\";\n    }\n    if (this.options.dialect === \"sqlite\" && this.options.timezone !== \"+00:00\") {\n      throw new Error(\"Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.\");\n    }\n    if (this.options.logging === true) {\n      deprecations.noTrueLogging();\n      this.options.logging = console.log;\n    }\n    this._setupHooks(options.hooks);\n    this.config = {\n      database: config.database || this.options.database,\n      username: config.username || this.options.username,\n      password: config.password || this.options.password || null,\n      host: config.host || this.options.host,\n      port: config.port || this.options.port,\n      pool: this.options.pool,\n      protocol: this.options.protocol,\n      native: this.options.native,\n      ssl: this.options.ssl,\n      replication: this.options.replication,\n      dialectModule: this.options.dialectModule,\n      dialectModulePath: this.options.dialectModulePath,\n      keepDefaultTimezone: this.options.keepDefaultTimezone,\n      dialectOptions: this.options.dialectOptions\n    };\n    let Dialect;\n    switch (this.getDialect()) {\n      case \"mariadb\":\n        Dialect = __webpack_require__(/*! ./dialects/mariadb */ \"(rsc)/./node_modules/sequelize/lib/dialects/mariadb/index.js\");\n        break;\n      case \"mssql\":\n        Dialect = __webpack_require__(/*! ./dialects/mssql */ \"(rsc)/./node_modules/sequelize/lib/dialects/mssql/index.js\");\n        break;\n      case \"mysql\":\n        Dialect = __webpack_require__(/*! ./dialects/mysql */ \"(rsc)/./node_modules/sequelize/lib/dialects/mysql/index.js\");\n        break;\n      case \"oracle\":\n        Dialect = __webpack_require__(/*! ./dialects/oracle */ \"(rsc)/./node_modules/sequelize/lib/dialects/oracle/index.js\");\n        break;\n      case \"postgres\":\n        Dialect = __webpack_require__(/*! ./dialects/postgres */ \"(rsc)/./node_modules/sequelize/lib/dialects/postgres/index.js\");\n        break;\n      case \"sqlite\":\n        Dialect = __webpack_require__(/*! ./dialects/sqlite */ \"(rsc)/./node_modules/sequelize/lib/dialects/sqlite/index.js\");\n        break;\n      case \"db2\":\n        Dialect = __webpack_require__(/*! ./dialects/db2 */ \"(rsc)/./node_modules/sequelize/lib/dialects/db2/index.js\");\n        break;\n      case \"snowflake\":\n        Dialect = __webpack_require__(/*! ./dialects/snowflake */ \"(rsc)/./node_modules/sequelize/lib/dialects/snowflake/index.js\");\n        break;\n      default:\n        throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, oracle, postgres, db2 and sqlite.`);\n    }\n    this.dialect = new Dialect(this);\n    this.dialect.queryGenerator.typeValidation = options.typeValidation;\n    if (_.isPlainObject(this.options.operatorsAliases)) {\n      deprecations.noStringOperators();\n      this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases);\n    } else if (typeof this.options.operatorsAliases === \"boolean\") {\n      deprecations.noBoolOperatorAliases();\n    }\n    this.queryInterface = this.dialect.queryInterface;\n    this.models = {};\n    this.modelManager = new ModelManager(this);\n    this.connectionManager = this.dialect.connectionManager;\n    Sequelize.runHooks(\"afterInit\", this);\n  }\n  refreshTypes() {\n    this.connectionManager.refreshTypeParser(DataTypes);\n  }\n  getDialect() {\n    return this.options.dialect;\n  }\n  getDatabaseName() {\n    return this.config.database;\n  }\n  getQueryInterface() {\n    return this.queryInterface;\n  }\n  define(modelName, attributes, options = {}) {\n    options.modelName = modelName;\n    options.sequelize = this;\n    const model = class extends Model {\n    };\n    model.init(attributes, options);\n    return model;\n  }\n  model(modelName) {\n    if (!this.isDefined(modelName)) {\n      throw new Error(`${modelName} has not been defined`);\n    }\n    return this.modelManager.getModel(modelName);\n  }\n  isDefined(modelName) {\n    return !!this.modelManager.models.find((model) => model.name === modelName);\n  }\n  async query(sql, options) {\n    options = __spreadValues(__spreadValues({}, this.options.query), options);\n    if (options.instance && !options.model) {\n      options.model = options.instance.constructor;\n    }\n    if (!options.instance && !options.model) {\n      options.raw = true;\n    }\n    if (options.mapToModel) {\n      options.fieldMap = _.get(options, \"model.fieldAttributeMap\", {});\n    }\n    options = _.defaults(options, {\n      logging: Object.prototype.hasOwnProperty.call(this.options, \"logging\") ? this.options.logging : console.log,\n      searchPath: Object.prototype.hasOwnProperty.call(this.options, \"searchPath\") ? this.options.searchPath : \"DEFAULT\"\n    });\n    if (!options.type) {\n      if (options.model || options.nest || options.plain) {\n        options.type = QueryTypes.SELECT;\n      } else {\n        options.type = QueryTypes.RAW;\n      }\n    }\n    if (!this.dialect.supports.searchPath || !this.options.dialectOptions || !this.options.dialectOptions.prependSearchPath || options.supportsSearchPath === false) {\n      delete options.searchPath;\n    } else if (!options.searchPath) {\n      options.searchPath = \"DEFAULT\";\n    }\n    if (typeof sql === \"object\") {\n      if (sql.values !== void 0) {\n        if (options.replacements !== void 0) {\n          throw new Error(\"Both `sql.values` and `options.replacements` cannot be set at the same time\");\n        }\n        options.replacements = sql.values;\n      }\n      if (sql.bind !== void 0) {\n        if (options.bind !== void 0) {\n          throw new Error(\"Both `sql.bind` and `options.bind` cannot be set at the same time\");\n        }\n        options.bind = sql.bind;\n      }\n      if (sql.query !== void 0) {\n        sql = sql.query;\n      }\n    }\n    sql = sql.trim();\n    if (options.replacements && options.bind) {\n      throw new Error(\"Both `replacements` and `bind` cannot be set at the same time\");\n    }\n    if (options.replacements) {\n      sql = injectReplacements(sql, this.dialect, options.replacements);\n    }\n    let bindParameters;\n    if (options.bind) {\n      [sql, bindParameters] = this.dialect.Query.formatBindParameters(sql, options.bind, this.options.dialect);\n    }\n    const checkTransaction = () => {\n      if (options.transaction && options.transaction.finished && !options.completesTransaction) {\n        const error = new Error(`${options.transaction.finished} has been called on this transaction(${options.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);\n        error.sql = sql;\n        throw error;\n      }\n    };\n    const retryOptions = __spreadValues(__spreadValues({}, this.options.retry), options.retry);\n    return retry(async () => {\n      if (options.transaction === void 0 && Sequelize._cls) {\n        options.transaction = Sequelize._cls.get(\"transaction\");\n      }\n      checkTransaction();\n      const connection = await (options.transaction ? options.transaction.connection : this.connectionManager.getConnection(options));\n      if (this.options.dialect === \"db2\" && options.alter) {\n        if (options.alter.drop === false) {\n          connection.dropTable = false;\n        }\n      }\n      const query = new this.dialect.Query(connection, this, options);\n      try {\n        await this.runHooks(\"beforeQuery\", options, query);\n        checkTransaction();\n        return await query.run(sql, bindParameters);\n      } finally {\n        await this.runHooks(\"afterQuery\", options, query);\n        if (!options.transaction) {\n          this.connectionManager.releaseConnection(connection);\n        }\n      }\n    }, retryOptions);\n  }\n  async set(variables, options) {\n    options = __spreadValues(__spreadValues({}, this.options.set), typeof options === \"object\" && options);\n    if (![\"mysql\", \"mariadb\"].includes(this.options.dialect)) {\n      throw new Error(\"sequelize.set is only supported for mysql or mariadb\");\n    }\n    if (!options.transaction || !(options.transaction instanceof Transaction)) {\n      throw new TypeError(\"options.transaction is required\");\n    }\n    options.raw = true;\n    options.plain = true;\n    options.type = \"SET\";\n    const query = `SET ${_.map(variables, (v, k) => `@${k} := ${typeof v === \"string\" ? `\"${v}\"` : v}`).join(\", \")}`;\n    return await this.query(query, options);\n  }\n  escape(value) {\n    return this.dialect.queryGenerator.escape(value);\n  }\n  async createSchema(schema, options) {\n    return await this.getQueryInterface().createSchema(schema, options);\n  }\n  async showAllSchemas(options) {\n    return await this.getQueryInterface().showAllSchemas(options);\n  }\n  async dropSchema(schema, options) {\n    return await this.getQueryInterface().dropSchema(schema, options);\n  }\n  async dropAllSchemas(options) {\n    return await this.getQueryInterface().dropAllSchemas(options);\n  }\n  async sync(options) {\n    options = __spreadProps(__spreadValues(__spreadValues(__spreadValues({}, this.options), this.options.sync), options), {\n      hooks: options ? options.hooks !== false : true\n    });\n    if (options.match) {\n      if (!options.match.test(this.config.database)) {\n        throw new Error(`Database \"${this.config.database}\" does not match sync match parameter \"${options.match}\"`);\n      }\n    }\n    if (options.hooks) {\n      await this.runHooks(\"beforeBulkSync\", options);\n    }\n    if (options.force) {\n      await this.drop(options);\n    }\n    if (this.modelManager.models.length === 0) {\n      await this.authenticate(options);\n    } else {\n      const models = this.modelManager.getModelsTopoSortedByForeignKey();\n      if (models == null) {\n        return this._syncModelsWithCyclicReferences(options);\n      }\n      models.reverse();\n      for (const model of models) {\n        await model.sync(options);\n      }\n    }\n    if (options.hooks) {\n      await this.runHooks(\"afterBulkSync\", options);\n    }\n    return this;\n  }\n  async _syncModelsWithCyclicReferences(options) {\n    if (this.dialect.name === \"sqlite\") {\n      await withSqliteForeignKeysOff(this, options, async () => {\n        for (const model of this.modelManager.models) {\n          await model.sync(options);\n        }\n      });\n      return;\n    }\n    for (const model of this.modelManager.models) {\n      await model.sync(__spreadProps(__spreadValues({}, options), { withoutForeignKeyConstraints: true }));\n    }\n    for (const model of this.modelManager.models) {\n      await model.sync(__spreadProps(__spreadValues({}, options), { force: false, alter: true }));\n    }\n  }\n  async truncate(options) {\n    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();\n    const models = sortedModels || this.modelManager.models;\n    const hasCyclicDependencies = sortedModels == null;\n    if (hasCyclicDependencies && (!options || !options.cascade)) {\n      throw new Error('Sequelize#truncate: Some of your models have cyclic references (foreign keys). You need to use the \"cascade\" option to be able to delete rows from models that have cyclic references.');\n    }\n    if (hasCyclicDependencies && this.dialect.name === \"sqlite\") {\n      return withSqliteForeignKeysOff(this, options, async () => {\n        await Promise.all(models.map((model) => model.truncate(options)));\n      });\n    }\n    if (options && options.cascade) {\n      for (const model of models)\n        await model.truncate(options);\n    } else {\n      await Promise.all(models.map((model) => model.truncate(options)));\n    }\n  }\n  async drop(options) {\n    if (options && options.cascade) {\n      for (const model of this.modelManager.models) {\n        await model.drop(options);\n      }\n    }\n    const sortedModels = this.modelManager.getModelsTopoSortedByForeignKey();\n    if (sortedModels) {\n      for (const model of sortedModels) {\n        await model.drop(options);\n      }\n    }\n    if (this.dialect.name === \"sqlite\") {\n      await withSqliteForeignKeysOff(this, options, async () => {\n        for (const model of this.modelManager.models) {\n          await model.drop(options);\n        }\n      });\n      return;\n    }\n    for (const model of this.modelManager.models) {\n      const tableName = model.getTableName();\n      const foreignKeys = await this.queryInterface.getForeignKeyReferencesForTable(tableName, options);\n      await Promise.all(foreignKeys.map((foreignKey) => {\n        return this.queryInterface.removeConstraint(tableName, foreignKey.constraintName, options);\n      }));\n    }\n    for (const model of this.modelManager.models) {\n      await model.drop(options);\n    }\n  }\n  async authenticate(options) {\n    options = __spreadValues({\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    }, options);\n    await this.query(this.dialect.queryGenerator.authTestQuery(), options);\n    return;\n  }\n  async databaseVersion(options) {\n    return await this.getQueryInterface().databaseVersion(options);\n  }\n  random() {\n    if ([\"postgres\", \"sqlite\", \"snowflake\"].includes(this.getDialect())) {\n      return this.fn(\"RANDOM\");\n    }\n    return this.fn(\"RAND\");\n  }\n  static fn(fn, ...args) {\n    return new Utils.Fn(fn, args);\n  }\n  static col(col) {\n    return new Utils.Col(col);\n  }\n  static cast(val, type) {\n    return new Utils.Cast(val, type);\n  }\n  static literal(val) {\n    return new Utils.Literal(val);\n  }\n  static and(...args) {\n    return { [Op.and]: args };\n  }\n  static or(...args) {\n    return { [Op.or]: args };\n  }\n  static json(conditionsOrPath, value) {\n    return new Utils.Json(conditionsOrPath, value);\n  }\n  static where(attr, comparator, logic) {\n    return new Utils.Where(attr, comparator, logic);\n  }\n  async transaction(options, autoCallback) {\n    if (typeof options === \"function\") {\n      autoCallback = options;\n      options = void 0;\n    }\n    const transaction = new Transaction(this, options);\n    if (!autoCallback) {\n      await transaction.prepareEnvironment(false);\n      return transaction;\n    }\n    return Sequelize._clsRun(async () => {\n      await transaction.prepareEnvironment(true);\n      let result;\n      try {\n        result = await autoCallback(transaction);\n      } catch (err) {\n        try {\n          await transaction.rollback();\n        } catch (ignore) {\n        }\n        throw err;\n      }\n      await transaction.commit();\n      return result;\n    });\n  }\n  static useCLS(ns) {\n    if (!ns || typeof ns !== \"object\" || typeof ns.bind !== \"function\" || typeof ns.run !== \"function\")\n      throw new Error(\"Must provide CLS namespace\");\n    Sequelize._cls = ns;\n    return this;\n  }\n  static _clsRun(fn) {\n    const ns = Sequelize._cls;\n    if (!ns)\n      return fn();\n    let res;\n    ns.run((context) => res = fn(context));\n    return res;\n  }\n  log(...args) {\n    let options;\n    const last = _.last(args);\n    if (last && _.isPlainObject(last) && Object.prototype.hasOwnProperty.call(last, \"logging\")) {\n      options = last;\n      if (options.logging === console.log) {\n        args.splice(args.length - 1, 1);\n      }\n    } else {\n      options = this.options;\n    }\n    if (options.logging) {\n      if (options.logging === true) {\n        deprecations.noTrueLogging();\n        options.logging = console.log;\n      }\n      if ((this.options.benchmark || options.benchmark) && options.logging === console.log) {\n        args = [`${args[0]} Elapsed time: ${args[1]}ms`];\n      }\n      options.logging(...args);\n    }\n  }\n  close() {\n    return this.connectionManager.close();\n  }\n  normalizeDataType(Type) {\n    let type = typeof Type === \"function\" ? new Type() : Type;\n    const dialectTypes = this.dialect.DataTypes || {};\n    if (dialectTypes[type.key]) {\n      type = dialectTypes[type.key].extend(type);\n    }\n    if (type instanceof DataTypes.ARRAY) {\n      if (!type.type) {\n        throw new Error(\"ARRAY is missing type definition for its values.\");\n      }\n      if (dialectTypes[type.type.key]) {\n        type.type = dialectTypes[type.type.key].extend(type.type);\n      }\n    }\n    return type;\n  }\n  normalizeAttribute(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = { type: attribute };\n    }\n    if (!attribute.type)\n      return attribute;\n    attribute.type = this.normalizeDataType(attribute.type);\n    if (Object.prototype.hasOwnProperty.call(attribute, \"defaultValue\")) {\n      if (typeof attribute.defaultValue === \"function\" && [DataTypes.NOW, DataTypes.UUIDV1, DataTypes.UUIDV4].includes(attribute.defaultValue)) {\n        attribute.defaultValue = new attribute.defaultValue();\n      }\n    }\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.values) {\n        attribute.type.values = attribute.type.options.values = attribute.values;\n      } else {\n        attribute.values = attribute.type.values;\n      }\n      if (!attribute.values.length) {\n        throw new Error(\"Values for ENUM have not been defined.\");\n      }\n    }\n    return attribute;\n  }\n}\nSequelize.prototype.fn = Sequelize.fn;\nSequelize.prototype.col = Sequelize.col;\nSequelize.prototype.cast = Sequelize.cast;\nSequelize.prototype.literal = Sequelize.literal;\nSequelize.prototype.and = Sequelize.and;\nSequelize.prototype.or = Sequelize.or;\nSequelize.prototype.json = Sequelize.json;\nSequelize.prototype.where = Sequelize.where;\nSequelize.prototype.validate = Sequelize.prototype.authenticate;\nObject.defineProperty(Sequelize, \"version\", {\n  enumerable: true,\n  get() {\n    return (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/sequelize/package.json\").version);\n  }\n});\nSequelize.options = { hooks: {} };\nSequelize.Utils = Utils;\nSequelize.Op = Op;\nSequelize.TableHints = TableHints;\nSequelize.IndexHints = IndexHints;\nSequelize.Transaction = Transaction;\nSequelize.prototype.Sequelize = Sequelize;\nSequelize.prototype.QueryTypes = Sequelize.QueryTypes = QueryTypes;\nSequelize.prototype.Validator = Sequelize.Validator = Validator;\nSequelize.Model = Model;\nSequelize.QueryInterface = QueryInterface;\nSequelize.BelongsTo = BelongsTo;\nSequelize.HasOne = HasOne;\nSequelize.HasMany = HasMany;\nSequelize.BelongsToMany = BelongsToMany;\nSequelize.DataTypes = DataTypes;\nfor (const dataType in DataTypes) {\n  Sequelize[dataType] = DataTypes[dataType];\n}\nSequelize.Deferrable = Deferrable;\nSequelize.prototype.Association = Sequelize.Association = Association;\nSequelize.useInflection = Utils.useInflection;\nHooks.applyTo(Sequelize);\nHooks.applyTo(Sequelize.prototype);\nSequelize.Error = sequelizeErrors.BaseError;\nfor (const error of Object.keys(sequelizeErrors)) {\n  Sequelize[error] = sequelizeErrors[error];\n}\nmodule.exports = Sequelize;\nmodule.exports.Sequelize = Sequelize;\nmodule.exports[\"default\"] = Sequelize;\n//# sourceMappingURL=sequelize.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zZXF1ZWxpemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQiwyQkFBMkIsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDekQsY0FBYyxpSEFBb0M7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsc0VBQWM7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsc0VBQWM7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsNEVBQWlCO0FBQzlDLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFlO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLG1CQUFtQixtQkFBTyxDQUFDLHdFQUFlO0FBQzFDLHdCQUF3QixtQkFBTyxDQUFDLG9FQUFVO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDbEQsa0JBQWtCLCtIQUE2QztBQUMvRCxXQUFXLG1CQUFPLENBQUMsb0VBQWE7QUFDaEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ25ELFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxvSEFBcUM7QUFDeEUsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLDBGQUF3QjtBQUMvQyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMEdBQWdDO0FBQ2xFLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsNEZBQXlCO0FBQ3JELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQywwR0FBZ0M7QUFDN0UsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHdGQUFvQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsb0ZBQWtCO0FBQzVDO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBa0I7QUFDNUM7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHNGQUFtQjtBQUM3QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMEZBQXFCO0FBQy9DO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRkFBbUI7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGdGQUFnQjtBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEZBQXNCO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOEJBQThCLHNDQUFzQyx1QkFBdUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQkFBK0IsR0FBRyxLQUFLLDRCQUE0QixFQUFFLE9BQU8sY0FBYztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUIseUNBQXlDLGNBQWM7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsY0FBYyxvQ0FBb0M7QUFDeEc7QUFDQTtBQUNBLHNEQUFzRCxjQUFjLDJCQUEyQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUyxnQkFBZ0IsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtR0FBa0M7QUFDN0M7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc2VxdWVsaXplLmpzPzVhYTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBwZ0Nvbm5lY3Rpb25TdHJpbmcgPSByZXF1aXJlKFwicGctY29ubmVjdGlvbi1zdHJpbmdcIik7XG5jb25zdCByZXRyeSA9IHJlcXVpcmUoXCJyZXRyeS1hcy1wcm9taXNlZFwiKS5kZWZhdWx0O1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgTW9kZWwgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuL2RhdGEtdHlwZXNcIik7XG5jb25zdCBEZWZlcnJhYmxlID0gcmVxdWlyZShcIi4vZGVmZXJyYWJsZVwiKTtcbmNvbnN0IE1vZGVsTWFuYWdlciA9IHJlcXVpcmUoXCIuL21vZGVsLW1hbmFnZXJcIik7XG5jb25zdCBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgUXVlcnlUeXBlcyA9IHJlcXVpcmUoXCIuL3F1ZXJ5LXR5cGVzXCIpO1xuY29uc3QgVGFibGVIaW50cyA9IHJlcXVpcmUoXCIuL3RhYmxlLWhpbnRzXCIpO1xuY29uc3QgSW5kZXhIaW50cyA9IHJlcXVpcmUoXCIuL2luZGV4LWhpbnRzXCIpO1xuY29uc3Qgc2VxdWVsaXplRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgSG9va3MgPSByZXF1aXJlKFwiLi9ob29rc1wiKTtcbmNvbnN0IEFzc29jaWF0aW9uID0gcmVxdWlyZShcIi4vYXNzb2NpYXRpb25zL2luZGV4XCIpO1xuY29uc3QgVmFsaWRhdG9yID0gcmVxdWlyZShcIi4vdXRpbHMvdmFsaWRhdG9yLWV4dHJhc1wiKS52YWxpZGF0b3I7XG5jb25zdCBPcCA9IHJlcXVpcmUoXCIuL29wZXJhdG9yc1wiKTtcbmNvbnN0IGRlcHJlY2F0aW9ucyA9IHJlcXVpcmUoXCIuL3V0aWxzL2RlcHJlY2F0aW9uc1wiKTtcbmNvbnN0IHsgUXVlcnlJbnRlcmZhY2UgfSA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL2Fic3RyYWN0L3F1ZXJ5LWludGVyZmFjZVwiKTtcbmNvbnN0IHsgQmVsb25nc1RvIH0gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10b1wiKTtcbmNvbnN0IEhhc09uZSA9IHJlcXVpcmUoXCIuL2Fzc29jaWF0aW9ucy9oYXMtb25lXCIpO1xuY29uc3QgeyBCZWxvbmdzVG9NYW55IH0gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvYmVsb25ncy10by1tYW55XCIpO1xuY29uc3QgeyBIYXNNYW55IH0gPSByZXF1aXJlKFwiLi9hc3NvY2lhdGlvbnMvaGFzLW1hbnlcIik7XG5jb25zdCB7IHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZiB9ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvc3FsaXRlL3NxbGl0ZS11dGlsc1wiKTtcbmNvbnN0IHsgaW5qZWN0UmVwbGFjZW1lbnRzIH0gPSByZXF1aXJlKFwiLi91dGlscy9zcWxcIik7XG5jbGFzcyBTZXF1ZWxpemUge1xuICBjb25zdHJ1Y3RvcihkYXRhYmFzZSwgdXNlcm5hbWUsIHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgbGV0IGNvbmZpZztcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGF0YWJhc2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSBkYXRhYmFzZTtcbiAgICAgIGNvbmZpZyA9IF8ucGljayhvcHRpb25zLCBcImhvc3RcIiwgXCJwb3J0XCIsIFwiZGF0YWJhc2VcIiwgXCJ1c2VybmFtZVwiLCBcInBhc3N3b3JkXCIpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGF0YWJhc2UgPT09IFwic3RyaW5nXCIgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgdXNlcm5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgb3B0aW9ucyA9IHVzZXJuYW1lIHx8IHt9O1xuICAgICAgY29uc3QgdXJsUGFydHMgPSB1cmwucGFyc2UoYXJndW1lbnRzWzBdLCB0cnVlKTtcbiAgICAgIG9wdGlvbnMuZGlhbGVjdCA9IHVybFBhcnRzLnByb3RvY29sLnJlcGxhY2UoLzokLywgXCJcIik7XG4gICAgICBvcHRpb25zLmhvc3QgPSB1cmxQYXJ0cy5ob3N0bmFtZTtcbiAgICAgIGlmIChvcHRpb25zLmRpYWxlY3QgPT09IFwic3FsaXRlXCIgJiYgdXJsUGFydHMucGF0aG5hbWUgJiYgIXVybFBhcnRzLnBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvOm1lbW9yeVwiKSkge1xuICAgICAgICBjb25zdCBzdG9yYWdlUGF0aCA9IHBhdGguam9pbihvcHRpb25zLmhvc3QsIHVybFBhcnRzLnBhdGhuYW1lKTtcbiAgICAgICAgb3B0aW9ucy5zdG9yYWdlID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuc3RvcmFnZSB8fCBzdG9yYWdlUGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodXJsUGFydHMucGF0aG5hbWUpIHtcbiAgICAgICAgY29uZmlnLmRhdGFiYXNlID0gdXJsUGFydHMucGF0aG5hbWUucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHVybFBhcnRzLnBvcnQpIHtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gdXJsUGFydHMucG9ydDtcbiAgICAgIH1cbiAgICAgIGlmICh1cmxQYXJ0cy5hdXRoKSB7XG4gICAgICAgIGNvbnN0IGF1dGhQYXJ0cyA9IHVybFBhcnRzLmF1dGguc3BsaXQoXCI6XCIpO1xuICAgICAgICBjb25maWcudXNlcm5hbWUgPSBhdXRoUGFydHNbMF07XG4gICAgICAgIGlmIChhdXRoUGFydHMubGVuZ3RoID4gMSlcbiAgICAgICAgICBjb25maWcucGFzc3dvcmQgPSBhdXRoUGFydHMuc2xpY2UoMSkuam9pbihcIjpcIik7XG4gICAgICB9XG4gICAgICBpZiAodXJsUGFydHMucXVlcnkpIHtcbiAgICAgICAgaWYgKHVybFBhcnRzLnF1ZXJ5Lmhvc3QpIHtcbiAgICAgICAgICBvcHRpb25zLmhvc3QgPSB1cmxQYXJ0cy5xdWVyeS5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmRpYWxlY3RPcHRpb25zKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLmRpYWxlY3RPcHRpb25zLCB1cmxQYXJ0cy5xdWVyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5kaWFsZWN0T3B0aW9ucyA9IHVybFBhcnRzLnF1ZXJ5O1xuICAgICAgICAgIGlmICh1cmxQYXJ0cy5xdWVyeS5vcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBvID0gSlNPTi5wYXJzZSh1cmxQYXJ0cy5xdWVyeS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgb3B0aW9ucy5kaWFsZWN0T3B0aW9ucy5vcHRpb25zID0gbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChbXCJwb3N0Z3Jlc1wiLCBcInBvc3RncmVzcWxcIl0uaW5jbHVkZXMob3B0aW9ucy5kaWFsZWN0KSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMuZGlhbGVjdE9wdGlvbnMsIHBnQ29ubmVjdGlvblN0cmluZy5wYXJzZShhcmd1bWVudHNbMF0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBjb25maWcgPSB7IGRhdGFiYXNlLCB1c2VybmFtZSwgcGFzc3dvcmQgfTtcbiAgICB9XG4gICAgU2VxdWVsaXplLnJ1bkhvb2tzKFwiYmVmb3JlSW5pdFwiLCBjb25maWcsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIGRpYWxlY3Q6IG51bGwsXG4gICAgICBkaWFsZWN0TW9kdWxlOiBudWxsLFxuICAgICAgZGlhbGVjdE1vZHVsZVBhdGg6IG51bGwsXG4gICAgICBob3N0OiBcImxvY2FsaG9zdFwiLFxuICAgICAgcHJvdG9jb2w6IFwidGNwXCIsXG4gICAgICBkZWZpbmU6IHt9LFxuICAgICAgcXVlcnk6IHt9LFxuICAgICAgc3luYzoge30sXG4gICAgICB0aW1lem9uZTogXCIrMDA6MDBcIixcbiAgICAgIHN0YW5kYXJkQ29uZm9ybWluZ1N0cmluZ3M6IHRydWUsXG4gICAgICBsb2dnaW5nOiBjb25zb2xlLmxvZyxcbiAgICAgIG9taXROdWxsOiBmYWxzZSxcbiAgICAgIG5hdGl2ZTogZmFsc2UsXG4gICAgICByZXBsaWNhdGlvbjogZmFsc2UsXG4gICAgICBzc2w6IHZvaWQgMCxcbiAgICAgIHBvb2w6IHt9LFxuICAgICAgcXVvdGVJZGVudGlmaWVyczogdHJ1ZSxcbiAgICAgIGhvb2tzOiB7fSxcbiAgICAgIHJldHJ5OiB7XG4gICAgICAgIG1heDogNSxcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICBcIlNRTElURV9CVVNZOiBkYXRhYmFzZSBpcyBsb2NrZWRcIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgdHJhbnNhY3Rpb25UeXBlOiBUcmFuc2FjdGlvbi5UWVBFUy5ERUZFUlJFRCxcbiAgICAgIGlzb2xhdGlvbkxldmVsOiBudWxsLFxuICAgICAgZGF0YWJhc2VWZXJzaW9uOiAwLFxuICAgICAgdHlwZVZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgYmVuY2htYXJrOiBmYWxzZSxcbiAgICAgIG1pbmlmeUFsaWFzZXM6IGZhbHNlLFxuICAgICAgbG9nUXVlcnlQYXJhbWV0ZXJzOiBmYWxzZSxcbiAgICAgIGF0dHJpYnV0ZUJlaGF2aW9yOiBcInRocm93XCJcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaWFsZWN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaWFsZWN0IG5lZWRzIHRvIGJlIGV4cGxpY2l0bHkgc3VwcGxpZWQgYXMgb2YgdjQuMC4wXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmRpYWxlY3QgPT09IFwicG9zdGdyZXNxbFwiKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuZGlhbGVjdCA9IFwicG9zdGdyZXNcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaWFsZWN0ID09PSBcInNxbGl0ZVwiICYmIHRoaXMub3B0aW9ucy50aW1lem9uZSAhPT0gXCIrMDA6MDBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZyBhIGN1c3RvbSB0aW1lem9uZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IFNRTGl0ZSwgZGF0ZXMgYXJlIGFsd2F5cyByZXR1cm5lZCBhcyBVVEMuIFBsZWFzZSByZW1vdmUgdGhlIGN1c3RvbSB0aW1lem9uZSBwYXJhbWV0ZXIuXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvZ2dpbmcgPT09IHRydWUpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub1RydWVMb2dnaW5nKCk7XG4gICAgICB0aGlzLm9wdGlvbnMubG9nZ2luZyA9IGNvbnNvbGUubG9nO1xuICAgIH1cbiAgICB0aGlzLl9zZXR1cEhvb2tzKG9wdGlvbnMuaG9va3MpO1xuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgZGF0YWJhc2U6IGNvbmZpZy5kYXRhYmFzZSB8fCB0aGlzLm9wdGlvbnMuZGF0YWJhc2UsXG4gICAgICB1c2VybmFtZTogY29uZmlnLnVzZXJuYW1lIHx8IHRoaXMub3B0aW9ucy51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiBjb25maWcucGFzc3dvcmQgfHwgdGhpcy5vcHRpb25zLnBhc3N3b3JkIHx8IG51bGwsXG4gICAgICBob3N0OiBjb25maWcuaG9zdCB8fCB0aGlzLm9wdGlvbnMuaG9zdCxcbiAgICAgIHBvcnQ6IGNvbmZpZy5wb3J0IHx8IHRoaXMub3B0aW9ucy5wb3J0LFxuICAgICAgcG9vbDogdGhpcy5vcHRpb25zLnBvb2wsXG4gICAgICBwcm90b2NvbDogdGhpcy5vcHRpb25zLnByb3RvY29sLFxuICAgICAgbmF0aXZlOiB0aGlzLm9wdGlvbnMubmF0aXZlLFxuICAgICAgc3NsOiB0aGlzLm9wdGlvbnMuc3NsLFxuICAgICAgcmVwbGljYXRpb246IHRoaXMub3B0aW9ucy5yZXBsaWNhdGlvbixcbiAgICAgIGRpYWxlY3RNb2R1bGU6IHRoaXMub3B0aW9ucy5kaWFsZWN0TW9kdWxlLFxuICAgICAgZGlhbGVjdE1vZHVsZVBhdGg6IHRoaXMub3B0aW9ucy5kaWFsZWN0TW9kdWxlUGF0aCxcbiAgICAgIGtlZXBEZWZhdWx0VGltZXpvbmU6IHRoaXMub3B0aW9ucy5rZWVwRGVmYXVsdFRpbWV6b25lLFxuICAgICAgZGlhbGVjdE9wdGlvbnM6IHRoaXMub3B0aW9ucy5kaWFsZWN0T3B0aW9uc1xuICAgIH07XG4gICAgbGV0IERpYWxlY3Q7XG4gICAgc3dpdGNoICh0aGlzLmdldERpYWxlY3QoKSkge1xuICAgICAgY2FzZSBcIm1hcmlhZGJcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL21hcmlhZGJcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1zc3FsXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9tc3NxbFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibXlzcWxcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL215c3FsXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvcmFjbGVcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL29yYWNsZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9zdGdyZXNcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3Bvc3RncmVzXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzcWxpdGVcIjpcbiAgICAgICAgRGlhbGVjdCA9IHJlcXVpcmUoXCIuL2RpYWxlY3RzL3NxbGl0ZVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGIyXCI6XG4gICAgICAgIERpYWxlY3QgPSByZXF1aXJlKFwiLi9kaWFsZWN0cy9kYjJcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNub3dmbGFrZVwiOlxuICAgICAgICBEaWFsZWN0ID0gcmVxdWlyZShcIi4vZGlhbGVjdHMvc25vd2ZsYWtlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRpYWxlY3QgJHt0aGlzLmdldERpYWxlY3QoKX0gaXMgbm90IHN1cHBvcnRlZC4gU3VwcG9ydGVkIGRpYWxlY3RzOiBtc3NxbCwgbWFyaWFkYiwgbXlzcWwsIG9yYWNsZSwgcG9zdGdyZXMsIGRiMiBhbmQgc3FsaXRlLmApO1xuICAgIH1cbiAgICB0aGlzLmRpYWxlY3QgPSBuZXcgRGlhbGVjdCh0aGlzKTtcbiAgICB0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IudHlwZVZhbGlkYXRpb24gPSBvcHRpb25zLnR5cGVWYWxpZGF0aW9uO1xuICAgIGlmIChfLmlzUGxhaW5PYmplY3QodGhpcy5vcHRpb25zLm9wZXJhdG9yc0FsaWFzZXMpKSB7XG4gICAgICBkZXByZWNhdGlvbnMubm9TdHJpbmdPcGVyYXRvcnMoKTtcbiAgICAgIHRoaXMuZGlhbGVjdC5xdWVyeUdlbmVyYXRvci5zZXRPcGVyYXRvcnNBbGlhc2VzKHRoaXMub3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub3BlcmF0b3JzQWxpYXNlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIGRlcHJlY2F0aW9ucy5ub0Jvb2xPcGVyYXRvckFsaWFzZXMoKTtcbiAgICB9XG4gICAgdGhpcy5xdWVyeUludGVyZmFjZSA9IHRoaXMuZGlhbGVjdC5xdWVyeUludGVyZmFjZTtcbiAgICB0aGlzLm1vZGVscyA9IHt9O1xuICAgIHRoaXMubW9kZWxNYW5hZ2VyID0gbmV3IE1vZGVsTWFuYWdlcih0aGlzKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5kaWFsZWN0LmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgIFNlcXVlbGl6ZS5ydW5Ib29rcyhcImFmdGVySW5pdFwiLCB0aGlzKTtcbiAgfVxuICByZWZyZXNoVHlwZXMoKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWZyZXNoVHlwZVBhcnNlcihEYXRhVHlwZXMpO1xuICB9XG4gIGdldERpYWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kaWFsZWN0O1xuICB9XG4gIGdldERhdGFiYXNlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YWJhc2U7XG4gIH1cbiAgZ2V0UXVlcnlJbnRlcmZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlJbnRlcmZhY2U7XG4gIH1cbiAgZGVmaW5lKG1vZGVsTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5tb2RlbE5hbWUgPSBtb2RlbE5hbWU7XG4gICAgb3B0aW9ucy5zZXF1ZWxpemUgPSB0aGlzO1xuICAgIGNvbnN0IG1vZGVsID0gY2xhc3MgZXh0ZW5kcyBNb2RlbCB7XG4gICAgfTtcbiAgICBtb2RlbC5pbml0KGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBtb2RlbChtb2RlbE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNEZWZpbmVkKG1vZGVsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHttb2RlbE5hbWV9IGhhcyBub3QgYmVlbiBkZWZpbmVkYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vZGVsTWFuYWdlci5nZXRNb2RlbChtb2RlbE5hbWUpO1xuICB9XG4gIGlzRGVmaW5lZChtb2RlbE5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMuZmluZCgobW9kZWwpID0+IG1vZGVsLm5hbWUgPT09IG1vZGVsTmFtZSk7XG4gIH1cbiAgYXN5bmMgcXVlcnkoc3FsLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMucXVlcnkpLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbnN0YW5jZSAmJiAhb3B0aW9ucy5tb2RlbCkge1xuICAgICAgb3B0aW9ucy5tb2RlbCA9IG9wdGlvbnMuaW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5pbnN0YW5jZSAmJiAhb3B0aW9ucy5tb2RlbCkge1xuICAgICAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5tYXBUb01vZGVsKSB7XG4gICAgICBvcHRpb25zLmZpZWxkTWFwID0gXy5nZXQob3B0aW9ucywgXCJtb2RlbC5maWVsZEF0dHJpYnV0ZU1hcFwiLCB7fSk7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGxvZ2dpbmc6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm9wdGlvbnMsIFwibG9nZ2luZ1wiKSA/IHRoaXMub3B0aW9ucy5sb2dnaW5nIDogY29uc29sZS5sb2csXG4gICAgICBzZWFyY2hQYXRoOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5vcHRpb25zLCBcInNlYXJjaFBhdGhcIikgPyB0aGlzLm9wdGlvbnMuc2VhcmNoUGF0aCA6IFwiREVGQVVMVFwiXG4gICAgfSk7XG4gICAgaWYgKCFvcHRpb25zLnR5cGUpIHtcbiAgICAgIGlmIChvcHRpb25zLm1vZGVsIHx8IG9wdGlvbnMubmVzdCB8fCBvcHRpb25zLnBsYWluKSB7XG4gICAgICAgIG9wdGlvbnMudHlwZSA9IFF1ZXJ5VHlwZXMuU0VMRUNUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy50eXBlID0gUXVlcnlUeXBlcy5SQVc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5kaWFsZWN0LnN1cHBvcnRzLnNlYXJjaFBhdGggfHwgIXRoaXMub3B0aW9ucy5kaWFsZWN0T3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLmRpYWxlY3RPcHRpb25zLnByZXBlbmRTZWFyY2hQYXRoIHx8IG9wdGlvbnMuc3VwcG9ydHNTZWFyY2hQYXRoID09PSBmYWxzZSkge1xuICAgICAgZGVsZXRlIG9wdGlvbnMuc2VhcmNoUGF0aDtcbiAgICB9IGVsc2UgaWYgKCFvcHRpb25zLnNlYXJjaFBhdGgpIHtcbiAgICAgIG9wdGlvbnMuc2VhcmNoUGF0aCA9IFwiREVGQVVMVFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNxbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKHNxbC52YWx1ZXMgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yZXBsYWNlbWVudHMgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggYHNxbC52YWx1ZXNgIGFuZCBgb3B0aW9ucy5yZXBsYWNlbWVudHNgIGNhbm5vdCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlcGxhY2VtZW50cyA9IHNxbC52YWx1ZXM7XG4gICAgICB9XG4gICAgICBpZiAoc3FsLmJpbmQgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAob3B0aW9ucy5iaW5kICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3RoIGBzcWwuYmluZGAgYW5kIGBvcHRpb25zLmJpbmRgIGNhbm5vdCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmJpbmQgPSBzcWwuYmluZDtcbiAgICAgIH1cbiAgICAgIGlmIChzcWwucXVlcnkgIT09IHZvaWQgMCkge1xuICAgICAgICBzcWwgPSBzcWwucXVlcnk7XG4gICAgICB9XG4gICAgfVxuICAgIHNxbCA9IHNxbC50cmltKCk7XG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZW1lbnRzICYmIG9wdGlvbnMuYmluZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBgcmVwbGFjZW1lbnRzYCBhbmQgYGJpbmRgIGNhbm5vdCBiZSBzZXQgYXQgdGhlIHNhbWUgdGltZVwiKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVwbGFjZW1lbnRzKSB7XG4gICAgICBzcWwgPSBpbmplY3RSZXBsYWNlbWVudHMoc3FsLCB0aGlzLmRpYWxlY3QsIG9wdGlvbnMucmVwbGFjZW1lbnRzKTtcbiAgICB9XG4gICAgbGV0IGJpbmRQYXJhbWV0ZXJzO1xuICAgIGlmIChvcHRpb25zLmJpbmQpIHtcbiAgICAgIFtzcWwsIGJpbmRQYXJhbWV0ZXJzXSA9IHRoaXMuZGlhbGVjdC5RdWVyeS5mb3JtYXRCaW5kUGFyYW1ldGVycyhzcWwsIG9wdGlvbnMuYmluZCwgdGhpcy5vcHRpb25zLmRpYWxlY3QpO1xuICAgIH1cbiAgICBjb25zdCBjaGVja1RyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMudHJhbnNhY3Rpb24gJiYgb3B0aW9ucy50cmFuc2FjdGlvbi5maW5pc2hlZCAmJiAhb3B0aW9ucy5jb21wbGV0ZXNUcmFuc2FjdGlvbikge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgJHtvcHRpb25zLnRyYW5zYWN0aW9uLmZpbmlzaGVkfSBoYXMgYmVlbiBjYWxsZWQgb24gdGhpcyB0cmFuc2FjdGlvbigke29wdGlvbnMudHJhbnNhY3Rpb24uaWR9KSwgeW91IGNhbiBubyBsb25nZXIgdXNlIGl0LiAoVGhlIHJlamVjdGVkIHF1ZXJ5IGlzIGF0dGFjaGVkIGFzIHRoZSAnc3FsJyBwcm9wZXJ0eSBvZiB0aGlzIGVycm9yKWApO1xuICAgICAgICBlcnJvci5zcWwgPSBzcWw7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmV0cnlPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMub3B0aW9ucy5yZXRyeSksIG9wdGlvbnMucmV0cnkpO1xuICAgIHJldHVybiByZXRyeShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy50cmFuc2FjdGlvbiA9PT0gdm9pZCAwICYmIFNlcXVlbGl6ZS5fY2xzKSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNhY3Rpb24gPSBTZXF1ZWxpemUuX2Nscy5nZXQoXCJ0cmFuc2FjdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrVHJhbnNhY3Rpb24oKTtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCAob3B0aW9ucy50cmFuc2FjdGlvbiA/IG9wdGlvbnMudHJhbnNhY3Rpb24uY29ubmVjdGlvbiA6IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0Q29ubmVjdGlvbihvcHRpb25zKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRpYWxlY3QgPT09IFwiZGIyXCIgJiYgb3B0aW9ucy5hbHRlcikge1xuICAgICAgICBpZiAob3B0aW9ucy5hbHRlci5kcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgIGNvbm5lY3Rpb24uZHJvcFRhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IHRoaXMuZGlhbGVjdC5RdWVyeShjb25uZWN0aW9uLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVRdWVyeVwiLCBvcHRpb25zLCBxdWVyeSk7XG4gICAgICAgIGNoZWNrVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHF1ZXJ5LnJ1bihzcWwsIGJpbmRQYXJhbWV0ZXJzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJhZnRlclF1ZXJ5XCIsIG9wdGlvbnMsIHF1ZXJ5KTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZWxlYXNlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHJldHJ5T3B0aW9ucyk7XG4gIH1cbiAgYXN5bmMgc2V0KHZhcmlhYmxlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5vcHRpb25zLnNldCksIHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMpO1xuICAgIGlmICghW1wibXlzcWxcIiwgXCJtYXJpYWRiXCJdLmluY2x1ZGVzKHRoaXMub3B0aW9ucy5kaWFsZWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VxdWVsaXplLnNldCBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgbXlzcWwgb3IgbWFyaWFkYlwiKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLnRyYW5zYWN0aW9uIHx8ICEob3B0aW9ucy50cmFuc2FjdGlvbiBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMudHJhbnNhY3Rpb24gaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgICBvcHRpb25zLnBsYWluID0gdHJ1ZTtcbiAgICBvcHRpb25zLnR5cGUgPSBcIlNFVFwiO1xuICAgIGNvbnN0IHF1ZXJ5ID0gYFNFVCAke18ubWFwKHZhcmlhYmxlcywgKHYsIGspID0+IGBAJHtrfSA6PSAke3R5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gYFwiJHt2fVwiYCA6IHZ9YCkuam9pbihcIiwgXCIpfWA7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnkocXVlcnksIG9wdGlvbnMpO1xuICB9XG4gIGVzY2FwZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpYWxlY3QucXVlcnlHZW5lcmF0b3IuZXNjYXBlKHZhbHVlKTtcbiAgfVxuICBhc3luYyBjcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5jcmVhdGVTY2hlbWEoc2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzaG93QWxsU2NoZW1hcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5zaG93QWxsU2NoZW1hcyhvcHRpb25zKTtcbiAgfVxuICBhc3luYyBkcm9wU2NoZW1hKHNjaGVtYSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFF1ZXJ5SW50ZXJmYWNlKCkuZHJvcFNjaGVtYShzY2hlbWEsIG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIGRyb3BBbGxTY2hlbWFzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRRdWVyeUludGVyZmFjZSgpLmRyb3BBbGxTY2hlbWFzKG9wdGlvbnMpO1xuICB9XG4gIGFzeW5jIHN5bmMob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLm9wdGlvbnMpLCB0aGlzLm9wdGlvbnMuc3luYyksIG9wdGlvbnMpLCB7XG4gICAgICBob29rczogb3B0aW9ucyA/IG9wdGlvbnMuaG9va3MgIT09IGZhbHNlIDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChvcHRpb25zLm1hdGNoKSB7XG4gICAgICBpZiAoIW9wdGlvbnMubWF0Y2gudGVzdCh0aGlzLmNvbmZpZy5kYXRhYmFzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBcIiR7dGhpcy5jb25maWcuZGF0YWJhc2V9XCIgZG9lcyBub3QgbWF0Y2ggc3luYyBtYXRjaCBwYXJhbWV0ZXIgXCIke29wdGlvbnMubWF0Y2h9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaG9va3MpIHtcbiAgICAgIGF3YWl0IHRoaXMucnVuSG9va3MoXCJiZWZvcmVCdWxrU3luY1wiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgIGF3YWl0IHRoaXMuZHJvcChvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscy5sZW5ndGggPT09IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuYXV0aGVudGljYXRlKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtb2RlbHMgPSB0aGlzLm1vZGVsTWFuYWdlci5nZXRNb2RlbHNUb3BvU29ydGVkQnlGb3JlaWduS2V5KCk7XG4gICAgICBpZiAobW9kZWxzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N5bmNNb2RlbHNXaXRoQ3ljbGljUmVmZXJlbmNlcyhvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG1vZGVscy5yZXZlcnNlKCk7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vZGVscykge1xuICAgICAgICBhd2FpdCBtb2RlbC5zeW5jKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5ob29rcykge1xuICAgICAgYXdhaXQgdGhpcy5ydW5Ib29rcyhcImFmdGVyQnVsa1N5bmNcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFzeW5jIF9zeW5jTW9kZWxzV2l0aEN5Y2xpY1JlZmVyZW5jZXMob3B0aW9ucykge1xuICAgIGlmICh0aGlzLmRpYWxlY3QubmFtZSA9PT0gXCJzcWxpdGVcIikge1xuICAgICAgYXdhaXQgd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmKHRoaXMsIG9wdGlvbnMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgICAgICBhd2FpdCBtb2RlbC5zeW5jKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2RlbCBvZiB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHMpIHtcbiAgICAgIGF3YWl0IG1vZGVsLnN5bmMoX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucyksIHsgd2l0aG91dEZvcmVpZ25LZXlDb25zdHJhaW50czogdHJ1ZSB9KSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICBhd2FpdCBtb2RlbC5zeW5jKF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMpLCB7IGZvcmNlOiBmYWxzZSwgYWx0ZXI6IHRydWUgfSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyB0cnVuY2F0ZShvcHRpb25zKSB7XG4gICAgY29uc3Qgc29ydGVkTW9kZWxzID0gdGhpcy5tb2RlbE1hbmFnZXIuZ2V0TW9kZWxzVG9wb1NvcnRlZEJ5Rm9yZWlnbktleSgpO1xuICAgIGNvbnN0IG1vZGVscyA9IHNvcnRlZE1vZGVscyB8fCB0aGlzLm1vZGVsTWFuYWdlci5tb2RlbHM7XG4gICAgY29uc3QgaGFzQ3ljbGljRGVwZW5kZW5jaWVzID0gc29ydGVkTW9kZWxzID09IG51bGw7XG4gICAgaWYgKGhhc0N5Y2xpY0RlcGVuZGVuY2llcyAmJiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuY2FzY2FkZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VxdWVsaXplI3RydW5jYXRlOiBTb21lIG9mIHlvdXIgbW9kZWxzIGhhdmUgY3ljbGljIHJlZmVyZW5jZXMgKGZvcmVpZ24ga2V5cykuIFlvdSBuZWVkIHRvIHVzZSB0aGUgXCJjYXNjYWRlXCIgb3B0aW9uIHRvIGJlIGFibGUgdG8gZGVsZXRlIHJvd3MgZnJvbSBtb2RlbHMgdGhhdCBoYXZlIGN5Y2xpYyByZWZlcmVuY2VzLicpO1xuICAgIH1cbiAgICBpZiAoaGFzQ3ljbGljRGVwZW5kZW5jaWVzICYmIHRoaXMuZGlhbGVjdC5uYW1lID09PSBcInNxbGl0ZVwiKSB7XG4gICAgICByZXR1cm4gd2l0aFNxbGl0ZUZvcmVpZ25LZXlzT2ZmKHRoaXMsIG9wdGlvbnMsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwobW9kZWxzLm1hcCgobW9kZWwpID0+IG1vZGVsLnRydW5jYXRlKG9wdGlvbnMpKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYXNjYWRlKSB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vZGVscylcbiAgICAgICAgYXdhaXQgbW9kZWwudHJ1bmNhdGUob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKG1vZGVscy5tYXAoKG1vZGVsKSA9PiBtb2RlbC50cnVuY2F0ZShvcHRpb25zKSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBkcm9wKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNhc2NhZGUpIHtcbiAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICAgIGF3YWl0IG1vZGVsLmRyb3Aob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNvcnRlZE1vZGVscyA9IHRoaXMubW9kZWxNYW5hZ2VyLmdldE1vZGVsc1RvcG9Tb3J0ZWRCeUZvcmVpZ25LZXkoKTtcbiAgICBpZiAoc29ydGVkTW9kZWxzKSB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHNvcnRlZE1vZGVscykge1xuICAgICAgICBhd2FpdCBtb2RlbC5kcm9wKG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kaWFsZWN0Lm5hbWUgPT09IFwic3FsaXRlXCIpIHtcbiAgICAgIGF3YWl0IHdpdGhTcWxpdGVGb3JlaWduS2V5c09mZih0aGlzLCBvcHRpb25zLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICAgICAgYXdhaXQgbW9kZWwuZHJvcChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kZWwgb2YgdGhpcy5tb2RlbE1hbmFnZXIubW9kZWxzKSB7XG4gICAgICBjb25zdCB0YWJsZU5hbWUgPSBtb2RlbC5nZXRUYWJsZU5hbWUoKTtcbiAgICAgIGNvbnN0IGZvcmVpZ25LZXlzID0gYXdhaXQgdGhpcy5xdWVyeUludGVyZmFjZS5nZXRGb3JlaWduS2V5UmVmZXJlbmNlc0ZvclRhYmxlKHRhYmxlTmFtZSwgb3B0aW9ucyk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChmb3JlaWduS2V5cy5tYXAoKGZvcmVpZ25LZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlJbnRlcmZhY2UucmVtb3ZlQ29uc3RyYWludCh0YWJsZU5hbWUsIGZvcmVpZ25LZXkuY29uc3RyYWludE5hbWUsIG9wdGlvbnMpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIHRoaXMubW9kZWxNYW5hZ2VyLm1vZGVscykge1xuICAgICAgYXdhaXQgbW9kZWwuZHJvcChvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgYXV0aGVudGljYXRlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcmF3OiB0cnVlLFxuICAgICAgcGxhaW46IHRydWUsXG4gICAgICB0eXBlOiBRdWVyeVR5cGVzLlNFTEVDVFxuICAgIH0sIG9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMucXVlcnkodGhpcy5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmF1dGhUZXN0UXVlcnkoKSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzeW5jIGRhdGFiYXNlVmVyc2lvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kYXRhYmFzZVZlcnNpb24ob3B0aW9ucyk7XG4gIH1cbiAgcmFuZG9tKCkge1xuICAgIGlmIChbXCJwb3N0Z3Jlc1wiLCBcInNxbGl0ZVwiLCBcInNub3dmbGFrZVwiXS5pbmNsdWRlcyh0aGlzLmdldERpYWxlY3QoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZuKFwiUkFORE9NXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbihcIlJBTkRcIik7XG4gIH1cbiAgc3RhdGljIGZuKGZuLCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBVdGlscy5GbihmbiwgYXJncyk7XG4gIH1cbiAgc3RhdGljIGNvbChjb2wpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkNvbChjb2wpO1xuICB9XG4gIHN0YXRpYyBjYXN0KHZhbCwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuQ2FzdCh2YWwsIHR5cGUpO1xuICB9XG4gIHN0YXRpYyBsaXRlcmFsKHZhbCkge1xuICAgIHJldHVybiBuZXcgVXRpbHMuTGl0ZXJhbCh2YWwpO1xuICB9XG4gIHN0YXRpYyBhbmQoLi4uYXJncykge1xuICAgIHJldHVybiB7IFtPcC5hbmRdOiBhcmdzIH07XG4gIH1cbiAgc3RhdGljIG9yKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4geyBbT3Aub3JdOiBhcmdzIH07XG4gIH1cbiAgc3RhdGljIGpzb24oY29uZGl0aW9uc09yUGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFV0aWxzLkpzb24oY29uZGl0aW9uc09yUGF0aCwgdmFsdWUpO1xuICB9XG4gIHN0YXRpYyB3aGVyZShhdHRyLCBjb21wYXJhdG9yLCBsb2dpYykge1xuICAgIHJldHVybiBuZXcgVXRpbHMuV2hlcmUoYXR0ciwgY29tcGFyYXRvciwgbG9naWMpO1xuICB9XG4gIGFzeW5jIHRyYW5zYWN0aW9uKG9wdGlvbnMsIGF1dG9DYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBhdXRvQ2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24odGhpcywgb3B0aW9ucyk7XG4gICAgaWYgKCFhdXRvQ2FsbGJhY2spIHtcbiAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLnByZXBhcmVFbnZpcm9ubWVudChmYWxzZSk7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICAgIHJldHVybiBTZXF1ZWxpemUuX2Nsc1J1bihhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0cmFuc2FjdGlvbi5wcmVwYXJlRW52aXJvbm1lbnQodHJ1ZSk7XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgYXV0b0NhbGxiYWNrKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLnJvbGxiYWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgdXNlQ0xTKG5zKSB7XG4gICAgaWYgKCFucyB8fCB0eXBlb2YgbnMgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG5zLmJpbmQgIT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgbnMucnVuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgQ0xTIG5hbWVzcGFjZVwiKTtcbiAgICBTZXF1ZWxpemUuX2NscyA9IG5zO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0YXRpYyBfY2xzUnVuKGZuKSB7XG4gICAgY29uc3QgbnMgPSBTZXF1ZWxpemUuX2NscztcbiAgICBpZiAoIW5zKVxuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgbGV0IHJlcztcbiAgICBucy5ydW4oKGNvbnRleHQpID0+IHJlcyA9IGZuKGNvbnRleHQpKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGxvZyguLi5hcmdzKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgY29uc3QgbGFzdCA9IF8ubGFzdChhcmdzKTtcbiAgICBpZiAobGFzdCAmJiBfLmlzUGxhaW5PYmplY3QobGFzdCkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxhc3QsIFwibG9nZ2luZ1wiKSkge1xuICAgICAgb3B0aW9ucyA9IGxhc3Q7XG4gICAgICBpZiAob3B0aW9ucy5sb2dnaW5nID09PSBjb25zb2xlLmxvZykge1xuICAgICAgICBhcmdzLnNwbGljZShhcmdzLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sb2dnaW5nKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2dnaW5nID09PSB0cnVlKSB7XG4gICAgICAgIGRlcHJlY2F0aW9ucy5ub1RydWVMb2dnaW5nKCk7XG4gICAgICAgIG9wdGlvbnMubG9nZ2luZyA9IGNvbnNvbGUubG9nO1xuICAgICAgfVxuICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuYmVuY2htYXJrIHx8IG9wdGlvbnMuYmVuY2htYXJrKSAmJiBvcHRpb25zLmxvZ2dpbmcgPT09IGNvbnNvbGUubG9nKSB7XG4gICAgICAgIGFyZ3MgPSBbYCR7YXJnc1swXX0gRWxhcHNlZCB0aW1lOiAke2FyZ3NbMV19bXNgXTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMubG9nZ2luZyguLi5hcmdzKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY2xvc2UoKTtcbiAgfVxuICBub3JtYWxpemVEYXRhVHlwZShUeXBlKSB7XG4gICAgbGV0IHR5cGUgPSB0eXBlb2YgVHlwZSA9PT0gXCJmdW5jdGlvblwiID8gbmV3IFR5cGUoKSA6IFR5cGU7XG4gICAgY29uc3QgZGlhbGVjdFR5cGVzID0gdGhpcy5kaWFsZWN0LkRhdGFUeXBlcyB8fCB7fTtcbiAgICBpZiAoZGlhbGVjdFR5cGVzW3R5cGUua2V5XSkge1xuICAgICAgdHlwZSA9IGRpYWxlY3RUeXBlc1t0eXBlLmtleV0uZXh0ZW5kKHR5cGUpO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5BUlJBWSkge1xuICAgICAgaWYgKCF0eXBlLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQVJSQVkgaXMgbWlzc2luZyB0eXBlIGRlZmluaXRpb24gZm9yIGl0cyB2YWx1ZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGRpYWxlY3RUeXBlc1t0eXBlLnR5cGUua2V5XSkge1xuICAgICAgICB0eXBlLnR5cGUgPSBkaWFsZWN0VHlwZXNbdHlwZS50eXBlLmtleV0uZXh0ZW5kKHR5cGUudHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIG5vcm1hbGl6ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpIHtcbiAgICBpZiAoIV8uaXNQbGFpbk9iamVjdChhdHRyaWJ1dGUpKSB7XG4gICAgICBhdHRyaWJ1dGUgPSB7IHR5cGU6IGF0dHJpYnV0ZSB9O1xuICAgIH1cbiAgICBpZiAoIWF0dHJpYnV0ZS50eXBlKVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICBhdHRyaWJ1dGUudHlwZSA9IHRoaXMubm9ybWFsaXplRGF0YVR5cGUoYXR0cmlidXRlLnR5cGUpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0cmlidXRlLCBcImRlZmF1bHRWYWx1ZVwiKSkge1xuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUuZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgW0RhdGFUeXBlcy5OT1csIERhdGFUeXBlcy5VVUlEVjEsIERhdGFUeXBlcy5VVUlEVjRdLmluY2x1ZGVzKGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgIGF0dHJpYnV0ZS5kZWZhdWx0VmFsdWUgPSBuZXcgYXR0cmlidXRlLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuRU5VTSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlLnR5cGUudmFsdWVzID0gYXR0cmlidXRlLnR5cGUub3B0aW9ucy52YWx1ZXMgPSBhdHRyaWJ1dGUudmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlcyA9IGF0dHJpYnV0ZS50eXBlLnZhbHVlcztcbiAgICAgIH1cbiAgICAgIGlmICghYXR0cmlidXRlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWVzIGZvciBFTlVNIGhhdmUgbm90IGJlZW4gZGVmaW5lZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cbn1cblNlcXVlbGl6ZS5wcm90b3R5cGUuZm4gPSBTZXF1ZWxpemUuZm47XG5TZXF1ZWxpemUucHJvdG90eXBlLmNvbCA9IFNlcXVlbGl6ZS5jb2w7XG5TZXF1ZWxpemUucHJvdG90eXBlLmNhc3QgPSBTZXF1ZWxpemUuY2FzdDtcblNlcXVlbGl6ZS5wcm90b3R5cGUubGl0ZXJhbCA9IFNlcXVlbGl6ZS5saXRlcmFsO1xuU2VxdWVsaXplLnByb3RvdHlwZS5hbmQgPSBTZXF1ZWxpemUuYW5kO1xuU2VxdWVsaXplLnByb3RvdHlwZS5vciA9IFNlcXVlbGl6ZS5vcjtcblNlcXVlbGl6ZS5wcm90b3R5cGUuanNvbiA9IFNlcXVlbGl6ZS5qc29uO1xuU2VxdWVsaXplLnByb3RvdHlwZS53aGVyZSA9IFNlcXVlbGl6ZS53aGVyZTtcblNlcXVlbGl6ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBTZXF1ZWxpemUucHJvdG90eXBlLmF1dGhlbnRpY2F0ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXF1ZWxpemUsIFwidmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKS52ZXJzaW9uO1xuICB9XG59KTtcblNlcXVlbGl6ZS5vcHRpb25zID0geyBob29rczoge30gfTtcblNlcXVlbGl6ZS5VdGlscyA9IFV0aWxzO1xuU2VxdWVsaXplLk9wID0gT3A7XG5TZXF1ZWxpemUuVGFibGVIaW50cyA9IFRhYmxlSGludHM7XG5TZXF1ZWxpemUuSW5kZXhIaW50cyA9IEluZGV4SGludHM7XG5TZXF1ZWxpemUuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcblNlcXVlbGl6ZS5wcm90b3R5cGUuU2VxdWVsaXplID0gU2VxdWVsaXplO1xuU2VxdWVsaXplLnByb3RvdHlwZS5RdWVyeVR5cGVzID0gU2VxdWVsaXplLlF1ZXJ5VHlwZXMgPSBRdWVyeVR5cGVzO1xuU2VxdWVsaXplLnByb3RvdHlwZS5WYWxpZGF0b3IgPSBTZXF1ZWxpemUuVmFsaWRhdG9yID0gVmFsaWRhdG9yO1xuU2VxdWVsaXplLk1vZGVsID0gTW9kZWw7XG5TZXF1ZWxpemUuUXVlcnlJbnRlcmZhY2UgPSBRdWVyeUludGVyZmFjZTtcblNlcXVlbGl6ZS5CZWxvbmdzVG8gPSBCZWxvbmdzVG87XG5TZXF1ZWxpemUuSGFzT25lID0gSGFzT25lO1xuU2VxdWVsaXplLkhhc01hbnkgPSBIYXNNYW55O1xuU2VxdWVsaXplLkJlbG9uZ3NUb01hbnkgPSBCZWxvbmdzVG9NYW55O1xuU2VxdWVsaXplLkRhdGFUeXBlcyA9IERhdGFUeXBlcztcbmZvciAoY29uc3QgZGF0YVR5cGUgaW4gRGF0YVR5cGVzKSB7XG4gIFNlcXVlbGl6ZVtkYXRhVHlwZV0gPSBEYXRhVHlwZXNbZGF0YVR5cGVdO1xufVxuU2VxdWVsaXplLkRlZmVycmFibGUgPSBEZWZlcnJhYmxlO1xuU2VxdWVsaXplLnByb3RvdHlwZS5Bc3NvY2lhdGlvbiA9IFNlcXVlbGl6ZS5Bc3NvY2lhdGlvbiA9IEFzc29jaWF0aW9uO1xuU2VxdWVsaXplLnVzZUluZmxlY3Rpb24gPSBVdGlscy51c2VJbmZsZWN0aW9uO1xuSG9va3MuYXBwbHlUbyhTZXF1ZWxpemUpO1xuSG9va3MuYXBwbHlUbyhTZXF1ZWxpemUucHJvdG90eXBlKTtcblNlcXVlbGl6ZS5FcnJvciA9IHNlcXVlbGl6ZUVycm9ycy5CYXNlRXJyb3I7XG5mb3IgKGNvbnN0IGVycm9yIG9mIE9iamVjdC5rZXlzKHNlcXVlbGl6ZUVycm9ycykpIHtcbiAgU2VxdWVsaXplW2Vycm9yXSA9IHNlcXVlbGl6ZUVycm9yc1tlcnJvcl07XG59XG5tb2R1bGUuZXhwb3J0cyA9IFNlcXVlbGl6ZTtcbm1vZHVsZS5leHBvcnRzLlNlcXVlbGl6ZSA9IFNlcXVlbGl6ZTtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBTZXF1ZWxpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXF1ZWxpemUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/sequelize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/sql-string.js":
/*!**************************************************!*\
  !*** ./node_modules/sequelize/lib/sql-string.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst dataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst { logger } = __webpack_require__(/*! ./utils/logger */ \"(rsc)/./node_modules/sequelize/lib/utils/logger.js\");\nfunction arrayToList(array, timeZone, dialect, format2) {\n  return array.reduce((sql, val, i) => {\n    if (i !== 0) {\n      sql += \", \";\n    }\n    if (Array.isArray(val)) {\n      sql += `(${arrayToList(val, timeZone, dialect, format2)})`;\n    } else {\n      sql += escape(val, timeZone, dialect, format2);\n    }\n    return sql;\n  }, \"\");\n}\nexports.arrayToList = arrayToList;\nfunction escape(val, timeZone, dialect, format2) {\n  let prependN = false;\n  if (val === void 0 || val === null) {\n    return \"NULL\";\n  }\n  switch (typeof val) {\n    case \"boolean\":\n      if ([\"sqlite\", \"mssql\", \"oracle\"].includes(dialect)) {\n        return +!!val;\n      }\n      return (!!val).toString();\n    case \"number\":\n    case \"bigint\":\n      return val.toString();\n    case \"string\":\n      prependN = dialect === \"mssql\";\n      break;\n  }\n  if (val instanceof Date) {\n    val = dataTypes[dialect].DATE.prototype.stringify(val, { timezone: timeZone });\n  }\n  if (Buffer.isBuffer(val)) {\n    if (dataTypes[dialect].BLOB) {\n      return dataTypes[dialect].BLOB.prototype.stringify(val);\n    }\n    return dataTypes.BLOB.prototype.stringify(val);\n  }\n  if (Array.isArray(val)) {\n    const partialEscape = (escVal) => escape(escVal, timeZone, dialect, format2);\n    if (dialect === \"postgres\" && !format2) {\n      return dataTypes.ARRAY.prototype.stringify(val, { escape: partialEscape });\n    }\n    return arrayToList(val, timeZone, dialect, format2);\n  }\n  if (!val.replace) {\n    throw new Error(`Invalid value ${logger.inspect(val)}`);\n  }\n  if ([\"postgres\", \"sqlite\", \"mssql\", \"snowflake\", \"db2\"].includes(dialect)) {\n    val = val.replace(/'/g, \"''\");\n    if (dialect === \"postgres\") {\n      val = val.replace(/\\0/g, \"\\\\0\");\n    }\n  } else if (dialect === \"oracle\" && typeof val === \"string\") {\n    if (val.startsWith(\"TO_TIMESTAMP_TZ\") || val.startsWith(\"TO_DATE\")) {\n      const splitVal = val.split(/\\(|\\)/);\n      if (splitVal.length !== 3 || splitVal[2] !== \"\") {\n        throw new Error(\"Invalid SQL function call.\");\n      }\n      const functionName = splitVal[0].trim();\n      const insideParens = splitVal[1].trim();\n      if (functionName !== \"TO_TIMESTAMP_TZ\" && functionName !== \"TO_DATE\") {\n        throw new Error(\"Invalid SQL function call. Expected TO_TIMESTAMP_TZ or TO_DATE.\");\n      }\n      const params = insideParens.split(\",\");\n      if (params.length !== 2) {\n        throw new Error(\"Unexpected input received.\\nSequelize supports TO_TIMESTAMP_TZ or TO_DATE exclusively with a combination of value and format.\");\n      }\n      const dateValue = params[0].trim().replace(/'/g, \"\");\n      const formatValue = params[1].trim();\n      if (functionName === \"TO_TIMESTAMP_TZ\") {\n        const expectedFormat = \"'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM'\";\n        if (formatValue !== expectedFormat) {\n          throw new Error(`Invalid format string for TO_TIMESTAMP_TZ. Expected format: ${expectedFormat}`);\n        }\n        const formattedDate = moment(dateValue).format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n        if (formattedDate !== dateValue) {\n          throw new Error(\"Invalid date value for TO_TIMESTAMP_TZ. Expected format: 'YYYY-MM-DD HH:mm:ss.SSS Z'\");\n        }\n      } else if (functionName === \"TO_DATE\") {\n        const expectedFormat = \"'YYYY/MM/DD'\";\n        if (formatValue !== expectedFormat) {\n          throw new Error(`Invalid format string for TO_DATE. Expected format: ${expectedFormat}`);\n        }\n        const formattedDate = moment(dateValue).format(\"YYYY-MM-DD\");\n        if (formattedDate !== dateValue) {\n          throw new Error(\"Invalid date value for TO_DATE. Expected format: 'YYYY-MM-DD'\");\n        }\n      }\n      return val;\n    }\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\'\"\\x1a]/g, (s) => {\n      switch (s) {\n        case \"\\0\":\n          return \"\\\\0\";\n        case \"\\n\":\n          return \"\\\\n\";\n        case \"\\r\":\n          return \"\\\\r\";\n        case \"\\b\":\n          return \"\\\\b\";\n        case \"\t\":\n          return \"\\\\t\";\n        case \"\u001a\":\n          return \"\\\\Z\";\n        default:\n          return `\\\\${s}`;\n      }\n    });\n  }\n  return `${(prependN ? \"N'\" : \"'\") + val}'`;\n}\nexports.escape = escape;\nfunction format(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n  if (typeof sql !== \"string\") {\n    throw new Error(`Invalid SQL string provided: ${sql}`);\n  }\n  return sql.replace(/\\?/g, (match) => {\n    if (!values.length) {\n      return match;\n    }\n    return escape(values.shift(), timeZone, dialect, true);\n  });\n}\nexports.format = format;\nfunction formatNamedParameters(sql, values, timeZone, dialect) {\n  return sql.replace(/:+(?!\\d)(\\w+)/g, (value, key) => {\n    if (dialect === \"postgres\" && value.slice(0, 2) === \"::\") {\n      return value;\n    }\n    if (values[key] !== void 0) {\n      return escape(values[key], timeZone, dialect, true);\n    }\n    throw new Error(`Named parameter \"${value}\" has no value in the given object.`);\n  });\n}\nexports.formatNamedParameters = formatNamedParameters;\n//# sourceMappingURL=sql-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9zcWwtc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3hDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEVBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkM7QUFDOUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZUFBZTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsSUFBSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDLEdBQUc7QUFDSDtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvc3FsLXN0cmluZy5qcz9hNmZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZShcIm1vbWVudFwiKTtcbmNvbnN0IGRhdGFUeXBlcyA9IHJlcXVpcmUoXCIuL2RhdGEtdHlwZXNcIik7XG5jb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZShcIi4vdXRpbHMvbG9nZ2VyXCIpO1xuZnVuY3Rpb24gYXJyYXlUb0xpc3QoYXJyYXksIHRpbWVab25lLCBkaWFsZWN0LCBmb3JtYXQyKSB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKHNxbCwgdmFsLCBpKSA9PiB7XG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIHNxbCArPSBcIiwgXCI7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHNxbCArPSBgKCR7YXJyYXlUb0xpc3QodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0Mil9KWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNxbCArPSBlc2NhcGUodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0Mik7XG4gICAgfVxuICAgIHJldHVybiBzcWw7XG4gIH0sIFwiXCIpO1xufVxuZXhwb3J0cy5hcnJheVRvTGlzdCA9IGFycmF5VG9MaXN0O1xuZnVuY3Rpb24gZXNjYXBlKHZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdDIpIHtcbiAgbGV0IHByZXBlbmROID0gZmFsc2U7XG4gIGlmICh2YWwgPT09IHZvaWQgMCB8fCB2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJOVUxMXCI7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGlmIChbXCJzcWxpdGVcIiwgXCJtc3NxbFwiLCBcIm9yYWNsZVwiXS5pbmNsdWRlcyhkaWFsZWN0KSkge1xuICAgICAgICByZXR1cm4gKyEhdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuICghIXZhbCkudG9TdHJpbmcoKTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHByZXBlbmROID0gZGlhbGVjdCA9PT0gXCJtc3NxbFwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICB2YWwgPSBkYXRhVHlwZXNbZGlhbGVjdF0uREFURS5wcm90b3R5cGUuc3RyaW5naWZ5KHZhbCwgeyB0aW1lem9uZTogdGltZVpvbmUgfSk7XG4gIH1cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgaWYgKGRhdGFUeXBlc1tkaWFsZWN0XS5CTE9CKSB7XG4gICAgICByZXR1cm4gZGF0YVR5cGVzW2RpYWxlY3RdLkJMT0IucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVR5cGVzLkJMT0IucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBjb25zdCBwYXJ0aWFsRXNjYXBlID0gKGVzY1ZhbCkgPT4gZXNjYXBlKGVzY1ZhbCwgdGltZVpvbmUsIGRpYWxlY3QsIGZvcm1hdDIpO1xuICAgIGlmIChkaWFsZWN0ID09PSBcInBvc3RncmVzXCIgJiYgIWZvcm1hdDIpIHtcbiAgICAgIHJldHVybiBkYXRhVHlwZXMuQVJSQVkucHJvdG90eXBlLnN0cmluZ2lmeSh2YWwsIHsgZXNjYXBlOiBwYXJ0aWFsRXNjYXBlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlUb0xpc3QodmFsLCB0aW1lWm9uZSwgZGlhbGVjdCwgZm9ybWF0Mik7XG4gIH1cbiAgaWYgKCF2YWwucmVwbGFjZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSAke2xvZ2dlci5pbnNwZWN0KHZhbCl9YCk7XG4gIH1cbiAgaWYgKFtcInBvc3RncmVzXCIsIFwic3FsaXRlXCIsIFwibXNzcWxcIiwgXCJzbm93Zmxha2VcIiwgXCJkYjJcIl0uaW5jbHVkZXMoZGlhbGVjdCkpIHtcbiAgICB2YWwgPSB2YWwucmVwbGFjZSgvJy9nLCBcIicnXCIpO1xuICAgIGlmIChkaWFsZWN0ID09PSBcInBvc3RncmVzXCIpIHtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXDAvZywgXCJcXFxcMFwiKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlhbGVjdCA9PT0gXCJvcmFjbGVcIiAmJiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHZhbC5zdGFydHNXaXRoKFwiVE9fVElNRVNUQU1QX1RaXCIpIHx8IHZhbC5zdGFydHNXaXRoKFwiVE9fREFURVwiKSkge1xuICAgICAgY29uc3Qgc3BsaXRWYWwgPSB2YWwuc3BsaXQoL1xcKHxcXCkvKTtcbiAgICAgIGlmIChzcGxpdFZhbC5sZW5ndGggIT09IDMgfHwgc3BsaXRWYWxbMl0gIT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTUUwgZnVuY3Rpb24gY2FsbC5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBzcGxpdFZhbFswXS50cmltKCk7XG4gICAgICBjb25zdCBpbnNpZGVQYXJlbnMgPSBzcGxpdFZhbFsxXS50cmltKCk7XG4gICAgICBpZiAoZnVuY3Rpb25OYW1lICE9PSBcIlRPX1RJTUVTVEFNUF9UWlwiICYmIGZ1bmN0aW9uTmFtZSAhPT0gXCJUT19EQVRFXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTUUwgZnVuY3Rpb24gY2FsbC4gRXhwZWN0ZWQgVE9fVElNRVNUQU1QX1RaIG9yIFRPX0RBVEUuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gaW5zaWRlUGFyZW5zLnNwbGl0KFwiLFwiKTtcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaW5wdXQgcmVjZWl2ZWQuXFxuU2VxdWVsaXplIHN1cHBvcnRzIFRPX1RJTUVTVEFNUF9UWiBvciBUT19EQVRFIGV4Y2x1c2l2ZWx5IHdpdGggYSBjb21iaW5hdGlvbiBvZiB2YWx1ZSBhbmQgZm9ybWF0LlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IHBhcmFtc1swXS50cmltKCkucmVwbGFjZSgvJy9nLCBcIlwiKTtcbiAgICAgIGNvbnN0IGZvcm1hdFZhbHVlID0gcGFyYW1zWzFdLnRyaW0oKTtcbiAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT09IFwiVE9fVElNRVNUQU1QX1RaXCIpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRGb3JtYXQgPSBcIidZWVlZLU1NLUREIEhIMjQ6TUk6U1MuRkZUWkg6VFpNJ1wiO1xuICAgICAgICBpZiAoZm9ybWF0VmFsdWUgIT09IGV4cGVjdGVkRm9ybWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcm1hdCBzdHJpbmcgZm9yIFRPX1RJTUVTVEFNUF9UWi4gRXhwZWN0ZWQgZm9ybWF0OiAke2V4cGVjdGVkRm9ybWF0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBtb21lbnQoZGF0ZVZhbHVlKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBaXCIpO1xuICAgICAgICBpZiAoZm9ybWF0dGVkRGF0ZSAhPT0gZGF0ZVZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlIHZhbHVlIGZvciBUT19USU1FU1RBTVBfVFouIEV4cGVjdGVkIGZvcm1hdDogJ1lZWVktTU0tREQgSEg6bW06c3MuU1NTIFonXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSA9PT0gXCJUT19EQVRFXCIpIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRGb3JtYXQgPSBcIidZWVlZL01NL0REJ1wiO1xuICAgICAgICBpZiAoZm9ybWF0VmFsdWUgIT09IGV4cGVjdGVkRm9ybWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcm1hdCBzdHJpbmcgZm9yIFRPX0RBVEUuIEV4cGVjdGVkIGZvcm1hdDogJHtleHBlY3RlZEZvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWREYXRlID0gbW9tZW50KGRhdGVWYWx1ZSkuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcbiAgICAgICAgaWYgKGZvcm1hdHRlZERhdGUgIT09IGRhdGVWYWx1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSB2YWx1ZSBmb3IgVE9fREFURS4gRXhwZWN0ZWQgZm9ybWF0OiAnWVlZWS1NTS1ERCdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHZhbCA9IHZhbC5yZXBsYWNlKC8nL2csIFwiJydcIik7XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoL1tcXDBcXG5cXHJcXGJcXHRcXFxcJ1wiXFx4MWFdL2csIChzKSA9PiB7XG4gICAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSBcIlxcMFwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFwwXCI7XG4gICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgY2FzZSBcIlxcYlwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgIGNhc2UgXCJcdFwiOlxuICAgICAgICAgIHJldHVybiBcIlxcXFx0XCI7XG4gICAgICAgIGNhc2UgXCJcdTAwMWFcIjpcbiAgICAgICAgICByZXR1cm4gXCJcXFxcWlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBgXFxcXCR7c31gO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBgJHsocHJlcGVuZE4gPyBcIk4nXCIgOiBcIidcIikgKyB2YWx9J2A7XG59XG5leHBvcnRzLmVzY2FwZSA9IGVzY2FwZTtcbmZ1bmN0aW9uIGZvcm1hdChzcWwsIHZhbHVlcywgdGltZVpvbmUsIGRpYWxlY3QpIHtcbiAgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlcyk7XG4gIGlmICh0eXBlb2Ygc3FsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFNRTCBzdHJpbmcgcHJvdmlkZWQ6ICR7c3FsfWApO1xuICB9XG4gIHJldHVybiBzcWwucmVwbGFjZSgvXFw/L2csIChtYXRjaCkgPT4ge1xuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICByZXR1cm4gZXNjYXBlKHZhbHVlcy5zaGlmdCgpLCB0aW1lWm9uZSwgZGlhbGVjdCwgdHJ1ZSk7XG4gIH0pO1xufVxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5mdW5jdGlvbiBmb3JtYXROYW1lZFBhcmFtZXRlcnMoc3FsLCB2YWx1ZXMsIHRpbWVab25lLCBkaWFsZWN0KSB7XG4gIHJldHVybiBzcWwucmVwbGFjZSgvOisoPyFcXGQpKFxcdyspL2csICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKGRpYWxlY3QgPT09IFwicG9zdGdyZXNcIiAmJiB2YWx1ZS5zbGljZSgwLCAyKSA9PT0gXCI6OlwiKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZXNba2V5XSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZXNjYXBlKHZhbHVlc1trZXldLCB0aW1lWm9uZSwgZGlhbGVjdCwgdHJ1ZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTmFtZWQgcGFyYW1ldGVyIFwiJHt2YWx1ZX1cIiBoYXMgbm8gdmFsdWUgaW4gdGhlIGdpdmVuIG9iamVjdC5gKTtcbiAgfSk7XG59XG5leHBvcnRzLmZvcm1hdE5hbWVkUGFyYW1ldGVycyA9IGZvcm1hdE5hbWVkUGFyYW1ldGVycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNxbC1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/sql-string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/table-hints.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/table-hints.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nconst TableHints = module.exports = {\n  NOLOCK: \"NOLOCK\",\n  READUNCOMMITTED: \"READUNCOMMITTED\",\n  UPDLOCK: \"UPDLOCK\",\n  REPEATABLEREAD: \"REPEATABLEREAD\",\n  SERIALIZABLE: \"SERIALIZABLE\",\n  READCOMMITTED: \"READCOMMITTED\",\n  TABLOCK: \"TABLOCK\",\n  TABLOCKX: \"TABLOCKX\",\n  PAGLOCK: \"PAGLOCK\",\n  ROWLOCK: \"ROWLOCK\",\n  NOWAIT: \"NOWAIT\",\n  READPAST: \"READPAST\",\n  XLOCK: \"XLOCK\",\n  SNAPSHOT: \"SNAPSHOT\",\n  NOEXPAND: \"NOEXPAND\"\n};\n//# sourceMappingURL=table-hints.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90YWJsZS1oaW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdGFibGUtaGludHMuanM/ODVlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IFRhYmxlSGludHMgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgTk9MT0NLOiBcIk5PTE9DS1wiLFxuICBSRUFEVU5DT01NSVRURUQ6IFwiUkVBRFVOQ09NTUlUVEVEXCIsXG4gIFVQRExPQ0s6IFwiVVBETE9DS1wiLFxuICBSRVBFQVRBQkxFUkVBRDogXCJSRVBFQVRBQkxFUkVBRFwiLFxuICBTRVJJQUxJWkFCTEU6IFwiU0VSSUFMSVpBQkxFXCIsXG4gIFJFQURDT01NSVRURUQ6IFwiUkVBRENPTU1JVFRFRFwiLFxuICBUQUJMT0NLOiBcIlRBQkxPQ0tcIixcbiAgVEFCTE9DS1g6IFwiVEFCTE9DS1hcIixcbiAgUEFHTE9DSzogXCJQQUdMT0NLXCIsXG4gIFJPV0xPQ0s6IFwiUk9XTE9DS1wiLFxuICBOT1dBSVQ6IFwiTk9XQUlUXCIsXG4gIFJFQURQQVNUOiBcIlJFQURQQVNUXCIsXG4gIFhMT0NLOiBcIlhMT0NLXCIsXG4gIFNOQVBTSE9UOiBcIlNOQVBTSE9UXCIsXG4gIE5PRVhQQU5EOiBcIk5PRVhQQU5EXCJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJsZS1oaW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/table-hints.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/transaction.js":
/*!***************************************************!*\
  !*** ./node_modules/sequelize/lib/transaction.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nclass Transaction {\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n    this.options = __spreadValues({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options);\n    this.parent = this.options.transaction;\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n    delete this.options.transaction;\n  }\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n    try {\n      await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Committing transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n      throw e;\n    } finally {\n      this.finished = \"commit\";\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n    if (!this.connection) {\n      throw new Error(\"Transaction cannot be rolled back because it never started\");\n    }\n    try {\n      await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);\n      this.cleanup();\n    } catch (e) {\n      console.warn(`Rolling back transaction ${this.id} failed with error ${JSON.stringify(e.message)}. We are killing its connection as it is now in an undetermined state.`);\n      await this.forceCleanup();\n      throw e;\n    }\n  }\n  async prepareEnvironment(useCLS = true) {\n    let connectionPromise;\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = \"SELECT\";\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr;\n      }\n    }\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set(\"transaction\", this);\n    }\n    return result;\n  }\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    return queryInterface.startTransaction(this, this.options);\n  }\n  cleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  async forceCleanup() {\n    if (this.parent || this.connection.uuid === void 0) {\n      return;\n    }\n    this._clearCls();\n    await this.sequelize.connectionManager.destroyConnection(this.connection);\n    this.connection.uuid = void 0;\n  }\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n    if (cls) {\n      if (cls.get(\"transaction\") === this) {\n        cls.set(\"transaction\", null);\n      }\n    }\n  }\n  afterCommit(fn) {\n    if (!fn || typeof fn !== \"function\") {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n  static get TYPES() {\n    return {\n      DEFERRED: \"DEFERRED\",\n      IMMEDIATE: \"IMMEDIATE\",\n      EXCLUSIVE: \"EXCLUSIVE\"\n    };\n  }\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: \"READ UNCOMMITTED\",\n      READ_COMMITTED: \"READ COMMITTED\",\n      REPEATABLE_READ: \"REPEATABLE READ\",\n      SERIALIZABLE: \"SERIALIZABLE\"\n    };\n  }\n  static get LOCK() {\n    return {\n      UPDATE: \"UPDATE\",\n      SHARE: \"SHARE\",\n      KEY_SHARE: \"KEY SHARE\",\n      NO_KEY_UPDATE: \"NO KEY UPDATE\"\n    };\n  }\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports[\"default\"] = Transaction;\n//# sourceMappingURL=transaction.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRLE1BQU0sOEJBQThCO0FBQ2pFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csY0FBYztBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2Q0FBNkMsU0FBUyxvQkFBb0IsMEJBQTBCO0FBQ3BHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxjQUFjO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxTQUFTLG9CQUFvQiwwQkFBMEI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQix5QkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3RyYW5zYWN0aW9uLmpzPzllNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNlcXVlbGl6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuc2VxdWVsaXplID0gc2VxdWVsaXplO1xuICAgIHRoaXMuc2F2ZXBvaW50cyA9IFtdO1xuICAgIHRoaXMuX2FmdGVyQ29tbWl0SG9va3MgPSBbXTtcbiAgICBjb25zdCBnZW5lcmF0ZVRyYW5zYWN0aW9uSWQgPSB0aGlzLnNlcXVlbGl6ZS5kaWFsZWN0LnF1ZXJ5R2VuZXJhdG9yLmdlbmVyYXRlVHJhbnNhY3Rpb25JZDtcbiAgICB0aGlzLm9wdGlvbnMgPSBfX3NwcmVhZFZhbHVlcyh7XG4gICAgICB0eXBlOiBzZXF1ZWxpemUub3B0aW9ucy50cmFuc2FjdGlvblR5cGUsXG4gICAgICBpc29sYXRpb25MZXZlbDogc2VxdWVsaXplLm9wdGlvbnMuaXNvbGF0aW9uTGV2ZWwsXG4gICAgICByZWFkT25seTogZmFsc2VcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLnBhcmVudCA9IHRoaXMub3B0aW9ucy50cmFuc2FjdGlvbjtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnBhcmVudC5pZDtcbiAgICAgIHRoaXMucGFyZW50LnNhdmVwb2ludHMucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMuaWR9LXNwLSR7dGhpcy5wYXJlbnQuc2F2ZXBvaW50cy5sZW5ndGh9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZCA9IHRoaXMubmFtZSA9IGdlbmVyYXRlVHJhbnNhY3Rpb25JZCgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5vcHRpb25zLnRyYW5zYWN0aW9uO1xuICB9XG4gIGFzeW5jIGNvbW1pdCgpIHtcbiAgICBpZiAodGhpcy5maW5pc2hlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBjYW5ub3QgYmUgY29tbWl0dGVkIGJlY2F1c2UgaXQgaGFzIGJlZW4gZmluaXNoZWQgd2l0aCBzdGF0ZTogJHt0aGlzLmZpbmlzaGVkfWApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5jb21taXRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGBDb21taXR0aW5nIHRyYW5zYWN0aW9uICR7dGhpcy5pZH0gZmFpbGVkIHdpdGggZXJyb3IgJHtKU09OLnN0cmluZ2lmeShlLm1lc3NhZ2UpfS4gV2UgYXJlIGtpbGxpbmcgaXRzIGNvbm5lY3Rpb24gYXMgaXQgaXMgbm93IGluIGFuIHVuZGV0ZXJtaW5lZCBzdGF0ZS5gKTtcbiAgICAgIGF3YWl0IHRoaXMuZm9yY2VDbGVhbnVwKCk7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmZpbmlzaGVkID0gXCJjb21taXRcIjtcbiAgICAgIGZvciAoY29uc3QgaG9vayBvZiB0aGlzLl9hZnRlckNvbW1pdEhvb2tzKSB7XG4gICAgICAgIGF3YWl0IGhvb2suYXBwbHkodGhpcywgW3RoaXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXN5bmMgcm9sbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuZmluaXNoZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gY2Fubm90IGJlIHJvbGxlZCBiYWNrIGJlY2F1c2UgaXQgaGFzIGJlZW4gZmluaXNoZWQgd2l0aCBzdGF0ZTogJHt0aGlzLmZpbmlzaGVkfWApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gY2Fubm90IGJlIHJvbGxlZCBiYWNrIGJlY2F1c2UgaXQgbmV2ZXIgc3RhcnRlZFwiKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuc2VxdWVsaXplLmdldFF1ZXJ5SW50ZXJmYWNlKCkucm9sbGJhY2tUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGBSb2xsaW5nIGJhY2sgdHJhbnNhY3Rpb24gJHt0aGlzLmlkfSBmYWlsZWQgd2l0aCBlcnJvciAke0pTT04uc3RyaW5naWZ5KGUubWVzc2FnZSl9LiBXZSBhcmUga2lsbGluZyBpdHMgY29ubmVjdGlvbiBhcyBpdCBpcyBub3cgaW4gYW4gdW5kZXRlcm1pbmVkIHN0YXRlLmApO1xuICAgICAgYXdhaXQgdGhpcy5mb3JjZUNsZWFudXAoKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIHByZXBhcmVFbnZpcm9ubWVudCh1c2VDTFMgPSB0cnVlKSB7XG4gICAgbGV0IGNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29ubmVjdGlvblByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcy5wYXJlbnQuY29ubmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFjcXVpcmVPcHRpb25zID0geyB1dWlkOiB0aGlzLmlkIH07XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJlYWRPbmx5KSB7XG4gICAgICAgIGFjcXVpcmVPcHRpb25zLnR5cGUgPSBcIlNFTEVDVFwiO1xuICAgICAgfVxuICAgICAgY29ubmVjdGlvblByb21pc2UgPSB0aGlzLnNlcXVlbGl6ZS5jb25uZWN0aW9uTWFuYWdlci5nZXRDb25uZWN0aW9uKGFjcXVpcmVPcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB0aGlzLmNvbm5lY3Rpb24udXVpZCA9IHRoaXMuaWQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYmVnaW4oKTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuc2V0RGVmZXJyYWJsZSgpO1xuICAgIH0gY2F0Y2ggKHNldHVwRXJyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnJvbGxiYWNrKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aHJvdyBzZXR1cEVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVzZUNMUyAmJiB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzKSB7XG4gICAgICB0aGlzLnNlcXVlbGl6ZS5jb25zdHJ1Y3Rvci5fY2xzLnNldChcInRyYW5zYWN0aW9uXCIsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIHNldERlZmVycmFibGUoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWZlcnJhYmxlKSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKS5kZWZlckNvbnN0cmFpbnRzKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGJlZ2luKCkge1xuICAgIGNvbnN0IHF1ZXJ5SW50ZXJmYWNlID0gdGhpcy5zZXF1ZWxpemUuZ2V0UXVlcnlJbnRlcmZhY2UoKTtcbiAgICBpZiAodGhpcy5zZXF1ZWxpemUuZGlhbGVjdC5zdXBwb3J0cy5zZXR0aW5nSXNvbGF0aW9uTGV2ZWxEdXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgYXdhaXQgcXVlcnlJbnRlcmZhY2Uuc3RhcnRUcmFuc2FjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHF1ZXJ5SW50ZXJmYWNlLnNldElzb2xhdGlvbkxldmVsKHRoaXMsIHRoaXMub3B0aW9ucy5pc29sYXRpb25MZXZlbCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgYXdhaXQgcXVlcnlJbnRlcmZhY2Uuc2V0SXNvbGF0aW9uTGV2ZWwodGhpcywgdGhpcy5vcHRpb25zLmlzb2xhdGlvbkxldmVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIHJldHVybiBxdWVyeUludGVyZmFjZS5zdGFydFRyYW5zYWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQgfHwgdGhpcy5jb25uZWN0aW9uLnV1aWQgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jbGVhckNscygpO1xuICAgIHRoaXMuc2VxdWVsaXplLmNvbm5lY3Rpb25NYW5hZ2VyLnJlbGVhc2VDb25uZWN0aW9uKHRoaXMuY29ubmVjdGlvbik7XG4gICAgdGhpcy5jb25uZWN0aW9uLnV1aWQgPSB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgZm9yY2VDbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCB8fCB0aGlzLmNvbm5lY3Rpb24udXVpZCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NsZWFyQ2xzKCk7XG4gICAgYXdhaXQgdGhpcy5zZXF1ZWxpemUuY29ubmVjdGlvbk1hbmFnZXIuZGVzdHJveUNvbm5lY3Rpb24odGhpcy5jb25uZWN0aW9uKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24udXVpZCA9IHZvaWQgMDtcbiAgfVxuICBfY2xlYXJDbHMoKSB7XG4gICAgY29uc3QgY2xzID0gdGhpcy5zZXF1ZWxpemUuY29uc3RydWN0b3IuX2NscztcbiAgICBpZiAoY2xzKSB7XG4gICAgICBpZiAoY2xzLmdldChcInRyYW5zYWN0aW9uXCIpID09PSB0aGlzKSB7XG4gICAgICAgIGNscy5zZXQoXCJ0cmFuc2FjdGlvblwiLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWZ0ZXJDb21taXQoZm4pIHtcbiAgICBpZiAoIWZuIHx8IHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZm5cIiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdGhpcy5fYWZ0ZXJDb21taXRIb29rcy5wdXNoKGZuKTtcbiAgfVxuICBzdGF0aWMgZ2V0IFRZUEVTKCkge1xuICAgIHJldHVybiB7XG4gICAgICBERUZFUlJFRDogXCJERUZFUlJFRFwiLFxuICAgICAgSU1NRURJQVRFOiBcIklNTUVESUFURVwiLFxuICAgICAgRVhDTFVTSVZFOiBcIkVYQ0xVU0lWRVwiXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0IElTT0xBVElPTl9MRVZFTFMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFJFQURfVU5DT01NSVRURUQ6IFwiUkVBRCBVTkNPTU1JVFRFRFwiLFxuICAgICAgUkVBRF9DT01NSVRURUQ6IFwiUkVBRCBDT01NSVRURURcIixcbiAgICAgIFJFUEVBVEFCTEVfUkVBRDogXCJSRVBFQVRBQkxFIFJFQURcIixcbiAgICAgIFNFUklBTElaQUJMRTogXCJTRVJJQUxJWkFCTEVcIlxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldCBMT0NLKCkge1xuICAgIHJldHVybiB7XG4gICAgICBVUERBVEU6IFwiVVBEQVRFXCIsXG4gICAgICBTSEFSRTogXCJTSEFSRVwiLFxuICAgICAgS0VZX1NIQVJFOiBcIktFWSBTSEFSRVwiLFxuICAgICAgTk9fS0VZX1VQREFURTogXCJOTyBLRVkgVVBEQVRFXCJcbiAgICB9O1xuICB9XG4gIGdldCBMT0NLKCkge1xuICAgIHJldHVybiBUcmFuc2FjdGlvbi5MT0NLO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zYWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuVHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc2FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/transaction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DataTypes = __webpack_require__(/*! ./data-types */ \"(rsc)/./node_modules/sequelize/lib/data-types.js\");\nconst SqlString = __webpack_require__(/*! ./sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\");\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst baseIsNative = __webpack_require__(/*! lodash/_baseIsNative */ \"(rsc)/./node_modules/lodash/_baseIsNative.js\");\nconst uuidv1 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v1);\nconst uuidv4 = (__webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\").v4);\nconst operators = __webpack_require__(/*! ./operators */ \"(rsc)/./node_modules/sequelize/lib/operators.js\");\nconst operatorsSet = new Set(Object.values(operators));\nlet inflection = __webpack_require__(/*! inflection */ \"(rsc)/./node_modules/inflection/lib/inflection.js\");\nexports.classToInvokable = __webpack_require__(/*! ./utils/class-to-invokable */ \"(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js\").classToInvokable;\nexports.joinSQLFragments = __webpack_require__(/*! ./utils/join-sql-fragments */ \"(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js\").joinSQLFragments;\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\nfunction camelizeIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = camelize(str);\n  }\n  return result;\n}\nexports.camelizeIf = camelizeIf;\nfunction underscoredIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = underscore(str);\n  }\n  return result;\n}\nexports.underscoredIf = underscoredIf;\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return [\"string\", \"number\", \"boolean\"].includes(type);\n}\nexports.isPrimitive = isPrimitive;\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    if (!_.isPlainObject(objectValue) && objectValue !== void 0) {\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\nfunction merge() {\n  const result = {};\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== void 0) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n  return result;\n}\nexports.merge = merge;\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\nfunction format(arr, dialect) {\n  const timeZone = null;\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, (elem) => {\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return void 0;\n    }\n    if (onlyPlain || typeof elem === \"object\") {\n      return elem;\n    }\n    if (elem && typeof elem.clone === \"function\") {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter((v) => !Model._virtualAttributes.has(v));\n  }\n  mapOptionFieldNames(options, Model);\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map((attr) => {\n      if (typeof attr !== \"string\")\n        return attr;\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach((attribute) => {\n      const rawAttribute = Model.rawAttributes[attribute];\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n    });\n  }\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n  for (const attr of fields) {\n    if (dataValues[attr] !== void 0 && !Model._virtualAttributes.has(attr)) {\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\nfunction isColString(value) {\n  return typeof value === \"string\" && value[0] === \"$\" && value[value.length - 1] === \"$\";\n}\nexports.isColString = isColString;\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some((arg) => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === \"function\") {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return __spreadValues({}, value);\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\nfunction defaultValueSchemable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n  return typeof value !== \"function\";\n}\nexports.defaultValueSchemable = defaultValueSchemable;\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n  if (omitNull) {\n    const _hash = {};\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith(\"Id\") || val !== null && val !== void 0) {\n        _hash[key] = val;\n      }\n    });\n    result = _hash;\n  }\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\nconst dialects = /* @__PURE__ */ new Set([\"mariadb\", \"mysql\", \"postgres\", \"sqlite\", \"mssql\", \"db2\", \"oracle\"]);\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\nconst TICK_CHAR = \"`\";\nexports.TICK_CHAR = TICK_CHAR;\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, \"g\"), \"\");\n}\nexports.removeTicks = removeTicks;\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value))\n    return value;\n  const flattenedObj = {};\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach((key) => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === \"object\" && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n  return flattenObject(value, void 0);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\nclass SequelizeMethod {\n}\nexports.SequelizeMethod = SequelizeMethod;\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || \"\").trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === void 0) {\n      logic = comparator;\n      comparator = \"=\";\n    }\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter((s) => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach((key) => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\nfunction defaults(object, ...sources) {\n  object = Object(object);\n  sources.forEach((source) => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach((key) => {\n        const value = object[key];\n        if (value === void 0 || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\nexports.defaults = defaults;\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName)\n    tableName = tableName.tableName;\n  if (!Object.prototype.hasOwnProperty.call(index, \"name\")) {\n    const fields = index.fields.map((field) => typeof field === \"string\" ? field : field.name || field.attribute);\n    index.name = underscore(`${tableName}_${fields.join(\"_\")}`);\n  }\n  return index;\n}\nexports.nameIndex = nameIndex;\nfunction intersects(arr1, arr2) {\n  return arr1.some((v) => arr2.includes(v));\n}\nexports.intersects = intersects;\nfunction safeStringifyJson(value) {\n  return JSON.stringify(value, (key, value2) => {\n    if (typeof value2 === \"bigint\") {\n      return String(value2);\n    }\n    return value2;\n  });\n}\nexports.safeStringifyJson = safeStringifyJson;\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN4QyxVQUFVLG1CQUFPLENBQUMscURBQVE7QUFDMUIscUJBQXFCLG1CQUFPLENBQUMsMEVBQXNCO0FBQ25ELGVBQWUsd0ZBQWtCO0FBQ2pDLGVBQWUsd0ZBQWtCO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3ZDO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMscUVBQVk7QUFDckMsbUtBQWlGO0FBQ2pGLG1LQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVEsR0FBRyxJQUFJO0FBQ3pEO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUIsVUFBVSxHQUFHLFdBQVc7QUFDekM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVSxHQUFHLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMuanM/Njc1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoXCIuL2RhdGEtdHlwZXNcIik7XG5jb25zdCBTcWxTdHJpbmcgPSByZXF1aXJlKFwiLi9zcWwtc3RyaW5nXCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKFwibG9kYXNoL19iYXNlSXNOYXRpdmVcIik7XG5jb25zdCB1dWlkdjEgPSByZXF1aXJlKFwidXVpZFwiKS52MTtcbmNvbnN0IHV1aWR2NCA9IHJlcXVpcmUoXCJ1dWlkXCIpLnY0O1xuY29uc3Qgb3BlcmF0b3JzID0gcmVxdWlyZShcIi4vb3BlcmF0b3JzXCIpO1xuY29uc3Qgb3BlcmF0b3JzU2V0ID0gbmV3IFNldChPYmplY3QudmFsdWVzKG9wZXJhdG9ycykpO1xubGV0IGluZmxlY3Rpb24gPSByZXF1aXJlKFwiaW5mbGVjdGlvblwiKTtcbmV4cG9ydHMuY2xhc3NUb0ludm9rYWJsZSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NsYXNzLXRvLWludm9rYWJsZVwiKS5jbGFzc1RvSW52b2thYmxlO1xuZXhwb3J0cy5qb2luU1FMRnJhZ21lbnRzID0gcmVxdWlyZShcIi4vdXRpbHMvam9pbi1zcWwtZnJhZ21lbnRzXCIpLmpvaW5TUUxGcmFnbWVudHM7XG5mdW5jdGlvbiB1c2VJbmZsZWN0aW9uKF9pbmZsZWN0aW9uKSB7XG4gIGluZmxlY3Rpb24gPSBfaW5mbGVjdGlvbjtcbn1cbmV4cG9ydHMudXNlSW5mbGVjdGlvbiA9IHVzZUluZmxlY3Rpb247XG5mdW5jdGlvbiBjYW1lbGl6ZUlmKHN0ciwgY29uZGl0aW9uKSB7XG4gIGxldCByZXN1bHQgPSBzdHI7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICByZXN1bHQgPSBjYW1lbGl6ZShzdHIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNhbWVsaXplSWYgPSBjYW1lbGl6ZUlmO1xuZnVuY3Rpb24gdW5kZXJzY29yZWRJZihzdHIsIGNvbmRpdGlvbikge1xuICBsZXQgcmVzdWx0ID0gc3RyO1xuICBpZiAoY29uZGl0aW9uKSB7XG4gICAgcmVzdWx0ID0gdW5kZXJzY29yZShzdHIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVuZGVyc2NvcmVkSWYgPSB1bmRlcnNjb3JlZElmO1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYm9vbGVhblwiXS5pbmNsdWRlcyh0eXBlKTtcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMoYSwgYikge1xuICByZXR1cm4gXy5tZXJnZVdpdGgoYSwgYiwgKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSkgPT4ge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9iamVjdFZhbHVlKSAmJiBvYmplY3RWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9iamVjdFZhbHVlKSAmJiBiYXNlSXNOYXRpdmUob2JqZWN0VmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VWYWx1ZSB8fCBvYmplY3RWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3RWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5tZXJnZURlZmF1bHRzID0gbWVyZ2VEZWZhdWx0cztcbmZ1bmN0aW9uIG1lcmdlKCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgZm9yIChjb25zdCBvYmogb2YgYXJndW1lbnRzKSB7XG4gICAgXy5mb3JPd24ob2JqLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCFyZXN1bHRba2V5XSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBfLmlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS5jb25jYXQocmVzdWx0W2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZnVuY3Rpb24gc3BsaWNlU3RyKHN0ciwgaW5kZXgsIGNvdW50LCBhZGQpIHtcbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBpbmRleCkgKyBhZGQgKyBzdHIuc2xpY2UoaW5kZXggKyBjb3VudCk7XG59XG5leHBvcnRzLnNwbGljZVN0ciA9IHNwbGljZVN0cjtcbmZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKS5yZXBsYWNlKC9bLV9cXHNdKyguKT8vZywgKG1hdGNoLCBjKSA9PiBjLnRvVXBwZXJDYXNlKCkpO1xufVxuZXhwb3J0cy5jYW1lbGl6ZSA9IGNhbWVsaXplO1xuZnVuY3Rpb24gdW5kZXJzY29yZShzdHIpIHtcbiAgcmV0dXJuIGluZmxlY3Rpb24udW5kZXJzY29yZShzdHIpO1xufVxuZXhwb3J0cy51bmRlcnNjb3JlID0gdW5kZXJzY29yZTtcbmZ1bmN0aW9uIHNpbmd1bGFyaXplKHN0cikge1xuICByZXR1cm4gaW5mbGVjdGlvbi5zaW5ndWxhcml6ZShzdHIpO1xufVxuZXhwb3J0cy5zaW5ndWxhcml6ZSA9IHNpbmd1bGFyaXplO1xuZnVuY3Rpb24gcGx1cmFsaXplKHN0cikge1xuICByZXR1cm4gaW5mbGVjdGlvbi5wbHVyYWxpemUoc3RyKTtcbn1cbmV4cG9ydHMucGx1cmFsaXplID0gcGx1cmFsaXplO1xuZnVuY3Rpb24gZm9ybWF0KGFyciwgZGlhbGVjdCkge1xuICBjb25zdCB0aW1lWm9uZSA9IG51bGw7XG4gIHJldHVybiBTcWxTdHJpbmcuZm9ybWF0KGFyclswXSwgYXJyLnNsaWNlKDEpLCB0aW1lWm9uZSwgZGlhbGVjdCk7XG59XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmZ1bmN0aW9uIGZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIHBhcmFtZXRlcnMsIGRpYWxlY3QpIHtcbiAgY29uc3QgdGltZVpvbmUgPSBudWxsO1xuICByZXR1cm4gU3FsU3RyaW5nLmZvcm1hdE5hbWVkUGFyYW1ldGVycyhzcWwsIHBhcmFtZXRlcnMsIHRpbWVab25lLCBkaWFsZWN0KTtcbn1cbmV4cG9ydHMuZm9ybWF0TmFtZWRQYXJhbWV0ZXJzID0gZm9ybWF0TmFtZWRQYXJhbWV0ZXJzO1xuZnVuY3Rpb24gY2xvbmVEZWVwKG9iaiwgb25seVBsYWluKSB7XG4gIG9iaiA9IG9iaiB8fCB7fTtcbiAgcmV0dXJuIF8uY2xvbmVEZWVwV2l0aChvYmosIChlbGVtKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbSkgfHwgXy5pc1BsYWluT2JqZWN0KGVsZW0pKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAob25seVBsYWluIHx8IHR5cGVvZiBlbGVtID09PSBcIm9iamVjdFwiKSB7XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9XG4gICAgaWYgKGVsZW0gJiYgdHlwZW9mIGVsZW0uY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGVsZW0uY2xvbmUoKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0cy5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG5mdW5jdGlvbiBtYXBGaW5kZXJPcHRpb25zKG9wdGlvbnMsIE1vZGVsKSB7XG4gIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmF0dHJpYnV0ZXMpKSB7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gTW9kZWwuX2luamVjdERlcGVuZGVudFZpcnR1YWxBdHRyaWJ1dGVzKG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzLmZpbHRlcigodikgPT4gIU1vZGVsLl92aXJ0dWFsQXR0cmlidXRlcy5oYXModikpO1xuICB9XG4gIG1hcE9wdGlvbkZpZWxkTmFtZXMob3B0aW9ucywgTW9kZWwpO1xuICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMubWFwRmluZGVyT3B0aW9ucyA9IG1hcEZpbmRlck9wdGlvbnM7XG5mdW5jdGlvbiBtYXBPcHRpb25GaWVsZE5hbWVzKG9wdGlvbnMsIE1vZGVsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0cmlidXRlcykpIHtcbiAgICBvcHRpb25zLmF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMubWFwKChhdHRyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGF0dHIgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgaWYgKE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0gJiYgYXR0ciAhPT0gTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXS5maWVsZCkge1xuICAgICAgICByZXR1cm4gW01vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQsIGF0dHJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHI7XG4gICAgfSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMud2hlcmUgJiYgXy5pc1BsYWluT2JqZWN0KG9wdGlvbnMud2hlcmUpKSB7XG4gICAgb3B0aW9ucy53aGVyZSA9IG1hcFdoZXJlRmllbGROYW1lcyhvcHRpb25zLndoZXJlLCBNb2RlbCk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLm1hcE9wdGlvbkZpZWxkTmFtZXMgPSBtYXBPcHRpb25GaWVsZE5hbWVzO1xuZnVuY3Rpb24gbWFwV2hlcmVGaWVsZE5hbWVzKGF0dHJpYnV0ZXMsIE1vZGVsKSB7XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgYXR0cmlidXRlcyA9IGNsb25lRGVlcChhdHRyaWJ1dGVzKTtcbiAgICBnZXRDb21wbGV4S2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKChhdHRyaWJ1dGUpID0+IHtcbiAgICAgIGNvbnN0IHJhd0F0dHJpYnV0ZSA9IE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmIChyYXdBdHRyaWJ1dGUgJiYgcmF3QXR0cmlidXRlLmZpZWxkICE9PSByYXdBdHRyaWJ1dGUuZmllbGROYW1lKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbcmF3QXR0cmlidXRlLmZpZWxkXSA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNbYXR0cmlidXRlXTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzUGxhaW5PYmplY3QoYXR0cmlidXRlc1thdHRyaWJ1dGVdKSAmJiAhKHJhd0F0dHJpYnV0ZSAmJiAocmF3QXR0cmlidXRlLnR5cGUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuSFNUT1JFIHx8IHJhd0F0dHJpYnV0ZS50eXBlIGluc3RhbmNlb2YgRGF0YVR5cGVzLkpTT04pKSkge1xuICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSBtYXBPcHRpb25GaWVsZE5hbWVzKHtcbiAgICAgICAgICB3aGVyZTogYXR0cmlidXRlc1thdHRyaWJ1dGVdXG4gICAgICAgIH0sIE1vZGVsKS53aGVyZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dHJpYnV0ZXNbYXR0cmlidXRlXSkpIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyaWJ1dGVdLmZvckVhY2goKHdoZXJlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIGlmIChfLmlzUGxhaW5PYmplY3Qod2hlcmUpKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYnV0ZV1baW5kZXhdID0gbWFwV2hlcmVGaWVsZE5hbWVzKHdoZXJlLCBNb2RlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlcztcbn1cbmV4cG9ydHMubWFwV2hlcmVGaWVsZE5hbWVzID0gbWFwV2hlcmVGaWVsZE5hbWVzO1xuZnVuY3Rpb24gbWFwVmFsdWVGaWVsZE5hbWVzKGRhdGFWYWx1ZXMsIGZpZWxkcywgTW9kZWwpIHtcbiAgY29uc3QgdmFsdWVzID0ge307XG4gIGZvciAoY29uc3QgYXR0ciBvZiBmaWVsZHMpIHtcbiAgICBpZiAoZGF0YVZhbHVlc1thdHRyXSAhPT0gdm9pZCAwICYmICFNb2RlbC5fdmlydHVhbEF0dHJpYnV0ZXMuaGFzKGF0dHIpKSB7XG4gICAgICBpZiAoTW9kZWwucmF3QXR0cmlidXRlc1thdHRyXSAmJiBNb2RlbC5yYXdBdHRyaWJ1dGVzW2F0dHJdLmZpZWxkICYmIE1vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGQgIT09IGF0dHIpIHtcbiAgICAgICAgdmFsdWVzW01vZGVsLnJhd0F0dHJpYnV0ZXNbYXR0cl0uZmllbGRdID0gZGF0YVZhbHVlc1thdHRyXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1thdHRyXSA9IGRhdGFWYWx1ZXNbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLm1hcFZhbHVlRmllbGROYW1lcyA9IG1hcFZhbHVlRmllbGROYW1lcztcbmZ1bmN0aW9uIGlzQ29sU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWVbMF0gPT09IFwiJFwiICYmIHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSBcIiRcIjtcbn1cbmV4cG9ydHMuaXNDb2xTdHJpbmcgPSBpc0NvbFN0cmluZztcbmZ1bmN0aW9uIGNhblRyZWF0QXJyYXlBc0FuZChhcnIpIHtcbiAgcmV0dXJuIGFyci5zb21lKChhcmcpID0+IF8uaXNQbGFpbk9iamVjdChhcmcpIHx8IGFyZyBpbnN0YW5jZW9mIFdoZXJlKTtcbn1cbmV4cG9ydHMuY2FuVHJlYXRBcnJheUFzQW5kID0gY2FuVHJlYXRBcnJheUFzQW5kO1xuZnVuY3Rpb24gY29tYmluZVRhYmxlTmFtZXModGFibGVOYW1lMSwgdGFibGVOYW1lMikge1xuICByZXR1cm4gdGFibGVOYW1lMS50b0xvd2VyQ2FzZSgpIDwgdGFibGVOYW1lMi50b0xvd2VyQ2FzZSgpID8gdGFibGVOYW1lMSArIHRhYmxlTmFtZTIgOiB0YWJsZU5hbWUyICsgdGFibGVOYW1lMTtcbn1cbmV4cG9ydHMuY29tYmluZVRhYmxlTmFtZXMgPSBjb21iaW5lVGFibGVOYW1lcztcbmZ1bmN0aW9uIHRvRGVmYXVsdFZhbHVlKHZhbHVlLCBkaWFsZWN0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHRtcCA9IHZhbHVlKCk7XG4gICAgaWYgKHRtcCBpbnN0YW5jZW9mIERhdGFUeXBlcy5BQlNUUkFDVCkge1xuICAgICAgcmV0dXJuIHRtcC50b1NxbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdG1wO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjEpIHtcbiAgICByZXR1cm4gdXVpZHYxKCk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0YVR5cGVzLlVVSURWNCkge1xuICAgIHJldHVybiB1dWlkdjQoKTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuTk9XKSB7XG4gICAgcmV0dXJuIG5vdyhkaWFsZWN0KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgfVxuICBpZiAoXy5pc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBfX3NwcmVhZFZhbHVlcyh7fSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydHMudG9EZWZhdWx0VmFsdWUgPSB0b0RlZmF1bHRWYWx1ZTtcbmZ1bmN0aW9uIGRlZmF1bHRWYWx1ZVNjaGVtYWJsZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuTk9XKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFUeXBlcy5VVUlEVjEgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRhVHlwZXMuVVVJRFY0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuZGVmYXVsdFZhbHVlU2NoZW1hYmxlID0gZGVmYXVsdFZhbHVlU2NoZW1hYmxlO1xuZnVuY3Rpb24gcmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoKGhhc2gsIG9taXROdWxsLCBvcHRpb25zKSB7XG4gIGxldCByZXN1bHQgPSBoYXNoO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5hbGxvd051bGwgPSBvcHRpb25zLmFsbG93TnVsbCB8fCBbXTtcbiAgaWYgKG9taXROdWxsKSB7XG4gICAgY29uc3QgX2hhc2ggPSB7fTtcbiAgICBfLmZvckluKGhhc2gsICh2YWwsIGtleSkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsb3dOdWxsLmluY2x1ZGVzKGtleSkgfHwga2V5LmVuZHNXaXRoKFwiSWRcIikgfHwgdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIF9oYXNoW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0ID0gX2hhc2g7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoID0gcmVtb3ZlTnVsbFZhbHVlc0Zyb21IYXNoO1xuY29uc3QgZGlhbGVjdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJtYXJpYWRiXCIsIFwibXlzcWxcIiwgXCJwb3N0Z3Jlc1wiLCBcInNxbGl0ZVwiLCBcIm1zc3FsXCIsIFwiZGIyXCIsIFwib3JhY2xlXCJdKTtcbmZ1bmN0aW9uIG5vdyhkaWFsZWN0KSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xuICBpZiAoIWRpYWxlY3RzLmhhcyhkaWFsZWN0KSkge1xuICAgIGQuc2V0TWlsbGlzZWNvbmRzKDApO1xuICB9XG4gIHJldHVybiBkO1xufVxuZXhwb3J0cy5ub3cgPSBub3c7XG5jb25zdCBUSUNLX0NIQVIgPSBcImBcIjtcbmV4cG9ydHMuVElDS19DSEFSID0gVElDS19DSEFSO1xuZnVuY3Rpb24gYWRkVGlja3MocywgdGlja0NoYXIpIHtcbiAgdGlja0NoYXIgPSB0aWNrQ2hhciB8fCBUSUNLX0NIQVI7XG4gIHJldHVybiB0aWNrQ2hhciArIHJlbW92ZVRpY2tzKHMsIHRpY2tDaGFyKSArIHRpY2tDaGFyO1xufVxuZXhwb3J0cy5hZGRUaWNrcyA9IGFkZFRpY2tzO1xuZnVuY3Rpb24gcmVtb3ZlVGlja3MocywgdGlja0NoYXIpIHtcbiAgdGlja0NoYXIgPSB0aWNrQ2hhciB8fCBUSUNLX0NIQVI7XG4gIHJldHVybiBzLnJlcGxhY2UobmV3IFJlZ0V4cCh0aWNrQ2hhciwgXCJnXCIpLCBcIlwiKTtcbn1cbmV4cG9ydHMucmVtb3ZlVGlja3MgPSByZW1vdmVUaWNrcztcbmZ1bmN0aW9uIGZsYXR0ZW5PYmplY3REZWVwKHZhbHVlKSB7XG4gIGlmICghXy5pc1BsYWluT2JqZWN0KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IGZsYXR0ZW5lZE9iaiA9IHt9O1xuICBmdW5jdGlvbiBmbGF0dGVuT2JqZWN0KG9iaiwgc3ViUGF0aCkge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjb25zdCBwYXRoVG9Qcm9wZXJ0eSA9IHN1YlBhdGggPyBgJHtzdWJQYXRofS4ke2tleX1gIDoga2V5O1xuICAgICAgaWYgKHR5cGVvZiBvYmpba2V5XSA9PT0gXCJvYmplY3RcIiAmJiBvYmpba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBmbGF0dGVuT2JqZWN0KG9ialtrZXldLCBwYXRoVG9Qcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0dGVuZWRPYmpbcGF0aFRvUHJvcGVydHldID0gXy5nZXQob2JqLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmbGF0dGVuZWRPYmo7XG4gIH1cbiAgcmV0dXJuIGZsYXR0ZW5PYmplY3QodmFsdWUsIHZvaWQgMCk7XG59XG5leHBvcnRzLmZsYXR0ZW5PYmplY3REZWVwID0gZmxhdHRlbk9iamVjdERlZXA7XG5jbGFzcyBTZXF1ZWxpemVNZXRob2Qge1xufVxuZXhwb3J0cy5TZXF1ZWxpemVNZXRob2QgPSBTZXF1ZWxpemVNZXRob2Q7XG5jbGFzcyBGbiBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGZuLCBhcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IEZuKHRoaXMuZm4sIHRoaXMuYXJncyk7XG4gIH1cbn1cbmV4cG9ydHMuRm4gPSBGbjtcbmNsYXNzIENvbCBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKGNvbCwgLi4uYXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29sID0gYXJncztcbiAgICB9XG4gICAgdGhpcy5jb2wgPSBjb2w7XG4gIH1cbn1cbmV4cG9ydHMuQ29sID0gQ29sO1xuY2xhc3MgQ2FzdCBleHRlbmRzIFNlcXVlbGl6ZU1ldGhvZCB7XG4gIGNvbnN0cnVjdG9yKHZhbCwgdHlwZSwganNvbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWwgPSB2YWw7XG4gICAgdGhpcy50eXBlID0gKHR5cGUgfHwgXCJcIikudHJpbSgpO1xuICAgIHRoaXMuanNvbiA9IGpzb24gfHwgZmFsc2U7XG4gIH1cbn1cbmV4cG9ydHMuQ2FzdCA9IENhc3Q7XG5jbGFzcyBMaXRlcmFsIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbiAgfVxufVxuZXhwb3J0cy5MaXRlcmFsID0gTGl0ZXJhbDtcbmNsYXNzIEpzb24gZXh0ZW5kcyBTZXF1ZWxpemVNZXRob2Qge1xuICBjb25zdHJ1Y3Rvcihjb25kaXRpb25zT3JQYXRoLCB2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKF8uaXNPYmplY3QoY29uZGl0aW9uc09yUGF0aCkpIHtcbiAgICAgIHRoaXMuY29uZGl0aW9ucyA9IGNvbmRpdGlvbnNPclBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGF0aCA9IGNvbmRpdGlvbnNPclBhdGg7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5Kc29uID0gSnNvbjtcbmNsYXNzIFdoZXJlIGV4dGVuZHMgU2VxdWVsaXplTWV0aG9kIHtcbiAgY29uc3RydWN0b3IoYXR0cmlidXRlLCBjb21wYXJhdG9yLCBsb2dpYykge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKGxvZ2ljID09PSB2b2lkIDApIHtcbiAgICAgIGxvZ2ljID0gY29tcGFyYXRvcjtcbiAgICAgIGNvbXBhcmF0b3IgPSBcIj1cIjtcbiAgICB9XG4gICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLmxvZ2ljID0gbG9naWM7XG4gIH1cbn1cbmV4cG9ydHMuV2hlcmUgPSBXaGVyZTtcbmZ1bmN0aW9uIGdldE9wZXJhdG9ycyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKS5maWx0ZXIoKHMpID0+IG9wZXJhdG9yc1NldC5oYXMocykpO1xufVxuZXhwb3J0cy5nZXRPcGVyYXRvcnMgPSBnZXRPcGVyYXRvcnM7XG5mdW5jdGlvbiBnZXRDb21wbGV4S2V5cyhvYmopIHtcbiAgcmV0dXJuIGdldE9wZXJhdG9ycyhvYmopLmNvbmNhdChPYmplY3Qua2V5cyhvYmopKTtcbn1cbmV4cG9ydHMuZ2V0Q29tcGxleEtleXMgPSBnZXRDb21wbGV4S2V5cztcbmZ1bmN0aW9uIGdldENvbXBsZXhTaXplKG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopID8gb2JqLmxlbmd0aCA6IGdldENvbXBsZXhLZXlzKG9iaikubGVuZ3RoO1xufVxuZXhwb3J0cy5nZXRDb21wbGV4U2l6ZSA9IGdldENvbXBsZXhTaXplO1xuZnVuY3Rpb24gaXNXaGVyZUVtcHR5KG9iaikge1xuICByZXR1cm4gISFvYmogJiYgXy5pc0VtcHR5KG9iaikgJiYgZ2V0T3BlcmF0b3JzKG9iaikubGVuZ3RoID09PSAwO1xufVxuZXhwb3J0cy5pc1doZXJlRW1wdHkgPSBpc1doZXJlRW1wdHk7XG5mdW5jdGlvbiBnZW5lcmF0ZUVudW1OYW1lKHRhYmxlTmFtZSwgY29sdW1uTmFtZSkge1xuICByZXR1cm4gYGVudW1fJHt0YWJsZU5hbWV9XyR7Y29sdW1uTmFtZX1gO1xufVxuZXhwb3J0cy5nZW5lcmF0ZUVudW1OYW1lID0gZ2VuZXJhdGVFbnVtTmFtZTtcbmZ1bmN0aW9uIGNhbWVsaXplT2JqZWN0S2V5cyhvYmopIHtcbiAgY29uc3QgbmV3T2JqID0gbmV3IE9iamVjdCgpO1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goKGtleSkgPT4ge1xuICAgIG5ld09ialtjYW1lbGl6ZShrZXkpXSA9IG9ialtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG5ld09iajtcbn1cbmV4cG9ydHMuY2FtZWxpemVPYmplY3RLZXlzID0gY2FtZWxpemVPYmplY3RLZXlzO1xuZnVuY3Rpb24gZGVmYXVsdHMob2JqZWN0LCAuLi5zb3VyY2VzKSB7XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIHNvdXJjZSA9IE9iamVjdChzb3VyY2UpO1xuICAgICAgZ2V0Q29tcGxleEtleXMoc291cmNlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDAgfHwgXy5lcSh2YWx1ZSwgT2JqZWN0LnByb3RvdHlwZVtrZXldKSAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmplY3Q7XG59XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5mdW5jdGlvbiBuYW1lSW5kZXgoaW5kZXgsIHRhYmxlTmFtZSkge1xuICBpZiAodGFibGVOYW1lLnRhYmxlTmFtZSlcbiAgICB0YWJsZU5hbWUgPSB0YWJsZU5hbWUudGFibGVOYW1lO1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbmRleCwgXCJuYW1lXCIpKSB7XG4gICAgY29uc3QgZmllbGRzID0gaW5kZXguZmllbGRzLm1hcCgoZmllbGQpID0+IHR5cGVvZiBmaWVsZCA9PT0gXCJzdHJpbmdcIiA/IGZpZWxkIDogZmllbGQubmFtZSB8fCBmaWVsZC5hdHRyaWJ1dGUpO1xuICAgIGluZGV4Lm5hbWUgPSB1bmRlcnNjb3JlKGAke3RhYmxlTmFtZX1fJHtmaWVsZHMuam9pbihcIl9cIil9YCk7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufVxuZXhwb3J0cy5uYW1lSW5kZXggPSBuYW1lSW5kZXg7XG5mdW5jdGlvbiBpbnRlcnNlY3RzKGFycjEsIGFycjIpIHtcbiAgcmV0dXJuIGFycjEuc29tZSgodikgPT4gYXJyMi5pbmNsdWRlcyh2KSk7XG59XG5leHBvcnRzLmludGVyc2VjdHMgPSBpbnRlcnNlY3RzO1xuZnVuY3Rpb24gc2FmZVN0cmluZ2lmeUpzb24odmFsdWUpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCAoa2V5LCB2YWx1ZTIpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlMiA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZTIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUyO1xuICB9KTtcbn1cbmV4cG9ydHMuc2FmZVN0cmluZ2lmeUpzb24gPSBzYWZlU3RyaW5naWZ5SnNvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/class-to-invokable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n__export(exports, {\n  classToInvokable: () => classToInvokable\n});\nfunction classToInvokable(Class) {\n  return new Proxy(Class, {\n    apply(_target, _thisArg, args) {\n      return new Class(...args);\n    },\n    construct(_target, args) {\n      return new Class(...args);\n    }\n  });\n}\n//# sourceMappingURL=class-to-invokable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9jbGFzcy10by1pbnZva2FibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxtRUFBbUUsYUFBYTtBQUNoRjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMvY2xhc3MtdG8taW52b2thYmxlLmpzPzYxYzEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBjbGFzc1RvSW52b2thYmxlOiAoKSA9PiBjbGFzc1RvSW52b2thYmxlXG59KTtcbmZ1bmN0aW9uIGNsYXNzVG9JbnZva2FibGUoQ2xhc3MpIHtcbiAgcmV0dXJuIG5ldyBQcm94eShDbGFzcywge1xuICAgIGFwcGx5KF90YXJnZXQsIF90aGlzQXJnLCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IENsYXNzKC4uLmFyZ3MpO1xuICAgIH0sXG4gICAgY29uc3RydWN0KF90YXJnZXQsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgQ2xhc3MoLi4uYXJncyk7XG4gICAgfVxuICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYXNzLXRvLWludm9rYWJsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/class-to-invokable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/deprecations.js":
/*!**********************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/deprecations.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  noBoolOperatorAliases: () => noBoolOperatorAliases,\n  noDoubleNestedGroup: () => noDoubleNestedGroup,\n  noStringOperators: () => noStringOperators,\n  noTrueLogging: () => noTrueLogging,\n  unsupportedEngine: () => unsupportedEngine\n});\nvar import_util = __toModule(__webpack_require__(/*! util */ \"util\"));\nconst noop = () => {\n};\nconst noTrueLogging = (0, import_util.deprecate)(noop, \"The logging-option should be either a function or false. Default: console.log\", \"SEQUELIZE0002\");\nconst noStringOperators = (0, import_util.deprecate)(noop, \"String based operators are deprecated. Please use Symbol based operators for better security, read more at https://sequelize.org/master/manual/querying.html#operators\", \"SEQUELIZE0003\");\nconst noBoolOperatorAliases = (0, import_util.deprecate)(noop, \"A boolean value was passed to options.operatorsAliases. This is a no-op with v5 and should be removed.\", \"SEQUELIZE0004\");\nconst noDoubleNestedGroup = (0, import_util.deprecate)(noop, \"Passing a double nested nested array to `group` is unsupported and will be removed in v6.\", \"SEQUELIZE0005\");\nconst unsupportedEngine = (0, import_util.deprecate)(noop, \"This database engine version is not supported, please update your database server. More information https://github.com/sequelize/sequelize/blob/main/ENGINE.md\", \"SEQUELIZE0006\");\n//# sourceMappingURL=deprecations.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9kZXByZWNhdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QixtQkFBTyxDQUFDLGtCQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL2RlcHJlY2F0aW9ucy5qcz80M2RmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19tYXJrQXNNb2R1bGUgPSAodGFyZ2V0KSA9PiBfX2RlZlByb3AodGFyZ2V0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xuX19leHBvcnQoZXhwb3J0cywge1xuICBub0Jvb2xPcGVyYXRvckFsaWFzZXM6ICgpID0+IG5vQm9vbE9wZXJhdG9yQWxpYXNlcyxcbiAgbm9Eb3VibGVOZXN0ZWRHcm91cDogKCkgPT4gbm9Eb3VibGVOZXN0ZWRHcm91cCxcbiAgbm9TdHJpbmdPcGVyYXRvcnM6ICgpID0+IG5vU3RyaW5nT3BlcmF0b3JzLFxuICBub1RydWVMb2dnaW5nOiAoKSA9PiBub1RydWVMb2dnaW5nLFxuICB1bnN1cHBvcnRlZEVuZ2luZTogKCkgPT4gdW5zdXBwb3J0ZWRFbmdpbmVcbn0pO1xudmFyIGltcG9ydF91dGlsID0gX190b01vZHVsZShyZXF1aXJlKFwidXRpbFwiKSk7XG5jb25zdCBub29wID0gKCkgPT4ge1xufTtcbmNvbnN0IG5vVHJ1ZUxvZ2dpbmcgPSAoMCwgaW1wb3J0X3V0aWwuZGVwcmVjYXRlKShub29wLCBcIlRoZSBsb2dnaW5nLW9wdGlvbiBzaG91bGQgYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgZmFsc2UuIERlZmF1bHQ6IGNvbnNvbGUubG9nXCIsIFwiU0VRVUVMSVpFMDAwMlwiKTtcbmNvbnN0IG5vU3RyaW5nT3BlcmF0b3JzID0gKDAsIGltcG9ydF91dGlsLmRlcHJlY2F0ZSkobm9vcCwgXCJTdHJpbmcgYmFzZWQgb3BlcmF0b3JzIGFyZSBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFN5bWJvbCBiYXNlZCBvcGVyYXRvcnMgZm9yIGJldHRlciBzZWN1cml0eSwgcmVhZCBtb3JlIGF0IGh0dHBzOi8vc2VxdWVsaXplLm9yZy9tYXN0ZXIvbWFudWFsL3F1ZXJ5aW5nLmh0bWwjb3BlcmF0b3JzXCIsIFwiU0VRVUVMSVpFMDAwM1wiKTtcbmNvbnN0IG5vQm9vbE9wZXJhdG9yQWxpYXNlcyA9ICgwLCBpbXBvcnRfdXRpbC5kZXByZWNhdGUpKG5vb3AsIFwiQSBib29sZWFuIHZhbHVlIHdhcyBwYXNzZWQgdG8gb3B0aW9ucy5vcGVyYXRvcnNBbGlhc2VzLiBUaGlzIGlzIGEgbm8tb3Agd2l0aCB2NSBhbmQgc2hvdWxkIGJlIHJlbW92ZWQuXCIsIFwiU0VRVUVMSVpFMDAwNFwiKTtcbmNvbnN0IG5vRG91YmxlTmVzdGVkR3JvdXAgPSAoMCwgaW1wb3J0X3V0aWwuZGVwcmVjYXRlKShub29wLCBcIlBhc3NpbmcgYSBkb3VibGUgbmVzdGVkIG5lc3RlZCBhcnJheSB0byBgZ3JvdXBgIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjYuXCIsIFwiU0VRVUVMSVpFMDAwNVwiKTtcbmNvbnN0IHVuc3VwcG9ydGVkRW5naW5lID0gKDAsIGltcG9ydF91dGlsLmRlcHJlY2F0ZSkobm9vcCwgXCJUaGlzIGRhdGFiYXNlIGVuZ2luZSB2ZXJzaW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHBsZWFzZSB1cGRhdGUgeW91ciBkYXRhYmFzZSBzZXJ2ZXIuIE1vcmUgaW5mb3JtYXRpb24gaHR0cHM6Ly9naXRodWIuY29tL3NlcXVlbGl6ZS9zZXF1ZWxpemUvYmxvYi9tYWluL0VOR0lORS5tZFwiLCBcIlNFUVVFTElaRTAwMDZcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXByZWNhdGlvbnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/deprecations.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js":
/*!****************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/join-sql-fragments.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  JoinSQLFragmentsError: () => JoinSQLFragmentsError,\n  joinSQLFragments: () => joinSQLFragments\n});\nfunction doesNotWantLeadingSpace(str) {\n  return /^[;,)]/.test(str);\n}\nfunction doesNotWantTrailingSpace(str) {\n  return /\\($/.test(str);\n}\nfunction singleSpaceJoinHelper(parts) {\n  return parts.reduce(({ skipNextLeadingSpace, result }, part) => {\n    if (skipNextLeadingSpace || doesNotWantLeadingSpace(part)) {\n      result += part.trim();\n    } else {\n      result += ` ${part.trim()}`;\n    }\n    return {\n      skipNextLeadingSpace: doesNotWantTrailingSpace(part),\n      result\n    };\n  }, {\n    skipNextLeadingSpace: true,\n    result: \"\"\n  }).result;\n}\nfunction joinSQLFragments(array) {\n  if (array.length === 0)\n    return \"\";\n  const truthyArray = array.filter((x) => !!x);\n  const flattenedArray = truthyArray.map((fragment) => {\n    if (Array.isArray(fragment)) {\n      return joinSQLFragments(fragment);\n    }\n    return fragment;\n  });\n  for (const fragment of flattenedArray) {\n    if (fragment && typeof fragment !== \"string\") {\n      throw new JoinSQLFragmentsError(flattenedArray, fragment, `Tried to construct a SQL string with a non-string, non-falsy fragment (${fragment}).`);\n    }\n  }\n  const trimmedArray = flattenedArray.map((x) => x.trim());\n  const nonEmptyStringArray = trimmedArray.filter((x) => x !== \"\");\n  return singleSpaceJoinHelper(nonEmptyStringArray);\n}\nclass JoinSQLFragmentsError extends TypeError {\n  constructor(args, fragment, message) {\n    super(message);\n    __publicField(this, \"args\");\n    __publicField(this, \"fragment\");\n    this.args = args;\n    this.fragment = fragment;\n    this.name = \"JoinSQLFragmentsError\";\n  }\n}\n//# sourceMappingURL=join-sql-fragments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9qb2luLXNxbC1mcmFnbWVudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMElBQTBJLFNBQVM7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMvam9pbi1zcWwtZnJhZ21lbnRzLmpzP2QwMDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIEpvaW5TUUxGcmFnbWVudHNFcnJvcjogKCkgPT4gSm9pblNRTEZyYWdtZW50c0Vycm9yLFxuICBqb2luU1FMRnJhZ21lbnRzOiAoKSA9PiBqb2luU1FMRnJhZ21lbnRzXG59KTtcbmZ1bmN0aW9uIGRvZXNOb3RXYW50TGVhZGluZ1NwYWNlKHN0cikge1xuICByZXR1cm4gL15bOywpXS8udGVzdChzdHIpO1xufVxuZnVuY3Rpb24gZG9lc05vdFdhbnRUcmFpbGluZ1NwYWNlKHN0cikge1xuICByZXR1cm4gL1xcKCQvLnRlc3Qoc3RyKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVNwYWNlSm9pbkhlbHBlcihwYXJ0cykge1xuICByZXR1cm4gcGFydHMucmVkdWNlKCh7IHNraXBOZXh0TGVhZGluZ1NwYWNlLCByZXN1bHQgfSwgcGFydCkgPT4ge1xuICAgIGlmIChza2lwTmV4dExlYWRpbmdTcGFjZSB8fCBkb2VzTm90V2FudExlYWRpbmdTcGFjZShwYXJ0KSkge1xuICAgICAgcmVzdWx0ICs9IHBhcnQudHJpbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gYCAke3BhcnQudHJpbSgpfWA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBza2lwTmV4dExlYWRpbmdTcGFjZTogZG9lc05vdFdhbnRUcmFpbGluZ1NwYWNlKHBhcnQpLFxuICAgICAgcmVzdWx0XG4gICAgfTtcbiAgfSwge1xuICAgIHNraXBOZXh0TGVhZGluZ1NwYWNlOiB0cnVlLFxuICAgIHJlc3VsdDogXCJcIlxuICB9KS5yZXN1bHQ7XG59XG5mdW5jdGlvbiBqb2luU1FMRnJhZ21lbnRzKGFycmF5KSB7XG4gIGlmIChhcnJheS5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHRydXRoeUFycmF5ID0gYXJyYXkuZmlsdGVyKCh4KSA9PiAhIXgpO1xuICBjb25zdCBmbGF0dGVuZWRBcnJheSA9IHRydXRoeUFycmF5Lm1hcCgoZnJhZ21lbnQpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmcmFnbWVudCkpIHtcbiAgICAgIHJldHVybiBqb2luU1FMRnJhZ21lbnRzKGZyYWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xuICB9KTtcbiAgZm9yIChjb25zdCBmcmFnbWVudCBvZiBmbGF0dGVuZWRBcnJheSkge1xuICAgIGlmIChmcmFnbWVudCAmJiB0eXBlb2YgZnJhZ21lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBKb2luU1FMRnJhZ21lbnRzRXJyb3IoZmxhdHRlbmVkQXJyYXksIGZyYWdtZW50LCBgVHJpZWQgdG8gY29uc3RydWN0IGEgU1FMIHN0cmluZyB3aXRoIGEgbm9uLXN0cmluZywgbm9uLWZhbHN5IGZyYWdtZW50ICgke2ZyYWdtZW50fSkuYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRyaW1tZWRBcnJheSA9IGZsYXR0ZW5lZEFycmF5Lm1hcCgoeCkgPT4geC50cmltKCkpO1xuICBjb25zdCBub25FbXB0eVN0cmluZ0FycmF5ID0gdHJpbW1lZEFycmF5LmZpbHRlcigoeCkgPT4geCAhPT0gXCJcIik7XG4gIHJldHVybiBzaW5nbGVTcGFjZUpvaW5IZWxwZXIobm9uRW1wdHlTdHJpbmdBcnJheSk7XG59XG5jbGFzcyBKb2luU1FMRnJhZ21lbnRzRXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihhcmdzLCBmcmFnbWVudCwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhcmdzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJmcmFnbWVudFwiKTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICB0aGlzLm5hbWUgPSBcIkpvaW5TUUxGcmFnbWVudHNFcnJvclwiO1xuICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qb2luLXNxbC1mcmFnbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/join-sql-fragments.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/logger.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  Logger: () => Logger,\n  logger: () => logger\n});\nvar import_debug = __toModule(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nvar import_util = __toModule(__webpack_require__(/*! util */ \"util\"));\nclass Logger {\n  constructor(_a = {}) {\n    __publicField(this, \"config\");\n    var _b = _a, { context = \"sequelize\" } = _b, rest = __objRest(_b, [\"context\"]);\n    this.config = __spreadValues({\n      context\n    }, rest);\n  }\n  warn(message) {\n    console.warn(`(${this.config.context}) Warning: ${message}`);\n  }\n  inspect(value) {\n    return import_util.default.inspect(value, {\n      showHidden: false,\n      depth: 1\n    });\n  }\n  debugContext(name) {\n    return (0, import_debug.default)(`${this.config.context}:${name}`);\n  }\n}\nconst logger = new Logger();\n//# sourceMappingURL=logger.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCLG1CQUFPLENBQUMsc0RBQU87QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsa0JBQU07QUFDM0M7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0IsYUFBYSxRQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IsR0FBRyxLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVkd29vZGZvbnQvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9sb2dnZXIuanM/M2Q5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYSwgYikgPT4ge1xuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKGIsIHByb3ApKVxuICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcbiAgICBmb3IgKHZhciBwcm9wIG9mIF9fZ2V0T3duUHJvcFN5bWJvbHMoYikpIHtcbiAgICAgIGlmIChfX3Byb3BJc0VudW0uY2FsbChiLCBwcm9wKSlcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGE7XG59O1xudmFyIF9fbWFya0FzTW9kdWxlID0gKHRhcmdldCkgPT4gX19kZWZQcm9wKHRhcmdldCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBfX21hcmtBc01vZHVsZSh0YXJnZXQpO1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX3JlRXhwb3J0ID0gKHRhcmdldCwgbW9kdWxlMiwgZGVzYykgPT4ge1xuICBpZiAobW9kdWxlMiAmJiB0eXBlb2YgbW9kdWxlMiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgbW9kdWxlMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZHVsZTIpKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0YXJnZXQsIGtleSkgJiYga2V5ICE9PSBcImRlZmF1bHRcIilcbiAgICAgICAgX19kZWZQcm9wKHRhcmdldCwga2V5LCB7IGdldDogKCkgPT4gbW9kdWxlMltrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKG1vZHVsZTIsIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBfX3RvTW9kdWxlID0gKG1vZHVsZTIpID0+IHtcbiAgcmV0dXJuIF9fcmVFeHBvcnQoX19tYXJrQXNNb2R1bGUoX19kZWZQcm9wKG1vZHVsZTIgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2R1bGUyKSkgOiB7fSwgXCJkZWZhdWx0XCIsIG1vZHVsZTIgJiYgbW9kdWxlMi5fX2VzTW9kdWxlICYmIFwiZGVmYXVsdFwiIGluIG1vZHVsZTIgPyB7IGdldDogKCkgPT4gbW9kdWxlMi5kZWZhdWx0LCBlbnVtZXJhYmxlOiB0cnVlIH0gOiB7IHZhbHVlOiBtb2R1bGUyLCBlbnVtZXJhYmxlOiB0cnVlIH0pKSwgbW9kdWxlMik7XG59O1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIExvZ2dlcjogKCkgPT4gTG9nZ2VyLFxuICBsb2dnZXI6ICgpID0+IGxvZ2dlclxufSk7XG52YXIgaW1wb3J0X2RlYnVnID0gX190b01vZHVsZShyZXF1aXJlKFwiZGVidWdcIikpO1xudmFyIGltcG9ydF91dGlsID0gX190b01vZHVsZShyZXF1aXJlKFwidXRpbFwiKSk7XG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3RvcihfYSA9IHt9KSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbmZpZ1wiKTtcbiAgICB2YXIgX2IgPSBfYSwgeyBjb250ZXh0ID0gXCJzZXF1ZWxpemVcIiB9ID0gX2IsIHJlc3QgPSBfX29ialJlc3QoX2IsIFtcImNvbnRleHRcIl0pO1xuICAgIHRoaXMuY29uZmlnID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgY29udGV4dFxuICAgIH0sIHJlc3QpO1xuICB9XG4gIHdhcm4obWVzc2FnZSkge1xuICAgIGNvbnNvbGUud2FybihgKCR7dGhpcy5jb25maWcuY29udGV4dH0pIFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgfVxuICBpbnNwZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGltcG9ydF91dGlsLmRlZmF1bHQuaW5zcGVjdCh2YWx1ZSwge1xuICAgICAgc2hvd0hpZGRlbjogZmFsc2UsXG4gICAgICBkZXB0aDogMVxuICAgIH0pO1xuICB9XG4gIGRlYnVnQ29udGV4dChuYW1lKSB7XG4gICAgcmV0dXJuICgwLCBpbXBvcnRfZGVidWcuZGVmYXVsdCkoYCR7dGhpcy5jb25maWcuY29udGV4dH06JHtuYW1lfWApO1xuICB9XG59XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/sql.js":
/*!*************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/sql.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __markAsModule = (target) => __defProp(target, \"__esModule\", { value: true });\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2))\n      if (!__hasOwnProp.call(target, key) && key !== \"default\")\n        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });\n  }\n  return target;\n};\nvar __toModule = (module2) => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);\n};\n__export(exports, {\n  injectReplacements: () => injectReplacements\n});\nvar import_isPlainObject = __toModule(__webpack_require__(/*! lodash/isPlainObject */ \"(rsc)/./node_modules/lodash/isPlainObject.js\"));\nvar import_sql_string = __toModule(__webpack_require__(/*! ../sql-string */ \"(rsc)/./node_modules/sequelize/lib/sql-string.js\"));\nfunction injectReplacements(sqlString, dialect, replacements) {\n  var _a, _b, _c, _d;\n  if (replacements == null) {\n    return sqlString;\n  }\n  if (!Array.isArray(replacements) && !(0, import_isPlainObject.default)(replacements)) {\n    throw new TypeError(`\"replacements\" must be an array or a plain object, but received ${JSON.stringify(replacements)} instead.`);\n  }\n  const isNamedReplacements = (0, import_isPlainObject.default)(replacements);\n  const isPositionalReplacements = Array.isArray(replacements);\n  let lastConsumedPositionalReplacementIndex = -1;\n  let output = \"\";\n  let currentDollarStringTagName = null;\n  let isString = false;\n  let isColumn = false;\n  let previousSliceEnd = 0;\n  let isSingleLineComment = false;\n  let isCommentBlock = false;\n  let stringIsBackslashEscapable = false;\n  for (let i = 0; i < sqlString.length; i++) {\n    const char = sqlString[i];\n    if (isColumn) {\n      if (char === dialect.TICK_CHAR_RIGHT) {\n        isColumn = false;\n      }\n      continue;\n    }\n    if (isString) {\n      if (char === \"'\" && (!stringIsBackslashEscapable || !isBackslashEscaped(sqlString, i - 1))) {\n        isString = false;\n        stringIsBackslashEscapable = false;\n      }\n      continue;\n    }\n    if (currentDollarStringTagName !== null) {\n      if (char !== \"$\") {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      const tagName = ((_a = dollarStringStartMatch == null ? void 0 : dollarStringStartMatch.groups) == null ? void 0 : _a.name) || \"\";\n      if (currentDollarStringTagName === tagName) {\n        currentDollarStringTagName = null;\n      }\n      continue;\n    }\n    if (isSingleLineComment) {\n      if (char === \"\\n\") {\n        isSingleLineComment = false;\n      }\n      continue;\n    }\n    if (isCommentBlock) {\n      if (char === \"*\" && sqlString[i + 1] === \"/\") {\n        isCommentBlock = false;\n      }\n      continue;\n    }\n    if (char === dialect.TICK_CHAR_LEFT) {\n      isColumn = true;\n      continue;\n    }\n    if (char === \"'\") {\n      isString = true;\n      stringIsBackslashEscapable = dialect.canBackslashEscape() || dialect.supports.escapeStringConstants && (sqlString[i - 1] === \"E\" || sqlString[i - 1] === \"e\") && canPrecedeNewToken(sqlString[i - 2]);\n      continue;\n    }\n    if (char === \"-\" && sqlString.slice(i, i + 3) === \"-- \") {\n      isSingleLineComment = true;\n      continue;\n    }\n    if (char === \"/\" && sqlString.slice(i, i + 2) === \"/*\") {\n      isCommentBlock = true;\n      continue;\n    }\n    if (char === \"$\") {\n      const previousChar = sqlString[i - 1];\n      if (/[0-9a-z_]/i.test(previousChar)) {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const dollarStringStartMatch = remainingString.match(/^\\$(?<name>[a-z_][0-9a-z_]*)?(\\$)/i);\n      if (dollarStringStartMatch) {\n        currentDollarStringTagName = (_c = (_b = dollarStringStartMatch.groups) == null ? void 0 : _b.name) != null ? _c : \"\";\n        i += dollarStringStartMatch[0].length - 1;\n        continue;\n      }\n      continue;\n    }\n    if (isNamedReplacements && char === \":\") {\n      const previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n      const remainingString = sqlString.slice(i, sqlString.length);\n      const match = remainingString.match(/^:(?<name>[a-z_][0-9a-z_]*)(?:\\)|,|$|\\s|::|;|])/i);\n      const replacementName = (_d = match == null ? void 0 : match.groups) == null ? void 0 : _d.name;\n      if (!replacementName) {\n        continue;\n      }\n      const replacementValue = replacements[replacementName];\n      if (!Object.prototype.hasOwnProperty.call(replacements, replacementName) || replacementValue === void 0) {\n        throw new Error(`Named replacement \":${replacementName}\" has no entry in the replacement map.`);\n      }\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + replacementName.length + 1;\n      output += escapedReplacement;\n      continue;\n    }\n    if (isPositionalReplacements && char === \"?\") {\n      const previousChar = sqlString[i - 1];\n      if (!canPrecedeNewToken(previousChar) && previousChar !== \"[\") {\n        continue;\n      }\n      const nextChar = sqlString[i + 1];\n      if (nextChar === \"|\" || nextChar === \"&\") {\n        continue;\n      }\n      const replacementIndex = ++lastConsumedPositionalReplacementIndex;\n      const replacementValue = replacements[lastConsumedPositionalReplacementIndex];\n      if (replacementValue === void 0) {\n        throw new Error(`Positional replacement (?) ${replacementIndex} has no entry in the replacement map (replacements[${replacementIndex}] is undefined).`);\n      }\n      const escapedReplacement = (0, import_sql_string.escape)(replacementValue, void 0, dialect.name, true);\n      output += sqlString.slice(previousSliceEnd, i);\n      previousSliceEnd = i + 1;\n      output += escapedReplacement;\n    }\n  }\n  if (isString) {\n    throw new Error(`The following SQL query includes an unterminated string literal:\n${sqlString}`);\n  }\n  output += sqlString.slice(previousSliceEnd, sqlString.length);\n  return output;\n}\nfunction canPrecedeNewToken(char) {\n  return char === void 0 || /[\\s(>,=]/.test(char);\n}\nfunction isBackslashEscaped(string, pos) {\n  let escaped = false;\n  for (let i = pos; i >= 0; i--) {\n    const char = string[i];\n    if (char !== \"\\\\\") {\n      break;\n    }\n    escaped = !escaped;\n  }\n  return escaped;\n}\n//# sourceMappingURL=sql.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy9zcWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtHQUFrRztBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRyx1RUFBdUUsK0NBQStDLElBQUksa0NBQWtDO0FBQy9QO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsbUJBQU8sQ0FBQywwRUFBc0I7QUFDcEUsbUNBQW1DLG1CQUFPLENBQUMsdUVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLDhCQUE4QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZ0JBQWdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQixvREFBb0QsaUJBQWlCO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsVUFBVTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvdXRpbHMvc3FsLmpzPzU2YjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX21hcmtBc01vZHVsZSA9ICh0YXJnZXQpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIF9fbWFya0FzTW9kdWxlKHRhcmdldCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2R1bGUyLCBkZXNjKSA9PiB7XG4gIGlmIChtb2R1bGUyICYmIHR5cGVvZiBtb2R1bGUyID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBtb2R1bGUyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMobW9kdWxlMikpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRhcmdldCwga2V5KSAmJiBrZXkgIT09IFwiZGVmYXVsdFwiKVxuICAgICAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHsgZ2V0OiAoKSA9PiBtb2R1bGUyW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MobW9kdWxlMiwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xudmFyIF9fdG9Nb2R1bGUgPSAobW9kdWxlMikgPT4ge1xuICByZXR1cm4gX19yZUV4cG9ydChfX21hcmtBc01vZHVsZShfX2RlZlByb3AobW9kdWxlMiAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZHVsZTIpKSA6IHt9LCBcImRlZmF1bHRcIiwgbW9kdWxlMiAmJiBtb2R1bGUyLl9fZXNNb2R1bGUgJiYgXCJkZWZhdWx0XCIgaW4gbW9kdWxlMiA/IHsgZ2V0OiAoKSA9PiBtb2R1bGUyLmRlZmF1bHQsIGVudW1lcmFibGU6IHRydWUgfSA6IHsgdmFsdWU6IG1vZHVsZTIsIGVudW1lcmFibGU6IHRydWUgfSkpLCBtb2R1bGUyKTtcbn07XG5fX2V4cG9ydChleHBvcnRzLCB7XG4gIGluamVjdFJlcGxhY2VtZW50czogKCkgPT4gaW5qZWN0UmVwbGFjZW1lbnRzXG59KTtcbnZhciBpbXBvcnRfaXNQbGFpbk9iamVjdCA9IF9fdG9Nb2R1bGUocmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpKTtcbnZhciBpbXBvcnRfc3FsX3N0cmluZyA9IF9fdG9Nb2R1bGUocmVxdWlyZShcIi4uL3NxbC1zdHJpbmdcIikpO1xuZnVuY3Rpb24gaW5qZWN0UmVwbGFjZW1lbnRzKHNxbFN0cmluZywgZGlhbGVjdCwgcmVwbGFjZW1lbnRzKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgaWYgKHJlcGxhY2VtZW50cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNxbFN0cmluZztcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnRzKSAmJiAhKDAsIGltcG9ydF9pc1BsYWluT2JqZWN0LmRlZmF1bHQpKHJlcGxhY2VtZW50cykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcInJlcGxhY2VtZW50c1wiIG11c3QgYmUgYW4gYXJyYXkgb3IgYSBwbGFpbiBvYmplY3QsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KHJlcGxhY2VtZW50cyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgY29uc3QgaXNOYW1lZFJlcGxhY2VtZW50cyA9ICgwLCBpbXBvcnRfaXNQbGFpbk9iamVjdC5kZWZhdWx0KShyZXBsYWNlbWVudHMpO1xuICBjb25zdCBpc1Bvc2l0aW9uYWxSZXBsYWNlbWVudHMgPSBBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50cyk7XG4gIGxldCBsYXN0Q29uc3VtZWRQb3NpdGlvbmFsUmVwbGFjZW1lbnRJbmRleCA9IC0xO1xuICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgbGV0IGN1cnJlbnREb2xsYXJTdHJpbmdUYWdOYW1lID0gbnVsbDtcbiAgbGV0IGlzU3RyaW5nID0gZmFsc2U7XG4gIGxldCBpc0NvbHVtbiA9IGZhbHNlO1xuICBsZXQgcHJldmlvdXNTbGljZUVuZCA9IDA7XG4gIGxldCBpc1NpbmdsZUxpbmVDb21tZW50ID0gZmFsc2U7XG4gIGxldCBpc0NvbW1lbnRCbG9jayA9IGZhbHNlO1xuICBsZXQgc3RyaW5nSXNCYWNrc2xhc2hFc2NhcGFibGUgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcWxTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gc3FsU3RyaW5nW2ldO1xuICAgIGlmIChpc0NvbHVtbikge1xuICAgICAgaWYgKGNoYXIgPT09IGRpYWxlY3QuVElDS19DSEFSX1JJR0hUKSB7XG4gICAgICAgIGlzQ29sdW1uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBpZiAoY2hhciA9PT0gXCInXCIgJiYgKCFzdHJpbmdJc0JhY2tzbGFzaEVzY2FwYWJsZSB8fCAhaXNCYWNrc2xhc2hFc2NhcGVkKHNxbFN0cmluZywgaSAtIDEpKSkge1xuICAgICAgICBpc1N0cmluZyA9IGZhbHNlO1xuICAgICAgICBzdHJpbmdJc0JhY2tzbGFzaEVzY2FwYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjdXJyZW50RG9sbGFyU3RyaW5nVGFnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoYXIgIT09IFwiJFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVtYWluaW5nU3RyaW5nID0gc3FsU3RyaW5nLnNsaWNlKGksIHNxbFN0cmluZy5sZW5ndGgpO1xuICAgICAgY29uc3QgZG9sbGFyU3RyaW5nU3RhcnRNYXRjaCA9IHJlbWFpbmluZ1N0cmluZy5tYXRjaCgvXlxcJCg/PG5hbWU+W2Etel9dWzAtOWEtel9dKik/KFxcJCkvaSk7XG4gICAgICBjb25zdCB0YWdOYW1lID0gKChfYSA9IGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2guZ3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZSkgfHwgXCJcIjtcbiAgICAgIGlmIChjdXJyZW50RG9sbGFyU3RyaW5nVGFnTmFtZSA9PT0gdGFnTmFtZSkge1xuICAgICAgICBjdXJyZW50RG9sbGFyU3RyaW5nVGFnTmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzU2luZ2xlTGluZUNvbW1lbnQpIHtcbiAgICAgIGlmIChjaGFyID09PSBcIlxcblwiKSB7XG4gICAgICAgIGlzU2luZ2xlTGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNDb21tZW50QmxvY2spIHtcbiAgICAgIGlmIChjaGFyID09PSBcIipcIiAmJiBzcWxTdHJpbmdbaSArIDFdID09PSBcIi9cIikge1xuICAgICAgICBpc0NvbW1lbnRCbG9jayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBkaWFsZWN0LlRJQ0tfQ0hBUl9MRUZUKSB7XG4gICAgICBpc0NvbHVtbiA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiJ1wiKSB7XG4gICAgICBpc1N0cmluZyA9IHRydWU7XG4gICAgICBzdHJpbmdJc0JhY2tzbGFzaEVzY2FwYWJsZSA9IGRpYWxlY3QuY2FuQmFja3NsYXNoRXNjYXBlKCkgfHwgZGlhbGVjdC5zdXBwb3J0cy5lc2NhcGVTdHJpbmdDb25zdGFudHMgJiYgKHNxbFN0cmluZ1tpIC0gMV0gPT09IFwiRVwiIHx8IHNxbFN0cmluZ1tpIC0gMV0gPT09IFwiZVwiKSAmJiBjYW5QcmVjZWRlTmV3VG9rZW4oc3FsU3RyaW5nW2kgLSAyXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiLVwiICYmIHNxbFN0cmluZy5zbGljZShpLCBpICsgMykgPT09IFwiLS0gXCIpIHtcbiAgICAgIGlzU2luZ2xlTGluZUNvbW1lbnQgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaGFyID09PSBcIi9cIiAmJiBzcWxTdHJpbmcuc2xpY2UoaSwgaSArIDIpID09PSBcIi8qXCIpIHtcbiAgICAgIGlzQ29tbWVudEJsb2NrID0gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2hhciA9PT0gXCIkXCIpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzQ2hhciA9IHNxbFN0cmluZ1tpIC0gMV07XG4gICAgICBpZiAoL1swLTlhLXpfXS9pLnRlc3QocHJldmlvdXNDaGFyKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbWFpbmluZ1N0cmluZyA9IHNxbFN0cmluZy5zbGljZShpLCBzcWxTdHJpbmcubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2ggPSByZW1haW5pbmdTdHJpbmcubWF0Y2goL15cXCQoPzxuYW1lPlthLXpfXVswLTlhLXpfXSopPyhcXCQpL2kpO1xuICAgICAgaWYgKGRvbGxhclN0cmluZ1N0YXJ0TWF0Y2gpIHtcbiAgICAgICAgY3VycmVudERvbGxhclN0cmluZ1RhZ05hbWUgPSAoX2MgPSAoX2IgPSBkb2xsYXJTdHJpbmdTdGFydE1hdGNoLmdyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpICE9IG51bGwgPyBfYyA6IFwiXCI7XG4gICAgICAgIGkgKz0gZG9sbGFyU3RyaW5nU3RhcnRNYXRjaFswXS5sZW5ndGggLSAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNOYW1lZFJlcGxhY2VtZW50cyAmJiBjaGFyID09PSBcIjpcIikge1xuICAgICAgY29uc3QgcHJldmlvdXNDaGFyID0gc3FsU3RyaW5nW2kgLSAxXTtcbiAgICAgIGlmICghY2FuUHJlY2VkZU5ld1Rva2VuKHByZXZpb3VzQ2hhcikgJiYgcHJldmlvdXNDaGFyICE9PSBcIltcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbWFpbmluZ1N0cmluZyA9IHNxbFN0cmluZy5zbGljZShpLCBzcWxTdHJpbmcubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG1hdGNoID0gcmVtYWluaW5nU3RyaW5nLm1hdGNoKC9eOig/PG5hbWU+W2Etel9dWzAtOWEtel9dKikoPzpcXCl8LHwkfFxcc3w6Onw7fF0pL2kpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnROYW1lID0gKF9kID0gbWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoLmdyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLm5hbWU7XG4gICAgICBpZiAoIXJlcGxhY2VtZW50TmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50VmFsdWUgPSByZXBsYWNlbWVudHNbcmVwbGFjZW1lbnROYW1lXTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcGxhY2VtZW50cywgcmVwbGFjZW1lbnROYW1lKSB8fCByZXBsYWNlbWVudFZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOYW1lZCByZXBsYWNlbWVudCBcIjoke3JlcGxhY2VtZW50TmFtZX1cIiBoYXMgbm8gZW50cnkgaW4gdGhlIHJlcGxhY2VtZW50IG1hcC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVzY2FwZWRSZXBsYWNlbWVudCA9ICgwLCBpbXBvcnRfc3FsX3N0cmluZy5lc2NhcGUpKHJlcGxhY2VtZW50VmFsdWUsIHZvaWQgMCwgZGlhbGVjdC5uYW1lLCB0cnVlKTtcbiAgICAgIG91dHB1dCArPSBzcWxTdHJpbmcuc2xpY2UocHJldmlvdXNTbGljZUVuZCwgaSk7XG4gICAgICBwcmV2aW91c1NsaWNlRW5kID0gaSArIHJlcGxhY2VtZW50TmFtZS5sZW5ndGggKyAxO1xuICAgICAgb3V0cHV0ICs9IGVzY2FwZWRSZXBsYWNlbWVudDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNQb3NpdGlvbmFsUmVwbGFjZW1lbnRzICYmIGNoYXIgPT09IFwiP1wiKSB7XG4gICAgICBjb25zdCBwcmV2aW91c0NoYXIgPSBzcWxTdHJpbmdbaSAtIDFdO1xuICAgICAgaWYgKCFjYW5QcmVjZWRlTmV3VG9rZW4ocHJldmlvdXNDaGFyKSAmJiBwcmV2aW91c0NoYXIgIT09IFwiW1wiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dENoYXIgPSBzcWxTdHJpbmdbaSArIDFdO1xuICAgICAgaWYgKG5leHRDaGFyID09PSBcInxcIiB8fCBuZXh0Q2hhciA9PT0gXCImXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXBsYWNlbWVudEluZGV4ID0gKytsYXN0Q29uc3VtZWRQb3NpdGlvbmFsUmVwbGFjZW1lbnRJbmRleDtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50VmFsdWUgPSByZXBsYWNlbWVudHNbbGFzdENvbnN1bWVkUG9zaXRpb25hbFJlcGxhY2VtZW50SW5kZXhdO1xuICAgICAgaWYgKHJlcGxhY2VtZW50VmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvc2l0aW9uYWwgcmVwbGFjZW1lbnQgKD8pICR7cmVwbGFjZW1lbnRJbmRleH0gaGFzIG5vIGVudHJ5IGluIHRoZSByZXBsYWNlbWVudCBtYXAgKHJlcGxhY2VtZW50c1ske3JlcGxhY2VtZW50SW5kZXh9XSBpcyB1bmRlZmluZWQpLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgZXNjYXBlZFJlcGxhY2VtZW50ID0gKDAsIGltcG9ydF9zcWxfc3RyaW5nLmVzY2FwZSkocmVwbGFjZW1lbnRWYWx1ZSwgdm9pZCAwLCBkaWFsZWN0Lm5hbWUsIHRydWUpO1xuICAgICAgb3V0cHV0ICs9IHNxbFN0cmluZy5zbGljZShwcmV2aW91c1NsaWNlRW5kLCBpKTtcbiAgICAgIHByZXZpb3VzU2xpY2VFbmQgPSBpICsgMTtcbiAgICAgIG91dHB1dCArPSBlc2NhcGVkUmVwbGFjZW1lbnQ7XG4gICAgfVxuICB9XG4gIGlmIChpc1N0cmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGZvbGxvd2luZyBTUUwgcXVlcnkgaW5jbHVkZXMgYW4gdW50ZXJtaW5hdGVkIHN0cmluZyBsaXRlcmFsOlxuJHtzcWxTdHJpbmd9YCk7XG4gIH1cbiAgb3V0cHV0ICs9IHNxbFN0cmluZy5zbGljZShwcmV2aW91c1NsaWNlRW5kLCBzcWxTdHJpbmcubGVuZ3RoKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGNhblByZWNlZGVOZXdUb2tlbihjaGFyKSB7XG4gIHJldHVybiBjaGFyID09PSB2b2lkIDAgfHwgL1tcXHMoPiw9XS8udGVzdChjaGFyKTtcbn1cbmZ1bmN0aW9uIGlzQmFja3NsYXNoRXNjYXBlZChzdHJpbmcsIHBvcykge1xuICBsZXQgZXNjYXBlZCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gcG9zOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGNoYXIgPSBzdHJpbmdbaV07XG4gICAgaWYgKGNoYXIgIT09IFwiXFxcXFwiKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICB9XG4gIHJldHVybiBlc2NhcGVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3FsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/sql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js":
/*!**************************************************************!*\
  !*** ./node_modules/sequelize/lib/utils/validator-extras.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst _ = __webpack_require__(/*! lodash */ \"(rsc)/./node_modules/lodash/lodash.js\");\nconst validator = _.cloneDeep(__webpack_require__(/*! validator */ \"(rsc)/./node_modules/validator/index.js\"));\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += \"\";\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== \"RegExp\") {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== \"\" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\nvalidator.notNull = function(val) {\n  return val !== null && val !== void 0;\n};\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\nvalidator.isNull = validator.isEmpty;\nvalidator.isDate = function(dateString) {\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    return false;\n  }\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\nexports.validator = validator;\n//# sourceMappingURL=validator-extras.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi91dGlscy92YWxpZGF0b3ItZXh0cmFzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsVUFBVSxtQkFBTyxDQUFDLHFEQUFRO0FBQzFCLDhCQUE4QixtQkFBTyxDQUFDLDBEQUFXO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWR3b29kZm9udC8uL25vZGVfbW9kdWxlcy9zZXF1ZWxpemUvbGliL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMuanM/OTk3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuY29uc3QgdmFsaWRhdG9yID0gXy5jbG9uZURlZXAocmVxdWlyZShcInZhbGlkYXRvclwiKSk7XG5jb25zdCBtb21lbnQgPSByZXF1aXJlKFwibW9tZW50XCIpO1xuY29uc3QgZXh0ZW5zaW9ucyA9IHtcbiAgZXh0ZW5kKG5hbWUsIGZuKSB7XG4gICAgdGhpc1tuYW1lXSA9IGZuO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBub3RFbXB0eShzdHIpIHtcbiAgICByZXR1cm4gIXN0ci5tYXRjaCgvXltcXHNcXHRcXHJcXG5dKiQvKTtcbiAgfSxcbiAgbGVuKHN0ciwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlbmd0aChzdHIsIG1pbiwgbWF4KTtcbiAgfSxcbiAgaXNVcmwoc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNVUkwoc3RyKTtcbiAgfSxcbiAgaXNJUHY2KHN0cikge1xuICAgIHJldHVybiB0aGlzLmlzSVAoc3RyLCA2KTtcbiAgfSxcbiAgaXNJUHY0KHN0cikge1xuICAgIHJldHVybiB0aGlzLmlzSVAoc3RyLCA0KTtcbiAgfSxcbiAgbm90SW4oc3RyLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNJbihzdHIsIHZhbHVlcyk7XG4gIH0sXG4gIHJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgc3RyICs9IFwiXCI7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwYXR0ZXJuKS5zbGljZSg4LCAtMSkgIT09IFwiUmVnRXhwXCIpIHtcbiAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4sIG1vZGlmaWVycyk7XG4gICAgfVxuICAgIHJldHVybiBzdHIubWF0Y2gocGF0dGVybik7XG4gIH0sXG4gIG5vdFJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKSB7XG4gICAgcmV0dXJuICF0aGlzLnJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfSxcbiAgaXNEZWNpbWFsKHN0cikge1xuICAgIHJldHVybiBzdHIgIT09IFwiXCIgJiYgISFzdHIubWF0Y2goL14oPzotPyg/OlswLTldKykpPyg/OlxcLlswLTldKik/KD86W2VFXVsrLV0/KD86WzAtOV0rKSk/JC8pO1xuICB9LFxuICBtaW4oc3RyLCB2YWwpIHtcbiAgICBjb25zdCBudW1iZXIgPSBwYXJzZUZsb2F0KHN0cik7XG4gICAgcmV0dXJuIGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID49IHZhbDtcbiAgfSxcbiAgbWF4KHN0ciwgdmFsKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcGFyc2VGbG9hdChzdHIpO1xuICAgIHJldHVybiBpc05hTihudW1iZXIpIHx8IG51bWJlciA8PSB2YWw7XG4gIH0sXG4gIG5vdChzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHJldHVybiB0aGlzLm5vdFJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfSxcbiAgY29udGFpbnMoc3RyLCBlbGVtKSB7XG4gICAgcmV0dXJuICEhZWxlbSAmJiBzdHIuaW5jbHVkZXMoZWxlbSk7XG4gIH0sXG4gIG5vdENvbnRhaW5zKHN0ciwgZWxlbSkge1xuICAgIHJldHVybiAhdGhpcy5jb250YWlucyhzdHIsIGVsZW0pO1xuICB9LFxuICBpcyhzdHIsIHBhdHRlcm4sIG1vZGlmaWVycykge1xuICAgIHJldHVybiB0aGlzLnJlZ2V4KHN0ciwgcGF0dGVybiwgbW9kaWZpZXJzKTtcbiAgfVxufTtcbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG52YWxpZGF0b3IuaXNJbW11dGFibGUgPSBmdW5jdGlvbih2YWx1ZSwgdmFsaWRhdG9yQXJncywgZmllbGQsIG1vZGVsSW5zdGFuY2UpIHtcbiAgcmV0dXJuIG1vZGVsSW5zdGFuY2UuaXNOZXdSZWNvcmQgfHwgbW9kZWxJbnN0YW5jZS5kYXRhVmFsdWVzW2ZpZWxkXSA9PT0gbW9kZWxJbnN0YW5jZS5fcHJldmlvdXNEYXRhVmFsdWVzW2ZpZWxkXTtcbn07XG52YWxpZGF0b3Iubm90TnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdm9pZCAwO1xufTtcbl8uZm9yRWFjaChleHRlbnNpb25zLCAoZXh0ZW5kLCBrZXkpID0+IHtcbiAgdmFsaWRhdG9yW2tleV0gPSBleHRlbmQ7XG59KTtcbnZhbGlkYXRvci5pc051bGwgPSB2YWxpZGF0b3IuaXNFbXB0eTtcbnZhbGlkYXRvci5pc0RhdGUgPSBmdW5jdGlvbihkYXRlU3RyaW5nKSB7XG4gIGNvbnN0IHBhcnNlZCA9IERhdGUucGFyc2UoZGF0ZVN0cmluZyk7XG4gIGlmIChpc05hTihwYXJzZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwYXJzZWQpO1xuICByZXR1cm4gbW9tZW50KGRhdGUudG9JU09TdHJpbmcoKSkuaXNWYWxpZCgpO1xufTtcbmV4cG9ydHMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9yLWV4dHJhcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/utils/validator-extras.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/lib/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/sequelize/lib/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ABSTRACT: () => (/* binding */ ABSTRACT),\n/* harmony export */   ARRAY: () => (/* binding */ ARRAY),\n/* harmony export */   AccessDeniedError: () => (/* binding */ AccessDeniedError),\n/* harmony export */   AggregateError: () => (/* binding */ AggregateError),\n/* harmony export */   Association: () => (/* binding */ Association),\n/* harmony export */   AssociationError: () => (/* binding */ AssociationError),\n/* harmony export */   AsyncQueueError: () => (/* binding */ AsyncQueueError),\n/* harmony export */   BIGINT: () => (/* binding */ BIGINT),\n/* harmony export */   BLOB: () => (/* binding */ BLOB),\n/* harmony export */   BOOLEAN: () => (/* binding */ BOOLEAN),\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   BelongsTo: () => (/* binding */ BelongsTo),\n/* harmony export */   BelongsToMany: () => (/* binding */ BelongsToMany),\n/* harmony export */   BulkRecordError: () => (/* binding */ BulkRecordError),\n/* harmony export */   CHAR: () => (/* binding */ CHAR),\n/* harmony export */   CIDR: () => (/* binding */ CIDR),\n/* harmony export */   CITEXT: () => (/* binding */ CITEXT),\n/* harmony export */   ConnectionAcquireTimeoutError: () => (/* binding */ ConnectionAcquireTimeoutError),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionRefusedError: () => (/* binding */ ConnectionRefusedError),\n/* harmony export */   ConnectionTimedOutError: () => (/* binding */ ConnectionTimedOutError),\n/* harmony export */   DATE: () => (/* binding */ DATE),\n/* harmony export */   DATEONLY: () => (/* binding */ DATEONLY),\n/* harmony export */   DECIMAL: () => (/* binding */ DECIMAL),\n/* harmony export */   DOUBLE: () => (/* binding */ DOUBLE),\n/* harmony export */   DataTypes: () => (/* binding */ DataTypes),\n/* harmony export */   DatabaseError: () => (/* binding */ DatabaseError),\n/* harmony export */   Deferrable: () => (/* binding */ Deferrable),\n/* harmony export */   ENUM: () => (/* binding */ ENUM),\n/* harmony export */   EagerLoadingError: () => (/* binding */ EagerLoadingError),\n/* harmony export */   EmptyResultError: () => (/* binding */ EmptyResultError),\n/* harmony export */   Error: () => (/* binding */ Error),\n/* harmony export */   ExclusionConstraintError: () => (/* binding */ ExclusionConstraintError),\n/* harmony export */   FLOAT: () => (/* binding */ FLOAT),\n/* harmony export */   ForeignKeyConstraintError: () => (/* binding */ ForeignKeyConstraintError),\n/* harmony export */   GEOGRAPHY: () => (/* binding */ GEOGRAPHY),\n/* harmony export */   GEOMETRY: () => (/* binding */ GEOMETRY),\n/* harmony export */   HSTORE: () => (/* binding */ HSTORE),\n/* harmony export */   HasMany: () => (/* binding */ HasMany),\n/* harmony export */   HasOne: () => (/* binding */ HasOne),\n/* harmony export */   HostNotFoundError: () => (/* binding */ HostNotFoundError),\n/* harmony export */   HostNotReachableError: () => (/* binding */ HostNotReachableError),\n/* harmony export */   INET: () => (/* binding */ INET),\n/* harmony export */   INTEGER: () => (/* binding */ INTEGER),\n/* harmony export */   IndexHints: () => (/* binding */ IndexHints),\n/* harmony export */   InstanceError: () => (/* binding */ InstanceError),\n/* harmony export */   InvalidConnectionError: () => (/* binding */ InvalidConnectionError),\n/* harmony export */   JSON: () => (/* binding */ JSON),\n/* harmony export */   JSONB: () => (/* binding */ JSONB),\n/* harmony export */   MACADDR: () => (/* binding */ MACADDR),\n/* harmony export */   MEDIUMINT: () => (/* binding */ MEDIUMINT),\n/* harmony export */   Model: () => (/* binding */ Model),\n/* harmony export */   NOW: () => (/* binding */ NOW),\n/* harmony export */   NUMBER: () => (/* binding */ NUMBER),\n/* harmony export */   NUMERIC: () => (/* binding */ NUMERIC),\n/* harmony export */   Op: () => (/* binding */ Op),\n/* harmony export */   OptimisticLockError: () => (/* binding */ OptimisticLockError),\n/* harmony export */   QueryError: () => (/* binding */ QueryError),\n/* harmony export */   QueryInterface: () => (/* binding */ QueryInterface),\n/* harmony export */   QueryTypes: () => (/* binding */ QueryTypes),\n/* harmony export */   RANGE: () => (/* binding */ RANGE),\n/* harmony export */   REAL: () => (/* binding */ REAL),\n/* harmony export */   SMALLINT: () => (/* binding */ SMALLINT),\n/* harmony export */   STRING: () => (/* binding */ STRING),\n/* harmony export */   Sequelize: () => (/* binding */ Sequelize),\n/* harmony export */   SequelizeScopeError: () => (/* binding */ SequelizeScopeError),\n/* harmony export */   TEXT: () => (/* binding */ TEXT),\n/* harmony export */   TIME: () => (/* binding */ TIME),\n/* harmony export */   TINYINT: () => (/* binding */ TINYINT),\n/* harmony export */   TSVECTOR: () => (/* binding */ TSVECTOR),\n/* harmony export */   TableHints: () => (/* binding */ TableHints),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   UUID: () => (/* binding */ UUID),\n/* harmony export */   UUIDV1: () => (/* binding */ UUIDV1),\n/* harmony export */   UUIDV4: () => (/* binding */ UUIDV4),\n/* harmony export */   UniqueConstraintError: () => (/* binding */ UniqueConstraintError),\n/* harmony export */   UnknownConstraintError: () => (/* binding */ UnknownConstraintError),\n/* harmony export */   Utils: () => (/* binding */ Utils),\n/* harmony export */   VIRTUAL: () => (/* binding */ VIRTUAL),\n/* harmony export */   ValidationError: () => (/* binding */ ValidationError),\n/* harmony export */   ValidationErrorItem: () => (/* binding */ ValidationErrorItem),\n/* harmony export */   ValidationErrorItemOrigin: () => (/* binding */ ValidationErrorItemOrigin),\n/* harmony export */   ValidationErrorItemType: () => (/* binding */ ValidationErrorItemType),\n/* harmony export */   Validator: () => (/* binding */ Validator),\n/* harmony export */   and: () => (/* binding */ and),\n/* harmony export */   cast: () => (/* binding */ cast),\n/* harmony export */   col: () => (/* binding */ col),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fn: () => (/* binding */ fn),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   or: () => (/* binding */ or),\n/* harmony export */   useInflection: () => (/* binding */ useInflection),\n/* harmony export */   where: () => (/* binding */ where)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/sequelize/lib/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\n// export * from './lib/sequelize';\nconst Sequelize = _index_js__WEBPACK_IMPORTED_MODULE_0__.Sequelize;\nconst fn = _index_js__WEBPACK_IMPORTED_MODULE_0__.fn;\nconst col = _index_js__WEBPACK_IMPORTED_MODULE_0__.col;\nconst cast = _index_js__WEBPACK_IMPORTED_MODULE_0__.cast;\nconst literal = _index_js__WEBPACK_IMPORTED_MODULE_0__.literal;\nconst and = _index_js__WEBPACK_IMPORTED_MODULE_0__.and;\nconst or = _index_js__WEBPACK_IMPORTED_MODULE_0__.or;\nconst json = _index_js__WEBPACK_IMPORTED_MODULE_0__.json;\nconst where = _index_js__WEBPACK_IMPORTED_MODULE_0__.where;\n\n// export * from './lib/query-interface';\nconst QueryInterface = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryInterface;\n\n// export * from './lib/data-types';\n// 'DOUBLE PRECISION' is missing because its name is not a valid export identifier.\nconst ABSTRACT = _index_js__WEBPACK_IMPORTED_MODULE_0__.ABSTRACT;\nconst STRING = _index_js__WEBPACK_IMPORTED_MODULE_0__.STRING;\nconst CHAR = _index_js__WEBPACK_IMPORTED_MODULE_0__.CHAR;\nconst TEXT = _index_js__WEBPACK_IMPORTED_MODULE_0__.TEXT;\nconst NUMBER = _index_js__WEBPACK_IMPORTED_MODULE_0__.NUMBER;\nconst TINYINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.TINYINT;\nconst SMALLINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.SMALLINT;\nconst MEDIUMINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.MEDIUMINT;\nconst INTEGER = _index_js__WEBPACK_IMPORTED_MODULE_0__.INTEGER;\nconst BIGINT = _index_js__WEBPACK_IMPORTED_MODULE_0__.BIGINT;\nconst FLOAT = _index_js__WEBPACK_IMPORTED_MODULE_0__.FLOAT;\nconst TIME = _index_js__WEBPACK_IMPORTED_MODULE_0__.TIME;\nconst DATE = _index_js__WEBPACK_IMPORTED_MODULE_0__.DATE;\nconst DATEONLY = _index_js__WEBPACK_IMPORTED_MODULE_0__.DATEONLY;\nconst BOOLEAN = _index_js__WEBPACK_IMPORTED_MODULE_0__.BOOLEAN;\nconst NOW = _index_js__WEBPACK_IMPORTED_MODULE_0__.NOW;\nconst BLOB = _index_js__WEBPACK_IMPORTED_MODULE_0__.BLOB;\nconst DECIMAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.DECIMAL;\nconst NUMERIC = _index_js__WEBPACK_IMPORTED_MODULE_0__.NUMERIC;\nconst UUID = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUID;\nconst UUIDV1 = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUIDV1;\nconst UUIDV4 = _index_js__WEBPACK_IMPORTED_MODULE_0__.UUIDV4;\nconst HSTORE = _index_js__WEBPACK_IMPORTED_MODULE_0__.HSTORE;\nconst JSON = _index_js__WEBPACK_IMPORTED_MODULE_0__.JSON;\nconst JSONB = _index_js__WEBPACK_IMPORTED_MODULE_0__.JSONB;\nconst VIRTUAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.VIRTUAL;\nconst ARRAY = _index_js__WEBPACK_IMPORTED_MODULE_0__.ARRAY;\nconst ENUM = _index_js__WEBPACK_IMPORTED_MODULE_0__.ENUM;\nconst RANGE = _index_js__WEBPACK_IMPORTED_MODULE_0__.RANGE;\nconst REAL = _index_js__WEBPACK_IMPORTED_MODULE_0__.REAL;\nconst DOUBLE = _index_js__WEBPACK_IMPORTED_MODULE_0__.DOUBLE;\nconst GEOMETRY = _index_js__WEBPACK_IMPORTED_MODULE_0__.GEOMETRY;\nconst GEOGRAPHY = _index_js__WEBPACK_IMPORTED_MODULE_0__.GEOGRAPHY;\nconst CIDR = _index_js__WEBPACK_IMPORTED_MODULE_0__.CIDR;\nconst INET = _index_js__WEBPACK_IMPORTED_MODULE_0__.INET;\nconst MACADDR = _index_js__WEBPACK_IMPORTED_MODULE_0__.MACADDR;\nconst CITEXT = _index_js__WEBPACK_IMPORTED_MODULE_0__.CITEXT;\nconst TSVECTOR = _index_js__WEBPACK_IMPORTED_MODULE_0__.TSVECTOR;\n\n// export * from './lib/model';\nconst Model = _index_js__WEBPACK_IMPORTED_MODULE_0__.Model;\n\n// export * from './lib/transaction';\nconst Transaction = _index_js__WEBPACK_IMPORTED_MODULE_0__.Transaction;\n\n// export * from './lib/associations/index';\nconst Association = _index_js__WEBPACK_IMPORTED_MODULE_0__.Association;\nconst BelongsTo = _index_js__WEBPACK_IMPORTED_MODULE_0__.BelongsTo;\nconst HasOne = _index_js__WEBPACK_IMPORTED_MODULE_0__.HasOne;\nconst HasMany = _index_js__WEBPACK_IMPORTED_MODULE_0__.HasMany;\nconst BelongsToMany = _index_js__WEBPACK_IMPORTED_MODULE_0__.BelongsToMany;\n\n// export * from './lib/errors';\nconst BaseError = _index_js__WEBPACK_IMPORTED_MODULE_0__.BaseError;\n\nconst AggregateError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AggregateError;\nconst AsyncQueueError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AsyncQueueError;\nconst AssociationError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AssociationError;\nconst BulkRecordError = _index_js__WEBPACK_IMPORTED_MODULE_0__.BulkRecordError;\nconst ConnectionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionError;\nconst DatabaseError = _index_js__WEBPACK_IMPORTED_MODULE_0__.DatabaseError;\nconst EagerLoadingError = _index_js__WEBPACK_IMPORTED_MODULE_0__.EagerLoadingError;\nconst EmptyResultError = _index_js__WEBPACK_IMPORTED_MODULE_0__.EmptyResultError;\nconst InstanceError = _index_js__WEBPACK_IMPORTED_MODULE_0__.InstanceError;\nconst OptimisticLockError = _index_js__WEBPACK_IMPORTED_MODULE_0__.OptimisticLockError;\nconst QueryError = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryError;\nconst SequelizeScopeError = _index_js__WEBPACK_IMPORTED_MODULE_0__.SequelizeScopeError;\nconst ValidationError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationError;\nconst ValidationErrorItem = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItem;\n\nconst AccessDeniedError = _index_js__WEBPACK_IMPORTED_MODULE_0__.AccessDeniedError;\nconst ConnectionAcquireTimeoutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionAcquireTimeoutError;\nconst ConnectionRefusedError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionRefusedError;\nconst ConnectionTimedOutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ConnectionTimedOutError;\nconst HostNotFoundError = _index_js__WEBPACK_IMPORTED_MODULE_0__.HostNotFoundError;\nconst HostNotReachableError = _index_js__WEBPACK_IMPORTED_MODULE_0__.HostNotReachableError;\nconst InvalidConnectionError = _index_js__WEBPACK_IMPORTED_MODULE_0__.InvalidConnectionError;\n\nconst ExclusionConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ExclusionConstraintError;\nconst ForeignKeyConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.ForeignKeyConstraintError;\nconst TimeoutError = _index_js__WEBPACK_IMPORTED_MODULE_0__.TimeoutError;\nconst UnknownConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.UnknownConstraintError;\n\nconst UniqueConstraintError = _index_js__WEBPACK_IMPORTED_MODULE_0__.UniqueConstraintError;\n\n// export { BaseError as Error } from './lib/errors';\nconst Error = _index_js__WEBPACK_IMPORTED_MODULE_0__.Error;\n\n// export { useInflection } from './lib/utils';\nconst useInflection = _index_js__WEBPACK_IMPORTED_MODULE_0__.useInflection;\n\n// export { Utils, QueryTypes, Op, TableHints, IndexHints, DataTypes, Deferrable };\nconst Utils = _index_js__WEBPACK_IMPORTED_MODULE_0__.Utils;\nconst QueryTypes = _index_js__WEBPACK_IMPORTED_MODULE_0__.QueryTypes;\nconst Op = _index_js__WEBPACK_IMPORTED_MODULE_0__.Op;\nconst TableHints = _index_js__WEBPACK_IMPORTED_MODULE_0__.TableHints;\nconst IndexHints = _index_js__WEBPACK_IMPORTED_MODULE_0__.IndexHints;\nconst DataTypes = _index_js__WEBPACK_IMPORTED_MODULE_0__.DataTypes;\nconst Deferrable = _index_js__WEBPACK_IMPORTED_MODULE_0__.Deferrable;\n\n// export { Validator as validator } from './lib/utils/validator-extras';\nconst Validator = _index_js__WEBPACK_IMPORTED_MODULE_0__.Validator;\n\nconst ValidationErrorItemOrigin = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItemOrigin;\nconst ValidationErrorItemType = _index_js__WEBPACK_IMPORTED_MODULE_0__.ValidationErrorItemType;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VxdWVsaXplL2xpYi9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCOztBQUU3QixpRUFBZSxzQ0FBRyxFQUFDOztBQUVuQjtBQUNPLGtCQUFrQixnREFBYTtBQUMvQixXQUFXLHlDQUFNO0FBQ2pCLFlBQVksMENBQU87QUFDbkIsYUFBYSwyQ0FBUTtBQUNyQixnQkFBZ0IsOENBQVc7QUFDM0IsWUFBWSwwQ0FBTztBQUNuQixXQUFXLHlDQUFNO0FBQ2pCLGFBQWEsMkNBQVE7QUFDckIsY0FBYyw0Q0FBUzs7QUFFOUI7QUFDTyx1QkFBdUIscURBQWtCOztBQUVoRDtBQUNBO0FBQ08saUJBQWlCLCtDQUFZO0FBQzdCLGVBQWUsNkNBQVU7QUFDekIsYUFBYSwyQ0FBUTtBQUNyQixhQUFhLDJDQUFRO0FBQ3JCLGVBQWUsNkNBQVU7QUFDekIsZ0JBQWdCLDhDQUFXO0FBQzNCLGlCQUFpQiwrQ0FBWTtBQUM3QixrQkFBa0IsZ0RBQWE7QUFDL0IsZ0JBQWdCLDhDQUFXO0FBQzNCLGVBQWUsNkNBQVU7QUFDekIsY0FBYyw0Q0FBUztBQUN2QixhQUFhLDJDQUFRO0FBQ3JCLGFBQWEsMkNBQVE7QUFDckIsaUJBQWlCLCtDQUFZO0FBQzdCLGdCQUFnQiw4Q0FBVztBQUMzQixZQUFZLDBDQUFPO0FBQ25CLGFBQWEsMkNBQVE7QUFDckIsZ0JBQWdCLDhDQUFXO0FBQzNCLGdCQUFnQiw4Q0FBVztBQUMzQixhQUFhLDJDQUFRO0FBQ3JCLGVBQWUsNkNBQVU7QUFDekIsZUFBZSw2Q0FBVTtBQUN6QixlQUFlLDZDQUFVO0FBQ3pCLGFBQWEsMkNBQVE7QUFDckIsY0FBYyw0Q0FBUztBQUN2QixnQkFBZ0IsOENBQVc7QUFDM0IsY0FBYyw0Q0FBUztBQUN2QixhQUFhLDJDQUFRO0FBQ3JCLGNBQWMsNENBQVM7QUFDdkIsYUFBYSwyQ0FBUTtBQUNyQixlQUFlLDZDQUFVO0FBQ3pCLGlCQUFpQiwrQ0FBWTtBQUM3QixrQkFBa0IsZ0RBQWE7QUFDL0IsYUFBYSwyQ0FBUTtBQUNyQixhQUFhLDJDQUFRO0FBQ3JCLGdCQUFnQiw4Q0FBVztBQUMzQixlQUFlLDZDQUFVO0FBQ3pCLGlCQUFpQiwrQ0FBWTs7QUFFcEM7QUFDTyxjQUFjLDRDQUFTOztBQUU5QjtBQUNPLG9CQUFvQixrREFBZTs7QUFFMUM7QUFDTyxvQkFBb0Isa0RBQWU7QUFDbkMsa0JBQWtCLGdEQUFhO0FBQy9CLGVBQWUsNkNBQVU7QUFDekIsZ0JBQWdCLDhDQUFXO0FBQzNCLHNCQUFzQixvREFBaUI7O0FBRTlDO0FBQ08sa0JBQWtCLGdEQUFhOztBQUUvQix1QkFBdUIscURBQWtCO0FBQ3pDLHdCQUF3QixzREFBbUI7QUFDM0MseUJBQXlCLHVEQUFvQjtBQUM3Qyx3QkFBd0Isc0RBQW1CO0FBQzNDLHdCQUF3QixzREFBbUI7QUFDM0Msc0JBQXNCLG9EQUFpQjtBQUN2QywwQkFBMEIsd0RBQXFCO0FBQy9DLHlCQUF5Qix1REFBb0I7QUFDN0Msc0JBQXNCLG9EQUFpQjtBQUN2Qyw0QkFBNEIsMERBQXVCO0FBQ25ELG1CQUFtQixpREFBYztBQUNqQyw0QkFBNEIsMERBQXVCO0FBQ25ELHdCQUF3QixzREFBbUI7QUFDM0MsNEJBQTRCLDBEQUF1Qjs7QUFFbkQsMEJBQTBCLHdEQUFxQjtBQUMvQyxzQ0FBc0Msb0VBQWlDO0FBQ3ZFLCtCQUErQiw2REFBMEI7QUFDekQsZ0NBQWdDLDhEQUEyQjtBQUMzRCwwQkFBMEIsd0RBQXFCO0FBQy9DLDhCQUE4Qiw0REFBeUI7QUFDdkQsK0JBQStCLDZEQUEwQjs7QUFFekQsaUNBQWlDLCtEQUE0QjtBQUM3RCxrQ0FBa0MsZ0VBQTZCO0FBQy9ELHFCQUFxQixtREFBZ0I7QUFDckMsK0JBQStCLDZEQUEwQjs7QUFFekQsOEJBQThCLDREQUF5Qjs7QUFFOUQsWUFBWSxxQkFBcUI7QUFDMUIsY0FBYyw0Q0FBUzs7QUFFOUIsWUFBWSxnQkFBZ0I7QUFDckIsc0JBQXNCLG9EQUFpQjs7QUFFOUMsWUFBWTtBQUNMLGNBQWMsNENBQVM7QUFDdkIsbUJBQW1CLGlEQUFjO0FBQ2pDLFdBQVcseUNBQU07QUFDakIsbUJBQW1CLGlEQUFjO0FBQ2pDLG1CQUFtQixpREFBYztBQUNqQyxrQkFBa0IsZ0RBQWE7QUFDL0IsbUJBQW1CLGlEQUFjOztBQUV4QyxZQUFZLHlCQUF5QjtBQUM5QixrQkFBa0IsZ0RBQWE7O0FBRS9CLGtDQUFrQyxnRUFBNkI7QUFDL0QsZ0NBQWdDLDhEQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZHdvb2Rmb250Ly4vbm9kZV9tb2R1bGVzL3NlcXVlbGl6ZS9saWIvaW5kZXgubWpzP2Y4ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBrZyBmcm9tICcuL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgUGtnO1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi9zZXF1ZWxpemUnO1xuZXhwb3J0IGNvbnN0IFNlcXVlbGl6ZSA9IFBrZy5TZXF1ZWxpemU7XG5leHBvcnQgY29uc3QgZm4gPSBQa2cuZm47XG5leHBvcnQgY29uc3QgY29sID0gUGtnLmNvbDtcbmV4cG9ydCBjb25zdCBjYXN0ID0gUGtnLmNhc3Q7XG5leHBvcnQgY29uc3QgbGl0ZXJhbCA9IFBrZy5saXRlcmFsO1xuZXhwb3J0IGNvbnN0IGFuZCA9IFBrZy5hbmQ7XG5leHBvcnQgY29uc3Qgb3IgPSBQa2cub3I7XG5leHBvcnQgY29uc3QganNvbiA9IFBrZy5qc29uO1xuZXhwb3J0IGNvbnN0IHdoZXJlID0gUGtnLndoZXJlO1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi9xdWVyeS1pbnRlcmZhY2UnO1xuZXhwb3J0IGNvbnN0IFF1ZXJ5SW50ZXJmYWNlID0gUGtnLlF1ZXJ5SW50ZXJmYWNlO1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi9kYXRhLXR5cGVzJztcbi8vICdET1VCTEUgUFJFQ0lTSU9OJyBpcyBtaXNzaW5nIGJlY2F1c2UgaXRzIG5hbWUgaXMgbm90IGEgdmFsaWQgZXhwb3J0IGlkZW50aWZpZXIuXG5leHBvcnQgY29uc3QgQUJTVFJBQ1QgPSBQa2cuQUJTVFJBQ1Q7XG5leHBvcnQgY29uc3QgU1RSSU5HID0gUGtnLlNUUklORztcbmV4cG9ydCBjb25zdCBDSEFSID0gUGtnLkNIQVI7XG5leHBvcnQgY29uc3QgVEVYVCA9IFBrZy5URVhUO1xuZXhwb3J0IGNvbnN0IE5VTUJFUiA9IFBrZy5OVU1CRVI7XG5leHBvcnQgY29uc3QgVElOWUlOVCA9IFBrZy5USU5ZSU5UO1xuZXhwb3J0IGNvbnN0IFNNQUxMSU5UID0gUGtnLlNNQUxMSU5UO1xuZXhwb3J0IGNvbnN0IE1FRElVTUlOVCA9IFBrZy5NRURJVU1JTlQ7XG5leHBvcnQgY29uc3QgSU5URUdFUiA9IFBrZy5JTlRFR0VSO1xuZXhwb3J0IGNvbnN0IEJJR0lOVCA9IFBrZy5CSUdJTlQ7XG5leHBvcnQgY29uc3QgRkxPQVQgPSBQa2cuRkxPQVQ7XG5leHBvcnQgY29uc3QgVElNRSA9IFBrZy5USU1FO1xuZXhwb3J0IGNvbnN0IERBVEUgPSBQa2cuREFURTtcbmV4cG9ydCBjb25zdCBEQVRFT05MWSA9IFBrZy5EQVRFT05MWTtcbmV4cG9ydCBjb25zdCBCT09MRUFOID0gUGtnLkJPT0xFQU47XG5leHBvcnQgY29uc3QgTk9XID0gUGtnLk5PVztcbmV4cG9ydCBjb25zdCBCTE9CID0gUGtnLkJMT0I7XG5leHBvcnQgY29uc3QgREVDSU1BTCA9IFBrZy5ERUNJTUFMO1xuZXhwb3J0IGNvbnN0IE5VTUVSSUMgPSBQa2cuTlVNRVJJQztcbmV4cG9ydCBjb25zdCBVVUlEID0gUGtnLlVVSUQ7XG5leHBvcnQgY29uc3QgVVVJRFYxID0gUGtnLlVVSURWMTtcbmV4cG9ydCBjb25zdCBVVUlEVjQgPSBQa2cuVVVJRFY0O1xuZXhwb3J0IGNvbnN0IEhTVE9SRSA9IFBrZy5IU1RPUkU7XG5leHBvcnQgY29uc3QgSlNPTiA9IFBrZy5KU09OO1xuZXhwb3J0IGNvbnN0IEpTT05CID0gUGtnLkpTT05CO1xuZXhwb3J0IGNvbnN0IFZJUlRVQUwgPSBQa2cuVklSVFVBTDtcbmV4cG9ydCBjb25zdCBBUlJBWSA9IFBrZy5BUlJBWTtcbmV4cG9ydCBjb25zdCBFTlVNID0gUGtnLkVOVU07XG5leHBvcnQgY29uc3QgUkFOR0UgPSBQa2cuUkFOR0U7XG5leHBvcnQgY29uc3QgUkVBTCA9IFBrZy5SRUFMO1xuZXhwb3J0IGNvbnN0IERPVUJMRSA9IFBrZy5ET1VCTEU7XG5leHBvcnQgY29uc3QgR0VPTUVUUlkgPSBQa2cuR0VPTUVUUlk7XG5leHBvcnQgY29uc3QgR0VPR1JBUEhZID0gUGtnLkdFT0dSQVBIWTtcbmV4cG9ydCBjb25zdCBDSURSID0gUGtnLkNJRFI7XG5leHBvcnQgY29uc3QgSU5FVCA9IFBrZy5JTkVUO1xuZXhwb3J0IGNvbnN0IE1BQ0FERFIgPSBQa2cuTUFDQUREUjtcbmV4cG9ydCBjb25zdCBDSVRFWFQgPSBQa2cuQ0lURVhUO1xuZXhwb3J0IGNvbnN0IFRTVkVDVE9SID0gUGtnLlRTVkVDVE9SO1xuXG4vLyBleHBvcnQgKiBmcm9tICcuL2xpYi9tb2RlbCc7XG5leHBvcnQgY29uc3QgTW9kZWwgPSBQa2cuTW9kZWw7XG5cbi8vIGV4cG9ydCAqIGZyb20gJy4vbGliL3RyYW5zYWN0aW9uJztcbmV4cG9ydCBjb25zdCBUcmFuc2FjdGlvbiA9IFBrZy5UcmFuc2FjdGlvbjtcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvYXNzb2NpYXRpb25zL2luZGV4JztcbmV4cG9ydCBjb25zdCBBc3NvY2lhdGlvbiA9IFBrZy5Bc3NvY2lhdGlvbjtcbmV4cG9ydCBjb25zdCBCZWxvbmdzVG8gPSBQa2cuQmVsb25nc1RvO1xuZXhwb3J0IGNvbnN0IEhhc09uZSA9IFBrZy5IYXNPbmU7XG5leHBvcnQgY29uc3QgSGFzTWFueSA9IFBrZy5IYXNNYW55O1xuZXhwb3J0IGNvbnN0IEJlbG9uZ3NUb01hbnkgPSBQa2cuQmVsb25nc1RvTWFueTtcblxuLy8gZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCBjb25zdCBCYXNlRXJyb3IgPSBQa2cuQmFzZUVycm9yO1xuXG5leHBvcnQgY29uc3QgQWdncmVnYXRlRXJyb3IgPSBQa2cuQWdncmVnYXRlRXJyb3I7XG5leHBvcnQgY29uc3QgQXN5bmNRdWV1ZUVycm9yID0gUGtnLkFzeW5jUXVldWVFcnJvcjtcbmV4cG9ydCBjb25zdCBBc3NvY2lhdGlvbkVycm9yID0gUGtnLkFzc29jaWF0aW9uRXJyb3I7XG5leHBvcnQgY29uc3QgQnVsa1JlY29yZEVycm9yID0gUGtnLkJ1bGtSZWNvcmRFcnJvcjtcbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uRXJyb3IgPSBQa2cuQ29ubmVjdGlvbkVycm9yO1xuZXhwb3J0IGNvbnN0IERhdGFiYXNlRXJyb3IgPSBQa2cuRGF0YWJhc2VFcnJvcjtcbmV4cG9ydCBjb25zdCBFYWdlckxvYWRpbmdFcnJvciA9IFBrZy5FYWdlckxvYWRpbmdFcnJvcjtcbmV4cG9ydCBjb25zdCBFbXB0eVJlc3VsdEVycm9yID0gUGtnLkVtcHR5UmVzdWx0RXJyb3I7XG5leHBvcnQgY29uc3QgSW5zdGFuY2VFcnJvciA9IFBrZy5JbnN0YW5jZUVycm9yO1xuZXhwb3J0IGNvbnN0IE9wdGltaXN0aWNMb2NrRXJyb3IgPSBQa2cuT3B0aW1pc3RpY0xvY2tFcnJvcjtcbmV4cG9ydCBjb25zdCBRdWVyeUVycm9yID0gUGtnLlF1ZXJ5RXJyb3I7XG5leHBvcnQgY29uc3QgU2VxdWVsaXplU2NvcGVFcnJvciA9IFBrZy5TZXF1ZWxpemVTY29wZUVycm9yO1xuZXhwb3J0IGNvbnN0IFZhbGlkYXRpb25FcnJvciA9IFBrZy5WYWxpZGF0aW9uRXJyb3I7XG5leHBvcnQgY29uc3QgVmFsaWRhdGlvbkVycm9ySXRlbSA9IFBrZy5WYWxpZGF0aW9uRXJyb3JJdGVtO1xuXG5leHBvcnQgY29uc3QgQWNjZXNzRGVuaWVkRXJyb3IgPSBQa2cuQWNjZXNzRGVuaWVkRXJyb3I7XG5leHBvcnQgY29uc3QgQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3IgPSBQa2cuQ29ubmVjdGlvbkFjcXVpcmVUaW1lb3V0RXJyb3I7XG5leHBvcnQgY29uc3QgQ29ubmVjdGlvblJlZnVzZWRFcnJvciA9IFBrZy5Db25uZWN0aW9uUmVmdXNlZEVycm9yO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25UaW1lZE91dEVycm9yID0gUGtnLkNvbm5lY3Rpb25UaW1lZE91dEVycm9yO1xuZXhwb3J0IGNvbnN0IEhvc3ROb3RGb3VuZEVycm9yID0gUGtnLkhvc3ROb3RGb3VuZEVycm9yO1xuZXhwb3J0IGNvbnN0IEhvc3ROb3RSZWFjaGFibGVFcnJvciA9IFBrZy5Ib3N0Tm90UmVhY2hhYmxlRXJyb3I7XG5leHBvcnQgY29uc3QgSW52YWxpZENvbm5lY3Rpb25FcnJvciA9IFBrZy5JbnZhbGlkQ29ubmVjdGlvbkVycm9yO1xuXG5leHBvcnQgY29uc3QgRXhjbHVzaW9uQ29uc3RyYWludEVycm9yID0gUGtnLkV4Y2x1c2lvbkNvbnN0cmFpbnRFcnJvcjtcbmV4cG9ydCBjb25zdCBGb3JlaWduS2V5Q29uc3RyYWludEVycm9yID0gUGtnLkZvcmVpZ25LZXlDb25zdHJhaW50RXJyb3I7XG5leHBvcnQgY29uc3QgVGltZW91dEVycm9yID0gUGtnLlRpbWVvdXRFcnJvcjtcbmV4cG9ydCBjb25zdCBVbmtub3duQ29uc3RyYWludEVycm9yID0gUGtnLlVua25vd25Db25zdHJhaW50RXJyb3I7XG5cbmV4cG9ydCBjb25zdCBVbmlxdWVDb25zdHJhaW50RXJyb3IgPSBQa2cuVW5pcXVlQ29uc3RyYWludEVycm9yO1xuXG4vLyBleHBvcnQgeyBCYXNlRXJyb3IgYXMgRXJyb3IgfSBmcm9tICcuL2xpYi9lcnJvcnMnO1xuZXhwb3J0IGNvbnN0IEVycm9yID0gUGtnLkVycm9yO1xuXG4vLyBleHBvcnQgeyB1c2VJbmZsZWN0aW9uIH0gZnJvbSAnLi9saWIvdXRpbHMnO1xuZXhwb3J0IGNvbnN0IHVzZUluZmxlY3Rpb24gPSBQa2cudXNlSW5mbGVjdGlvbjtcblxuLy8gZXhwb3J0IHsgVXRpbHMsIFF1ZXJ5VHlwZXMsIE9wLCBUYWJsZUhpbnRzLCBJbmRleEhpbnRzLCBEYXRhVHlwZXMsIERlZmVycmFibGUgfTtcbmV4cG9ydCBjb25zdCBVdGlscyA9IFBrZy5VdGlscztcbmV4cG9ydCBjb25zdCBRdWVyeVR5cGVzID0gUGtnLlF1ZXJ5VHlwZXM7XG5leHBvcnQgY29uc3QgT3AgPSBQa2cuT3A7XG5leHBvcnQgY29uc3QgVGFibGVIaW50cyA9IFBrZy5UYWJsZUhpbnRzO1xuZXhwb3J0IGNvbnN0IEluZGV4SGludHMgPSBQa2cuSW5kZXhIaW50cztcbmV4cG9ydCBjb25zdCBEYXRhVHlwZXMgPSBQa2cuRGF0YVR5cGVzO1xuZXhwb3J0IGNvbnN0IERlZmVycmFibGUgPSBQa2cuRGVmZXJyYWJsZTtcblxuLy8gZXhwb3J0IHsgVmFsaWRhdG9yIGFzIHZhbGlkYXRvciB9IGZyb20gJy4vbGliL3V0aWxzL3ZhbGlkYXRvci1leHRyYXMnO1xuZXhwb3J0IGNvbnN0IFZhbGlkYXRvciA9IFBrZy5WYWxpZGF0b3I7XG5cbmV4cG9ydCBjb25zdCBWYWxpZGF0aW9uRXJyb3JJdGVtT3JpZ2luID0gUGtnLlZhbGlkYXRpb25FcnJvckl0ZW1PcmlnaW47XG5leHBvcnQgY29uc3QgVmFsaWRhdGlvbkVycm9ySXRlbVR5cGUgPSBQa2cuVmFsaWRhdGlvbkVycm9ySXRlbVR5cGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/sequelize/lib/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/sequelize/package.json":
/*!*********************************************!*\
  !*** ./node_modules/sequelize/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"sequelize","description":"Sequelize is a promise-based Node.js ORM tool for Postgres, MySQL, MariaDB, SQLite, Microsoft SQL Server, Amazon Redshift and Snowflake’s Data Cloud. It features solid transaction support, relations, eager and lazy loading, read replication and more.","version":"6.37.4","funding":[{"type":"opencollective","url":"https://opencollective.com/sequelize"}],"repository":{"type":"git","url":"https://github.com/sequelize/sequelize.git"},"bugs":{"url":"https://github.com/sequelize/sequelize/issues"},"homepage":"https://sequelize.org/","main":"./lib/index.js","types":"./types/index.d.ts","type":"commonjs","exports":{".":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"./lib/*":{"types":"./types/*.d.ts","default":"./lib/*.js"},"./lib/errors":{"types":"./types/errors/index.d.ts","default":"./lib/errors/index.js"},"./package.json":"./package.json","./types/*":{"types":"./types/*.d.ts"}},"engines":{"node":">=10.0.0"},"files":["lib","types","index.js"],"license":"MIT","dependencies":{"@types/debug":"^4.1.8","@types/validator":"^13.7.17","debug":"^4.3.4","dottie":"^2.0.6","inflection":"^1.13.4","lodash":"^4.17.21","moment":"^2.29.4","moment-timezone":"^0.5.43","pg-connection-string":"^2.6.1","retry-as-promised":"^7.0.4","semver":"^7.5.4","sequelize-pool":"^7.1.0","toposort-class":"^1.0.1","uuid":"^8.3.2","validator":"^13.9.0","wkx":"^0.5.0"},"devDependencies":{"@commitlint/cli":"^15.0.0","@commitlint/config-angular":"^15.0.0","@octokit/rest":"^18.12.0","@octokit/types":"^6.34.0","@types/chai":"^4.3.0","@types/lodash":"4.14.197","@types/mocha":"^9.0.0","@types/node":"^16.11.17","@types/sinon":"^10.0.6","@typescript-eslint/eslint-plugin":"^5.8.1","@typescript-eslint/parser":"^5.8.1","acorn":"^8.7.0","chai":"^4.3.7","chai-as-promised":"^7.1.1","chai-datetime":"^1.8.0","cheerio":"^1.0.0-rc.10","cls-hooked":"^4.2.2","copyfiles":"^2.4.1","cross-env":"^7.0.3","delay":"^5.0.0","esbuild":"0.14.3","esdoc":"^1.1.0","esdoc-ecmascript-proposal-plugin":"^1.0.0","esdoc-inject-style-plugin":"^1.0.0","esdoc-standard-plugin":"^1.0.0","eslint":"^8.5.0","eslint-plugin-jsdoc":"^37.4.0","eslint-plugin-mocha":"^9.0.0","expect-type":"^0.12.0","fast-glob":"^3.2.7","fs-jetpack":"^4.3.0","husky":"^7.0.4","ibm_db":"^2.8.1","js-combinatorics":"^0.6.1","lcov-result-merger":"^3.1.0","lint-staged":"^12.1.4","mariadb":"^2.5.5","markdownlint-cli":"^0.30.0","mocha":"^7.2.0","module-alias":"^2.2.2","mysql2":"^2.3.3","node-hook":"^1.0.0","nyc":"^15.1.0","oracledb":"^5.5.0","p-map":"^4.0.0","p-props":"^4.0.0","p-settle":"^4.1.1","p-timeout":"^4.0.0","pg":"^8.7.1","pg-hstore":"^2.3.4","rimraf":"^3.0.2","semantic-release":"^18.0.1","semantic-release-fail-on-major-bump":"^1.0.0","sinon":"^12.0.1","sinon-chai":"^3.7.0","snowflake-sdk":"^1.6.6","source-map-support":"^0.5.21","sqlite3":"^5.1.6","tedious":"8.3.0","typescript":"^4.5.4"},"peerDependenciesMeta":{"pg":{"optional":true},"pg-hstore":{"optional":true},"mysql2":{"optional":true},"ibm_db":{"optional":true},"snowflake-sdk":{"optional":true},"mariadb":{"optional":true},"sqlite3":{"optional":true},"tedious":{"optional":true},"oracledb":{"optional":true}},"keywords":["mysql","mariadb","sqlite","postgresql","postgres","pg","mssql","db2","ibm_db","sql","oracledb","sqlserver","snowflake","orm","nodejs","object relational mapper","database","db"],"commitlint":{"extends":["@commitlint/config-angular"],"rules":{"type-enum":[2,"always",["build","ci","docs","feat","fix","perf","refactor","revert","style","test","meta"]]}},"lint-staged":{"*!(d).[tj]s":"eslint"},"release":{"plugins":["@semantic-release/commit-analyzer","semantic-release-fail-on-major-bump","@semantic-release/release-notes-generator","@semantic-release/npm","@semantic-release/github"],"branches":["v6",{"name":"v6-beta","prerelease":"beta"}]},"publishConfig":{"tag":"latest"},"scripts":{"----------------------------------------- static analysis -----------------------------------------":"","lint":"eslint src test --quiet --fix","lint-docs":"markdownlint docs","test-typings":"tsc --noEmit --emitDeclarationOnly false && tsc -b test/tsconfig.json","----------------------------------------- documentation -------------------------------------------":"","docs":"sh docs.sh","----------------------------------------- tests ---------------------------------------------------":"","mocha":"mocha -r ./test/registerEsbuild","test-unit":"yarn mocha \\"test/unit/**/*.test.[tj]s\\"","test-integration":"yarn mocha \\"test/integration/**/*.test.[tj]s\\"","teaser":"node test/teaser.js","test":"npm run prepare && npm run test-typings && npm run teaser && npm run test-unit && npm run test-integration","----------------------------------------- coverage ------------------------------------------------":"","cover":"rimraf coverage && npm run teaser && npm run cover-integration && npm run cover-unit && npm run merge-coverage","cover-integration":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \\"test/integration/**/*.test.[tj]s\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/integration.info\')\\"","cover-unit":"cross-env COVERAGE=true nyc --reporter=lcovonly yarn mocha \\"test/unit/**/*.test.[tj]s\\" && node -e \\"require(\'fs\').renameSync(\'coverage/lcov.info\', \'coverage/unit.info\')\\"","merge-coverage":"lcov-result-merger \\"coverage/*.info\\" \\"coverage/lcov.info\\"","----------------------------------------- local test dbs ------------------------------------------":"","start-mariadb":"bash dev/mariadb/10.3/start.sh","start-mysql":"bash dev/mysql/5.7/start.sh","start-mysql-8":"bash dev/mysql/8.0/start.sh","start-postgres":"bash dev/postgres/10/start.sh","start-mssql":"bash dev/mssql/2019/start.sh","start-db2":"bash dev/db2/11.5/start.sh","start-oracle-oldest":"bash dev/oracle/18-slim/start.sh","start-oracle-latest":"bash dev/oracle/23-slim/start.sh","stop-mariadb":"bash dev/mariadb/10.3/stop.sh","stop-mysql":"bash dev/mysql/5.7/stop.sh","stop-mysql-8":"bash dev/mysql/8.0/stop.sh","stop-postgres":"bash dev/postgres/10/stop.sh","stop-mssql":"bash dev/mssql/2019/stop.sh","stop-db2":"bash dev/db2/11.5/stop.sh","stop-oracle-oldest":"bash dev/oracle/18-slim/stop.sh","stop-oracle-latest":"bash dev/oracle/23-slim/stop.sh","restart-mariadb":"npm run start-mariadb","restart-mysql":"npm run start-mysql","restart-postgres":"npm run start-postgres","restart-mssql":"npm run start-mssql","restart-db2":"npm run start-db2","restart-oracle-oldest":"npm run start-oracle-oldest","restart-oracle-latest":"npm run start-oracle-latest","----------------------------------------- local tests ---------------------------------------------":"","test-unit-mariadb":"cross-env DIALECT=mariadb npm run test-unit","test-unit-mysql":"cross-env DIALECT=mysql npm run test-unit","test-unit-postgres":"cross-env DIALECT=postgres npm run test-unit","test-unit-postgres-native":"cross-env DIALECT=postgres-native npm run test-unit","test-unit-sqlite":"cross-env DIALECT=sqlite npm run test-unit","test-unit-mssql":"cross-env DIALECT=mssql npm run test-unit","test-unit-db2":"cross-env DIALECT=db2 npm run test-unit","test-unit-snowflake":"cross-env DIALECT=snowflake npm run test-unit","test-unit-oracle":"cross-env DIALECT=oracle npm run test-unit","test-unit-all":"npm run test-unit-mariadb && npm run test-unit-mysql && npm run test-unit-postgres && npm run test-unit-postgres-native && npm run test-unit-mssql && npm run test-unit-sqlite && npm run test-unit-snowflake && npm run test-unit-db2 && npm run test-unit-oracle","test-integration-mariadb":"cross-env DIALECT=mariadb npm run test-integration","test-integration-mysql":"cross-env DIALECT=mysql npm run test-integration","test-integration-postgres":"cross-env DIALECT=postgres npm run test-integration","test-integration-postgres-native":"cross-env DIALECT=postgres-native npm run test-integration","test-integration-sqlite":"cross-env DIALECT=sqlite npm run test-integration","test-integration-mssql":"cross-env DIALECT=mssql npm run test-integration","test-integration-db2":"cross-env DIALECT=db2 npm run test-integration","test-integration-snowflake":"cross-env DIALECT=snowflake npm run test-integration","test-integration-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm run test-integration","test-mariadb":"cross-env DIALECT=mariadb npm test","test-mysql":"cross-env DIALECT=mysql npm test","test-sqlite":"cross-env DIALECT=sqlite npm test","test-postgres":"cross-env DIALECT=postgres npm test","test-postgres-native":"cross-env DIALECT=postgres-native npm test","test-mssql":"cross-env DIALECT=mssql npm test","test-db2":"cross-env DIALECT=db2 npm test","test-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 npm test","----------------------------------------- development ---------------------------------------------":"","sscce":"node sscce.js","sscce-mariadb":"cross-env DIALECT=mariadb node sscce.js","sscce-mysql":"cross-env DIALECT=mysql node sscce.js","sscce-postgres":"cross-env DIALECT=postgres node sscce.js","sscce-postgres-native":"cross-env DIALECT=postgres-native node sscce.js","sscce-sqlite":"cross-env DIALECT=sqlite node sscce.js","sscce-mssql":"cross-env DIALECT=mssql node sscce.js","sscce-db2":"cross-env DIALECT=db2 node sscce.js","sscce-oracle":"cross-env LD_LIBRARY_PATH=\\"$PWD/.oracle/instantclient/\\" DIALECT=oracle UV_THREADPOOL_SIZE=128 node sscce.js","prepare":"npm run build && husky install","build":"node ./build.js","---------------------------------------------------------------------------------------------------":""},"support":true}');

/***/ })

};
;